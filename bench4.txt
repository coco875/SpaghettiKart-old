--------------------------------------------------------------------------------
Profile data file 'callgrind.out.78938' (creator: callgrind-3.23.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 11133770800
Trigger: Program termination
Profiled target:  ./build/Spaghettify (PID 78938, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                       
--------------------------------------------------------------------------------
120,704,757,429 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                       file:function
--------------------------------------------------------------------------------
72,541,668,532 (60.10%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 5,849,969,381 ( 4.85%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 5,035,863,375 ( 4.17%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_x_for_aspect_ratio(float) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 4,426,152,783 ( 3.67%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_step() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 2,755,803,984 ( 2.28%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::contains(signed char) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 2,665,050,549 ( 2.21%)  /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::_Deque_iterator(std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 2,474,976,900 ( 2.05%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tri2_handler_f3dex(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 2,085,691,698 ( 1.73%)  /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::operator--() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 1,969,819,937 ( 1.63%)  /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::back() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 1,622,204,668 ( 1.34%)  /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::end() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 1,137,833,640 ( 0.94%)  /usr/include/c++/14/array:std::array<UcodeHandler const*, 4ul>::operator[](unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 1,042,845,849 ( 0.86%)  /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::top() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   981,823,930 ( 0.81%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_run(Gfx*, std::unordered_map<MtxS*, MtxF, std::hash<MtxS*>, std::equal_to<MtxS*>, std::allocator<std::pair<MtxS* const, MtxF> > > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   866,235,225 ( 0.72%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::at(signed char) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   811,102,327 ( 0.67%)  /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::operator*() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   750,747,673 ( 0.62%)  /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::empty() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   692,997,852 ( 0.57%)  /usr/include/c++/14/bits/stl_deque.h:std::operator==(std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&, std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   519,748,389 ( 0.43%)  /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::empty() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   519,748,380 ( 0.43%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Fast::GfxDebugger, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   519,748,380 ( 0.43%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Fast::GfxDebugger, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   519,741,135 ( 0.43%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::currCmd() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   482,026,104 ( 0.40%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   404,248,740 ( 0.33%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Fast::GfxDebugger, (__gnu_cxx::_Lock_policy)2>::get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   404,245,919 ( 0.33%)  libultraship/src/graphic/Fast3D/debug/GfxDebugger.cpp:Fast::GfxDebugger::IsDebugging() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   378,734,796 ( 0.31%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_M_key_equals(Attribute const&, std::__detail::_Hash_node_value<std::pair<Attribute const, std::any>, false> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   367,257,984 ( 0.30%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_before_node(unsigned long, Attribute const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   298,397,112 ( 0.25%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_M_equals(Attribute const&, unsigned long, std::__detail::_Hash_node_value<std::pair<Attribute const, std::any>, false> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   241,013,052 ( 0.20%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node(unsigned long, Attribute const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   223,797,834 ( 0.19%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<Attribute const, std::any>, false, false>::_Node_const_iterator(std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   183,629,184 ( 0.15%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(Attribute const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   172,152,320 ( 0.14%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator_base<std::pair<Attribute const, std::any>, false>::_Node_iterator_base(std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   171,415,980 ( 0.14%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_vtx_handler_f3dex(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   160,675,592 ( 0.13%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   160,675,592 ( 0.13%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_bucket_index(unsigned long, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   150,642,018 ( 0.12%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:unsigned int get_attr<unsigned int>(Attribute) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   149,198,556 ( 0.12%)  /usr/include/c++/14/bits/stl_function.h:std::equal_to<Attribute>::operator()(Attribute const&, Attribute const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   137,722,056 ( 0.11%)  /usr/include/c++/14/bits/functional_hash.h:std::__hash_enum<Attribute, true>::operator()(Attribute) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   133,838,870 ( 0.11%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Mod_range_hashing::operator()(unsigned long, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   131,983,338 ( 0.11%)  /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > >::contains(Attribute const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   114,768,380 ( 0.10%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<Attribute const, std::any> const&>::type&& std::__detail::_Select1st::operator()<std::pair<Attribute const, std::any> const&>(std::pair<Attribute const, std::any> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   114,768,120 ( 0.10%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Map_base<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::at(Attribute const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   106,007,346 ( 0.09%)  /usr/include/c++/14/any:void* std::__any_caster<unsigned int>(std::any const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   103,291,542 ( 0.09%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   103,291,416 ( 0.09%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<Attribute const, std::any> >::_M_ptr() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   103,291,308 ( 0.09%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_M_eq() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    97,796,955 ( 0.08%)  build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    83,690,010 ( 0.07%)  /usr/include/c++/14/any:unsigned int std::any_cast<unsigned int>(std::any const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    80,451,196 ( 0.07%)  /usr/include/c++/14/bits/functional_hash.h:std::hash<unsigned int>::operator()(unsigned int) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    80,337,782 ( 0.07%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    80,337,684 ( 0.07%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<Attribute, std::pair<Attribute const, std::any>, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_S_equals(unsigned long, std::__detail::_Hash_node_code_cache<false> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    80,337,684 ( 0.07%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<Attribute const, std::any>, false, false>::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    70,941,744 ( 0.06%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_matrix_mul(float (*) [4], float const (*) [4], float const (*) [4]) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    68,861,448 ( 0.06%)  /usr/include/c++/14/bits/move.h:std::pair<Attribute const, std::any> const& std::forward<std::pair<Attribute const, std::any> const&>(std::remove_reference<std::pair<Attribute const, std::any> const&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    68,861,028 ( 0.06%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<1, std::hash<Attribute>, true>::_M_cget() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    68,860,944 ( 0.06%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<Attribute const, std::any> >::_M_addr() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    68,860,872 ( 0.06%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::equal_to<Attribute>, true>::_M_cget() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    68,860,872 ( 0.06%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<Attribute const, std::any>, false> const&, std::__detail::_Node_iterator_base<std::pair<Attribute const, std::any>, false> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    68,860,872 ( 0.06%)  /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > >::at(Attribute const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    66,952,008 ( 0.06%)  /usr/include/c++/14/any:unsigned int const* std::any_cast<unsigned int>(std::any const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    66,352,080 ( 0.05%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    63,122,466 ( 0.05%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::end() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    62,873,882 ( 0.05%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_free [/usr/lib64/libc.so.6]
    61,822,060 ( 0.05%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() [/usr/lib64/libspdlog.so.1.12.0]
    59,242,725 ( 0.05%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib64/libc.so.6]
    57,384,200 ( 0.05%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    57,384,200 ( 0.05%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_hash_traits<std::hash<Attribute> >::__small_size_threshold() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    57,384,060 ( 0.05%)  /usr/include/c++/14/array:std::array<std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > > const*, 4ul>::operator[](unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    56,891,682 ( 0.05%)  /usr/include/c++/14/array:gfx_step()
    53,658,612 ( 0.04%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc [/usr/lib64/libc.so.6]
    51,645,906 ( 0.04%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<Attribute const, std::any> >::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    44,767,996 ( 0.04%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_ci8(int, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    44,634,672 ( 0.04%)  /usr/include/c++/14/any:std::any::_Manager_internal<unsigned int>::_S_access(std::any::_Storage const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    36,781,440 ( 0.03%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    35,558,539 ( 0.03%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_malloc [/usr/lib64/libc.so.6]
    34,430,604 ( 0.03%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<Attribute const, std::any> >::_M_addr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    33,550,693 ( 0.03%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_matrix(unsigned char, int const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    31,457,156 ( 0.03%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free [/usr/lib64/libc.so.6]
    31,400,417 ( 0.03%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms [/usr/lib64/libc.so.6]
    31,047,684 ( 0.03%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    28,292,845 ( 0.02%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    26,975,788 ( 0.02%)  ???:0x0000000000847890 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    26,502,376 ( 0.02%)  /usr/include/c++/14/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    25,644,564 ( 0.02%)  /usr/include/c++/14/ext/atomicity.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release()
    24,508,016 ( 0.02%)  src/os/guMtxF2L.c:guMtxF2L [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    23,738,316 ( 0.02%)  ???:0x0000000000f7a470 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    22,871,802 ( 0.02%)  /usr/include/c++/14/ext/atomicity.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_copy()
    20,487,174 ( 0.02%)  ???:0x0000000000a7c320 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    19,706,233 ( 0.02%)  ???:0x0000000000b29bc0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    19,296,786 ( 0.02%)  build/_deps/stormlib-src/src/SBaseCommon.cpp:DecryptMpqBlock(void*, unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    18,930,322 ( 0.02%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_lookup_or_create_color_combiner(ColorCombinerKey const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    17,809,477 ( 0.01%)  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/hash_bytes.cc:std::_Hash_bytes(void const*, unsigned long, unsigned long) [/usr/lib64/libstdc++.so.6.0.33]
    17,373,548 ( 0.01%)  /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_create(unsigned long&, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    16,846,212 ( 0.01%)  ???:0x0000000000b2c2d0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    16,468,218 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_tile(unsigned char, unsigned int, unsigned int, unsigned int, unsigned char, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    16,418,628 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/getc.c:getc [/usr/lib64/libc.so.6]
    16,030,954 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    15,783,936 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    15,247,860 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_copy() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    15,064,865 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 [/usr/lib64/libc.so.6]
    14,986,173 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_rgba16(int, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    14,496,281 ( 0.01%)  ???:0x0000000000ad9080 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    14,194,957 ( 0.01%)  ???:0x0000000000816080 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    14,193,159 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_block(unsigned char, unsigned int, unsigned int, unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    13,425,622 ( 0.01%)  /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::copy(char*, char const*, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    13,295,018 ( 0.01%)  build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::operator[](int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    13,290,970 ( 0.01%)  ???:0x0000000000b61150 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    13,272,189 ( 0.01%)  build/_deps/imgui-src/imgui.cpp:ImGui::UpdateKeyboardInputs() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,893,262 ( 0.01%)  build/_deps/stormlib-src/src/SFileListFile.cpp:ReadListFileLine(TListFileCache*, unsigned long*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,889,690 ( 0.01%)  src/code_80091750.c:func_800A7A4C [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,862,117 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_destroy(unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,811,291 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 [/usr/lib64/libc.so.6]
    12,785,013 ( 0.01%)  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inffast_tpl.h:inflate_fast_avx2 [/usr/lib64/libz.so.1.3.1.zlib-ng]
    12,569,407 ( 0.01%)  src/racing/actors.c:evaluate_collision_for_players_and_actors [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,391,473 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyphShapeTT(stbtt_fontinfo const*, int, stbtt_vertex**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,307,942 ( 0.01%)  ???:0x0000000000069100 [/usr/lib64/libnvidia-glsi.so.560.35.03]
    11,853,723 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_shader_get_info(ShaderProgram*, unsigned char*, bool*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,588,226 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,580,802 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_lock_nothrow() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,507,930 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,289,990 ( 0.01%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<ColorCombinerKey const, ColorCombiner> >::_M_valptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,289,450 ( 0.01%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,194,384 ( 0.01%)  libultraship/src/utils/StrHash64.cpp:CRC64(char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,969,808 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt_FlattenCurves(stbtt_vertex*, int, float, int**, int*, void*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,728,725 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_dispose() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,676,449 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_cc.h:ColorCombinerKey::operator==(ColorCombinerKey const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,638,039 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,423,165 ( 0.01%)  ???:0x00000000006fd110 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    10,399,823 ( 0.01%)  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inftrees.c:zng_inflate_table [/usr/lib64/libz.so.1.3.1.zlib-ng]
    10,388,249 ( 0.01%)  /usr/include/c++/14/bits/new_allocator.h:std::__new_allocator<char>::allocate(unsigned long, void const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,382,788 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__weak_count<(__gnu_cxx::_Lock_policy)2> const&, std::nothrow_t) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,382,788 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__weak_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2> const&, std::nothrow_t) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,379,852 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_lock.c:pthread_mutex_lock@@GLIBC_2.2.5 [/usr/lib64/libc.so.6]
    10,304,880 ( 0.01%)  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) [/usr/lib64/libstdc++.so.6.0.33]
    10,236,954 ( 0.01%)  /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::assign(char&, char const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,182,571 ( 0.01%)  /usr/include/c++/14/new:operator new(unsigned long, void*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,160,991 ( 0.01%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<std::pair<ColorCombinerKey const, ColorCombiner> >::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,139,255 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,136,431 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_combine_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,903,285 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__fill_active_edges_new(float*, float*, int, stbtt__active_edge*, float) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,824,689 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/dl-lookup.c:do_lookup_x [/usr/lib64/ld-linux-x86-64.so.2]
     9,769,942 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,704,930 ( 0.01%)  build/_deps/imgui-src/imgui.cpp:FindLatestInputEvent(ImGuiContext*, ImGuiInputEventType, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,636,675 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,507,992 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_timg_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,376,047 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,242,695 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,128,352 ( 0.01%)  ???:0x0000000000a25d20 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,892,715 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__rasterize_sorted_edges(stbtt__bitmap*, stbtt__edge*, int, int, int, int, void*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     8,870,160 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_clip_parameters() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     8,860,458 ( 0.01%)  ???:0x000000000087e2a0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,760,958 ( 0.01%)  ???:0x00000000007aa5e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,748,712 ( 0.01%)  ???:0x0000000000a1b880 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,624,963 ( 0.01%)  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inflate.c:inflate [/usr/lib64/libz.so.1.3.1.zlib-ng]
     8,548,448 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_unlock.c:__pthread_mutex_unlock_usercnt [/usr/lib64/libc.so.6]
     8,353,766 ( 0.01%)  ???:0x00000000007a2bb0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,290,226 ( 0.01%)  /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     8,168,908 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy_chars(char*, char const*, char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     8,025,314 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,900,360 ( 0.01%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::end() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,799,934 ( 0.01%)  ???:0x00000000009f1040 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,741,617 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,719,517 ( 0.01%)  ???:0x0000000000fc60e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,665,314 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::ret() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,644,662 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_allocate(std::allocator<char>&, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,482,680 ( 0.01%)  /usr/include/c++/14/bits/stl_deque.h:std::operator-(std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&, std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,448,543 ( 0.01%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_before_node(unsigned long, unsigned long const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,442,358 ( 0.01%)  ???:0x000000000093eb10 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,438,193 ( 0.01%)  ???:0x0000000000a70090 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,410,177 ( 0.01%)  ???:0x0000000000a22680 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,308,870 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,292,400 ( 0.01%)  /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&, std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,291,238 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,289,220 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,205,410 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_length(unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,136,907 ( 0.01%)  /usr/include/c++/14/variant:decltype(auto) std::__do_visit<std::__detail::__variant::__variant_idx_cookie, std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,066,332 ( 0.01%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,066,332 ( 0.01%)  /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>::_M_head(std::_Tuple_impl<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,066,332 ( 0.01%)  /usr/include/c++/14/tuple:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*& std::__get_helper<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>(std::_Tuple_impl<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,066,332 ( 0.01%)  /usr/include/c++/14/tuple:std::tuple_element<0ul, std::tuple<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter> >::type& std::get<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>(std::tuple<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,064,856 ( 0.01%)  /usr/include/c++/14/bits/move.h:std::__future_base::_Result_base::_Deleter&& std::forward<std::__future_base::_Result_base::_Deleter>(std::remove_reference<std::__future_base::_Result_base::_Deleter>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,027,616 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_set_other_mode(unsigned int, unsigned int, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,970,359 ( 0.01%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_M_key_equals(unsigned long const&, std::__detail::_Hash_node_value<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,937,385 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,921,180 ( 0.01%)  /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource> const& std::forward<std::shared_ptr<Ship::IResource> const&>(std::remove_reference<std::shared_ptr<Ship::IResource> const&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,921,180 ( 0.01%)  /usr/include/c++/14/bits/stl_construct.h:void std::_Construct<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >, std::in_place_index_t<1ul> const&, std::shared_ptr<Ship::IResource> const&>(std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >*, std::in_place_index_t<1ul> const&, std::shared_ptr<Ship::IResource> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,903,423 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c:nexttoken [/usr/lib64/libX11.so.6.4.0]
     6,832,578 ( 0.01%)  /usr/include/c++/14/variant:decltype(auto) std::__do_visit<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,797,739 ( 0.01%)  libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,776,686 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,773,994 ( 0.01%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<std::pair<ColorCombinerKey const, ColorCombiner> >::_M_addr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,770,872 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe [/usr/lib64/libc.so.6]
     6,740,116 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__rasterize(stbtt__bitmap*, stbtt__point*, int*, int, float, float, float, float, int, int, int, void*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,687,465 ( 0.01%)  ???:0x0000000000b4e1a0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,673,594 ( 0.01%)  /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,645,915 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,611,521 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,577,983 ( 0.01%)  /usr/include/c++/14/bits/move.h:char const* std::addressof<char const>(char const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,577,983 ( 0.01%)  /usr/include/c++/14/bits/ptr_traits.h:std::__ptr_traits_ptr_to<char const*, char const, false>::pointer_to(char const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,570,013 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c:parsestringfile [/usr/lib64/libX11.so.6.4.0]
     6,540,130 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,525,018 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,443,473 ( 0.01%)  src/racing/collision.c:generate_collision_grid [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,324,974 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_ins_sort(stbtt__edge*, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,315,384 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c:nextch [/usr/lib64/libX11.so.6.4.0]
     6,298,920 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::OtrSignatureCheck(char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,293,900 ( 0.01%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::_Rb_tree_iterator(std::_Rb_tree_node_base*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,274,728 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release()'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,236,847 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,175,092 ( 0.01%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,173,391 ( 0.01%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::find(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,153,942 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_transposed_matrix_mul(float*, float const*, float const (*) [4]) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,039,522 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,888,772 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::max_size() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,886,117 ( 0.00%)  /usr/include/c++/14/bits/move.h:char* std::addressof<char>(char&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,886,117 ( 0.00%)  /usr/include/c++/14/bits/ptr_traits.h:std::__ptr_traits_ptr_to<char*, char, false>::pointer_to(char&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,871,655 ( 0.00%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_find_before_node(unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,859,090 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:bool std::operator==<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,836,376 ( 0.00%)  /usr/include/c++/14/bits/new_allocator.h:std::__new_allocator<char>::deallocate(char*, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,804,917 ( 0.00%)  ???:0x0000000000b5e190 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,793,308 ( 0.00%)  ???:0x0000000000847970 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,787,210 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,714,246 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:calloc [/usr/lib64/libc.so.6]
     5,625,522 ( 0.00%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(unsigned long const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,606,660 ( 0.00%)  ???:0x0000000000b5a2b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,575,395 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:std::__invoke_result<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul> >::type std::__invoke<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul> >(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,559,732 ( 0.00%)  ???:0x0000000000a241b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,531,758 ( 0.00%)  ???:0x0000000000b5fd40 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,473,839 ( 0.00%)  ???:0x0000000000815e50 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,472,876 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/libioP.h:getc
     5,450,640 ( 0.00%)  /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::index() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,449,232 ( 0.00%)  src/port/GBIMiddleware.cpp:gSPDisplayList [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,416,651 ( 0.00%)  ???:0x0000000000fc04d0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,414,519 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_M_equals(unsigned long const&, unsigned long, std::__detail::_Hash_node_value<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,399,020 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>>(std::promise<std::shared_ptr<Ship::IResource> >*&, std::_Sp_alloc_shared_tag<std::allocator<void> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,360,880 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,347,236 ( 0.00%)  /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,303,515 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>)'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,300,856 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,298,642 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter, void>(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,294,049 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 [/usr/lib64/libc.so.6]
     5,287,379 ( 0.00%)  ???:0x0000000000cdbab0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,285,764 ( 0.00%)  /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)::_Guard::~_Guard() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,274,828 ( 0.00%)  /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::end() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,237,876 ( 0.00%)  /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::push_back(F3DGfx* const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,213,815 ( 0.00%)  ???:0x0000000001006030 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,208,489 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,191,394 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::shared_ptr(std::weak_ptr<Ship::Context> const&, std::nothrow_t) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,191,394 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::weak_ptr<Ship::Context>::lock() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,186,962 ( 0.00%)  ???:0x0000000000a70ff0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,155,165 ( 0.00%)  ???:0x00000000006eb0a0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,153,904 ( 0.00%)  build/_deps/imgui-src/imgui_draw.cpp:ImFont::RenderText(ImDrawList*, float, ImVec2 const&, unsigned int, ImVec4 const&, char const*, char const*, float, bool) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,137,300 ( 0.00%)  /usr/include/c++/14/bits/utility.h:unsigned long std::__find_uniq_type_in_pack<std::shared_ptr<Ship::IResource>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,107,390 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,102,396 ( 0.00%)  /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base*&, std::__future_base::_Result_base::_Deleter, void>(std::__future_base::_Result_base*&, std::__future_base::_Result_base::_Deleter&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,102,396 ( 0.00%)  /usr/include/c++/14/tuple:std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result_base*&, std::__future_base::_Result_base::_Deleter>(std::__future_base::_Result_base*&, std::__future_base::_Result_base::_Deleter&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,089,058 ( 0.00%)  /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::push_back(char const&) [/usr/lib64/libspdlog.so.1.12.0]
     5,069,556 ( 0.00%)  ???:0x0000000000b6f140 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,050,809 ( 0.00%)  /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::pop_back() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,039,904 ( 0.00%)  /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::push_back(F3DGfx const* const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,004,642 ( 0.00%)  /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::~promise() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,001,408 ( 0.00%)  ???:0x0000000000fbafd0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,974,728 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,852,300 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,836,701 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture(int, int, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,821,793 ( 0.00%)  src/code_80057C60.c:func_80062C74 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,809,392 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(unsigned long const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,807,908 ( 0.00%)  libultraship/src/Context.cpp:Ship::Context::GetResourceManager() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,806,375 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::__gen_vtable_impl<std::__detail::__variant::_Multi_array<std::__detail::__variant::__variant_idx_cookie (*)(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)>, std::integer_sequence<unsigned long, 1ul> >::__visit_invoke(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,805,240 ( 0.00%)  /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)::_Guard::_Guard(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,805,220 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::operator=(RawTexMetadata const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,803,909 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_key_equals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,803,485 ( 0.00%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,772,440 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,764,072 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::~_Alloc_hider() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,736,661 ( 0.00%)  ???:0x0000000000819120 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,710,888 ( 0.00%)  /usr/include/c++/14/tuple:std::_Head_base<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, false>::_M_head(std::_Head_base<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, false>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,688,855 ( 0.00%)  ???:0x0000000000b21b20 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,629,768 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&& std::forward<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}>(std::remove_reference<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,614,120 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:void std::__invoke_impl<void, std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul> >(std::__invoke_other, std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,614,080 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_once.c:__pthread_once_slow.isra.0 [/usr/lib64/libc.so.6]
     4,613,708 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count<std::__future_base::_State_baseV2, std::allocator<void>>(std::__future_base::_State_baseV2*&, std::_Sp_alloc_shared_tag<std::allocator<void> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,613,708 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_set_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,582,980 ( 0.00%)  src/code_800AF9B0.c:func_800AF9E4 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,573,937 ( 0.00%)  /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,562,390 ( 0.00%)  src/racing/math_util.c:coss [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,561,785 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_equals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true> const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,554,506 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,552,285 ( 0.00%)  ???:0x00000000009f1060 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,537,020 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,527,527 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:alpha_comb(unsigned int, unsigned int, unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,527,527 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:color_comb(unsigned int, unsigned int, unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,494,108 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,491,776 ( 0.00%)  ???:0x0000000000a21360 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,466,000 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dl_handler_common(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,464,486 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::shared_ptr(std::shared_ptr<Ship::ResourceManager> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,443,023 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_tile(unsigned char, unsigned int, unsigned int, unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,436,573 ( 0.00%)  ???:0x0000000000b839e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,434,650 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,416,642 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,416,642 ( 0.00%)  /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_head(std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,416,642 ( 0.00%)  /usr/include/c++/14/tuple:std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_M_head(std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,416,642 ( 0.00%)  /usr/include/c++/14/tuple:std::__future_base::_Result_base*& std::__get_helper<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>(std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,416,642 ( 0.00%)  /usr/include/c++/14/tuple:std::__future_base::_Result_base::_Deleter& std::__get_helper<1ul, std::__future_base::_Result_base::_Deleter>(std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,416,642 ( 0.00%)  /usr/include/c++/14/tuple:std::tuple_element<0ul, std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> >::type& std::get<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>(std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,406,754 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,393,395 ( 0.00%)  /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::set_value(std::shared_ptr<Ship::IResource> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,392,740 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,392,718 ( 0.00%)  libultraship/src/Context.cpp:Ship::Context::GetInstance() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,390,698 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,385,322 ( 0.00%)  /usr/include/c++/14/bits/move.h:char const* std::__addressof<char const>(char const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,380,544 ( 0.00%)  ???:0x0000000000a6fc20 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,379,217 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,375,379 ( 0.00%)  ???:0x0000000000a70fb0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,341,542 ( 0.00%)  ???:0x0000000000a750c0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,332,107 ( 0.00%)  /usr/include/c++/14/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char*>(char*, char*, std::forward_iterator_tag) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,328,916 ( 0.00%)  ???:0x0000000000a25600 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,324,722 ( 0.00%)  ???:0x0000000000abe6d0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,317,792 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check(unsigned long, char const*) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,294,944 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:signed char get_attr<signed char>(Attribute) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,286,112 ( 0.00%)  libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::HashToString[abi:cxx11](unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,229,610 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::__gen_vtable_impl<std::__detail::__variant::_Multi_array<void (*)(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&)>, std::integer_sequence<unsigned long, 1ul> >::__visit_invoke(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,221,052 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:void std::__invoke_impl<void, void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::__invoke_memfun_deref, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,183,949 ( 0.00%)  ???:0x00000000006ebb10 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,130,628 ( 0.00%)  src/racing/math_util.c:sins [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,128,594 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_normalize_vector(float*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,120,545 ( 0.00%)  ???:0x0000000000a6d610 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,115,474 ( 0.00%)  /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<F3DGfx const* const*, std::vector<F3DGfx const*, std::allocator<F3DGfx const*> > >::__normal_iterator(F3DGfx const* const* const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,088,239 ( 0.00%)  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/path-util.c:path_find_first_component [/usr/lib64/libudev.so.1.7.8]
     4,059,457 ( 0.00%)  build/_deps/imgui-src/imgui.cpp:ImGui::Begin(char const*, bool*, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,057,716 ( 0.00%)  src/racing/math_util.c:mtxf_pos_rotation_xyz [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,053,214 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__str_hash_base<char, std::allocator<char>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,047,174 ( 0.00%)  /usr/include/c++/14/bits/allocator.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_allocate(std::allocator<char>&, unsigned long)
     4,045,871 ( 0.00%)  ???:0x000000000070dc80 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,041,696 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_draw_rectangle(int, int, int, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,024,980 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,993,390 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,932,230 ( 0.00%)  build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::GetTexDataAsRGBA32(unsigned char**, int*, int*, int*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,928,020 ( 0.00%)  /usr/include/c++/14/bits/move.h:char* std::__addressof<char>(char&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,924,920 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::__uniq_ptr_impl<std::__future_base::_Result_base::_Deleter>(std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,921,705 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_self.c:pthread_self [/usr/lib64/libc.so.6]
     3,891,424 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_free_merge_chunk [/usr/lib64/libc.so.6]
     3,858,140 ( 0.00%)  /usr/include/c++/14/variant:void std::__detail::__variant::__raw_idx_visit<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,845,100 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:std::enable_if<is_invocable_r_v<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::shared_ptr<Ship::IResource>&>, void>::type std::__invoke_r<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::shared_ptr<Ship::IResource>&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::shared_ptr<Ship::IResource>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,845,100 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:void std::__invoke_impl<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::shared_ptr<Ship::IResource>&>(std::__invoke_other, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::shared_ptr<Ship::IResource>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,828,396 ( 0.00%)  /usr/include/c++/14/future:void std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2>(std::shared_ptr<std::__future_base::_State_baseV2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,825,700 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_othermode_h_handler_f3d(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,824,756 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, false, true>::_Node_iterator(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,777,664 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,741,340 ( 0.00%)  /usr/include/c++/14/bits/stl_construct.h:decltype (::new ((void*)(0)) F3DGfx*((declval<F3DGfx* const&>)())) std::construct_at<F3DGfx*, F3DGfx* const&>(F3DGfx**, F3DGfx* const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,733,280 ( 0.00%)  /usr/include/c++/14/bits/stl_construct.h:decltype (::new ((void*)(0)) F3DGfx const*((declval<F3DGfx const* const&>)())) std::construct_at<F3DGfx const*, F3DGfx const* const&>(F3DGfx const**, F3DGfx const* const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,733,280 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::call(F3DGfx*, F3DGfx*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,730,232 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::~unique_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,730,232 ( 0.00%)  /usr/include/c++/14/mutex:std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&)::{lambda()#1}::operator()() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,723,318 ( 0.00%)  ???:0x00000000009f1220 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,721,452 ( 0.00%)  ???:0x0000000000ac1cf0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,716,350 ( 0.00%)  /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__get<1ul, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,716,350 ( 0.00%)  /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__get_n<1ul, std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,702,679 ( 0.00%)  ???:glXGetConfig [/usr/lib64/libGLX_nvidia.so.560.35.03]
     3,696,561 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,652,845 ( 0.00%)  /usr/include/c++/14/variant:auto std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}::operator()<std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul> >(std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,632,068 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:std::__invoke_result<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>::type std::__invoke<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,612,340 ( 0.00%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__tesselate_curve(stbtt__point*, int*, float, float, float, float, float, float, float, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,605,763 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,604,923 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,604,923 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,568,650 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_geometry_mode(unsigned int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,559,080 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_marker_handler_otr(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,554,273 ( 0.00%)  /usr/include/c++/14/bits/stl_iterator.h:bool __gnu_cxx::operator==<F3DGfx const* const*, std::vector<F3DGfx const*, std::allocator<F3DGfx const*> > >(__gnu_cxx::__normal_iterator<F3DGfx const* const*, std::vector<F3DGfx const*, std::allocator<F3DGfx const*> > > const&, __gnu_cxx::__normal_iterator<F3DGfx const* const*, std::vector<F3DGfx const*, std::allocator<F3DGfx const*> > > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,554,273 ( 0.00%)  /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::empty() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,544,578 ( 0.00%)  /usr/include/c++/14/bits/stl_iterator.h:std::back_insert_iterator<fmt::v10::detail::buffer<char> >::operator=(char&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,533,904 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::operator bool() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,533,904 ( 0.00%)  /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::_M_get_result() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,533,904 ( 0.00%)  /usr/include/c++/14/mutex:void std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,533,166 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,532,428 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::__future_base::_Result_base*& std::forward<std::__future_base::_Result_base*&>(std::remove_reference<std::__future_base::_Result_base*&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,526,824 ( 0.00%)  ???:0x0000000000abcfe0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,517,128 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&& std::forward<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}>(std::remove_reference<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,509,737 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<LUS::Texture, (__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_ptr<LUS::Texture, (__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,484,650 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,482,466 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>::_Node_const_iterator(std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,466,376 ( 0.00%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,448,908 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,448,908 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,447,610 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&& std::__detail::_Select1st::operator()<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,446,305 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/arena.c:free
     3,441,819 ( 0.00%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node(unsigned long, unsigned long const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,435,740 ( 0.00%)  /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::~__allocated_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,435,740 ( 0.00%)  /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::~__allocated_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,434,230 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,393,079 ( 0.00%)  ???:0x00000000009f1720 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,366,792 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_tile_size(unsigned char, unsigned short, unsigned short, unsigned short, unsigned short) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,363,668 ( 0.00%)  /usr/include/c++/14/bits/stl_iterator_base_funcs.h:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)
     3,355,746 ( 0.00%)  ???:0x00000000006fd4e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,353,001 ( 0.00%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__h_prefilter(unsigned char*, int, int, int, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,349,614 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,337,576 ( 0.00%)  /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::__allocated_ptr(std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >&, std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,337,576 ( 0.00%)  /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::__allocated_ptr(std::allocator<std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >&, std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,335,214 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcspn-sse4.c:__strcspn_sse42 [/usr/lib64/libc.so.6]
     3,334,593 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,319,454 ( 0.00%)  /usr/include/c++/14/bits/std_function.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::function<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>, void>(std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,319,256 ( 0.00%)  /usr/include/c++/14/bits/allocator.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_destroy(unsigned long)
     3,297,215 ( 0.00%)  ???:0x0000000000b242f0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,288,480 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,268,335 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Uninitialized<std::shared_ptr<Ship::IResource>, false>::_Uninitialized<std::shared_ptr<Ship::IResource> const&>(std::in_place_index_t<0ul>, std::shared_ptr<Ship::IResource> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,268,335 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variadic_union<1ul, std::shared_ptr<Ship::IResource> const&>(std::in_place_index_t<1ul>, std::shared_ptr<Ship::IResource> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,268,335 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, std::shared_ptr<Ship::IResource> >::_Variadic_union<std::shared_ptr<Ship::IResource> const&>(std::in_place_index_t<0ul>, std::shared_ptr<Ship::IResource> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,266,040 ( 0.00%)  src/racing/math_util.c:mtxf_identity [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,252,570 ( 0.00%)  ???:0x0000000000b27090 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,239,412 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,238,296 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::substr(unsigned long, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,234,060 ( 0.00%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__new_active(stbtt__hheap*, stbtt__edge*, int, float, void*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,216,504 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_cc.h:ColorCombinerKey::operator<=>(ColorCombinerKey const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,196,564 ( 0.00%)  src/code_80057C60.c:func_80060504 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,182,160 ( 0.00%)  /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::substr(unsigned long, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,173,288 ( 0.00%)  /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::pop_back() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,161,143 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,139,936 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::release() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,139,936 ( 0.00%)  /usr/include/c++/14/tuple:std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter>(std::__future_base::_Result_base::_Deleter&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,102,849 ( 0.00%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_ptr() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,090,789 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,090,789 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,089,897 ( 0.00%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_find_node(unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,081,855 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_handler_f3d(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,054,148 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_vertex_array_set_attribs(ShaderProgram*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,031,738 ( 0.00%)  src/code_80057C60.c:func_80062B18 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,023,460 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count()'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,022,368 ( 0.00%)  /usr/include/c++/14/any:void* std::__any_caster<signed char>(std::any const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,009,930 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator_base<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>::_Node_iterator_base(std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,008,129 ( 0.00%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/StrKeysym.c:XStringToKeysym [/usr/lib64/libX11.so.6.4.0]
     3,005,640 ( 0.00%)  src/racing/math_util.c:mtxf_multiplication [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,004,957 ( 0.00%)  /usr/include/fmt/core.h:fmt::v10::appender fmt::v10::detail::copy_str<char, char*, fmt::v10::appender>(char*, char*, fmt::v10::appender) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,992,620 ( 0.00%)  /usr/include/c++/14/ext/atomicity.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release()'2
     2,983,008 ( 0.00%)  src/code_800AF9B0.c:func_800AFE00 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,980,090 ( 0.00%)  src/racing/actors.c:evaluate_collision_between_player_actor [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,970,808 ( 0.00%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/xlibi18n/lcFile.c:resolve_name [/usr/lib64/libX11.so.6.4.0]
     2,964,480 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,950,816 ( 0.00%)  src/code_80057C60.c:func_8006C6AC [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,946,419 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_free_create_chunk [/usr/lib64/libc.so.6]
     2,944,920 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,944,920 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,944,920 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,944,920 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::swap(std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,944,428 ( 0.00%)  /usr/include/c++/14/tuple:std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_M_head(std::_Head_base<0ul, std::__future_base::_Result_base*, false>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,944,428 ( 0.00%)  /usr/include/c++/14/tuple:std::_Head_base<1ul, std::__future_base::_Result_base::_Deleter, true>::_M_head(std::_Head_base<1ul, std::__future_base::_Result_base::_Deleter, true>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,943,690 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter, true, true>::__uniq_ptr_impl<std::__future_base::_Result_base::_Deleter>(std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,942,120 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator_base<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true>::_Node_iterator_base(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true>*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,912,923 ( 0.00%)  /usr/include/c++/14/bits/stl_function.h:std::equal_to<unsigned long>::operator()(unsigned long const&, unsigned long const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,885,302 ( 0.00%)  build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,874,510 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_check_image_signature(char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,862,020 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_Sp_counted_base() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,842,834 ( 0.00%)  build/_deps/imgui-src/imstb_rectpack.h:stbrp__skyline_find_min_y(stbrp_context*, stbrp_node*, int, int, int*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,831,299 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>::operator()() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,820,613 ( 0.00%)  ???:0x0000000000fb6ed0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,812,541 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_limit(unsigned long, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,803,829 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>::get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,799,138 ( 0.00%)  ???:0x0000000000a6d7c0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,795,608 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_i4(int, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,792,958 ( 0.00%)  build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,788,794 ( 0.00%)  ???:0x000000000076ef90 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,781,260 ( 0.00%)  ???:0x00000000005705b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,763,559 ( 0.00%)  /usr/include/c++/14/bits/functional_hash.h:std::_Hash_impl::hash(void const*, unsigned long, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,751,515 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2>::__shared_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,748,592 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_State_baseV2::_State_baseV2() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,748,018 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,747,444 ( 0.00%)  /usr/include/c++/14/tuple:std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_Head_base<std::__future_base::_Result_base*&>(std::__future_base::_Result_base*&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,735,544 ( 0.00%)  /usr/include/c++/14/variant:std::__do_visit<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&)::{lambda(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&, ...)#1}::operator()(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&, ...) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,723,504 ( 0.00%)  ???:0x0000000000a25c50 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,723,302 ( 0.00%)  ???:0x0000000000b5b1f0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,718,898 ( 0.00%)  /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,717,776 ( 0.00%)  libultraship/src/public/bridge/resourcebridge.cpp:ResourceLoad(char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,705,283 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,700,698 ( 0.00%)  /usr/include/c++/14/variant:std::__do_visit<std::__detail::__variant::__variant_idx_cookie, std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&, ...)#1}::operator()(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&, ...) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,696,320 ( 0.00%)  libultraship/src/utils/binarytools/MemoryStream.cpp:Ship::MemoryStream::Read(char const*, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,692,036 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/getenv.c:getenv [/usr/lib64/libc.so.6]
     2,682,484 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<LUS::Texture, (__gnu_cxx::_Lock_policy)2>::get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,675,504 ( 0.00%)  ???:0x0000000000a74ac0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,657,479 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:unlink_chunk.isra.0 [/usr/lib64/libc.so.6]
     2,650,428 ( 0.00%)  /usr/include/c++/14/bits/new_allocator.h:std::__new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >::allocate(unsigned long, void const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,650,428 ( 0.00%)  /usr/include/c++/14/bits/new_allocator.h:std::__new_allocator<std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >::allocate(unsigned long, void const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,650,428 ( 0.00%)  /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::_M_deleter() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,650,428 ( 0.00%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::__future_base::_State_baseV2>::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,650,428 ( 0.00%)  /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::promise<std::shared_ptr<Ship::IResource> > >::_M_ptr() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,650,428 ( 0.00%)  /usr/include/c++/14/tuple:std::tuple_element<1ul, std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> >::type& std::get<1ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>(std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,649,690 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,646,462 ( 0.00%)  /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::basic_string_view(char const*, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,620,800 ( 0.00%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >::_Rb_tree_iterator(std::_Rb_tree_node_base*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,614,635 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::operator bool() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,612,759 ( 0.00%)  ???:0x0000000000b1fe30 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,589,840 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_size_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,555,280 ( 0.00%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::end() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,555,280 ( 0.00%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::find(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,552,264 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,552,264 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,552,264 ( 0.00%)  /usr/include/c++/14/bits/stl_construct.h:void std::_Construct<std::promise<std::shared_ptr<Ship::IResource> >>(std::promise<std::shared_ptr<Ship::IResource> >*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,552,264 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_State_baseV2::wait() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,552,264 ( 0.00%)  /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::promise() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,549,454 ( 0.00%)  ???:0x00000000007cf230 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,544,936 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,536,885 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_draw_triangles(float*, unsigned long, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,531,672 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Variant_storage() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,524,111 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_texture_rectangle(int, int, int, int, unsigned char, short, short, short, short, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,520,130 ( 0.00%)  /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,512,020 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::RawTexMetadata(RawTexMetadata const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,507,791 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Copy_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_assign_base(std::__detail::__variant::_Copy_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,507,791 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Move_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Move_assign_base(std::__detail::__variant::_Move_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,507,791 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Move_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Move_ctor_base(std::__detail::__variant::_Move_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,507,791 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_base(std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,507,791 ( 0.00%)  /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::variant(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,507,057 ( 0.00%)  /usr/include/c++/14/bits/functional_hash.h:std::hash<unsigned long>::operator()(unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,499,315 ( 0.00%)  /usr/include/c++/14/variant:auto std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}::operator()<std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,494,390 ( 0.00%)  ???:0x0000000000fc2730 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,467,101 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,462,938 ( 0.00%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/VisUtil.c:XGetVisualInfo [/usr/lib64/libX11.so.6.4.0]
     2,454,100 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<std::__future_base::_Result_base*> >, std::is_move_constructible<std::__future_base::_Result_base*>, std::is_move_assignable<std::__future_base::_Result_base*> >::value, void>::type std::swap<std::__future_base::_Result_base*>(std::__future_base::_Result_base*&, std::__future_base::_Result_base*&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,454,100 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>&&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,440,775 ( 0.00%)  /usr/include/c++/14/bits/invoke.h:std::enable_if<is_invocable_r_v<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>&>, std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::type std::__invoke_r<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>&>(std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,434,542 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_ebo_helper<0, std::allocator<void>, true>::_S_get(std::_Sp_ebo_helper<0, std::allocator<void>, true>&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,431,871 ( 0.00%)  /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::size() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,431,871 ( 0.00%)  /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::push(F3DGfx* const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,431,871 ( 0.00%)  /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::end() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,426,928 ( 0.00%)  /usr/include/fmt/format.h:void fmt::v10::detail::buffer<char>::append<char>(char const*, char const*) [/usr/lib64/libspdlog.so.1.12.0]
     2,422,888 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_cache_lookup(int, TextureCacheKey const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,403,947 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2>::get() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,403,440 ( 0.00%)  ???:0x0000000000fc95c0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,401,399 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::operator=(std::shared_ptr<LUS::Texture> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,392,861 ( 0.00%)  ???:0x00000000007891f0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,386,080 ( 0.00%)  /usr/include/c++/14/any:signed char std::any_cast<signed char>(std::any const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,385,152 ( 0.00%)  /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_mutex_lock(pthread_mutex_t*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,384,832 ( 0.00%)  /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_mutex_unlock(pthread_mutex_t*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,377,071 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.h:TextureCacheKey::operator==(TextureCacheKey const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,370,782 ( 0.00%)  src/code_80091750.c:func_80095E10 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,365,717 ( 0.00%)  /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [/usr/lib64/libspdlog.so.1.12.0]
     2,362,726 ( 0.00%)  build/_deps/imgui-src/imgui.h:ImVector<float>::operator[](int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,355,936 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::remove_reference<std::__future_base::_Result_base*&>::type&& std::move<std::__future_base::_Result_base*&>(std::__future_base::_Result_base*&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,355,936 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_do_set(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,348,837 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/../stdlib/strtol_l.c:____strtoul_l_internal [/usr/lib64/libc.so.6]
     2,347,706 ( 0.00%)  build/_deps/imgui-src/imgui_draw.cpp:Decode85(unsigned char const*, unsigned char*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,343,144 ( 0.00%)  /usr/include/c++/14/bits/std_function.h:void std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&> >::_M_create<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&> >(std::_Any_data&, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>&&, std::integral_constant<bool, true>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,342,641 ( 0.00%)  ???:0x0000000000a29660 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,339,064 ( 0.00%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,339,064 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_bucket_index(unsigned long, unsigned long) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,329,520 ( 0.00%)  /usr/include/c++/14/variant:std::variant_alternative<1ul, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >::type& std::get<1ul, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,326,620 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource>& std::forward<std::shared_ptr<Ship::IResource>&>(std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,320,978 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(decltype(nullptr)) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,314,884 ( 0.00%)  /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,307,060 ( 0.00%)  /usr/include/c++/14/bits/move.h:std::integral_constant<unsigned long, 1ul>&& std::forward<std::integral_constant<unsigned long, 1ul> >(std::remove_reference<std::integral_constant<unsigned long, 1ul> >::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,293,836 ( 0.00%)  /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_M_lower_bound(std::_Rb_tree_node<std::pair<ColorCombinerKey const, ColorCombiner> >*, std::_Rb_tree_node_base*, ColorCombinerKey const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,257,776 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::~_Result()'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,257,772 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_Sp_counted_ptr_inplace<>(std::allocator<void>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,257,772 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<std::allocator<void>>(std::_Sp_alloc_shared_tag<std::allocator<void> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,257,772 ( 0.00%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::promise<std::shared_ptr<Ship::IResource> >, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<std::allocator<void>>(std::_Sp_alloc_shared_tag<std::allocator<void> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,257,772 ( 0.00%)  /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::__basic_future(std::shared_ptr<std::__future_base::_State_baseV2> const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,249,625 ( 0.00%)  build/_deps/stormlib-src/src/SBaseFileTable.cpp:IsValidHashEntry1(_TMPQArchive*, _TMPQHash*, _TMPQBlock*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,245,513 ( 0.00%)  /usr/include/c++/14/bits/std_function.h:std::_Function_handler<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (), std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&> >::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,244,804 ( 0.00%)  /usr/include/c++/14/bits/move.h:F3DGfx* const& std::forward<F3DGfx* const&>(std::remove_reference<F3DGfx* const&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,244,804 ( 0.00%)  /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<F3DGfx const* const*, std::vector<F3DGfx const*, std::allocator<F3DGfx const*> > >::base() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,244,804 ( 0.00%)  /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::begin() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,244,804 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_end_dl_handler_common(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,239,986 ( 0.00%)  /usr/include/c++/14/bits/move.h:F3DGfx const* const& std::forward<F3DGfx const* const&>(std::remove_reference<F3DGfx const* const&>::type&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,229,906 ( 0.00%)  /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::splice(std::_List_const_iterator<TextureCacheMapIter>, std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&&, std::_List_const_iterator<TextureCacheMapIter>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,211,480 ( 0.00%)  /usr/include/c++/14/bits/std_mutex.h:std::lock_guard<std::mutex>::lock_guard(std::mutex&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,210,535 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::__detail::_Select1st, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>::_M_hash_code(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,201,700 ( 0.00%)  /usr/include/c++/14/variant:bool std::holds_alternative<std::shared_ptr<Ship::IResource>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,194,662 ( 0.00%)  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/hashmap.c:bucket_move_entry.lto_priv.0 [/usr/lib64/libudev.so.1.7.8]
     2,161,143 ( 0.00%)  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/siphash24.c:siphash24_compress [/usr/lib64/libudev.so.1.7.8]

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/allocated_ptr.h
--------------------------------------------------------------------------------
Ir                 

-- line 45 ----------------------------------------
        .             /// Non-standard RAII type for managing pointers obtained from allocators.
        .             template<typename _Alloc>
        .               struct __allocated_ptr
        .               {
        .                 using pointer = typename allocator_traits<_Alloc>::pointer;
        .                 using value_type = typename allocator_traits<_Alloc>::value_type;
        .           
        .                 /// Take ownership of __ptr
2,446,248 ( 0.00%)        __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
3,261,664 ( 0.00%)        : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
       24 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::allocator<std::_Sp_counted_ptr_inplace<Ship::ControllerLED, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >* std::__addressof<std::allocator<std::_Sp_counted_ptr_inplace<Ship::ControllerLED, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >(std::allocator<std::_Sp_counted_ptr_inplace<Ship::ControllerLED, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >&) (4x)
1,223,124 ( 0.00%)        { }
        .           
        .                 /// Convert __ptr to allocator's pointer type and take ownership of it
        .                 template<typename _Ptr,
        .           	       typename _Req = _Require<is_same<_Ptr, value_type*>>>
        .                 __allocated_ptr(_Alloc& __a, _Ptr __ptr)
        .                 : _M_alloc(std::__addressof(__a)),
        .           	_M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
        .                 { }
        .           
        .                 /// Transfer ownership of the owned pointer
        .                 __allocated_ptr(__allocated_ptr&& __gd) noexcept
        .                 : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
        .                 { __gd._M_ptr = nullptr; }
        .           
        .                 /// Deallocate the owned pointer
1,630,832 ( 0.00%)        ~__allocated_ptr()
        .                 {
1,630,832 ( 0.00%)  	if (_M_ptr != nullptr)
2,637,414 ( 0.00%)  	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
1,223,124 ( 0.00%)        }
        .           
        .                 /// Release ownership of the owned pointer
        .                 __allocated_ptr&
  819,320 ( 0.00%)        operator=(std::nullptr_t) noexcept
        .                 {
  409,660 ( 0.00%)  	_M_ptr = nullptr;
  204,830 ( 0.00%)  	return *this;
  409,660 ( 0.00%)        }
        .           
        .                 /// Get the address that the owned pointer refers to.
2,044,300 ( 0.00%)        value_type* get() { return std::__to_address(_M_ptr); }
        6 ( 0.00%)  => /usr/include/c++/14/bits/ptr_traits.h:std::_Sp_counted_ptr_inplace<Ship::ControlDeck, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>* std::__to_address<std::_Sp_counted_ptr_inplace<Ship::ControlDeck, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >(std::_Sp_counted_ptr_inplace<Ship::ControlDeck, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>*) (1x)
        .           
        .               private:
        .                 _Alloc* _M_alloc;
        .                 pointer _M_ptr;
        .               };
        .           
        .             /// Allocate space for a single object using __a
        .             template<typename _Alloc>
        .               __allocated_ptr<_Alloc>
2,453,160 ( 0.00%)      __allocate_guarded(_Alloc& __a)
        .               {
1,022,150 ( 0.00%)        return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
       23 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<spdlog::sinks::rotating_file_sink<std::mutex>, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::__allocated_ptr(std::allocator<std::_Sp_counted_ptr_inplace<spdlog::sinks::rotating_file_sink<std::mutex>, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >&, std::_Sp_counted_ptr_inplace<spdlog::sinks::rotating_file_sink<std::mutex>, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>*) (1x)
  613,290 ( 0.00%)      }
        .           
        .           /// @endcond
        .           _GLIBCXX_END_NAMESPACE_VERSION
        .           } // namespace std
        .           
        .           #endif
        .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir                 

-- line 225 ----------------------------------------
        .              *
        .              *  This is the simple classic generic implementation.  It will work on
        .              *  temporary expressions, since they are only evaluated once, unlike a
        .              *  preprocessor macro.
        .             */
        .             template<typename _Tp>
        .               _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
        .               inline const _Tp&
  773,100 ( 0.00%)      min(const _Tp& __a, const _Tp& __b)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
        .                 //return __b < __a ? __b : __a;
1,159,650 ( 0.00%)        if (__b < __a)
   25,640 ( 0.00%)  	return __b;
  180,455 ( 0.00%)        return __a;
  386,550 ( 0.00%)      }
        .           
        .             /**
        .              *  @brief This does what you think it does.
        .              *  @ingroup sorting_algorithms
        .              *  @param  __a  A thing of arbitrary type.
        .              *  @param  __b  Another thing of arbitrary type.
        .              *  @return   The greater of the parameters.
        .              *
        .              *  This is the simple classic generic implementation.  It will work on
        .              *  temporary expressions, since they are only evaluated once, unlike a
        .              *  preprocessor macro.
        .             */
        .             template<typename _Tp>
        .               _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
        .               inline const _Tp&
   51,172 ( 0.00%)      max(const _Tp& __a, const _Tp& __b)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
        .                 //return  __a < __b ? __b : __a;
   76,843 ( 0.00%)        if (__a < __b)
    5,864 ( 0.00%)  	return __b;
    9,861 ( 0.00%)        return __a;
   25,586 ( 0.00%)      }
        .           
        .             /**
        .              *  @brief This does what you think it does.
        .              *  @ingroup sorting_algorithms
        .              *  @param  __a  A thing of arbitrary type.
        .              *  @param  __b  Another thing of arbitrary type.
        .              *  @param  __comp  A @link comparison_functors comparison functor@endlink.
        .              *  @return   The lesser of the parameters.
-- line 273 ----------------------------------------
-- line 308 ----------------------------------------
        .                 return __a;
        .               }
        .           
        .             // Fallback implementation of the function in bits/stl_iterator.h used to
        .             // remove the __normal_iterator wrapper. See copy, fill, ...
        .             template<typename _Iterator>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _Iterator
  110,307 ( 0.00%)      __niter_base(_Iterator __it)
        .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
  110,319 ( 0.00%)      { return __it; }
        .           
        .           #if __cplusplus < 201103L
        .             template<typename _Ite, typename _Seq>
        .               _Ite
        .               __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
        .           		 std::random_access_iterator_tag>&);
        .           
        .            template<typename _Ite, typename _Cont, typename _Seq>
-- line 326 ----------------------------------------
-- line 338 ----------------------------------------
        .           #endif
        .           
        .             // Reverse the __niter_base transformation to get a
        .             // __normal_iterator back again (this assumes that __normal_iterator
        .             // is only used to wrap random access iterators, like pointers).
        .             template<typename _From, typename _To>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _From
       12 ( 0.00%)      __niter_wrap(_From __from, _To __res)
       40 ( 0.00%)      { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }
       66 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >::operator+(long) const (2x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:Ship::CommandArgument* std::__niter_base<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >(__gnu_cxx::__normal_iterator<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >) (2x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:Ship::CommandArgument* std::__niter_base<Ship::CommandArgument*>(Ship::CommandArgument*) (2x)
        .           
        .             // No need to wrap, iterator already has the right type.
        .             template<typename _Iterator>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _Iterator
    5,396 ( 0.00%)      __niter_wrap(const _Iterator&, _Iterator __res)
    4,055 ( 0.00%)      { return __res; }
        .           
        .             // All of these auxiliary structs serve two purposes.  (1) Replace
        .             // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
        .             // because the input and output ranges are permitted to overlap.)
        .             // (2) If we're using random access iterators, then write the loop as
        .             // a for loop with an explicit count.
        .           
        .             template<bool _IsMove, bool _IsSimple, typename _Category>
-- line 362 ----------------------------------------
-- line 390 ----------------------------------------
        .           #endif
        .           
        .             template<>
        .               struct __copy_move<false, false, random_access_iterator_tag>
        .               {
        .                 template<typename _II, typename _OI>
        .           	_GLIBCXX20_CONSTEXPR
        .           	static _OI
       72 ( 0.00%)  	__copy_m(_II __first, _II __last, _OI __result)
        .           	{
        .           	  typedef typename iterator_traits<_II>::difference_type _Distance;
       56 ( 0.00%)  	  for(_Distance __n = __last - __first; __n > 0; --__n)
       70 ( 0.00%)  => /usr/include/c++/14/bits/stl_bvector.h:std::operator-(std::_Bit_iterator_base const&, std::_Bit_iterator_base const&) (2x)
        .           	    {
        .           	      *__result = *__first;
        .           	      ++__first;
        .           	      ++__result;
        .           	    }
       26 ( 0.00%)  	  return __result;
       16 ( 0.00%)  	}
        .           
        .                 template<typename _Tp, typename _Up>
        .           	static void
       64 ( 0.00%)  	__assign_one(_Tp* __to, _Up* __from)
   98,605 ( 0.00%)  	{ *__to = *__from; }
        .               };
        .           
        .           #if __cplusplus >= 201103L
        .             template<>
        .               struct __copy_move<true, false, random_access_iterator_tag>
        .               {
        .                 template<typename _II, typename _OI>
        .           	_GLIBCXX20_CONSTEXPR
-- line 421 ----------------------------------------
-- line 440 ----------------------------------------
        .           #endif
        .           
        .             template<bool _IsMove>
        .               struct __copy_move<_IsMove, true, random_access_iterator_tag>
        .               {
        .                 template<typename _Tp, typename _Up>
        .           	_GLIBCXX20_CONSTEXPR
        .           	static _Up*
    7,950 ( 0.00%)  	__copy_m(_Tp* __first, _Tp* __last, _Up* __result)
        .           	{
    3,994 ( 0.00%)  	  const ptrdiff_t _Num = __last - __first;
  158,911 ( 0.00%)  	  if (__builtin_expect(_Num > 1, true))
  144,398 ( 0.00%)  	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
       11 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
   32,846 ( 0.00%)  	  else if (_Num == 1)
        .           	    std::__copy_move<_IsMove, false, random_access_iterator_tag>::
        .           	      __assign_one(__result, __first);
    3,994 ( 0.00%)  	  return __result + _Num;
    2,650 ( 0.00%)  	}
        .               };
        .           
        .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        .           
        .             template<typename _Tp, typename _Ref, typename _Ptr>
        .               struct _Deque_iterator;
        .           
        .             struct _Bit_iterator;
-- line 465 ----------------------------------------
-- line 504 ----------------------------------------
        .           	istreambuf_iterator<_CharT, char_traits<_CharT> >,
        .           	istreambuf_iterator<_CharT, char_traits<_CharT> >,
        .           	_GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>);
        .           #endif // HOSTED
        .           
        .             template<bool _IsMove, typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
    8,022 ( 0.00%)      __copy_move_a2(_II __first, _II __last, _OI __result)
        .               {
        .                 typedef typename iterator_traits<_II>::iterator_category _Category;
        .           #ifdef __cpp_lib_is_constant_evaluated
    3,993 ( 0.00%)        if (std::is_constant_evaluated())
    6,530 ( 0.00%)  => /usr/include/c++/14/type_traits:std::is_constant_evaluated() (1,306x)
        .           	return std::__copy_move<_IsMove, false, _Category>::
        .           	  __copy_m(__first, __last, __result);
        .           #endif
        .                 return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
    9,345 ( 0.00%)  			      _Category>::__copy_m(__first, __last, __result);
  436,551 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<char, char>(char*, char*, char*) (1,306x)
    2,674 ( 0.00%)      }
        .           
        .             template<bool _IsMove,
        .           	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
        .               _OI
        .               __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
        .           		   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
        .           		   _OI);
        .           
-- line 530 ----------------------------------------
-- line 539 ----------------------------------------
        .               typename __gnu_cxx::__enable_if<
        .                 __is_random_access_iter<_II>::__value,
        .                 _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
        .               __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
        .           
        .             template<bool _IsMove, typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
    8,022 ( 0.00%)      __copy_move_a1(_II __first, _II __last, _OI __result)
   10,688 ( 0.00%)      { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
       92 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long* std::__copy_move_a2<false, unsigned long*, unsigned long*>(unsigned long*, unsigned long*, unsigned long*) (2x)
        .           
        .             template<bool _IsMove, typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
   10,676 ( 0.00%)      __copy_move_a(_II __first, _II __last, _OI __result)
        .               {
   26,708 ( 0.00%)        return std::__niter_wrap(__result,
       78 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:spdlog::level::level_enum* std::__copy_move_a1<false, spdlog::level::level_enum const*, spdlog::level::level_enum*>(spdlog::level::level_enum const*, spdlog::level::level_enum const*, spdlog::level::level_enum*) (1x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:spdlog::level::level_enum const* std::__niter_base<spdlog::level::level_enum const*>(spdlog::level::level_enum const*) (2x)
        7 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:spdlog::level::level_enum* std::__niter_wrap<spdlog::level::level_enum*>(spdlog::level::level_enum* const&, spdlog::level::level_enum*) (1x)
        6 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:spdlog::level::level_enum* std::__niter_base<spdlog::level::level_enum*>(spdlog::level::level_enum*) (1x)
        .           		std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
        .           					     std::__niter_base(__last),
        8 ( 0.00%)  					     std::__niter_base(__result)));
    6,647 ( 0.00%)      }
        .           
        .             template<bool _IsMove,
        .           	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               _OI
        .               __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           		  _OI);
-- line 567 ----------------------------------------
-- line 634 ----------------------------------------
        .              *  [first,last); the copy_backward function should be used instead.
        .              *
        .              *  Note that the end of the output range is permitted to be contained
        .              *  within [first,last).
        .             */
        .             template<typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
    9,349 ( 0.00%)      copy(_II __first, _II __last, _OI __result)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_II>)
        .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI,
        .           	    typename iterator_traits<_II>::reference>)
        .                 __glibcxx_requires_can_increment_range(__first, __last, __result);
        .           
        .                 return std::__copy_move_a<__is_move_iterator<_II>::__value>
   17,367 ( 0.00%)  	     (std::__miter_base(__first), std::__miter_base(__last), __result);
      690 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned short* std::__copy_move_a<false, __gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > >, unsigned short*>(__gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > >, __gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > >, unsigned short*) (5x)
       60 ( 0.00%)  => /usr/include/c++/14/bits/cpp_type_traits.h:__gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > > std::__miter_base<__gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > > >(__gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > >) (10x)
    3,993 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201103L
        .             /**
        .              *  @brief Moves the range [first,last) into result.
        .              *  @ingroup mutating_algorithms
        .              *  @param  __first  An input iterator.
        .              *  @param  __last   An input iterator.
        .              *  @param  __result An output iterator.
-- line 660 ----------------------------------------
-- line 754 ----------------------------------------
        .           #endif
        .           
        .             template<bool _IsMove>
        .               struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
        .               {
        .                 template<typename _Tp, typename _Up>
        .           	_GLIBCXX20_CONSTEXPR
        .           	static _Up*
       96 ( 0.00%)  	__copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
        .           	{
       64 ( 0.00%)  	  const ptrdiff_t _Num = __last - __first;
       80 ( 0.00%)  	  if (__builtin_expect(_Num > 1, true))
        .           	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
       32 ( 0.00%)  	  else if (_Num == 1)
        .           	    std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       96 ( 0.00%)  	      __assign_one(__result - 1, __first);
      176 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:void std::__copy_move<false, false, std::random_access_iterator_tag>::__assign_one<OSContPad*, OSContPad*>(OSContPad**, OSContPad**) (16x)
       96 ( 0.00%)  	  return __result - _Num;
       32 ( 0.00%)  	}
        .               };
        .           
        .             template<bool _IsMove, typename _BI1, typename _BI2>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _BI2
       96 ( 0.00%)      __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
        .               {
        .                 typedef typename iterator_traits<_BI1>::iterator_category _Category;
        .           #ifdef __cpp_lib_is_constant_evaluated
       48 ( 0.00%)        if (std::is_constant_evaluated())
       80 ( 0.00%)  => /usr/include/c++/14/type_traits:std::is_constant_evaluated() (16x)
        .           	return std::__copy_move_backward<_IsMove, false, _Category>::
        .           	  __copy_move_b(__first, __last, __result);
        .           #endif
        .                 return std::__copy_move_backward<_IsMove,
        .           				       __memcpyable<_BI2, _BI1>::__value,
       96 ( 0.00%)  				       _Category>::__copy_move_b(__first,
      672 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:OSContPad** std::__copy_move_backward<false, true, std::random_access_iterator_tag>::__copy_move_b<OSContPad*, OSContPad*>(OSContPad**, OSContPad**, OSContPad**) (16x)
        .           								 __last,
       16 ( 0.00%)  								 __result);
       32 ( 0.00%)      }
        .           
        .             template<bool _IsMove, typename _BI1, typename _BI2>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _BI2
       96 ( 0.00%)      __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
      128 ( 0.00%)      { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }
    1,040 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:OSContPad** std::__copy_move_backward_a2<false, OSContPad**, OSContPad**>(OSContPad**, OSContPad**, OSContPad**) (16x)
        .           
        .             template<bool _IsMove,
        .           	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
        .               _OI
        .               __copy_move_backward_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
        .           			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
        .           			    _OI);
        .           
-- line 804 ----------------------------------------
-- line 815 ----------------------------------------
        .                 __is_random_access_iter<_II>::__value,
        .                 _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
        .               __copy_move_backward_a1(_II, _II,
        .           			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
        .           
        .             template<bool _IsMove, typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
      128 ( 0.00%)      __copy_move_backward_a(_II __first, _II __last, _OI __result)
        .               {
      320 ( 0.00%)        return std::__niter_wrap(__result,
    1,264 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:OSContPad** std::__copy_move_backward_a1<false, OSContPad**, OSContPad**>(OSContPad**, OSContPad**, OSContPad**) (16x)
      288 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:OSContPad** std::__niter_base<OSContPad**>(OSContPad**) (48x)
      112 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:OSContPad** std::__niter_wrap<OSContPad**>(OSContPad** const&, OSContPad**) (16x)
        .           		std::__copy_move_backward_a1<_IsMove>
        .           		  (std::__niter_base(__first), std::__niter_base(__last),
        .           		   std::__niter_base(__result)));
       80 ( 0.00%)      }
        .           
        .             template<bool _IsMove,
        .           	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               _OI
        .               __copy_move_backward_a(
        .           		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
-- line 837 ----------------------------------------
-- line 870 ----------------------------------------
        .              *  optimizations such as unrolling).
        .              *
        .              *  Result may not be in the range (first,last].  Use copy instead.  Note
        .              *  that the start of the output range may overlap [first,last).
        .             */
        .             template<typename _BI1, typename _BI2>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _BI2
      112 ( 0.00%)      copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
        .                 __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
        .                 __glibcxx_function_requires(_OutputIteratorConcept<_BI2,
        .           	    typename iterator_traits<_BI1>::reference>)
        .                 __glibcxx_requires_can_decrement_range(__first, __last, __result);
        .           
        .                 return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      208 ( 0.00%)  	     (std::__miter_base(__first), std::__miter_base(__last), __result);
    2,192 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:OSContPad** std::__copy_move_backward_a<false, OSContPad**, OSContPad**>(OSContPad**, OSContPad**, OSContPad**) (16x)
      192 ( 0.00%)  => /usr/include/c++/14/bits/cpp_type_traits.h:OSContPad** std::__miter_base<OSContPad**>(OSContPad**) (32x)
       48 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201103L
        .             /**
        .              *  @brief Moves the range [first,last) into result.
        .              *  @ingroup mutating_algorithms
        .              *  @param  __first  A bidirectional iterator.
        .              *  @param  __last   A bidirectional iterator.
        .              *  @param  __result A bidirectional iterator.
-- line 897 ----------------------------------------
-- line 939 ----------------------------------------
        .                 for (; __first != __last; ++__first)
        .           	*__first = __value;
        .               }
        .           
        .             template<typename _ForwardIterator, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline typename
        .               __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
       10 ( 0.00%)      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
        .           	      const _Tp& __value)
        .               {
        6 ( 0.00%)        const _Tp __tmp = __value;
    1,032 ( 0.00%)        for (; __first != __last; ++__first)
      768 ( 0.00%)  	*__first = __tmp;
        8 ( 0.00%)      }
        .           
        .             // Specialization: for char types we can use memset.
        .             template<typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline typename
        .               __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    3,942 ( 0.00%)      __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
        .               {
    1,971 ( 0.00%)        const _Tp __tmp = __c;
        .           #if __cpp_lib_is_constant_evaluated
    1,971 ( 0.00%)        if (std::is_constant_evaluated())
    3,285 ( 0.00%)  => /usr/include/c++/14/type_traits:std::is_constant_evaluated() (657x)
        .           	{
        .           	  for (; __first != __last; ++__first)
        .           	    *__first = __tmp;
        .           	  return;
        .           	}
        .           #endif
    3,285 ( 0.00%)        if (const size_t __len = __last - __first)
    5,256 ( 0.00%)  	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
1,540,898 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (657x)
    1,314 ( 0.00%)      }
        .           
        .             template<typename _Ite, typename _Cont, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
        .               __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
        .           	      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
        .           	      const _Tp& __value)
        .               { std::__fill_a1(__first.base(), __last.base(), __value); }
-- line 981 ----------------------------------------
-- line 989 ----------------------------------------
        .             _GLIBCXX20_CONSTEXPR
        .             void
        .             __fill_a1(_GLIBCXX_STD_C::_Bit_iterator, _GLIBCXX_STD_C::_Bit_iterator,
        .           	    const bool&);
        .           
        .             template<typename _FIte, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
    3,954 ( 0.00%)      __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    5,931 ( 0.00%)      { std::__fill_a1(__first, __last, __value); }
1,561,922 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:__gnu_cxx::__enable_if<std::__is_byte<char>::__value, void>::__type std::__fill_a1<char>(char*, char*, char const&) (657x)
        .           
        .             template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               void
        .               __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           	     const _Tp&);
        .           
-- line 1006 ----------------------------------------
-- line 1014 ----------------------------------------
        .              *
        .              *  This function fills a range with copies of the same value.  For char
        .              *  types filling contiguous areas of memory, this becomes an inline call
        .              *  to @c memset or @c wmemset.
        .             */
        .             template<typename _ForwardIterator, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
       12 ( 0.00%)      fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
        .           				  _ForwardIterator>)
        .                 __glibcxx_requires_valid_range(__first, __last);
        .           
       12 ( 0.00%)        std::__fill_a(__first, __last, __value);
    1,854 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:void std::__fill_a<int*, int>(int*, int*, int const&) (2x)
        6 ( 0.00%)      }
        .           
        .             // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
        .             inline _GLIBCXX_CONSTEXPR int
        .             __size_to_integer(int __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR unsigned
        .             __size_to_integer(unsigned __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR long
        .             __size_to_integer(long __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR unsigned long
    3,960 ( 0.00%)    __size_to_integer(unsigned long __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR long long
        .             __size_to_integer(long long __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR unsigned long long
        .             __size_to_integer(unsigned long long __n) { return __n; }
        .           
        .           #if defined(__GLIBCXX_TYPE_INT_N_0)
        .             __extension__ inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
        .             __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
-- line 1048 ----------------------------------------
-- line 1132 ----------------------------------------
        .                 static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
        .           #endif
        .                 return __fill_n_a1(__first, __n, __value);
        .               }
        .           
        .             template<typename _OutputIterator, typename _Size, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OutputIterator
    3,960 ( 0.00%)      __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        .           	       std::random_access_iterator_tag)
        .               {
        .           #if __cplusplus >= 201103L
        .                 static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
        .           #endif
    1,320 ( 0.00%)        if (__n <= 0)
        6 ( 0.00%)  	return __first;
        .           
        .                 __glibcxx_requires_can_increment(__first, __n);
        .           
    5,256 ( 0.00%)        std::__fill_a(__first, __first + __n, __value);
1,571,777 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:void std::__fill_a<char*, char>(char*, char*, char const&) (657x)
    1,971 ( 0.00%)        return __first + __n;
    1,320 ( 0.00%)      }
        .           
        .             /**
        .              *  @brief Fills the range [first,first+n) with copies of value.
        .              *  @ingroup mutating_algorithms
        .              *  @param  __first  An output iterator.
        .              *  @param  __n      The count of copies to perform.
        .              *  @param  __value  A reference-to-const of arbitrary type.
        .              *  @return   The iterator at first+n.
-- line 1161 ----------------------------------------
-- line 1167 ----------------------------------------
        .              *  If @p __n is negative, the function does nothing.
        .             */
        .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .             // DR 865. More algorithms that throw away information
        .             // DR 426. search_n(), fill_n(), and generate_n() with negative n
        .             template<typename _OI, typename _Size, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
    3,960 ( 0.00%)      fill_n(_OI __first, _Size __n, const _Tp& __value)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI, const _Tp&>)
        .           
    5,940 ( 0.00%)        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
1,585,574 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:char* std::__fill_n_a<char*, unsigned long, char>(char*, unsigned long, char const&, std::random_access_iterator_tag) (657x)
    3,942 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:std::__size_to_integer(unsigned long) (657x)
        .           			       std::__iterator_category(__first));
    1,320 ( 0.00%)      }
        .           
        .             template<bool _BoolType>
        .               struct __equal
        .               {
        .                 template<typename _II1, typename _II2>
        .           	_GLIBCXX20_CONSTEXPR
        .           	static bool
        .           	equal(_II1 __first1, _II1 __last1, _II2 __first2)
-- line 1190 ----------------------------------------
-- line 1599 ----------------------------------------
        .              *  This compares the elements of two ranges using the binary_pred
        .              *  parameter, and returns true or
        .              *  false depending on whether all of the corresponding elements of the
        .              *  ranges are equal.
        .             */
        .             template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline bool
      294 ( 0.00%)      equal(_IIter1 __first1, _IIter1 __last1,
        .           	  _IIter2 __first2, _BinaryPredicate __binary_pred)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
        .                 __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
        .                 __glibcxx_requires_valid_range(__first1, __last1);
        .           
    1,176 ( 0.00%)        for (; __first1 != __last1; ++__first1, (void)++__first2)
    3,069 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:bool __gnu_cxx::operator==<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) (99x)
    1,254 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator++() (114x)
    1,710 ( 0.00%)  	if (!bool(__binary_pred(*__first1, *__first2)))
    5,653 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/StringHelper.cpp:StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(char, char)#1}::operator()(char, char) const (95x)
    1,330 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator*() const (190x)
       76 ( 0.00%)  	  return false;
        4 ( 0.00%)        return true;
      126 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201103L
        .             // 4-iterator version of std::equal<It1, It2> for use in C++11.
        .             template<typename _II1, typename _II2>
        .               _GLIBCXX20_CONSTEXPR
        .               inline bool
        .               __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
        .               {
-- line 1627 ----------------------------------------
-- line 1644 ----------------------------------------
        .           	  return false;
        .                 return __first1 == __last1 && __first2 == __last2;
        .               }
        .           
        .             // 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.
        .             template<typename _II1, typename _II2, typename _BinaryPredicate>
        .               _GLIBCXX20_CONSTEXPR
        .               inline bool
    3,376 ( 0.00%)      __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
        .           	     _BinaryPredicate __binary_pred)
        .               {
        .                 using _RATag = random_access_iterator_tag;
        .                 using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        .                 using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        .                 using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
    3,798 ( 0.00%)        if (_RAIters())
    2,532 ( 0.00%)  => /usr/include/c++/14/type_traits:std::integral_constant<bool, true>::operator bool() const (422x)
        .           	{
    2,110 ( 0.00%)  	  auto __d1 = std::distance(__first1, __last1);
      422 ( 0.00%)  	  auto __d2 = std::distance(__first2, __last2);
    1,266 ( 0.00%)  	  if (__d1 != __d2)
      760 ( 0.00%)  	    return false;
      252 ( 0.00%)  	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
   14,692 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:bool std::equal<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(char, char)#1}>(__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(char, char)#1}) (42x)
       42 ( 0.00%)  				       __binary_pred);
        .           	}
        .           
        .                 for (; __first1 != __last1 && __first2 != __last2;
        .           	  ++__first1, (void)++__first2)
        .           	if (!bool(__binary_pred(*__first1, *__first2)))
        .           	  return false;
        .                 return __first1 == __last1 && __first2 == __last2;
    1,266 ( 0.00%)      }
        .           #endif // C++11
        .           
        .           #ifdef __glibcxx_robust_nonmodifying_seq_ops // C++ >= 14
        .             /**
        .              *  @brief Tests a range for element-wise equality.
        .              *  @ingroup non_mutating_algorithms
        .              *  @param  __first1  An input iterator.
        .              *  @param  __last1   An input iterator.
-- line 1682 ----------------------------------------
-- line 1719 ----------------------------------------
        .              *  This compares the elements of two ranges using the binary_pred
        .              *  parameter, and returns true or
        .              *  false depending on whether all of the corresponding elements of the
        .              *  ranges are equal.
        .             */
        .             template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline bool
    2,954 ( 0.00%)      equal(_IIter1 __first1, _IIter1 __last1,
        .           	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
        .                 __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
        .                 __glibcxx_requires_valid_range(__first1, __last1);
        .                 __glibcxx_requires_valid_range(__first2, __last2);
        .           
    2,532 ( 0.00%)        return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2,
   67,652 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:bool std::__equal4<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(char, char)#1}>(__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(char, char)#1}) (422x)
        .           				      __binary_pred);
      844 ( 0.00%)      }
        .           #endif // __glibcxx_robust_nonmodifying_seq_ops
        .           
        .             /**
        .              *  @brief Performs @b dictionary comparison on ranges.
        .              *  @ingroup sorting_algorithms
        .              *  @param  __first1  An input iterator.
        .              *  @param  __last1   An input iterator.
        .              *  @param  __first2  An input iterator.
-- line 1746 ----------------------------------------
-- line 2081 ----------------------------------------
        .           	++__first;
        .                 return __first;
        .               }
        .           
        .             /// This is an overload used by find algos for the RAI case.
        .             template<typename _RandomAccessIterator, typename _Predicate>
        .               _GLIBCXX20_CONSTEXPR
        .               _RandomAccessIterator
        6 ( 0.00%)      __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
        .           	      _Predicate __pred, random_access_iterator_tag)
        .               {
        .                 typename iterator_traits<_RandomAccessIterator>::difference_type
        7 ( 0.00%)  	__trip_count = (__last - __first) >> 2;
       33 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >::difference_type __gnu_cxx::operator-<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >(__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > > const&, __gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > > const&) (1x)
        .           
        3 ( 0.00%)        for (; __trip_count > 0; --__trip_count)
        .           	{
        .           	  if (__pred(__first))
        .           	    return __first;
        .           	  ++__first;
        .           
        .           	  if (__pred(__first))
        .           	    return __first;
        .           	  ++__first;
-- line 2103 ----------------------------------------
-- line 2106 ----------------------------------------
        .           	    return __first;
        .           	  ++__first;
        .           
        .           	  if (__pred(__first))
        .           	    return __first;
        .           	  ++__first;
        .           	}
        .           
       11 ( 0.00%)        switch (__last - __first)
       33 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >::difference_type __gnu_cxx::operator-<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >(__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > > const&, __gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > > const&) (1x)
        .           	{
        .           	case 3:
        .           	  if (__pred(__first))
        .           	    return __first;
        .           	  ++__first;
        .           	  // FALLTHRU
        .           	case 2:
        .           	  if (__pred(__first))
        .           	    return __first;
        .           	  ++__first;
        .           	  // FALLTHRU
        .           	case 1:
        7 ( 0.00%)  	  if (__pred(__first))
       23 ( 0.00%)  => /usr/include/c++/14/bits/predefined_ops.h:bool __gnu_cxx::__ops::_Iter_equals_val<Ship::WindowBackend const>::operator()<__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > > >(__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >) (1x)
        2 ( 0.00%)  	    return __first;
        .           	  ++__first;
        .           	  // FALLTHRU
        .           	case 0:
        .           	default:
        .           	  return __last;
        .           	}
        2 ( 0.00%)      }
        .           
        .             template<typename _Iterator, typename _Predicate>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _Iterator
        6 ( 0.00%)      __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
        .               {
        6 ( 0.00%)        return __find_if(__first, __last, __pred,
      127 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > > std::__find_if<__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >, __gnu_cxx::__ops::_Iter_equals_val<Ship::WindowBackend const> >(__gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >, __gnu_cxx::__normal_iterator<Ship::WindowBackend*, std::vector<Ship::WindowBackend, std::allocator<Ship::WindowBackend> > >, __gnu_cxx::__ops::_Iter_equals_val<Ship::WindowBackend const>, std::random_access_iterator_tag) (1x)
        .           		       std::__iterator_category(__first));
        2 ( 0.00%)      }
        .           
        .             template<typename _InputIterator, typename _Predicate>
        .               _GLIBCXX20_CONSTEXPR
        .               typename iterator_traits<_InputIterator>::difference_type
        .               __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
        .               {
        .                 typename iterator_traits<_InputIterator>::difference_type __n = 0;
        .                 for (; __first != __last; ++__first)
-- line 2152 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_opengl.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 64 ----------------------------------------
        .               uint32_t width, height;
        .               bool has_depth_buffer;
        .               uint32_t msaa_level;
        .               bool invert_y;
        .           
        .               GLuint fbo, clrbuf, clrbuf_msaa, rbo;
        .           };
        .           
        2 ( 0.00%)  static map<pair<uint64_t, uint32_t>, struct ShaderProgram> shader_program_pool;
       74 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::pair<unsigned long, unsigned int>, ShaderProgram, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::map() (1x)
        .           static GLuint opengl_vbo;
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .           static GLuint opengl_vao;
        .           #endif
        .           
        .           static uint32_t frame_count;
        .           
        .           static vector<Framebuffer> framebuffers;
-- line 80 ----------------------------------------
-- line 87 ----------------------------------------
        .           static int8_t last_depth_test;
        .           static int8_t last_depth_mask;
        .           static int8_t last_zmode_decal;
        .           
        .           GLint max_msaa_level = 1;
        .           GLuint pixel_depth_rb, pixel_depth_fb;
        .           size_t pixel_depth_rb_size;
        .           
        3 ( 0.00%)  static int gfx_opengl_get_max_texture_size() {
        .               GLint max_texture_size;
        5 ( 0.00%)      glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max_texture_size);
      137 ( 0.00%)  => ???:0x0000000004a815c0 (1x)
        1 ( 0.00%)      return max_texture_size;
        2 ( 0.00%)  }
        .           
        2 ( 0.00%)  static const char* gfx_opengl_get_name() {
        1 ( 0.00%)      return "OpenGL";
        2 ( 0.00%)  }
        .           
2,365,376 ( 0.00%)  static struct GfxClipParameters gfx_opengl_get_clip_parameters(void) {
4,730,752 ( 0.00%)      return { false, framebuffers[current_framebuffer].invert_y };
8,278,816 ( 0.01%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (591,344x)
1,774,032 ( 0.00%)  }
        .           
   86,248 ( 0.00%)  static void gfx_opengl_vertex_array_set_attribs(struct ShaderProgram* prg) {
   86,248 ( 0.00%)      size_t num_floats = prg->num_floats;
   21,562 ( 0.00%)      size_t pos = 0;
        .           
  525,634 ( 0.00%)      for (int i = 0; i < prg->num_attribs; i++) {
  437,154 ( 0.00%)          glEnableVertexAttribArray(prg->attrib_locations[i]);
5,495,595 ( 0.00%)  => ???:0x0000000004a80a40 (62,450x)
      977 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
1,311,454 ( 0.00%)          glVertexAttribPointer(prg->attrib_locations[i], prg->attrib_sizes[i], GL_FLOAT, GL_FALSE,
15,017,835 ( 0.01%)  => ???:0x0000000004a86ec0 (62,450x)
      917 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  124,900 ( 0.00%)                                num_floats * sizeof(float), (void*)(pos * sizeof(float)));
  374,700 ( 0.00%)          pos += prg->attrib_sizes[i];
        .               }
   86,248 ( 0.00%)  }
        .           
   86,248 ( 0.00%)  static void gfx_opengl_set_uniforms(struct ShaderProgram* prg) {
  172,500 ( 0.00%)      glUniform1i(prg->frame_count_location, frame_count);
  862,480 ( 0.00%)  => ???:0x0000000004a85a20 (21,562x)
      894 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  150,938 ( 0.00%)      glUniform1f(prg->noise_scale_location, current_noise_scale);
  862,480 ( 0.00%)  => ???:0x0000000004a859e0 (21,562x)
      822 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
   64,686 ( 0.00%)  }
        .           
   86,248 ( 0.00%)  static void gfx_opengl_unload_shader(struct ShaderProgram* old_prg) {
   43,124 ( 0.00%)      if (old_prg != NULL) {
  525,609 ( 0.00%)          for (int i = 0; i < old_prg->num_attribs; i++) {
  437,133 ( 0.00%)              glDisableVertexAttribArray(old_prg->attrib_locations[i]);
4,621,078 ( 0.00%)  => ???:0x0000000004a80680 (62,447x)
      972 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .                   }
        .               }
   64,686 ( 0.00%)  }
        .           
   86,248 ( 0.00%)  static void gfx_opengl_load_shader(struct ShaderProgram* new_prg) {
        .               // if (!new_prg) return;
  107,814 ( 0.00%)      glUseProgram(new_prg->opengl_program_id);
73,637,078 ( 0.06%)  => ???:0x0000000004a86060 (21,562x)
      826 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
   64,686 ( 0.00%)      gfx_opengl_vertex_array_set_attribs(new_prg);
23,569,472 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_vertex_array_set_attribs(ShaderProgram*) (21,562x)
   64,686 ( 0.00%)      gfx_opengl_set_uniforms(new_prg);
2,201,048 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_uniforms(ShaderProgram*) (21,562x)
   64,686 ( 0.00%)  }
        .           
      695 ( 0.00%)  static void append_str(char* buf, size_t* len, const char* str) {
    7,915 ( 0.00%)      while (*str != '\0') {
   21,660 ( 0.00%)          buf[(*len)++] = *str++;
        .               }
      556 ( 0.00%)  }
        .           
    2,800 ( 0.00%)  static void append_line(char* buf, size_t* len, const char* str) {
   74,488 ( 0.00%)      while (*str != '\0') {
  215,064 ( 0.00%)          buf[(*len)++] = *str++;
        .               }
    4,480 ( 0.00%)      buf[(*len)++] = '\n';
    1,680 ( 0.00%)  }
        .           
        .           #define RAND_NOISE "((random(vec3(floor(gl_FragCoord.xy * noise_scale), float(frame_count))) + 1.0) / 2.0)"
        .           
        .           static const char* shader_item_to_str(uint32_t item, bool with_alpha, bool only_alpha, bool inputs_have_alpha,
      546 ( 0.00%)                                        bool first_cycle, bool hint_single_element) {
      168 ( 0.00%)      if (!only_alpha) {
      155 ( 0.00%)          switch (item) {
        .                       case SHADER_0:
        .                           return with_alpha ? "vec4(0.0, 0.0, 0.0, 0.0)" : "vec3(0.0, 0.0, 0.0)";
        .                       case SHADER_1:
        4 ( 0.00%)                  return with_alpha ? "vec4(1.0, 1.0, 1.0, 1.0)" : "vec3(1.0, 1.0, 1.0)";
        .                       case SHADER_INPUT_1:
      100 ( 0.00%)                  return with_alpha || !inputs_have_alpha ? "vInput1" : "vInput1.rgb";
        .                       case SHADER_INPUT_2:
       24 ( 0.00%)                  return with_alpha || !inputs_have_alpha ? "vInput2" : "vInput2.rgb";
        .                       case SHADER_INPUT_3:
        .                           return with_alpha || !inputs_have_alpha ? "vInput3" : "vInput3.rgb";
        .                       case SHADER_INPUT_4:
        .                           return with_alpha || !inputs_have_alpha ? "vInput4" : "vInput4.rgb";
        .                       case SHADER_TEXEL0:
       60 ( 0.00%)                  return first_cycle ? (with_alpha ? "texVal0" : "texVal0.rgb")
       12 ( 0.00%)                                     : (with_alpha ? "texVal1" : "texVal1.rgb");
        .                       case SHADER_TEXEL0A:
        .                           return first_cycle
        5 ( 0.00%)                             ? (hint_single_element ? "texVal0.a"
        .                                                             : (with_alpha ? "vec4(texVal0.a, texVal0.a, texVal0.a, texVal0.a)"
        .                                                                           : "vec3(texVal0.a, texVal0.a, texVal0.a)"))
        .                                      : (hint_single_element ? "texVal1.a"
        .                                                             : (with_alpha ? "vec4(texVal1.a, texVal1.a, texVal1.a, texVal1.a)"
        1 ( 0.00%)                                                                  : "vec3(texVal1.a, texVal1.a, texVal1.a)"));
        .                       case SHADER_TEXEL1A:
        .                           return first_cycle
        .                                      ? (hint_single_element ? "texVal1.a"
        .                                                             : (with_alpha ? "vec4(texVal1.a, texVal1.a, texVal1.a, texVal1.a)"
        .                                                                           : "vec3(texVal1.a, texVal1.a, texVal1.a)"))
        .                                      : (hint_single_element ? "texVal0.a"
        .                                                             : (with_alpha ? "vec4(texVal0.a, texVal0.a, texVal0.a, texVal0.a)"
        .                                                                           : "vec3(texVal0.a, texVal0.a, texVal0.a)"));
-- line 190 ----------------------------------------
-- line 193 ----------------------------------------
        .                                              : (with_alpha ? "texVal0" : "texVal0.rgb");
        .                       case SHADER_COMBINED:
        .                           return with_alpha ? "texel" : "texel.rgb";
        .                       case SHADER_NOISE:
        .                           return with_alpha ? "vec4(" RAND_NOISE ", " RAND_NOISE ", " RAND_NOISE ", " RAND_NOISE ")"
        .                                             : "vec3(" RAND_NOISE ", " RAND_NOISE ", " RAND_NOISE ")";
        .                   }
        .               } else {
       55 ( 0.00%)          switch (item) {
        .                       case SHADER_0:
        .                           return "0.0";
        .                       case SHADER_1:
        .                           return "1.0";
        .                       case SHADER_INPUT_1:
        8 ( 0.00%)                  return "vInput1.a";
        .                       case SHADER_INPUT_2:
        .                           return "vInput2.a";
        .                       case SHADER_INPUT_3:
        .                           return "vInput3.a";
        .                       case SHADER_INPUT_4:
        .                           return "vInput4.a";
        .                       case SHADER_TEXEL0:
       28 ( 0.00%)                  return first_cycle ? "texVal0.a" : "texVal1.a";
        .                       case SHADER_TEXEL0A:
        .                           return first_cycle ? "texVal0.a" : "texVal1.a";
        .                       case SHADER_TEXEL1A:
        .                           return first_cycle ? "texVal1.a" : "texVal0.a";
        .                       case SHADER_TEXEL1:
        .                           return first_cycle ? "texVal1.a" : "texVal0.a";
        .                       case SHADER_COMBINED:
        .                           return "texel.a";
        .                       case SHADER_NOISE:
        .                           return RAND_NOISE;
        .                   }
        .               }
        .               return "";
       84 ( 0.00%)  }
        .           
        .           #undef RAND_NOISE
        .           
        .           static void append_formula(char* buf, size_t* len, uint8_t c[2][4], bool do_single, bool do_multiply, bool do_mix,
      650 ( 0.00%)                             bool with_alpha, bool only_alpha, bool opt_alpha, bool first_cycle) {
       50 ( 0.00%)      if (do_single) {
      180 ( 0.00%)          append_str(buf, len,
    1,864 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (12x)
      360 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (12x)
       60 ( 0.00%)                     shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, first_cycle, false));
       26 ( 0.00%)      } else if (do_multiply) {
      150 ( 0.00%)          append_str(buf, len,
    1,580 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (10x)
      292 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (10x)
       50 ( 0.00%)                     shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, first_cycle, false));
       60 ( 0.00%)          append_str(buf, len, " * ");
      620 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (10x)
      150 ( 0.00%)          append_str(buf, len,
    1,516 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (10x)
      290 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (10x)
       50 ( 0.00%)                     shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, first_cycle, true));
        6 ( 0.00%)      } else if (do_mix) {
       12 ( 0.00%)          append_str(buf, len, "mix(");
      156 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
       30 ( 0.00%)          append_str(buf, len,
      316 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
       64 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (2x)
       10 ( 0.00%)                     shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, first_cycle, false));
       12 ( 0.00%)          append_str(buf, len, ", ");
       92 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
       30 ( 0.00%)          append_str(buf, len,
      380 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
       62 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (2x)
       10 ( 0.00%)                     shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, first_cycle, false));
       12 ( 0.00%)          append_str(buf, len, ", ");
       92 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
       30 ( 0.00%)          append_str(buf, len,
      348 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
       60 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (2x)
       10 ( 0.00%)                     shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, first_cycle, true));
       12 ( 0.00%)          append_str(buf, len, ")");
       60 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (2x)
        .               } else {
        6 ( 0.00%)          append_str(buf, len, "(");
       30 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       15 ( 0.00%)          append_str(buf, len,
      318 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       28 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        5 ( 0.00%)                     shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        6 ( 0.00%)          append_str(buf, len, " - ");
       62 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       15 ( 0.00%)          append_str(buf, len,
      190 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       32 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        5 ( 0.00%)                     shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        6 ( 0.00%)          append_str(buf, len, ") * ");
       78 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       15 ( 0.00%)          append_str(buf, len,
      190 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       30 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        5 ( 0.00%)                     shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, first_cycle, true));
        6 ( 0.00%)          append_str(buf, len, " + ");
       62 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       15 ( 0.00%)          append_str(buf, len,
      190 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (1x)
       32 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        5 ( 0.00%)                     shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .               }
       99 ( 0.00%)  }
        .           
       90 ( 0.00%)  static struct ShaderProgram* gfx_opengl_create_and_load_new_shader(uint64_t shader_id0, uint32_t shader_id1) {
        .               struct CCFeatures cc_features;
      108 ( 0.00%)      gfx_cc_get_features(shader_id0, shader_id1, &cc_features);
   39,551 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_cc.cpp:gfx_cc_get_features(unsigned long, unsigned int, CCFeatures*) (18x)
        .           
        .               char vs_buf[1024];
        .               char fs_buf[6000];
       18 ( 0.00%)      size_t vs_len = 0;
       18 ( 0.00%)      size_t fs_len = 0;
       18 ( 0.00%)      size_t num_floats = 4;
        .           
        .               // Vertex shader
        .           #if defined(__APPLE__)
        .               append_line(vs_buf, &vs_len, "#version 410 core");
        .               append_line(vs_buf, &vs_len, "in vec4 aVtxPos;");
        .           #elif defined(USE_OPENGLES)
        .               append_line(vs_buf, &vs_len, "#version 300 es");
        .               append_line(vs_buf, &vs_len, "in vec4 aVtxPos;");
        .           #else
      108 ( 0.00%)      append_line(vs_buf, &vs_len, "#version 110");
    3,834 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)      append_line(vs_buf, &vs_len, "attribute vec4 aVtxPos;");
    7,002 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           #endif
      180 ( 0.00%)      for (int i = 0; i < 2; i++) {
      180 ( 0.00%)          if (cc_features.used_textures[i]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                       vs_len += sprintf(vs_buf + vs_len, "in vec2 aTexCoord%d;\n", i);
        .                       vs_len += sprintf(vs_buf + vs_len, "out vec2 vTexCoord%d;\n", i);
        .           #else
      210 ( 0.00%)              vs_len += sprintf(vs_buf + vs_len, "attribute vec2 aTexCoord%d;\n", i);
    7,770 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
      210 ( 0.00%)              vs_len += sprintf(vs_buf + vs_len, "varying vec2 vTexCoord%d;\n", i);
    7,770 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
        .           #endif
       15 ( 0.00%)              num_floats += 2;
      150 ( 0.00%)              for (int j = 0; j < 2; j++) {
      330 ( 0.00%)                  if (cc_features.clamp[i][j]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                               vs_len += sprintf(vs_buf + vs_len, "in float aTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
        .                               vs_len += sprintf(vs_buf + vs_len, "out float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
        .           #else
      105 ( 0.00%)                      vs_len += sprintf(vs_buf + vs_len, "attribute float aTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
    4,236 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
      105 ( 0.00%)                      vs_len += sprintf(vs_buf + vs_len, "varying float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
    4,236 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
        .           #endif
        6 ( 0.00%)                      num_floats += 1;
        .                           }
        .                       }
        .                   }
        .               }
       54 ( 0.00%)      if (cc_features.opt_fog) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(vs_buf, &vs_len, "in vec4 aFog;");
        .                   append_line(vs_buf, &vs_len, "out vec4 vFog;");
        .           #else
        .                   append_line(vs_buf, &vs_len, "attribute vec4 aFog;");
        .                   append_line(vs_buf, &vs_len, "varying vec4 vFog;");
        .           #endif
        .                   num_floats += 4;
        .               }
        .           
       54 ( 0.00%)      if (cc_features.opt_grayscale) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(vs_buf, &vs_len, "in vec4 aGrayscaleColor;");
        .                   append_line(vs_buf, &vs_len, "out vec4 vGrayscaleColor;");
        .           #else
        .                   append_line(vs_buf, &vs_len, "attribute vec4 aGrayscaleColor;");
        .                   append_line(vs_buf, &vs_len, "varying vec4 vGrayscaleColor;");
        .           #endif
        .                   num_floats += 4;
        .               }
        .           
      158 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   vs_len += sprintf(vs_buf + vs_len, "in vec%d aInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
        .                   vs_len += sprintf(vs_buf + vs_len, "out vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
        .           #else
      352 ( 0.00%)          vs_len += sprintf(vs_buf + vs_len, "attribute vec%d aInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
   14,229 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
      352 ( 0.00%)          vs_len += sprintf(vs_buf + vs_len, "varying vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
   14,229 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .           #endif
       97 ( 0.00%)          num_floats += cc_features.opt_alpha ? 4 : 3;
        .               }
      108 ( 0.00%)      append_line(vs_buf, &vs_len, "void main() {");
    4,122 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      180 ( 0.00%)      for (int i = 0; i < 2; i++) {
      180 ( 0.00%)          if (cc_features.used_textures[i]) {
      225 ( 0.00%)              vs_len += sprintf(vs_buf + vs_len, "vTexCoord%d = aTexCoord%d;\n", i, i);
   12,345 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
      150 ( 0.00%)              for (int j = 0; j < 2; j++) {
      330 ( 0.00%)                  if (cc_features.clamp[i][j]) {
      144 ( 0.00%)                      vs_len += sprintf(vs_buf + vs_len, "vTexClamp%s%d = aTexClamp%s%d;\n", j == 0 ? "S" : "T", i,
    7,194 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
        .                                                 j == 0 ? "S" : "T", i);
        .                           }
        .                       }
        .                   }
        .               }
       54 ( 0.00%)      if (cc_features.opt_fog) {
        .                   append_line(vs_buf, &vs_len, "vFog = aFog;");
        .               }
       54 ( 0.00%)      if (cc_features.opt_grayscale) {
        .                   append_line(vs_buf, &vs_len, "vGrayscaleColor = aGrayscaleColor;");
        .               }
      158 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
      272 ( 0.00%)          vs_len += sprintf(vs_buf + vs_len, "vInput%d = aInput%d;\n", i + 1, i + 1);
   14,229 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .               }
      108 ( 0.00%)      append_line(vs_buf, &vs_len, "gl_Position = aVtxPos;");
    6,714 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           #if defined(USE_OPENGLES) // workaround for no GL_DEPTH_CLAMP
        .               append_line(vs_buf, &vs_len, "gl_Position.z *= 0.3f;");
        .           #endif
      108 ( 0.00%)      append_line(vs_buf, &vs_len, "}");
      666 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           
        .               // Fragment shader
        .           #if defined(__APPLE__)
        .               append_line(fs_buf, &fs_len, "#version 410 core");
        .           #elif defined(USE_OPENGLES)
        .               append_line(fs_buf, &fs_len, "#version 300 es");
        .               append_line(fs_buf, &fs_len, "precision mediump float;");
        .           #else
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "#version 130");
    3,834 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           #endif
      180 ( 0.00%)      for (int i = 0; i < 2; i++) {
      180 ( 0.00%)          if (cc_features.used_textures[i]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                       fs_len += sprintf(fs_buf + fs_len, "in vec2 vTexCoord%d;\n", i);
        .           #else
      210 ( 0.00%)              fs_len += sprintf(fs_buf + fs_len, "varying vec2 vTexCoord%d;\n", i);
    7,770 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
        .           #endif
      150 ( 0.00%)              for (int j = 0; j < 2; j++) {
      330 ( 0.00%)                  if (cc_features.clamp[i][j]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                               fs_len += sprintf(fs_buf + fs_len, "in float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
        .           #else
      105 ( 0.00%)                      fs_len += sprintf(fs_buf + fs_len, "varying float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
    4,236 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
        .           #endif
        .                           }
        .                       }
        .                   }
        .               }
       54 ( 0.00%)      if (cc_features.opt_fog) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "in vec4 vFog;");
        .           #else
        .                   append_line(fs_buf, &fs_len, "varying vec4 vFog;");
        .           #endif
        .               }
       54 ( 0.00%)      if (cc_features.opt_grayscale) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "in vec4 vGrayscaleColor;");
        .           #else
        .                   append_line(fs_buf, &fs_len, "varying vec4 vGrayscaleColor;");
        .           #endif
        .               }
      158 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   fs_len += sprintf(fs_buf + fs_len, "in vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
        .           #else
      352 ( 0.00%)          fs_len += sprintf(fs_buf + fs_len, "varying vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
   14,229 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .           #endif
        .               }
       54 ( 0.00%)      if (cc_features.used_textures[0]) {
       90 ( 0.00%)          append_line(fs_buf, &fs_len, "uniform sampler2D uTex0;");
    6,075 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (15x)
        .               }
       54 ( 0.00%)      if (cc_features.used_textures[1]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTex1;");
        .               }
       54 ( 0.00%)      if (cc_features.used_masks[0]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexMask0;");
        .               }
       54 ( 0.00%)      if (cc_features.used_masks[1]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexMask1;");
        .               }
       54 ( 0.00%)      if (cc_features.used_blend[0]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexBlend0;");
        .               }
       54 ( 0.00%)      if (cc_features.used_blend[1]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexBlend1;");
        .               }
        .           
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "uniform int frame_count;");
    7,290 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "uniform float noise_scale;");
    7,866 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "float random(in vec3 value) {");
    8,730 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "    float random = dot(sin(value), vec3(12.9898, 78.233, 37.719));");
   19,386 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "    return fract(sin(random) * 143758.5453);");
   13,050 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "}");
      666 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           
       54 ( 0.00%)      if (current_filter_mode == FILTER_THREE_POINT) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "#define TEX_OFFSET(off) texture(tex, texCoord - (off)/texSize)");
        .           #else
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "#define TEX_OFFSET(off) texture2D(tex, texCoord - (off)/texSize)");
   18,810 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           #endif
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "vec4 filter3point(in sampler2D tex, in vec2 texCoord, in vec2 texSize) {");
   21,114 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    vec2 offset = fract(texCoord*texSize - vec2(0.5));");
   15,930 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    offset -= step(1.0, offset.x + offset.y);");
   13,338 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    vec4 c0 = TEX_OFFSET(offset);");
    9,882 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    vec4 c1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y));");
   19,962 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    vec4 c2 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)));");
   19,962 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    return c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0);");
   18,234 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "}");
      666 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "vec4 hookTexture2D(in sampler2D tex, in vec2 uv, in vec2 texSize) {");
   19,674 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)          append_line(fs_buf, &fs_len, "    return filter3point(tex, uv, texSize);");
   12,474 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      126 ( 0.00%)          append_line(fs_buf, &fs_len, "}");
      666 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .               } else {
        .                   append_line(fs_buf, &fs_len, "vec4 hookTexture2D(in sampler2D tex, in vec2 uv, in vec2 texSize) {");
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "    return texture(tex, uv);");
        .           #else
        .                   append_line(fs_buf, &fs_len, "    return texture2D(tex, uv);");
        .           #endif
        .                   append_line(fs_buf, &fs_len, "}");
        .               }
        .           
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .               append_line(fs_buf, &fs_len, "out vec4 outColor;");
        .           #endif
        .           
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "void main() {");
    4,122 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           
        .               // Reference approach to color wrapping as per GLideN64
        .               // Return wrapped value of x in interval [low, high)
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "#define WRAP(x, low, high) mod((x)-(low), (high)-(low)) + (low)");
   18,522 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           
      180 ( 0.00%)      for (int i = 0; i < 2; i++) {
      180 ( 0.00%)          if (cc_features.used_textures[i]) {
      120 ( 0.00%)              bool s = cc_features.clamp[i][0], t = cc_features.clamp[i][1];
        .           
        .           #if defined(USE_OPENGLES)
        .                       fs_len += sprintf(fs_buf + fs_len, "vec2 texSize%d = vec2(textureSize(uTex%d, 0));\n", i, i);
        .           #else
      225 ( 0.00%)              fs_len += sprintf(fs_buf + fs_len, "vec2 texSize%d = textureSize(uTex%d, 0);\n", i, i);
   12,270 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
        .           #endif
        .           
      108 ( 0.00%)              if (!s && !t) {
      192 ( 0.00%)                  fs_len += sprintf(fs_buf + fs_len, "vec2 vTexCoordAdj%d = vTexCoord%d;\n", i, i);
    9,852 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (12x)
        .                       } else {
       12 ( 0.00%)                  if (s && t) {
       72 ( 0.00%)                      fs_len += sprintf(fs_buf + fs_len,
    5,169 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (3x)
        .                                                 "vec2 vTexCoordAdj%d = clamp(vTexCoord%d, 0.5 / texSize%d, "
        .                                                 "vec2(vTexClampS%d, vTexClampT%d));\n",
        .                                                 i, i, i, i, i);
        .                           } else if (s) {
        .                               fs_len += sprintf(fs_buf + fs_len,
        .                                                 "vec2 vTexCoordAdj%d = vec2(clamp(vTexCoord%d.s, 0.5 / "
        .                                                 "texSize%d.s, vTexClampS%d), vTexCoord%d.t);\n",
        .                                                 i, i, i, i, i);
-- line 509 ----------------------------------------
-- line 510 ----------------------------------------
        .                           } else {
        .                               fs_len += sprintf(fs_buf + fs_len,
        .                                                 "vec2 vTexCoordAdj%d = vec2(vTexCoord%d.s, clamp(vTexCoord%d.t, "
        .                                                 "0.5 / texSize%d.t, vTexClampT%d));\n",
        .                                                 i, i, i, i, i);
        .                           }
        .                       }
        .           
      285 ( 0.00%)              fs_len += sprintf(fs_buf + fs_len, "vec4 texVal%d = hookTexture2D(uTex%d, vTexCoordAdj%d, texSize%d);\n", i,
   21,405 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
        .                                         i, i, i);
       75 ( 0.00%)              if (cc_features.used_masks[i]) {
        .           #ifdef USE_OPENGLES
        .                           fs_len += sprintf(fs_buf + fs_len, "vec2 maskSize%d = vec2(textureSize(uTexMask%d, 0));\n", i, i);
        .           #else
        .                           fs_len += sprintf(fs_buf + fs_len, "vec2 maskSize%d = textureSize(uTexMask%d, 0);\n", i, i);
        .           #endif
        .                           fs_len +=
        .                               sprintf(fs_buf + fs_len,
        .                                       "vec4 maskVal%d = hookTexture2D(uTexMask%d, vTexCoordAdj%d, maskSize%d);\n", i, i, i, i);
-- line 528 ----------------------------------------
-- line 534 ----------------------------------------
        .                               fs_len += sprintf(fs_buf + fs_len, "vec4 blendVal%d = vec4(0, 0, 0, 0);\n", i);
        .                           }
        .           
        .                           fs_len += sprintf(fs_buf + fs_len, "texVal%d = mix(texVal%d, blendVal%d, maskVal%d.a);\n", i, i, i, i);
        .                       }
        .                   }
        .               }
        .           
      175 ( 0.00%)      append_line(fs_buf, &fs_len, cc_features.opt_alpha ? "vec4 texel;" : "vec3 texel;");
    3,546 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
      270 ( 0.00%)      for (int c = 0; c < (cc_features.opt_2cyc ? 2 : 1); c++) {
       36 ( 0.00%)          if (c == 1) {
        .                       if (cc_features.opt_alpha) {
        .                           if (cc_features.c[c][1][2] == SHADER_COMBINED) {
        .                               append_line(fs_buf, &fs_len, "texel.a = WRAP(texel.a, -1.01, 1.01);");
        .                           } else {
        .                               append_line(fs_buf, &fs_len, "texel.a = WRAP(texel.a, -0.51, 1.51);");
        .                           }
        .                       }
        .           
        .                       if (cc_features.c[c][0][2] == SHADER_COMBINED) {
        .                           append_line(fs_buf, &fs_len, "texel.rgb = WRAP(texel.rgb, -1.01, 1.01);");
        .                       } else {
        .                           append_line(fs_buf, &fs_len, "texel.rgb = WRAP(texel.rgb, -0.51, 1.51);");
        .                       }
        .                   }
        .           
      108 ( 0.00%)          append_str(fs_buf, &fs_len, "texel = ");
    2,556 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (18x)
      144 ( 0.00%)          if (!cc_features.color_alpha_same[c] && cc_features.opt_alpha) {
       42 ( 0.00%)              append_str(fs_buf, &fs_len, "vec4(");
      658 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (7x)
      182 ( 0.00%)              append_formula(fs_buf, &fs_len, cc_features.c[c], cc_features.do_single[c][0],
    4,355 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_formula(char*, unsigned long*, unsigned char (*) [4], bool, bool, bool, bool, bool, bool, bool) (7x)
       56 ( 0.00%)                             cc_features.do_multiply[c][0], cc_features.do_mix[c][0], false, false, true, c == 0);
       42 ( 0.00%)              append_str(fs_buf, &fs_len, ", ");
      322 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (7x)
      175 ( 0.00%)              append_formula(fs_buf, &fs_len, cc_features.c[c], cc_features.do_single[c][1],
    2,762 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_formula(char*, unsigned long*, unsigned char (*) [4], bool, bool, bool, bool, bool, bool, bool) (7x)
       42 ( 0.00%)                             cc_features.do_multiply[c][1], cc_features.do_mix[c][1], true, true, true, c == 0);
       49 ( 0.00%)              append_str(fs_buf, &fs_len, ")");
      210 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (7x)
        .                   } else {
      330 ( 0.00%)              append_formula(fs_buf, &fs_len, cc_features.c[c], cc_features.do_single[c][0],
    4,080 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_formula(char*, unsigned long*, unsigned char (*) [4], bool, bool, bool, bool, bool, bool, bool) (11x)
       99 ( 0.00%)                             cc_features.do_multiply[c][0], cc_features.do_mix[c][0], cc_features.opt_alpha, false,
       11 ( 0.00%)                             cc_features.opt_alpha, c == 0);
        .                   }
      108 ( 0.00%)          append_line(fs_buf, &fs_len, ";");
      666 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .               }
        .           
      108 ( 0.00%)      append_str(fs_buf, &fs_len, "texel = WRAP(texel, -0.51, 1.51);");
    9,756 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (18x)
      108 ( 0.00%)      append_str(fs_buf, &fs_len, "texel = clamp(texel, 0.0, 1.0);");
    9,180 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_str(char*, unsigned long*, char const*) (18x)
        .               // TODO discard if alpha is 0?
       54 ( 0.00%)      if (cc_features.opt_fog) {
        .                   if (cc_features.opt_alpha) {
        .                       append_line(fs_buf, &fs_len, "texel = vec4(mix(texel.rgb, vFog.rgb, vFog.a), texel.a);");
        .                   } else {
        .                       append_line(fs_buf, &fs_len, "texel = mix(texel, vFog.rgb, vFog.a);");
        .                   }
        .               }
        .           
       66 ( 0.00%)      if (cc_features.opt_texture_edge && cc_features.opt_alpha) {
       24 ( 0.00%)          append_line(fs_buf, &fs_len, "if (texel.a > 0.19) texel.a = 1.0; else discard;");
    3,156 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (4x)
        .               }
        .           
       93 ( 0.00%)      if (cc_features.opt_alpha && cc_features.opt_noise) {
        .                   append_line(fs_buf, &fs_len,
        .                               "texel.a *= floor(clamp(random(vec3(floor(gl_FragCoord.xy * noise_scale), float(frame_count))) + "
        .                               "texel.a, 0.0, 1.0));");
        .               }
        .           
       54 ( 0.00%)      if (cc_features.opt_grayscale) {
        .                   append_line(fs_buf, &fs_len, "float intensity = (texel.r + texel.g + texel.b) / 3.0;");
        .                   append_line(fs_buf, &fs_len, "vec3 new_texel = vGrayscaleColor.rgb * intensity;");
        .                   append_line(fs_buf, &fs_len, "texel.rgb = mix(texel.rgb, new_texel, vGrayscaleColor.a);");
        .               }
        .           
       54 ( 0.00%)      if (cc_features.opt_alpha) {
       39 ( 0.00%)          if (cc_features.opt_alpha_threshold) {
        6 ( 0.00%)              append_line(fs_buf, &fs_len, "if (texel.a < 8.0 / 256.0) discard;");
      581 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (1x)
        .                   }
       39 ( 0.00%)          if (cc_features.opt_invisible) {
        .                       append_line(fs_buf, &fs_len, "texel.a = 0.0;");
        .                   }
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "outColor = texel;");
        .           #else
       91 ( 0.00%)          append_line(fs_buf, &fs_len, "gl_FragColor = texel;");
    4,641 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (13x)
        .           #endif
        .               } else {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "outColor = vec4(texel, 1.0);");
        .           #else
       30 ( 0.00%)          append_line(fs_buf, &fs_len, "gl_FragColor = vec4(texel, 1.0);");
    2,665 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (5x)
        .           #endif
        .               }
      108 ( 0.00%)      append_line(fs_buf, &fs_len, "}");
      666 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_line(char*, unsigned long*, char const*) (18x)
        .           
       36 ( 0.00%)      vs_buf[vs_len] = '\0';
       36 ( 0.00%)      fs_buf[fs_len] = '\0';
        .           
        .               /*puts("Vertex shader:");
        .               puts(vs_buf);
        .               puts("Fragment shader:");
        .               puts(fs_buf);
        .               puts("End");*/
        .           
       72 ( 0.00%)      const GLchar* sources[2] = { vs_buf, fs_buf };
       72 ( 0.00%)      const GLint lengths[2] = { (GLint)vs_len, (GLint)fs_len };
        .               GLint success;
        .           
       76 ( 0.00%)      GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
   30,568 ( 0.00%)  => ???:0x0000000004a80280 (18x)
      889 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      130 ( 0.00%)      glShaderSource(vertex_shader, 1, &sources[0], &lengths[0]);
   31,176 ( 0.00%)  => ???:0x0000000004a84cc0 (18x)
      881 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       76 ( 0.00%)      glCompileShader(vertex_shader);
  124,513 ( 0.00%)  => ???:0x0000000004a7fee0 (18x)
      894 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      112 ( 0.00%)      glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);
      883 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,980 ( 0.00%)  => ???:0x0000000004a81ca0 (18x)
       54 ( 0.00%)      if (!success) {
        .                   GLint max_length = 0;
        .                   glGetShaderiv(vertex_shader, GL_INFO_LOG_LENGTH, &max_length);
        .                   char error_log[1024];
        .                   // fprintf(stderr, "Vertex shader compilation failed\n");
        .                   glGetShaderInfoLog(vertex_shader, max_length, &max_length, &error_log[0]);
        .                   // fprintf(stderr, "%s\n", &error_log[0]);
        .                   abort();
        .               }
        .           
       72 ( 0.00%)      GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
   30,523 ( 0.00%)  => ???:0x0000000004a80280 (18x)
      162 ( 0.00%)      glShaderSource(fragment_shader, 1, &sources[1], &lengths[1]);
  127,448 ( 0.00%)  => ???:0x0000000004a84cc0 (18x)
       72 ( 0.00%)      glCompileShader(fragment_shader);
  241,048 ( 0.00%)  => ???:0x0000000004a7fee0 (18x)
      108 ( 0.00%)      glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);
    1,980 ( 0.00%)  => ???:0x0000000004a81ca0 (18x)
       54 ( 0.00%)      if (!success) {
        .                   GLint max_length = 0;
        .                   glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &max_length);
        .                   char error_log[1024];
        .                   fprintf(stderr, "Fragment shader compilation failed\n");
        .                   glGetShaderInfoLog(fragment_shader, max_length, &max_length, &error_log[0]);
        .                   fprintf(stderr, "%s\n", &error_log[0]);
        .                   abort();
        .               }
        .           
       58 ( 0.00%)      GLuint shader_program = glCreateProgram();
  177,164 ( 0.00%)  => ???:0x0000000004a801e0 (18x)
      854 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      112 ( 0.00%)      glAttachShader(shader_program, vertex_shader);
    3,739 ( 0.00%)  => ???:0x0000000004a7f0c0 (18x)
      890 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      108 ( 0.00%)      glAttachShader(shader_program, fragment_shader);
    7,606 ( 0.00%)  => ???:0x0000000004a7f0c0 (18x)
       76 ( 0.00%)      glLinkProgram(shader_program);
15,994,277 ( 0.01%)  => ???:0x0000000004a82ae0 (18x)
      933 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           
       18 ( 0.00%)      size_t cnt = 0;
        .           
      216 ( 0.00%)      struct ShaderProgram* prg = &shader_program_pool[make_pair(shader_id0, shader_id1)];
   42,699 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::pair<unsigned long, unsigned int>, ShaderProgram, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::operator[](std::pair<unsigned long, unsigned int>&&) (18x)
    1,242 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__strip_reference_wrapper<std::decay<unsigned long&>::type>::__type, std::__strip_reference_wrapper<std::decay<unsigned int&>::type>::__type> std::make_pair<unsigned long&, unsigned int&>(unsigned long&, unsigned int&) (18x)
      148 ( 0.00%)      prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aVtxPos");
    5,609 ( 0.00%)  => ???:0x0000000004a812a0 (18x)
      913 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       90 ( 0.00%)      prg->attrib_sizes[cnt] = 4;
       18 ( 0.00%)      ++cnt;
        .           
      180 ( 0.00%)      for (int i = 0; i < 2; i++) {
      180 ( 0.00%)          if (cc_features.used_textures[i]) {
        .                       char name[32];
      105 ( 0.00%)              sprintf(name, "aTexCoord%d", i);
    7,215 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (15x)
      135 ( 0.00%)              prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
    4,550 ( 0.00%)  => ???:0x0000000004a812a0 (15x)
       75 ( 0.00%)              prg->attrib_sizes[cnt] = 2;
       15 ( 0.00%)              ++cnt;
        .           
      150 ( 0.00%)              for (int j = 0; j < 2; j++) {
      330 ( 0.00%)                  if (cc_features.clamp[i][j]) {
       75 ( 0.00%)                      sprintf(name, "aTexClamp%s%d", j == 0 ? "S" : "T", i);
    4,014 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
       54 ( 0.00%)                      prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
    2,213 ( 0.00%)  => ???:0x0000000004a812a0 (6x)
       30 ( 0.00%)                      prg->attrib_sizes[cnt] = 1;
        6 ( 0.00%)                      ++cnt;
        .                           }
        .                       }
        .                   }
        .               }
        .           
       54 ( 0.00%)      if (cc_features.opt_fog) {
        .                   prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aFog");
        .                   prg->attrib_sizes[cnt] = 4;
        .                   ++cnt;
        .               }
        .           
       54 ( 0.00%)      if (cc_features.opt_grayscale) {
        .                   prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aGrayscaleColor");
        .                   prg->attrib_sizes[cnt] = 4;
        .                   ++cnt;
        .               }
        .           
      158 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
        .                   char name[16];
      136 ( 0.00%)          sprintf(name, "aInput%d", i + 1);
    8,313 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
      153 ( 0.00%)          prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
    4,947 ( 0.00%)  => ???:0x0000000004a812a0 (17x)
      165 ( 0.00%)          prg->attrib_sizes[cnt] = cc_features.opt_alpha ? 4 : 3;
       17 ( 0.00%)          ++cnt;
        .               }
        .           
       54 ( 0.00%)      prg->opengl_program_id = shader_program;
       72 ( 0.00%)      prg->num_inputs = cc_features.num_inputs;
       54 ( 0.00%)      prg->used_textures[0] = cc_features.used_textures[0];
       54 ( 0.00%)      prg->used_textures[1] = cc_features.used_textures[1];
       54 ( 0.00%)      prg->used_textures[2] = cc_features.used_masks[0];
       54 ( 0.00%)      prg->used_textures[3] = cc_features.used_masks[1];
       54 ( 0.00%)      prg->used_textures[4] = cc_features.used_blend[0];
       54 ( 0.00%)      prg->used_textures[5] = cc_features.used_blend[1];
       72 ( 0.00%)      prg->num_floats = num_floats;
       72 ( 0.00%)      prg->num_attribs = cnt;
        .           
      130 ( 0.00%)      prg->frame_count_location = glGetUniformLocation(shader_program, "frame_count");
    4,026 ( 0.00%)  => ???:0x0000000004a820a0 (18x)
      909 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      126 ( 0.00%)      prg->noise_scale_location = glGetUniformLocation(shader_program, "noise_scale");
    4,026 ( 0.00%)  => ???:0x0000000004a820a0 (18x)
        .           
       54 ( 0.00%)      gfx_opengl_load_shader(prg);
   89,541 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_load_shader(ShaderProgram*) (18x)
        .           
       54 ( 0.00%)      if (cc_features.used_textures[0]) {
       90 ( 0.00%)          GLint sampler_location = glGetUniformLocation(shader_program, "uTex0");
    3,930 ( 0.00%)  => ???:0x0000000004a820a0 (15x)
       75 ( 0.00%)          glUniform1i(sampler_location, 0);
    3,900 ( 0.00%)  => ???:0x0000000004a85a20 (15x)
        .               }
       54 ( 0.00%)      if (cc_features.used_textures[1]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTex1");
        .                   glUniform1i(sampler_location, 1);
        .               }
       54 ( 0.00%)      if (cc_features.used_masks[0]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexMask0");
        .                   glUniform1i(sampler_location, 2);
        .               }
       54 ( 0.00%)      if (cc_features.used_masks[1]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexMask1");
        .                   glUniform1i(sampler_location, 3);
        .               }
       54 ( 0.00%)      if (cc_features.used_blend[0]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexBlend0");
        .                   glUniform1i(sampler_location, 4);
        .               }
       54 ( 0.00%)      if (cc_features.used_blend[1]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexBlend1");
        .                   glUniform1i(sampler_location, 5);
        .               }
        .           
       18 ( 0.00%)      return prg;
       36 ( 0.00%)  }
        .           
      110 ( 0.00%)  static struct ShaderProgram* gfx_opengl_lookup_shader(uint64_t shader_id0, uint32_t shader_id1) {
      264 ( 0.00%)      auto it = shader_program_pool.find(make_pair(shader_id0, shader_id1));
   17,213 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::pair<unsigned long, unsigned int>, ShaderProgram, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::find(std::pair<unsigned long, unsigned int> const&) (22x)
    1,518 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__strip_reference_wrapper<std::decay<unsigned long&>::type>::__type, std::__strip_reference_wrapper<std::decay<unsigned int&>::type>::__type> std::make_pair<unsigned long&, unsigned int&>(unsigned long&, unsigned int&) (22x)
      272 ( 0.00%)      return it == shader_program_pool.end() ? nullptr : &it->second;
      704 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::pair<unsigned long, unsigned int>, ShaderProgram, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::end() (22x)
      264 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > const&, std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > const&) (22x)
      140 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >::operator->() const (4x)
       44 ( 0.00%)  }
        .           
2,822,315 ( 0.00%)  static void gfx_opengl_shader_get_info(struct ShaderProgram* prg, uint8_t* num_inputs, bool used_textures[2]) {
2,257,852 ( 0.00%)      *num_inputs = prg->num_inputs;
2,257,852 ( 0.00%)      used_textures[0] = prg->used_textures[0];
2,822,315 ( 0.00%)      used_textures[1] = prg->used_textures[1];
1,693,389 ( 0.00%)  }
        .           
    1,200 ( 0.00%)  static GLuint gfx_opengl_new_texture(void) {
        .               GLuint ret;
    2,000 ( 0.00%)      glGenTextures(1, &ret);
  133,494 ( 0.00%)  => ???:0x0000000004a810a0 (400x)
      400 ( 0.00%)      return ret;
      800 ( 0.00%)  }
        .           
        .           static void gfx_opengl_delete_texture(uint32_t texID) {
        .               glDeleteTextures(1, &texID);
        .           }
        .           
  167,145 ( 0.00%)  static void gfx_opengl_select_texture(int tile, GLuint texture_id) {
  167,149 ( 0.00%)      glActiveTexture(GL_TEXTURE0 + tile);
  568,293 ( 0.00%)  => ???:0x0000000004a7f040 (33,429x)
      892 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  167,145 ( 0.00%)      glBindTexture(GL_TEXTURE_2D, texture_id);
7,419,512 ( 0.01%)  => ???:0x0000000004a7f360 (33,429x)
  100,287 ( 0.00%)  }
        .           
    2,400 ( 0.00%)  static void gfx_opengl_upload_texture(const uint8_t* rgba32_buf, uint32_t width, uint32_t height) {
    6,000 ( 0.00%)      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, rgba32_buf);
6,006,783 ( 0.00%)  => ???:0x0000000004a85480 (400x)
    1,200 ( 0.00%)  }
        .           
        .           #ifdef USE_OPENGLES
        .           #define GL_MIRROR_CLAMP_TO_EDGE 0x8743
        .           #endif
        .           
    4,776 ( 0.00%)  static uint32_t gfx_cm_to_opengl(uint32_t val) {
   13,986 ( 0.00%)      switch (val) {
        .                   case G_TX_NOMIRROR | G_TX_CLAMP:
      978 ( 0.00%)              return GL_CLAMP_TO_EDGE;
        .                   case G_TX_MIRROR | G_TX_WRAP:
       22 ( 0.00%)              return GL_MIRRORED_REPEAT;
        .                   case G_TX_MIRROR | G_TX_CLAMP:
        .                       return GL_MIRROR_CLAMP_TO_EDGE;
        .                   case G_TX_NOMIRROR | G_TX_WRAP:
    2,184 ( 0.00%)              return GL_REPEAT;
        .               }
        .               return 0;
    3,184 ( 0.00%)  }
        .           
    6,368 ( 0.00%)  static void gfx_opengl_set_sampler_parameters(int tile, bool linear_filter, uint32_t cms, uint32_t cmt) {
    4,231 ( 0.00%)      const GLint filter = linear_filter && current_filter_mode == FILTER_LINEAR ? GL_LINEAR : GL_NEAREST;
    3,980 ( 0.00%)      glActiveTexture(GL_TEXTURE0 + tile);
   13,532 ( 0.00%)  => ???:0x0000000004a7f040 (796x)
    4,776 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filter);
  497,992 ( 0.00%)  => ???:0x0000000004a85580 (796x)
    4,776 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
  489,972 ( 0.00%)  => ???:0x0000000004a85580 (796x)
    6,368 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, gfx_cm_to_opengl(cms));
  405,725 ( 0.00%)  => ???:0x0000000004a85580 (796x)
   12,568 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_cm_to_opengl(unsigned int) (796x)
    6,368 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, gfx_cm_to_opengl(cmt));
  395,704 ( 0.00%)  => ???:0x0000000004a85580 (796x)
   12,562 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_cm_to_opengl(unsigned int) (796x)
    2,388 ( 0.00%)  }
        .           
   84,162 ( 0.00%)  static void gfx_opengl_set_depth_test_and_mask(bool depth_test, bool z_upd) {
   28,054 ( 0.00%)      current_depth_test = depth_test;
   28,054 ( 0.00%)      current_depth_mask = z_upd;
   42,081 ( 0.00%)  }
        .           
   42,816 ( 0.00%)  static void gfx_opengl_set_zmode_decal(bool zmode_decal) {
   21,408 ( 0.00%)      current_zmode_decal = zmode_decal;
   32,112 ( 0.00%)  }
        .           
    3,073 ( 0.00%)  static void gfx_opengl_set_viewport(int x, int y, int width, int height) {
    3,077 ( 0.00%)      glViewport(x, y, width, height);
  105,298 ( 0.00%)  => ???:0x0000000004a86fe0 (439x)
      912 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,317 ( 0.00%)  }
        .           
    3,073 ( 0.00%)  static void gfx_opengl_set_scissor(int x, int y, int width, int height) {
    3,077 ( 0.00%)      glScissor(x, y, width, height);
   82,517 ( 0.00%)  => ???:0x0000000004a84980 (439x)
      810 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,317 ( 0.00%)  }
        .           
   18,235 ( 0.00%)  static void gfx_opengl_set_use_alpha(bool use_alpha) {
    7,294 ( 0.00%)      if (use_alpha) {
    5,472 ( 0.00%)          glEnable(GL_BLEND);
  116,736 ( 0.00%)  => ???:0x0000000004a809e0 (1,824x)
        .               } else {
    5,469 ( 0.00%)          glDisable(GL_BLEND);
  120,318 ( 0.00%)  => ???:0x0000000004a80620 (1,823x)
        .               }
   12,765 ( 0.00%)  }
        .           
  286,956 ( 0.00%)  static void gfx_opengl_draw_triangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) {
  377,804 ( 0.00%)      if (current_depth_test != last_depth_test || current_depth_mask != last_depth_mask) {
   28,054 ( 0.00%)          last_depth_test = current_depth_test;
   28,054 ( 0.00%)          last_depth_mask = current_depth_mask;
        .           
   43,881 ( 0.00%)          if (current_depth_test || last_depth_mask) {
   40,281 ( 0.00%)              glEnable(GL_DEPTH_TEST);
  865,338 ( 0.00%)  => ???:0x0000000004a809e0 (13,427x)
  100,659 ( 0.00%)              glDepthMask(last_depth_mask ? GL_TRUE : GL_FALSE);
  535,676 ( 0.00%)  => ???:0x0000000004a80560 (13,427x)
  161,124 ( 0.00%)              glDepthFunc(current_depth_test ? (current_zmode_decal ? GL_LEQUAL : GL_LESS) : GL_ALWAYS);
  593,144 ( 0.00%)  => ???:0x0000000004a80540 (13,427x)
        .                   } else {
    1,800 ( 0.00%)              glDisable(GL_DEPTH_TEST);
   43,200 ( 0.00%)  => ???:0x0000000004a80620 (600x)
        .                   }
        .               }
        .           
  191,304 ( 0.00%)      if (current_zmode_decal != last_zmode_decal) {
   21,408 ( 0.00%)          last_zmode_decal = current_zmode_decal;
   32,112 ( 0.00%)          if (current_zmode_decal) {
        .                       // SSDB = SlopeScaledDepthBias 120 leads to -2 at 240p which is the same as N64 mode which has very little
        .                       // fighting
    5,352 ( 0.00%)              const int n64modeFactor = 120;
    5,352 ( 0.00%)              const int noVanishFactor = 100;
   10,704 ( 0.00%)              GLfloat SSDB = -2;
   42,816 ( 0.00%)              switch (CVarGetInteger(CVAR_Z_FIGHTING_MODE, 0)) {
8,011,944 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/consolevariablebridge.cpp:CVarGetInteger (5,352x)
        .                           // scaled z-fighting (N64 mode like)
        .                           case 1:
        .                               if (framebuffers.size() >
        .                                   current_framebuffer) { // safety check for vector size can probably be removed
        .                                   SSDB = -1.0f * (GLfloat)framebuffers[current_framebuffer].height / n64modeFactor;
        .                               }
        .                               break;
        .                           // no vanishing paths
-- line 873 ----------------------------------------
-- line 875 ----------------------------------------
        .                               if (framebuffers.size() >
        .                                   current_framebuffer) { // safety check for vector size can probably be removed
        .                                   SSDB = -1.0f * (GLfloat)framebuffers[current_framebuffer].height / noVanishFactor;
        .                               }
        .                               break;
        .                           // disabled
        .                           case 0:
        .                           default:
   16,056 ( 0.00%)                      SSDB = -2;
        .                       }
   26,764 ( 0.00%)              glPolygonOffset(SSDB, -2);
  181,968 ( 0.00%)  => ???:0x0000000004a83a80 (5,352x)
      887 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
   21,408 ( 0.00%)              glEnable(GL_POLYGON_OFFSET_FILL);
  289,008 ( 0.00%)  => ???:0x0000000004a809e0 (5,352x)
        .                   } else {
   26,760 ( 0.00%)              glPolygonOffset(0, 0);
  198,024 ( 0.00%)  => ???:0x0000000004a83a80 (5,352x)
   16,056 ( 0.00%)              glDisable(GL_POLYGON_OFFSET_FILL);
  289,008 ( 0.00%)  => ???:0x0000000004a80620 (5,352x)
        .                   }
        .               }
        .           
        .               // printf("flushing %d tris\n", buf_vbo_num_tris);
  430,438 ( 0.00%)      glBufferData(GL_ARRAY_BUFFER, sizeof(float) * buf_vbo_len, buf_vbo, GL_STREAM_DRAW);
254,351,784 ( 0.21%)  => ???:0x0000000004a7f5c0 (47,826x)
      869 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  478,264 ( 0.00%)      glDrawArrays(GL_TRIANGLES, 0, 3 * buf_vbo_num_tris);
178,724,290 ( 0.15%)  => ???:0x0000000004a80700 (47,826x)
      826 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  143,478 ( 0.00%)  }
        .           
        2 ( 0.00%)  static void gfx_opengl_init(void) {
        .           #ifndef __linux__
        .               glewInit();
        .           #endif
        .           
        8 ( 0.00%)      glGenBuffers(1, &opengl_vbo);
      826 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      215 ( 0.00%)  => ???:0x0000000004a80fc0 (1x)
        9 ( 0.00%)      glBindBuffer(GL_ARRAY_BUFFER, opengl_vbo);
      911 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,002 ( 0.00%)  => ???:0x0000000004a7f1a0 (1x)
        .           
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .               glGenVertexArrays(1, &opengl_vao);
        .               glBindVertexArray(opengl_vao);
        .           #endif
        .           
        .           #ifndef USE_OPENGLES // not supported on gles
        7 ( 0.00%)      glEnable(GL_DEPTH_CLAMP);
      827 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       84 ( 0.00%)  => ???:0x0000000004a809e0 (1x)
        .           #endif
        7 ( 0.00%)      glDepthFunc(GL_LEQUAL);
      838 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       46 ( 0.00%)  => ???:0x0000000004a80540 (1x)
        8 ( 0.00%)      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      822 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       52 ( 0.00%)  => ???:0x0000000004a7f500 (1x)
        .           
        3 ( 0.00%)      framebuffers.resize(1); // for the default screen buffer
      873 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::resize(unsigned long) (1x)
        .           
        8 ( 0.00%)      glGenRenderbuffers(1, &pixel_depth_rb);
      941 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      213 ( 0.00%)  => ???:0x0000000004a81060 (1x)
        9 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, pixel_depth_rb);
      945 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    3,207 ( 0.00%)  => ???:0x0000000004a7f300 (1x)
       10 ( 0.00%)      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 1, 1);
      930 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    5,399 ( 0.00%)  => ???:0x0000000004a847a0 (1x)
        4 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, 0);
      103 ( 0.00%)  => ???:0x0000000004a7f300 (1x)
        .           
        8 ( 0.00%)      glGenFramebuffers(1, &pixel_depth_fb);
      921 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      213 ( 0.00%)  => ???:0x0000000004a80fe0 (1x)
        9 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, pixel_depth_fb);
   25,528 ( 0.00%)  => ???:0x0000000004a7f280 (1x)
      922 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       11 ( 0.00%)      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, pixel_depth_rb);
   37,062 ( 0.00%)  => ???:0x0000000004a80ec0 (1x)
      969 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        4 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, 0);
   13,308 ( 0.00%)  => ???:0x0000000004a7f280 (1x)
        .           
        1 ( 0.00%)      pixel_depth_rb_size = 1;
        .           
        8 ( 0.00%)      glGetIntegerv(GL_MAX_SAMPLES, &max_msaa_level);
      850 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      131 ( 0.00%)  => ???:0x0000000004a815c0 (1x)
        3 ( 0.00%)  }
        .           
        .           static void gfx_opengl_on_resize(void) {
        .           }
        .           
      806 ( 0.00%)  static void gfx_opengl_start_frame(void) {
    1,209 ( 0.00%)      frame_count++;
    1,209 ( 0.00%)  }
        .           
      806 ( 0.00%)  static void gfx_opengl_end_frame(void) {
      810 ( 0.00%)      glFlush();
4,240,506 ( 0.00%)  => ???:0x0000000004a80d20 (403x)
      823 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,209 ( 0.00%)  }
        .           
      806 ( 0.00%)  static void gfx_opengl_finish_render(void) {
    1,209 ( 0.00%)  }
        .           
        8 ( 0.00%)  static int gfx_opengl_create_framebuffer() {
        .               GLuint clrbuf;
       14 ( 0.00%)      glGenTextures(1, &clrbuf);
      883 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      544 ( 0.00%)  => ???:0x0000000004a810a0 (2x)
       14 ( 0.00%)      glBindTexture(GL_TEXTURE_2D, clrbuf);
    6,304 ( 0.00%)  => ???:0x0000000004a7f360 (2x)
      841 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       30 ( 0.00%)      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
   11,140 ( 0.00%)  => ???:0x0000000004a85480 (2x)
      834 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       14 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      846 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    2,172 ( 0.00%)  => ???:0x0000000004a85580 (2x)
       10 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      414 ( 0.00%)  => ???:0x0000000004a85580 (2x)
        8 ( 0.00%)      glBindTexture(GL_TEXTURE_2D, 0);
      444 ( 0.00%)  => ???:0x0000000004a7f360 (2x)
        .           
        .               GLuint clrbuf_msaa;
       10 ( 0.00%)      glGenRenderbuffers(1, &clrbuf_msaa);
      670 ( 0.00%)  => ???:0x0000000004a81060 (2x)
        .           
        .               GLuint rbo;
       10 ( 0.00%)      glGenRenderbuffers(1, &rbo);
      400 ( 0.00%)  => ???:0x0000000004a81060 (2x)
       10 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    7,654 ( 0.00%)  => ???:0x0000000004a7f300 (2x)
       12 ( 0.00%)      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 1, 1);
   10,816 ( 0.00%)  => ???:0x0000000004a847a0 (2x)
        8 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, 0);
      206 ( 0.00%)  => ???:0x0000000004a7f300 (2x)
        .           
        .               GLuint fbo;
       10 ( 0.00%)      glGenFramebuffers(1, &fbo);
      535 ( 0.00%)  => ???:0x0000000004a80fe0 (2x)
        .           
        6 ( 0.00%)      size_t i = framebuffers.size();
       26 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::size() const (2x)
       10 ( 0.00%)      framebuffers.resize(i + 1);
    2,096 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::resize(unsigned long) (2x)
        .           
       12 ( 0.00%)      framebuffers[i].fbo = fbo;
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (2x)
       12 ( 0.00%)      framebuffers[i].clrbuf = clrbuf;
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (2x)
       12 ( 0.00%)      framebuffers[i].clrbuf_msaa = clrbuf_msaa;
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (2x)
       12 ( 0.00%)      framebuffers[i].rbo = rbo;
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (2x)
        .           
        2 ( 0.00%)      return i;
        6 ( 0.00%)  }
        .           
        .           static void gfx_opengl_update_framebuffer_parameters(int fb_id, uint32_t width, uint32_t height, uint32_t msaa_level,
        .                                                                bool opengl_invert_y, bool render_target, bool has_depth_buffer,
    6,464 ( 0.00%)                                                       bool can_extract_depth) {
    2,424 ( 0.00%)      Framebuffer& fb = framebuffers[fb_id];
    5,656 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (404x)
        .           
    3,232 ( 0.00%)      width = max(width, 1U);
    5,253 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned int const& std::max<unsigned int>(unsigned int const&, unsigned int const&) (404x)
    3,232 ( 0.00%)      height = max(height, 1U);
    5,253 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned int const& std::max<unsigned int>(unsigned int const&, unsigned int const&) (404x)
    3,636 ( 0.00%)      msaa_level = min(msaa_level, (uint32_t)max_msaa_level);
    5,252 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned int const& std::min<unsigned int>(unsigned int const&, unsigned int const&) (404x)
        .           
    2,424 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, fb.fbo);
  139,380 ( 0.00%)  => ???:0x0000000004a7f280 (404x)
        .           
      808 ( 0.00%)      if (fb_id != 0) {
        .                   if (fb.width != width || fb.height != height || fb.msaa_level != msaa_level) {
        .                       if (msaa_level <= 1) {
        .                           glBindTexture(GL_TEXTURE_2D, fb.clrbuf);
        .                           glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
        .                           glBindTexture(GL_TEXTURE_2D, 0);
        .                           glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fb.clrbuf, 0);
        .                       } else {
        .                           glBindRenderbuffer(GL_RENDERBUFFER, fb.clrbuf_msaa);
-- line 999 ----------------------------------------
-- line 1016 ----------------------------------------
        .           
        .                   if (!fb.has_depth_buffer && has_depth_buffer) {
        .                       glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, fb.rbo);
        .                   } else if (fb.has_depth_buffer && !has_depth_buffer) {
        .                       glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, 0);
        .                   }
        .               }
        .           
    1,212 ( 0.00%)      fb.width = width;
    1,212 ( 0.00%)      fb.height = height;
    1,212 ( 0.00%)      fb.has_depth_buffer = has_depth_buffer;
    1,212 ( 0.00%)      fb.msaa_level = msaa_level;
    1,212 ( 0.00%)      fb.invert_y = opengl_invert_y;
    1,212 ( 0.00%)  }
        .           
    2,015 ( 0.00%)  void gfx_opengl_start_draw_to_framebuffer(int fb_id, float noise_scale) {
    2,418 ( 0.00%)      Framebuffer& fb = framebuffers[fb_id];
    5,642 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::operator[](unsigned long) (403x)
        .           
    2,418 ( 0.00%)      if (noise_scale != 0.0f) {
    1,209 ( 0.00%)          current_noise_scale = 1.0f / noise_scale;
        .               }
    2,418 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, fb.fbo);
  139,035 ( 0.00%)  => ???:0x0000000004a7f280 (403x)
    1,209 ( 0.00%)      current_framebuffer = fb_id;
    1,209 ( 0.00%)  }
        .           
      806 ( 0.00%)  void gfx_opengl_clear_framebuffer() {
    1,213 ( 0.00%)      glDisable(GL_SCISSOR_TEST);
  997,415 ( 0.00%)  => ???:0x0000000004a80620 (403x)
      818 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,213 ( 0.00%)      glDepthMask(GL_TRUE);
   15,499 ( 0.00%)  => ???:0x0000000004a80560 (403x)
      822 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,213 ( 0.00%)      glClear(GL_DEPTH_BUFFER_BIT);
3,855,993 ( 0.00%)  => ???:0x0000000004a7f6c0 (403x)
      854 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    2,821 ( 0.00%)      glDepthMask(current_depth_mask ? GL_TRUE : GL_FALSE);
   16,120 ( 0.00%)  => ???:0x0000000004a80560 (403x)
    1,209 ( 0.00%)      glEnable(GL_SCISSOR_TEST);
  778,257 ( 0.00%)  => ???:0x0000000004a809e0 (403x)
    1,209 ( 0.00%)  }
        .           
        .           void gfx_opengl_resolve_msaa_color_buffer(int fb_id_target, int fb_id_source) {
        .               Framebuffer& fb_dst = framebuffers[fb_id_target];
        .               Framebuffer& fb_src = framebuffers[fb_id_source];
        .               glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fb_dst.fbo);
        .               glBindFramebuffer(GL_READ_FRAMEBUFFER, fb_src.fbo);
        .           
        .               // Disabled for blit
-- line 1055 ----------------------------------------
-- line 1212 ----------------------------------------
        .                   }
        .               }
        .           
        .               glBindFramebuffer(GL_FRAMEBUFFER, current_framebuffer);
        .           
        .               return res;
        .           }
        .           
        4 ( 0.00%)  void gfx_opengl_set_texture_filter(FilteringMode mode) {
        2 ( 0.00%)      current_filter_mode = mode;
        1 ( 0.00%)      gfx_texture_cache_clear();
      260 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_cache_clear (1x)
        3 ( 0.00%)  }
        .           
        .           FilteringMode gfx_opengl_get_texture_filter(void) {
        .               return current_filter_mode;
        .           }
        .           
        .           struct GfxRenderingAPI gfx_opengl_api = { gfx_opengl_get_name,
        .                                                     gfx_opengl_get_max_texture_size,
        .                                                     gfx_opengl_get_clip_parameters,
-- line 1231 ----------------------------------------
-- line 1256 ----------------------------------------
        .                                                     gfx_opengl_clear_framebuffer,
        .                                                     gfx_opengl_read_framebuffer_to_cpu,
        .                                                     gfx_opengl_resolve_msaa_color_buffer,
        .                                                     gfx_opengl_get_pixel_depth,
        .                                                     gfx_opengl_get_framebuffer_texture_id,
        .                                                     gfx_opengl_select_texture_fb,
        .                                                     gfx_opengl_delete_texture,
        .                                                     gfx_opengl_set_texture_filter,
       10 ( 0.00%)                                            gfx_opengl_get_texture_filter };
      257 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:__static_initialization_and_destruction_0() (1x)
        .           
        .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/shared_ptr.h
--------------------------------------------------------------------------------
Ir                  

-- line 167 ----------------------------------------
         .              * can be retrieved by calling the `get()` member function.
         .              *
         .              * The equality and relational operators for `shared_ptr` only compare
         .              * the stored pointer returned by `get()`, not the owned pointer.
         .              * To test whether two `shared_ptr` objects share ownership of the same
         .              * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.
         .             */
         .             template<typename _Tp>
28,608,980 ( 0.02%)      class shared_ptr : public __shared_ptr<_Tp>
    47,182 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceLoader, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() (656x)
         .               {
         .                 template<typename... _Args>
         .           	using _Constructible = typename enable_if<
         .           	  is_constructible<__shared_ptr<_Tp>, _Args...>::value
         .           	>::type;
         .           
         .                 template<typename _Arg>
         .           	using _Assignable = typename enable_if<
-- line 183 ----------------------------------------
-- line 193 ----------------------------------------
         .                 /// The corresponding weak_ptr type for this shared_ptr
         .                 /// @since C++17
         .                 using weak_type = weak_ptr<_Tp>;
         .           #endif
         .                 /**
         .                  *  @brief  Construct an empty %shared_ptr.
         .                  *  @post   use_count()==0 && get()==0
         .                  */
 2,713,520 ( 0.00%)        constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }
        21 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2>::__shared_ptr() (1x)
         .           
19,807,996 ( 0.02%)        shared_ptr(const shared_ptr&) noexcept = default; ///< Copy constructor
       355 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<spdlog::logger, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<spdlog::logger, (__gnu_cxx::_Lock_policy)2> const&) (6x)
         .           
         .                 /**
         .                  *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
         .                  *  @param  __p  A pointer that is convertible to element_type*.
         .                  *  @post   use_count() == 1 && get() == __p
         .                  *  @throw  std::bad_alloc, in which case @c delete @a __p is called.
         .                  */
         .                 template<typename _Yp, typename = _Constructible<_Yp*>>
-- line 211 ----------------------------------------
-- line 302 ----------------------------------------
         .                  *
         .                  * @code
         .                  * shared_ptr<pair<int,int>> pii(new pair<int,int>());
         .                  * shared_ptr<int> pi(pii, &pii->first);
         .                  * assert(pii.use_count() == 2);
         .                  * @endcode
         .                  */
         .                 template<typename _Yp>
   364,308 ( 0.00%)  	shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
   546,462 ( 0.00%)  	: __shared_ptr<_Tp>(__r, __p) { }
   185,216 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Controller, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<Ship::ControlDevice>(std::__shared_ptr<Ship::ControlDevice, (__gnu_cxx::_Lock_policy)2> const&, Ship::Controller*) (2,894x)
         .           
         .           #if __cplusplus > 201703L
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2996. Missing rvalue overloads for shared_ptr operations
         .                 /**
         .                  *  @brief  Constructs a `shared_ptr` instance that stores `__p`
         .                  *          and shares ownership with `__r`.
         .                  *  @param  __r  A `shared_ptr`.
-- line 319 ----------------------------------------
-- line 330 ----------------------------------------
         .                  * shared_ptr<pair<int,int>> pii(new pair<int,int>());
         .                  * shared_ptr<int> pi1(pii, &pii->first);
         .                  * assert(pii.use_count() == 2);
         .                  * shared_ptr<int> pi2(std::move(pii), &pii->second);
         .                  * assert(pii.use_count() == 0);
         .                  * @endcode
         .                  */
         .                 template<typename _Yp>
   347,445 ( 0.00%)  	shared_ptr(shared_ptr<_Yp>&& __r, element_type* __p) noexcept
   694,890 ( 0.00%)  	: __shared_ptr<_Tp>(std::move(__r), __p) { }
    20,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Fast::Fast3dWindow, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<Ship::Window>(std::__shared_ptr<Ship::Window, (__gnu_cxx::_Lock_policy)2>&&, Fast::Fast3dWindow*) (404x)
     2,424 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::Window>&>::type&& std::move<std::shared_ptr<Ship::Window>&>(std::shared_ptr<Ship::Window>&) (404x)
         .           #endif
         .                 /**
         .                  *  @brief  If @a __r is empty, constructs an empty %shared_ptr;
         .                  *          otherwise construct a %shared_ptr that shares ownership
         .                  *          with @a __r.
         .                  *  @param  __r  A %shared_ptr.
         .                  *  @post   get() == __r.get() && use_count() == __r.use_count()
         .                  */
         .                 template<typename _Yp,
         .           	       typename = _Constructible<const shared_ptr<_Yp>&>>
     6,640 ( 0.00%)  	shared_ptr(const shared_ptr<_Yp>& __r) noexcept
    10,624 ( 0.00%)          : __shared_ptr<_Tp>(__r) { }
    83,584 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Stream, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<Ship::MemoryStream, void>(std::__shared_ptr<Ship::MemoryStream, (__gnu_cxx::_Lock_policy)2> const&) (1,306x)
         .           
         .                 /**
         .                  *  @brief  Move-constructs a %shared_ptr instance from @a __r.
         .                  *  @param  __r  A %shared_ptr rvalue.
         .                  *  @post   *this contains the old value of @a __r, @a __r is empty.
         .                  */
 1,772,178 ( 0.00%)        shared_ptr(shared_ptr&& __r) noexcept
 3,248,993 ( 0.00%)        : __shared_ptr<_Tp>(std::move(__r)) { }
       350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ControlPort, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::ControlPort, (__gnu_cxx::_Lock_policy)2>&&) (7x)
        42 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::ControlPort>&>::type&& std::move<std::shared_ptr<Ship::ControlPort>&>(std::shared_ptr<Ship::ControlPort>&) (7x)
         .           
         .                 /**
         .                  *  @brief  Move-constructs a %shared_ptr instance from @a __r.
         .                  *  @param  __r  A %shared_ptr rvalue.
         .                  *  @post   *this contains the old value of @a __r, @a __r is empty.
         .                  */
         .                 template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
     4,284 ( 0.00%)  	shared_ptr(shared_ptr<_Yp>&& __r) noexcept
     7,854 ( 0.00%)  	: __shared_ptr<_Tp>(std::move(__r)) { }
        50 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceFactory, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<Ship::ResourceFactoryBinaryJsonV0, void>(std::__shared_ptr<Ship::ResourceFactoryBinaryJsonV0, (__gnu_cxx::_Lock_policy)2>&&) (1x)
         6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::ResourceFactoryBinaryJsonV0>&>::type&& std::move<std::shared_ptr<Ship::ResourceFactoryBinaryJsonV0>&>(std::shared_ptr<Ship::ResourceFactoryBinaryJsonV0>&) (1x)
         .           
         .                 /**
         .                  *  @brief  Constructs a %shared_ptr that shares ownership with @a __r
         .                  *          and stores a copy of the pointer stored in @a __r.
         .                  *  @param  __r  A weak_ptr.
         .                  *  @post   use_count() == __r.use_count()
         .                  *  @throw  bad_weak_ptr when __r.expired(),
         .                  *          in which case the constructor has no effect.
-- line 376 ----------------------------------------
-- line 403 ----------------------------------------
         .           	shared_ptr(unique_ptr<_Yp, _Del>&& __r)
         .           	: __shared_ptr<_Tp>(std::move(__r), __sp_array_delete()) { }
         .           #endif
         .           
         .                 /**
         .                  *  @brief  Construct an empty %shared_ptr.
         .                  *  @post   use_count() == 0 && get() == nullptr
         .                  */
 2,742,234 ( 0.00%)        constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
 1,109,645 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CVar>::shared_ptr() (35,795x)
         .           
 2,659,644 ( 0.00%)        shared_ptr& operator=(const shared_ptr&) noexcept = default;
 1,221,776 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Archive, (__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_ptr<Ship::Archive, (__gnu_cxx::_Lock_policy)2> const&) (17,206x)
         .           
         .                 template<typename _Yp>
         .           	_Assignable<const shared_ptr<_Yp>&>
         .           	operator=(const shared_ptr<_Yp>& __r) noexcept
         .           	{
         .           	  this->__shared_ptr<_Tp>::operator=(__r);
         .           	  return *this;
         .           	}
-- line 421 ----------------------------------------
-- line 429 ----------------------------------------
         .           	{
         .           	  this->__shared_ptr<_Tp>::operator=(std::move(__r));
         .           	  return *this;
         .           	}
         .           #pragma GCC diagnostic pop
         .           #endif
         .           
         .                 shared_ptr&
    28,626 ( 0.00%)        operator=(shared_ptr&& __r) noexcept
         .                 {
    33,397 ( 0.00%)  	this->__shared_ptr<_Tp>::operator=(std::move(__r));
       182 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Console, (__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_ptr<Ship::Console, (__gnu_cxx::_Lock_policy)2>&&) (1x)
         6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::Console>&>::type&& std::move<std::shared_ptr<Ship::Console>&>(std::shared_ptr<Ship::Console>&) (1x)
     4,771 ( 0.00%)  	return *this;
    14,313 ( 0.00%)        }
         .           
         .                 template<class _Yp>
         .           	_Assignable<shared_ptr<_Yp>>
        36 ( 0.00%)  	operator=(shared_ptr<_Yp>&& __r) noexcept
         .           	{
        42 ( 0.00%)  	  this->__shared_ptr<_Tp>::operator=(std::move(__r));
       182 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::enable_if<std::__sp_compatible_with<Ship::SDLAudioPlayer*, Ship::AudioPlayer*>::value, std::__shared_ptr<Ship::AudioPlayer, (__gnu_cxx::_Lock_policy)2>&>::type std::__shared_ptr<Ship::AudioPlayer, (__gnu_cxx::_Lock_policy)2>::operator=<Ship::SDLAudioPlayer>(std::__shared_ptr<Ship::SDLAudioPlayer, (__gnu_cxx::_Lock_policy)2>&&) (1x)
         6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::SDLAudioPlayer>&>::type&& std::move<std::shared_ptr<Ship::SDLAudioPlayer>&>(std::shared_ptr<Ship::SDLAudioPlayer>&) (1x)
         6 ( 0.00%)  	  return *this;
        18 ( 0.00%)  	}
         .           
         .                 template<typename _Yp, typename _Del>
         .           	_Assignable<unique_ptr<_Yp, _Del>>
         .           	operator=(unique_ptr<_Yp, _Del>&& __r)
         .           	{
         .           	  this->__shared_ptr<_Tp>::operator=(std::move(__r));
         .           	  return *this;
         .           	}
         .           
         .               private:
         .                 // This constructor is non-standard, it is used by allocate_shared.
         .                 template<typename _Alloc, typename... _Args>
 1,035,776 ( 0.00%)  	shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 1,050,859 ( 0.00%)  	: __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...)
       432 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceFactoryBinaryJsonV0, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<std::allocator<void>>(std::_Sp_alloc_shared_tag<std::allocator<void> >) (1x)
   621,518 ( 0.00%)  	{ }
         .           
         .                 template<typename _Yp, typename _Alloc, typename... _Args>
         .           	friend shared_ptr<_NonArray<_Yp>>
         .           	allocate_shared(const _Alloc&, _Args&&...);
         .           
         .                 template<typename _Yp, typename... _Args>
         .           	friend shared_ptr<_NonArray<_Yp>>
         .           	make_shared(_Args&&...);
-- line 472 ----------------------------------------
-- line 526 ----------------------------------------
         .           
         .                 template<typename _Yp>
         .           	friend shared_ptr<_UnboundedArray<_Yp>>
         .           	make_shared_for_overwrite(size_t);
         .           #endif
         .           #endif
         .           
         .                 // This constructor is non-standard, it is used by weak_ptr::lock().
 1,996,690 ( 0.00%)        shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t) noexcept
 3,194,704 ( 0.00%)        : __shared_ptr<_Tp>(__r, std::nothrow) { }
45,524,532 ( 0.04%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__weak_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2> const&, std::nothrow_t) (399,338x)
         .           
         .                 friend class weak_ptr<_Tp>;
         .               };
         .           
         .           #if __cpp_deduction_guides >= 201606
         .             template<typename _Tp>
         .               shared_ptr(weak_ptr<_Tp>) ->  shared_ptr<_Tp>;
         .             template<typename _Tp, typename _Del>
-- line 543 ----------------------------------------
-- line 552 ----------------------------------------
         .             template<typename _Tp, typename _Up>
         .               _GLIBCXX_NODISCARD inline bool
         .               operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
         .               { return __a.get() == __b.get(); }
         .           
         .             /// shared_ptr comparison with nullptr
         .             template<typename _Tp>
         .               _GLIBCXX_NODISCARD inline bool
 1,806,915 ( 0.00%)      operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
 2,168,298 ( 0.00%)      { return !__a; }
         9 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2>::operator bool() const (1x)
         .           
         .           #ifdef __cpp_lib_three_way_comparison
         .             template<typename _Tp, typename _Up>
         .               inline strong_ordering
         .               operator<=>(const shared_ptr<_Tp>& __a,
         .           		const shared_ptr<_Up>& __b) noexcept
         .               { return compare_three_way()(__a.get(), __b.get()); }
         .           
-- line 569 ----------------------------------------
-- line 691 ----------------------------------------
         .               swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
         .               { __a.swap(__b); }
         .           
         .             // 20.7.2.2.9 shared_ptr casts.
         .           
         .             /// Convert type of `shared_ptr`, via `static_cast`
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
   260,500 ( 0.00%)      static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
   468,900 ( 0.00%)        return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
 4,115,900 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::DisplayList>::shared_ptr<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, LUS::DisplayList*) (52,100x)
   364,700 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::get() const (52,100x)
   156,300 ( 0.00%)      }
         .           
         .             /// Convert type of `shared_ptr`, via `const_cast`
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
         .               const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
         .                 return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
         .               }
         .           
         .             /// Convert type of `shared_ptr`, via `dynamic_cast`
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
    43,200 ( 0.00%)      dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
   129,576 ( 0.00%)        if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
    50,880 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/dyncast.cc:__dynamic_cast (1,272x)
     8,904 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ControllerAxisDirectionMapping, (__gnu_cxx::_Lock_policy)2>::get() const (1,272x)
    60,326 ( 0.00%)  	return _Sp(__r, __p);
   100,488 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::KeyboardKeyToAxisDirectionMapping>::shared_ptr<Ship::ControllerAxisDirectionMapping>(std::shared_ptr<Ship::ControllerAxisDirectionMapping> const&, Ship::KeyboardKeyToAxisDirectionMapping*) (1,272x)
        66 ( 0.00%)        return _Sp();
       682 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::SDLMapping>::shared_ptr() (22x)
    25,920 ( 0.00%)      }
         .           
         .           #if __cplusplus >= 201703L
         .             /// Convert type of `shared_ptr`, via `reinterpret_cast`
         .             /// @since C++17
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
         .               reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
         .               {
-- line 731 ----------------------------------------
-- line 736 ----------------------------------------
         .           #if __cplusplus > 201703L
         .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .             // 2996. Missing rvalue overloads for shared_ptr operations
         .           
         .             /// Convert type of `shared_ptr` rvalue, via `static_cast`
         .             /// @since C++20
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
   295,368 ( 0.00%)      static_pointer_cast(shared_ptr<_Up>&& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
   196,912 ( 0.00%)        return _Sp(std::move(__r),
   295,368 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&& std::move<std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) (49,228x)
   443,052 ( 0.00%)  		 static_cast<typename _Sp::element_type*>(__r.get()));
 3,790,556 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::shared_ptr<Ship::IResource>(std::shared_ptr<Ship::IResource>&&, LUS::Texture*) (49,228x)
   344,596 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::get() const (49,228x)
   196,912 ( 0.00%)      }
         .           
         .             /// Convert type of `shared_ptr` rvalue, via `const_cast`
         .             /// @since C++20
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
         .               const_pointer_cast(shared_ptr<_Up>&& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
-- line 757 ----------------------------------------
-- line 758 ----------------------------------------
         .                 return _Sp(std::move(__r),
         .           		 const_cast<typename _Sp::element_type*>(__r.get()));
         .               }
         .           
         .             /// Convert type of `shared_ptr` rvalue, via `dynamic_cast`
         .             /// @since C++20
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
     2,035 ( 0.00%)      dynamic_pointer_cast(shared_ptr<_Up>&& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
     6,103 ( 0.00%)        if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
        21 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::OtrArchive, (__gnu_cxx::_Lock_policy)2>::get() const (3x)
     4,070 ( 0.00%)  	return _Sp(std::move(__r), __p);
       231 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::shared_ptr<Ship::OtrArchive>(std::shared_ptr<Ship::OtrArchive>&&, Ship::Archive*) (3x)
        18 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::OtrArchive>&>::type&& std::move<std::shared_ptr<Ship::OtrArchive>&>(std::shared_ptr<Ship::OtrArchive>&) (3x)
         .                 return _Sp();
     1,221 ( 0.00%)      }
         .           
         .             /// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`
         .             /// @since C++20
         .             template<typename _Tp, typename _Up>
         .               inline shared_ptr<_Tp>
         .               reinterpret_pointer_cast(shared_ptr<_Up>&& __r) noexcept
         .               {
         .                 using _Sp = shared_ptr<_Tp>;
-- line 780 ----------------------------------------
-- line 802 ----------------------------------------
         .              *
         .              * Also unlike a raw pointer, a weak_ptr does not become "dangling" after
         .              * the object it points to has been destroyed. Instead, a weak_ptr
         .              * becomes _expired_ and can no longer be converted to a shared_ptr that
         .              * owns the freed pointer, so you cannot accidentally access the pointed-to
         .              * object after it has been destroyed.
         .              */
         .             template<typename _Tp>
        20 ( 0.00%)      class weak_ptr : public __weak_ptr<_Tp>
        22 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<spdlog::details::thread_pool, (__gnu_cxx::_Lock_policy)2>::~__weak_ptr() (1x)
         .               {
         .                 template<typename _Arg>
         .           	using _Constructible = typename enable_if<
         .           	  is_constructible<__weak_ptr<_Tp>, _Arg>::value
         .           	>::type;
         .           
         .                 template<typename _Arg>
         .           	using _Assignable = typename enable_if<
         .           	  is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
         .           	>::type;
         .           
         .               public:
        10 ( 0.00%)        constexpr weak_ptr() noexcept = default;
        21 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<spdlog::async_logger, (__gnu_cxx::_Lock_policy)2>::__weak_ptr() (1x)
         .           
         .                 template<typename _Yp,
         .           	       typename = _Constructible<const shared_ptr<_Yp>&>>
         5 ( 0.00%)  	weak_ptr(const shared_ptr<_Yp>& __r) noexcept
         8 ( 0.00%)  	: __weak_ptr<_Tp>(__r) { }
        63 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<spdlog::details::thread_pool, (__gnu_cxx::_Lock_policy)2>::__weak_ptr<spdlog::details::thread_pool, void>(std::__shared_ptr<spdlog::details::thread_pool, (__gnu_cxx::_Lock_policy)2> const&) (1x)
         .           
         .                 weak_ptr(const weak_ptr&) noexcept = default;
         .           
         .                 template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
         .           	weak_ptr(const weak_ptr<_Yp>& __r) noexcept
         .           	: __weak_ptr<_Tp>(__r) { }
         .           
        13 ( 0.00%)        weak_ptr(weak_ptr&&) noexcept = default;
        44 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<spdlog::details::thread_pool, (__gnu_cxx::_Lock_policy)2>::__weak_ptr(std::__weak_ptr<spdlog::details::thread_pool, (__gnu_cxx::_Lock_policy)2>&&) (1x)
         .           
         .                 template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
         .           	weak_ptr(weak_ptr<_Yp>&& __r) noexcept
         .           	: __weak_ptr<_Tp>(std::move(__r)) { }
         .           
         .                 weak_ptr&
         .                 operator=(const weak_ptr& __r) noexcept = default;
         .           
-- line 844 ----------------------------------------
-- line 847 ----------------------------------------
         .           	operator=(const weak_ptr<_Yp>& __r) noexcept
         .           	{
         .           	  this->__weak_ptr<_Tp>::operator=(__r);
         .           	  return *this;
         .           	}
         .           
         .                 template<typename _Yp>
         .           	_Assignable<const shared_ptr<_Yp>&>
         5 ( 0.00%)  	operator=(const shared_ptr<_Yp>& __r) noexcept
         .           	{
         5 ( 0.00%)  	  this->__weak_ptr<_Tp>::operator=(__r);
        69 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::enable_if<std::__sp_compatible_with<Ship::Context*, Ship::Context*>::value, std::__weak_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>&>::type std::__weak_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>::operator=<Ship::Context>(std::__shared_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2> const&) (1x)
         1 ( 0.00%)  	  return *this;
         2 ( 0.00%)  	}
         .           
         .                 weak_ptr&
         .                 operator=(weak_ptr&& __r) noexcept = default;
         .           
         .                 template<typename _Yp>
         .           	_Assignable<weak_ptr<_Yp>>
         .           	operator=(weak_ptr<_Yp>&& __r) noexcept
         .           	{
         .           	  this->__weak_ptr<_Tp>::operator=(std::move(__r));
         .           	  return *this;
         .           	}
         .           
         .                 shared_ptr<_Tp>
 1,996,690 ( 0.00%)        lock() const noexcept
 3,194,704 ( 0.00%)        { return shared_ptr<_Tp>(*this, std::nothrow); }
50,715,926 ( 0.04%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::shared_ptr(std::weak_ptr<Ship::Context> const&, std::nothrow_t) (399,338x)
         .               };
         .           
         .           #if __cpp_deduction_guides >= 201606
         .             template<typename _Tp>
         .               weak_ptr(shared_ptr<_Tp>) ->  weak_ptr<_Tp>;
         .           #endif
         .           
         .             // 20.7.2.3.6 weak_ptr specialized algorithms.
-- line 882 ----------------------------------------
-- line 913 ----------------------------------------
         .              * @brief Base class allowing use of the member function `shared_from_this`.
         .              * @headerfile memory
         .              * @since C++11
         .              */
         .             template<typename _Tp>
         .               class enable_shared_from_this
         .               {
         .               protected:
        10 ( 0.00%)        constexpr enable_shared_from_this() noexcept { }
        31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::weak_ptr<spdlog::async_logger>::weak_ptr() (1x)
         .           
         .                 enable_shared_from_this(const enable_shared_from_this&) noexcept { }
         .           
         .                 enable_shared_from_this&
         .                 operator=(const enable_shared_from_this&) noexcept
         .                 { return *this; }
         .           
         .                 ~enable_shared_from_this() { }
-- line 929 ----------------------------------------
-- line 950 ----------------------------------------
         .                 weak_from_this() const noexcept
         .                 { return this->_M_weak_this; }
         .                 /// @}
         .           #endif
         .           
         .               private:
         .                 template<typename _Tp1>
         .           	void
         6 ( 0.00%)  	_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
         9 ( 0.00%)  	{ _M_weak_this._M_assign(__p, __n); }
        93 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<spdlog::async_logger, (__gnu_cxx::_Lock_policy)2>::_M_assign(spdlog::async_logger*, std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1x)
         .           
         .                 // Found by ADL when this is an associated class.
         .                 friend const enable_shared_from_this*
         4 ( 0.00%)        __enable_shared_from_this_base(const __shared_count<>&,
         .           				     const enable_shared_from_this* __p)
         3 ( 0.00%)        { return __p; }
         .           
         .                 template<typename, _Lock_policy>
         .           	friend class __shared_ptr;
         .           
         .                 mutable weak_ptr<_Tp>  _M_weak_this;
         .               };
         .           
         .             /// @relates shared_ptr @{
-- line 973 ----------------------------------------
-- line 995 ----------------------------------------
         .              *  @brief  Create an object that is owned by a shared_ptr.
         .              *  @param  __args  Arguments for the @a _Tp object's constructor.
         .              *  @return A shared_ptr that owns the newly created object.
         .              *  @throw  std::bad_alloc, or an exception thrown from the
         .              *          constructor of @a _Tp.
         .              */
         .             template<typename _Tp, typename... _Args>
         .               inline shared_ptr<_NonArray<_Tp>>
   825,983 ( 0.00%)      make_shared(_Args&&... __args)
         .               {
         .                 using _Alloc = allocator<void>;
         .                 _Alloc __a;
         .                 return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 1,253,875 ( 0.00%)  			     std::forward<_Args>(__args)...);
    60,615 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CVar>::shared_ptr<std::allocator<void>>(std::_Sp_alloc_shared_tag<std::allocator<void> >) (87x)
   614,764 ( 0.00%)      }
         .           
         .           #if __glibcxx_shared_ptr_arrays >= 201707L
         .             /// @cond undocumented
         .             template<typename _Tp, typename _Alloc = allocator<void>>
         .               auto
         .               __make_shared_arr_tag(size_t __n, const _Alloc& __a = _Alloc()) noexcept
         .               {
         .                 using _Up = remove_all_extents_t<_Tp>;
-- line 1017 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imgui_draw.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 169 ----------------------------------------
        .           using namespace IMGUI_STB_NAMESPACE;
        .           #endif
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] Style functions
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImGui::StyleColorsDark(ImGuiStyle* dst)
        5 ( 0.00%)  {
        4 ( 0.00%)      ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
        3 ( 0.00%)      ImVec4* colors = style->Colors;
        .           
       13 ( 0.00%)      colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
        7 ( 0.00%)      colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
       14 ( 0.00%)      colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       15 ( 0.00%)      colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLerp(ImVec4 const&, ImVec4 const&, float) (1x)
        7 ( 0.00%)      colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
       15 ( 0.00%)      colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLerp(ImVec4 const&, ImVec4 const&, float) (1x)
       15 ( 0.00%)      colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLerp(ImVec4 const&, ImVec4 const&, float) (1x)
       15 ( 0.00%)      colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLerp(ImVec4 const&, ImVec4 const&, float) (1x)
       20 ( 0.00%)      colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       60 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec4 const&, ImVec4 const&) (1x)
       14 ( 0.00%)      colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       14 ( 0.00%)      colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
        4 ( 0.00%)  }
        .           
        .           void ImGui::StyleColorsClassic(ImGuiStyle* dst)
        .           {
        .               ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
        .               ImVec4* colors = style->Colors;
        .           
        .               colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
        .               colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
-- line 244 ----------------------------------------
-- line 359 ----------------------------------------
        .               colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
        .               colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImDrawList
        .           //-----------------------------------------------------------------------------
        .           
       32 ( 0.00%)  ImDrawListSharedData::ImDrawListSharedData()
       18 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4() (1x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec2>::ImVector() (1x)
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (1x)
        .           {
        6 ( 0.00%)      memset(this, 0, sizeof(*this));
       50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      148 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
        .               {
      336 ( 0.00%)          const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
    1,016 ( 0.00%)          ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
    2,166 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (2x)
    1,588 ( 0.00%)  => ???:0x00000000000771e0 (48x)
    1,538 ( 0.00%)  => ???:0x000000000007cec0 (48x)
      672 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (48x)
        .               }
       19 ( 0.00%)      ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
       21 ( 0.00%)  => ???:0x00000000000771e0 (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (1x)
        6 ( 0.00%)  }
        .           
        .           void ImDrawListSharedData::SetCircleTessellationMaxError(float max_error)
    2,015 ( 0.00%)  {
    2,418 ( 0.00%)      if (CircleSegmentMaxError == max_error)
      402 ( 0.00%)          return;
        .           
        4 ( 0.00%)      IM_ASSERT(max_error > 0.0f);
        3 ( 0.00%)      CircleSegmentMaxError = max_error;
      196 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
        .               {
      128 ( 0.00%)          const float radius = (float)i;
    2,531 ( 0.00%)          CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
    3,654 ( 0.00%)  => ???:acosf (63x)
    1,125 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      945 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImClamp<int>(int, int, int) (63x)
      693 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (63x)
      189 ( 0.00%)  => ???:0x00000000000771d0 (63x)
        .               }
       20 ( 0.00%)      ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
       21 ( 0.00%)  => ???:0x00000000000771e0 (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (1x)
      806 ( 0.00%)  }
        .           
        .           // Initialize before use in a new frame. We always have a command ready in the buffer.
        .           // In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.
        .           void ImDrawList::_ResetForNewFrame()
   10,080 ( 0.00%)  {
        .               // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
        .               IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);
        .               IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));
        .               IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
    8,064 ( 0.00%)      if (_Splitter._Count > 1)
        .                   _Splitter.Merge(this);
        .           
    8,064 ( 0.00%)      CmdBuffer.resize(0);
   30,240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::resize(int) (2,016x)
   10,080 ( 0.00%)      IdxBuffer.resize(0);
   30,240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int) (2,016x)
   10,080 ( 0.00%)      VtxBuffer.resize(0);
   30,240 ( 0.00%)  => ???:ImVector<ImDrawVert>::resize(int) (2,016x)
   10,080 ( 0.00%)      Flags = _Data->InitialFlags;
   14,112 ( 0.00%)      memset(&_CmdHeader, 0, sizeof(_CmdHeader));
   24,192 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2,016x)
    4,032 ( 0.00%)      _VtxCurrentIdx = 0;
    4,032 ( 0.00%)      _VtxWritePtr = NULL;
    4,032 ( 0.00%)      _IdxWritePtr = NULL;
   10,080 ( 0.00%)      _ClipRectStack.resize(0);
   30,240 ( 0.00%)  => ???:ImVector<ImVec4>::resize(int) (2,016x)
   10,080 ( 0.00%)      _TextureIdStack.resize(0);
   30,240 ( 0.00%)  => ???:ImVector<void*>::resize(int) (2,016x)
   10,080 ( 0.00%)      _Path.resize(0);
   30,240 ( 0.00%)  => ???:ImVector<ImVec2>::resize(int) (2,016x)
    8,064 ( 0.00%)      _Splitter.Clear();
   20,160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawListSplitter::Clear() (2,016x)
   16,128 ( 0.00%)      CmdBuffer.push_back(ImDrawCmd());
   97,158 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::push_back(ImDrawCmd const&) (2,016x)
   92,736 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawCmd::ImDrawCmd() (2,016x)
    6,048 ( 0.00%)      _FringeScale = 1.0f;
    8,064 ( 0.00%)  }
        .           
        .           void ImDrawList::_ClearFreeMemory()
        4 ( 0.00%)  {
        3 ( 0.00%)      CmdBuffer.clear();
      182 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::clear() (1x)
        4 ( 0.00%)      IdxBuffer.clear();
      275 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::clear() (1x)
        4 ( 0.00%)      VtxBuffer.clear();
      268 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawVert>::clear() (1x)
        2 ( 0.00%)      Flags = ImDrawListFlags_None;
        2 ( 0.00%)      _VtxCurrentIdx = 0;
        2 ( 0.00%)      _VtxWritePtr = NULL;
        2 ( 0.00%)      _IdxWritePtr = NULL;
        4 ( 0.00%)      _ClipRectStack.clear();
      275 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec4>::clear() (1x)
        4 ( 0.00%)      _TextureIdStack.clear();
      182 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<void*>::clear() (1x)
        4 ( 0.00%)      _Path.clear();
      182 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec2>::clear() (1x)
        4 ( 0.00%)      _Splitter.ClearFreeMemory();
       32 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::ClearFreeMemory() (1x)
        3 ( 0.00%)  }
        .           
        .           ImDrawList* ImDrawList::CloneOutput() const
        .           {
        .               ImDrawList* dst = IM_NEW(ImDrawList(_Data));
        .               dst->CmdBuffer = CmdBuffer;
        .               dst->IdxBuffer = IdxBuffer;
        .               dst->VtxBuffer = VtxBuffer;
        .               dst->Flags = Flags;
        .               return dst;
        .           }
        .           
        .           void ImDrawList::AddDrawCmd()
    8,060 ( 0.00%)  {
    6,045 ( 0.00%)      ImDrawCmd draw_cmd;
   92,690 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawCmd::ImDrawCmd() (2,015x)
   10,075 ( 0.00%)      draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
    6,045 ( 0.00%)      draw_cmd.TextureId = _CmdHeader.TextureId;
    6,045 ( 0.00%)      draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
    6,045 ( 0.00%)      draw_cmd.IdxOffset = IdxBuffer.Size;
        .           
   16,120 ( 0.00%)      IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
   10,075 ( 0.00%)      CmdBuffer.push_back(draw_cmd);
   95,041 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::push_back(ImDrawCmd const&) (2,015x)
    6,045 ( 0.00%)  }
        .           
        .           // Pop trailing draw command (used before merging or presenting to user)
        .           // Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL
        .           void ImDrawList::_PopUnusedDrawCmd()
    3,228 ( 0.00%)  {
    7,657 ( 0.00%)      while (CmdBuffer.Size > 0)
        .               {
   14,520 ( 0.00%)          ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    8,060 ( 0.00%)          if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
      405 ( 0.00%)              return;// break;
    2,415 ( 0.00%)          CmdBuffer.pop_back();
   12,880 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::pop_back() (805x)
        .               }
    1,614 ( 0.00%)  }
        .           
        .           void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)
        .           {
        .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
        .               ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
        .               IM_ASSERT(curr_cmd->UserCallback == NULL);
        .               if (curr_cmd->ElemCount != 0)
        .               {
-- line 476 ----------------------------------------
-- line 500 ----------------------------------------
        .                   prev_cmd->ElemCount += curr_cmd->ElemCount;
        .                   CmdBuffer.pop_back();
        .               }
        .           }
        .           
        .           // Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
        .           // The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
        .           void ImDrawList::_OnChangedClipRect()
   24,192 ( 0.00%)  {
        .               // If current command is used with different settings we need to add a new command
        .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
   72,576 ( 0.00%)      ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
   36,292 ( 0.00%)      if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
   26,621 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,210x)
        .               {
    3,630 ( 0.00%)          AddDrawCmd();
  157,300 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddDrawCmd() (1,210x)
    1,210 ( 0.00%)          return;
        .               }
   19,352 ( 0.00%)      IM_ASSERT(curr_cmd->UserCallback == NULL);
        .           
        .               // Try to merge with previous command if it matches, else use current command
   14,514 ( 0.00%)      ImDrawCmd* prev_cmd = curr_cmd - 1;
   56,056 ( 0.00%)      if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
   25,414 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,210x)
        .               {
    1,212 ( 0.00%)          CmdBuffer.pop_back();
    6,464 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::pop_back() (404x)
      404 ( 0.00%)          return;
        .               }
        .           
   26,604 ( 0.00%)      curr_cmd->ClipRect = _CmdHeader.ClipRect;
   12,096 ( 0.00%)  }
        .           
        .           void ImDrawList::_OnChangedTextureID()
    8,064 ( 0.00%)  {
        .               // If current command is used with different settings we need to add a new command
        .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
   24,192 ( 0.00%)      ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    8,064 ( 0.00%)      if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
        .               {
        .                   AddDrawCmd();
        .                   return;
        .               }
    8,064 ( 0.00%)      IM_ASSERT(curr_cmd->UserCallback == NULL);
        .           
        .               // Try to merge with previous command if it matches, else use current command
    6,048 ( 0.00%)      ImDrawCmd* prev_cmd = curr_cmd - 1;
   16,128 ( 0.00%)      if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
        .               {
        .                   CmdBuffer.pop_back();
        .                   return;
        .               }
        .           
    8,064 ( 0.00%)      curr_cmd->TextureId = _CmdHeader.TextureId;
    4,032 ( 0.00%)  }
        .           
        .           void ImDrawList::_OnChangedVtxOffset()
        .           {
        .               // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
        .               _VtxCurrentIdx = 0;
        .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
        .               ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
        .               //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
-- line 559 ----------------------------------------
-- line 573 ----------------------------------------
        .               if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
        .                   return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
        .               else
        .                   return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
        .           }
        .           
        .           // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
        .           void ImDrawList::PushClipRect(const ImVec2& cr_min, const ImVec2& cr_max, bool intersect_with_current_clip_rect)
   32,256 ( 0.00%)  {
   60,480 ( 0.00%)      ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
   88,704 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (4,032x)
    8,064 ( 0.00%)      if (intersect_with_current_clip_rect)
        .               {
    8,065 ( 0.00%)          ImVec4 current = _CmdHeader.ClipRect;
    6,452 ( 0.00%)          if (cr.x < current.x) cr.x = current.x;
    6,452 ( 0.00%)          if (cr.y < current.y) cr.y = current.y;
    6,452 ( 0.00%)          if (cr.z > current.z) cr.z = current.z;
    6,452 ( 0.00%)          if (cr.w > current.w) cr.w = current.w;
        .               }
   28,224 ( 0.00%)      cr.z = ImMax(cr.x, cr.z);
   40,320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (4,032x)
   28,224 ( 0.00%)      cr.w = ImMax(cr.y, cr.w);
   40,320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (4,032x)
        .           
   24,192 ( 0.00%)      _ClipRectStack.push_back(cr);
  126,042 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec4>::push_back(ImVec4 const&) (4,032x)
   20,160 ( 0.00%)      _CmdHeader.ClipRect = cr;
   12,096 ( 0.00%)      _OnChangedClipRect();
  303,288 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_OnChangedClipRect() (4,032x)
   12,096 ( 0.00%)  }
        .           
        .           void ImDrawList::PushClipRectFullScreen()
        .           {
        .               PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
        .           }
        .           
        .           void ImDrawList::PopClipRect()
    8,064 ( 0.00%)  {
    8,064 ( 0.00%)      _ClipRectStack.pop_back();
   32,256 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec4>::pop_back() (2,016x)
   34,272 ( 0.00%)      _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
    6,048 ( 0.00%)      _OnChangedClipRect();
  180,649 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_OnChangedClipRect() (2,016x)
    6,048 ( 0.00%)  }
        .           
        .           void ImDrawList::PushTextureID(ImTextureID texture_id)
   10,080 ( 0.00%)  {
   12,096 ( 0.00%)      _TextureIdStack.push_back(texture_id);
   59,831 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<void*>::push_back(void* const&) (2,016x)
    6,048 ( 0.00%)      _CmdHeader.TextureId = texture_id;
    6,048 ( 0.00%)      _OnChangedTextureID();
   82,656 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_OnChangedTextureID() (2,016x)
    6,048 ( 0.00%)  }
        .           
        .           void ImDrawList::PopTextureID()
        .           {
        .               _TextureIdStack.pop_back();
        .               _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];
        .               _OnChangedTextureID();
        .           }
        .           
        .           // Reserve space for a number of vertices and indices.
        .           // You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
        .           // submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
        .           void ImDrawList::PrimReserve(int idx_count, int vtx_count)
   29,064 ( 0.00%)  {
        .               // Large mesh support (when enabled)
        .               IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
   29,064 ( 0.00%)      if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
        .               {
        .                   // FIXME: In theory we should be testing that vtx_count <64k here.
        .                   // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
        .                   // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
        .                   _CmdHeader.VtxOffset = VtxBuffer.Size;
        .                   _OnChangedVtxOffset();
        .               }
        .           
   58,128 ( 0.00%)      ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
   29,064 ( 0.00%)      draw_cmd->ElemCount += idx_count;
        .           
   14,532 ( 0.00%)      int vtx_buffer_old_size = VtxBuffer.Size;
   38,752 ( 0.00%)      VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
   81,307 ( 0.00%)  => ???:ImVector<ImDrawVert>::resize(int) (4,844x)
   53,284 ( 0.00%)      _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
        .           
   14,532 ( 0.00%)      int idx_buffer_old_size = IdxBuffer.Size;
   38,752 ( 0.00%)      IdxBuffer.resize(idx_buffer_old_size + idx_count);
   78,699 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int) (4,844x)
   38,752 ( 0.00%)      _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
   14,532 ( 0.00%)  }
        .           
        .           // Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
        .           void ImDrawList::PrimUnreserve(int idx_count, int vtx_count)
        .           {
        .               IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
        .           
        .               ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
        .               draw_cmd->ElemCount -= idx_count;
        .               VtxBuffer.shrink(VtxBuffer.Size - vtx_count);
        .               IdxBuffer.shrink(IdxBuffer.Size - idx_count);
        .           }
        .           
        .           // Fully unrolled with inline call to keep our debug builds decently fast.
        .           void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
    8,484 ( 0.00%)  {
   26,664 ( 0.00%)      ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
   33,936 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,424x)
    3,636 ( 0.00%)      ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
   19,392 ( 0.00%)      _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
   20,604 ( 0.00%)      _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
   15,756 ( 0.00%)      _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
   18,180 ( 0.00%)      _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
   19,392 ( 0.00%)      _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
   18,180 ( 0.00%)      _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
    6,060 ( 0.00%)      _VtxWritePtr += 4;
    6,060 ( 0.00%)      _VtxCurrentIdx += 4;
    6,060 ( 0.00%)      _IdxWritePtr += 6;
    3,636 ( 0.00%)  }
        .           
        .           void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
        .           {
        .               ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
        .               ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
        .               _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
        .               _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
        .               _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
-- line 686 ----------------------------------------
-- line 711 ----------------------------------------
        .           // - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.
        .           #define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
        .           #define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
        .           #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
        .           
        .           // TODO: Thickness anti-aliased lines cap are missing their AA fringe.
        .           // We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
        .           void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness)
    4,060 ( 0.00%)  {
    1,624 ( 0.00%)      if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
        .                   return;
        .           
    2,030 ( 0.00%)      const bool closed = (flags & ImDrawFlags_Closed) != 0;
    1,624 ( 0.00%)      const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
    2,030 ( 0.00%)      const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
    2,436 ( 0.00%)      const bool thick_line = (thickness > _FringeScale);
        .           
    2,030 ( 0.00%)      if (Flags & ImDrawListFlags_AntiAliasedLines)
        .               {
        .                   // Anti-aliased stroke
    1,218 ( 0.00%)          const float AA_SIZE = _FringeScale;
    1,218 ( 0.00%)          const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        .           
        .                   // Thicknesses <1.0 should behave like thickness 1.0
    2,436 ( 0.00%)          thickness = ImMax(thickness, 1.0f);
    4,466 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (406x)
    1,218 ( 0.00%)          const int integer_thickness = (int)thickness;
    1,624 ( 0.00%)          const float fractional_thickness = thickness - integer_thickness;
        .           
        .                   // Do we want to draw this line using a texture?
        .                   // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
        .                   // - If AA_SIZE is not 1.0f we cannot use the texture path.
    7,714 ( 0.00%)          const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
        .           
        .                   // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
        .                   IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
        .           
    3,654 ( 0.00%)          const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
    2,436 ( 0.00%)          const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
    2,436 ( 0.00%)          PrimReserve(idx_count, vtx_count);
   44,925 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (406x)
        .           
        .                   // Temporary buffer
        .                   // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
    4,466 ( 0.00%)          _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
    5,004 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec2>::reserve_discard(int) (406x)
    1,624 ( 0.00%)          ImVec2* temp_normals = _Data->TempBuffer.Data;
    2,436 ( 0.00%)          ImVec2* temp_points = temp_normals + points_count;
        .           
        .                   // Calculate normals (tangents) for each line segment
    8,502 ( 0.00%)          for (int i1 = 0; i1 < count; i1++)
        .                   {
   12,136 ( 0.00%)              const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
   22,652 ( 0.00%)              float dx = points[i2].x - points[i1].x;
   22,652 ( 0.00%)              float dy = points[i2].y - points[i1].y;
   33,978 ( 0.00%)              IM_NORMALIZE2F_OVER_ZERO(dx, dy);
   25,888 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRsqrt(float) (1,618x)
   11,326 ( 0.00%)              temp_normals[i1].x = dy;
   14,562 ( 0.00%)              temp_normals[i1].y = -dx;
        .                   }
    1,624 ( 0.00%)          if (!closed)
       28 ( 0.00%)              temp_normals[points_count - 1] = temp_normals[points_count - 2];
        .           
        .                   // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
      812 ( 0.00%)          if (use_texture || !thick_line)
        .                   {
        .                       // [PATH 1] Texture-based lines (thick or non-thick)
        .                       // [PATH 2] Non texture-based lines (non-thick)
        .           
        .                       // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
        .                       // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
        .                       //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
        .                       // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
        .                       //   allow scaling geometry while preserving one-screen-pixel AA fringe).
    3,654 ( 0.00%)              const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
        .           
        .                       // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
    1,624 ( 0.00%)              if (!closed)
        .                       {
       32 ( 0.00%)                  temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
       68 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (2x)
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2x)
       32 ( 0.00%)                  temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
       68 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (2x)
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (2x)
       62 ( 0.00%)                  temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
       68 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (2x)
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2x)
       64 ( 0.00%)                  temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
       68 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (2x)
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (2x)
        .                       }
        .           
        .                       // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
        .                       // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
        .                       // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
    1,218 ( 0.00%)              unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
    8,502 ( 0.00%)              for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
        .                       {
   12,136 ( 0.00%)                  const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
   16,586 ( 0.00%)                  const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
        .           
        .                           // Average normals
   25,888 ( 0.00%)                  float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
   25,888 ( 0.00%)                  float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
   33,978 ( 0.00%)                  IM_FIXNORMAL2F(dm_x, dm_y);
    4,854 ( 0.00%)                  dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
    4,854 ( 0.00%)                  dm_y *= half_draw_size;
        .           
        .                           // Add temporary vertexes for the outer edges
   11,326 ( 0.00%)                  ImVec2* out_vtx = &temp_points[i2 * 2];
   14,562 ( 0.00%)                  out_vtx[0].x = points[i2].x + dm_x;
   14,562 ( 0.00%)                  out_vtx[0].y = points[i2].y + dm_y;
   16,180 ( 0.00%)                  out_vtx[1].x = points[i2].x - dm_x;
   16,180 ( 0.00%)                  out_vtx[1].y = points[i2].y - dm_y;
        .           
    3,236 ( 0.00%)                  if (use_texture)
        .                           {
        .                               // Add indices for two triangles
   25,888 ( 0.00%)                      _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
   30,742 ( 0.00%)                      _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
    9,708 ( 0.00%)                      _IdxWritePtr += 6;
        .                           }
        .                           else
        .                           {
        .                               // Add indexes for four triangles
        .                               _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
        .                               _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
        .                               _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
        .                               _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
        .                               _IdxWritePtr += 12;
        .                           }
        .           
    3,236 ( 0.00%)                  idx1 = idx2;
        .                       }
        .           
        .                       // Add vertexes for each point on the line
      812 ( 0.00%)              if (use_texture)
        .                       {
        .                           // If we're using textures we only need to emit the left/right edge vertices
    4,466 ( 0.00%)                  ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
        .                           /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
        .                           {
        .                               const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
        .                               tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
        .                               tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
        .                               tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
        .                               tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
        .                           }*/
    2,842 ( 0.00%)                  ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
    5,684 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (406x)
    2,842 ( 0.00%)                  ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
    5,684 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (406x)
    8,510 ( 0.00%)                  for (int i = 0; i < points_count; i++)
        .                           {
   29,160 ( 0.00%)                      _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
   35,640 ( 0.00%)                      _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
    8,100 ( 0.00%)                      _VtxWritePtr += 2;
        .                           }
        .                       }
        .                       else
        .                       {
        .                           // If we're not using a texture, we need the center vertex as well
        .                           for (int i = 0; i < points_count; i++)
        .                           {
        .                               _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
        .                               _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
        .                               _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
        .                               _VtxWritePtr += 3;
        .                           }
        .                       }
      406 ( 0.00%)          }
        .                   else
        .                   {
        .                       // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
        .                       const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
        .           
        .                       // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
        .                       if (!closed)
        .                       {
-- line 876 ----------------------------------------
-- line 931 ----------------------------------------
        .                       {
        .                           _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
        .                           _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
        .                           _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
        .                           _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
        .                           _VtxWritePtr += 4;
        .                       }
        .                   }
    3,248 ( 0.00%)          _VtxCurrentIdx += (ImDrawIdx)vtx_count;
        .               }
        .               else
        .               {
        .                   // [PATH 4] Non texture-based, Non anti-aliased lines
        .                   const int idx_count = count * 6;
        .                   const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
        .                   PrimReserve(idx_count, vtx_count);
        .           
-- line 947 ----------------------------------------
-- line 964 ----------------------------------------
        .                       _VtxWritePtr += 4;
        .           
        .                       _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
        .                       _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
        .                       _IdxWritePtr += 6;
        .                       _VtxCurrentIdx += 4;
        .                   }
        .               }
    1,218 ( 0.00%)  }
        .           
        .           // - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
        .           // - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
        .           void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
    2,828 ( 0.00%)  {
    1,616 ( 0.00%)      if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
        .                   return;
        .           
    1,616 ( 0.00%)      const ImVec2 uv = _Data->TexUvWhitePixel;
        .           
    2,020 ( 0.00%)      if (Flags & ImDrawListFlags_AntiAliasedFill)
        .               {
        .                   // Anti-aliased Fill
    1,212 ( 0.00%)          const float AA_SIZE = _FringeScale;
    1,212 ( 0.00%)          const ImU32 col_trans = col & ~IM_COL32_A_MASK;
    4,848 ( 0.00%)          const int idx_count = (points_count - 2)*3 + points_count * 6;
    1,212 ( 0.00%)          const int vtx_count = (points_count * 2);
    2,424 ( 0.00%)          PrimReserve(idx_count, vtx_count);
   43,626 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (404x)
        .           
        .                   // Add indexes for fill
    1,212 ( 0.00%)          unsigned int vtx_inner_idx = _VtxCurrentIdx;
    1,616 ( 0.00%)          unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
    3,636 ( 0.00%)          for (int i = 2; i < points_count; i++)
        .                   {
    9,292 ( 0.00%)              _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
    2,020 ( 0.00%)              _IdxWritePtr += 3;
        .                   }
        .           
        .                   // Compute normals
    2,828 ( 0.00%)          _Data->TempBuffer.reserve_discard(points_count);
    4,848 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec2>::reserve_discard(int) (404x)
    1,616 ( 0.00%)          ImVec2* temp_normals = _Data->TempBuffer.Data;
   11,716 ( 0.00%)          for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        .                   {
    7,272 ( 0.00%)              const ImVec2& p0 = points[i0];
    7,272 ( 0.00%)              const ImVec2& p1 = points[i1];
    7,272 ( 0.00%)              float dx = p1.x - p0.x;
    7,272 ( 0.00%)              float dy = p1.y - p0.y;
   25,452 ( 0.00%)              IM_NORMALIZE2F_OVER_ZERO(dx, dy);
   19,392 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRsqrt(float) (1,212x)
    8,484 ( 0.00%)              temp_normals[i0].x = dy;
   10,908 ( 0.00%)              temp_normals[i0].y = -dx;
        .                   }
        .           
   11,716 ( 0.00%)          for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        .                   {
        .                       // Average normals
    7,272 ( 0.00%)              const ImVec2& n0 = temp_normals[i0];
    7,272 ( 0.00%)              const ImVec2& n1 = temp_normals[i1];
    9,696 ( 0.00%)              float dm_x = (n0.x + n1.x) * 0.5f;
    9,696 ( 0.00%)              float dm_y = (n0.y + n1.y) * 0.5f;
   25,452 ( 0.00%)              IM_FIXNORMAL2F(dm_x, dm_y);
    7,272 ( 0.00%)              dm_x *= AA_SIZE * 0.5f;
    7,272 ( 0.00%)              dm_y *= AA_SIZE * 0.5f;
        .           
        .                       // Add vertices
   33,936 ( 0.00%)              _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
   38,784 ( 0.00%)              _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
    6,060 ( 0.00%)              _VtxWritePtr += 2;
        .           
        .                       // Add indexes for fringes
   31,512 ( 0.00%)              _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
   32,724 ( 0.00%)              _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
    6,060 ( 0.00%)              _IdxWritePtr += 6;
        .                   }
    3,232 ( 0.00%)          _VtxCurrentIdx += (ImDrawIdx)vtx_count;
        .               }
        .               else
        .               {
        .                   // Non Anti-aliased Fill
        .                   const int idx_count = (points_count - 2)*3;
        .                   const int vtx_count = points_count;
        .                   PrimReserve(idx_count, vtx_count);
        .                   for (int i = 0; i < vtx_count; i++)
-- line 1044 ----------------------------------------
-- line 1048 ----------------------------------------
        .                   }
        .                   for (int i = 2; i < points_count; i++)
        .                   {
        .                       _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
        .                       _IdxWritePtr += 3;
        .                   }
        .                   _VtxCurrentIdx += (ImDrawIdx)vtx_count;
        .               }
      808 ( 0.00%)  }
        .           
        .           void ImDrawList::_PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step)
        .           {
        .               if (radius < 0.5f)
        .               {
        .                   _Path.push_back(center);
        .                   return;
        .               }
-- line 1064 ----------------------------------------
-- line 1361 ----------------------------------------
        .           
        .               if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
        .                   flags |= ImDrawFlags_RoundCornersAll;
        .           
        .               return flags;
        .           }
        .           
        .           void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawFlags flags)
    3,232 ( 0.00%)  {
    1,212 ( 0.00%)      if (rounding >= 0.5f)
        .               {
        .                   flags = FixRectCornerFlags(flags);
        .                   rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
        .                   rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
        .               }
    1,212 ( 0.00%)      if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
        .               {
    2,020 ( 0.00%)          PathLineTo(a);
   17,841 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    5,656 ( 0.00%)          PathLineTo(ImVec2(b.x, a.y));
   17,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
    2,020 ( 0.00%)          PathLineTo(b);
   17,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    6,060 ( 0.00%)          PathLineTo(ImVec2(a.x, b.y));
   17,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
        .               }
        .               else
        .               {
        .                   const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
        .                   const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
        .                   const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
        .                   const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
        .                   PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
        .                   PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
        .                   PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
        .                   PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
        .               }
    1,212 ( 0.00%)  }
        .           
        .           void ImDrawList::AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness)
       16 ( 0.00%)  {
        4 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
        .                   return;
       36 ( 0.00%)      PathLineTo(p1 + ImVec2(0.5f, 0.5f));
       86 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (2x)
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2x)
       36 ( 0.00%)      PathLineTo(p2 + ImVec2(0.5f, 0.5f));
       86 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (2x)
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2x)
       18 ( 0.00%)      PathStroke(col, 0, thickness);
    3,369 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathStroke(unsigned int, int, float) (2x)
        4 ( 0.00%)  }
        .           
        .           // p_min = upper-left, p_max = lower-right
        .           // Note we don't render 1 pixels sized rectangles properly.
        .           void ImDrawList::AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness)
    4,040 ( 0.00%)  {
      808 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
        .                   return;
    2,020 ( 0.00%)      if (Flags & ImDrawListFlags_AntiAliasedLines)
   14,140 ( 0.00%)          PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
  103,893 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PathRect(ImVec2 const&, ImVec2 const&, float, int) (404x)
   15,756 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (404x)
   15,756 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (404x)
   11,312 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (808x)
        .               else
        .                   PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
    3,636 ( 0.00%)      PathStroke(col, ImDrawFlags_Closed, thickness);
  657,026 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathStroke(unsigned int, int, float) (404x)
      808 ( 0.00%)  }
        .           
        .           void ImDrawList::AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags)
   10,908 ( 0.00%)  {
    2,424 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
        .                   return;
    3,636 ( 0.00%)      if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
        .               {
    6,060 ( 0.00%)          PrimReserve(6, 4);
  128,180 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (1,212x)
    8,484 ( 0.00%)          PrimRect(p_min, p_max, col);
  206,040 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimRect(ImVec2 const&, ImVec2 const&, unsigned int) (1,212x)
        .               }
        .               else
        .               {
        .                   PathRect(p_min, p_max, rounding, flags);
        .                   PathFillConvex(col);
        .               }
    2,424 ( 0.00%)  }
        .           
        .           // p_min = upper-left, p_max = lower-right
        .           void ImDrawList::AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
        .           {
        .               if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        .                   return;
        .           
        .               const ImVec2 uv = _Data->TexUvWhitePixel;
-- line 1440 ----------------------------------------
-- line 1478 ----------------------------------------
        .           
        .               PathLineTo(p1);
        .               PathLineTo(p2);
        .               PathLineTo(p3);
        .               PathStroke(col, ImDrawFlags_Closed, thickness);
        .           }
        .           
        .           void ImDrawList::AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col)
    3,232 ( 0.00%)  {
      808 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
        .                   return;
        .           
    2,020 ( 0.00%)      PathLineTo(p1);
   17,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    2,020 ( 0.00%)      PathLineTo(p2);
   17,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    2,020 ( 0.00%)      PathLineTo(p3);
   17,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathLineTo(ImVec2 const&) (404x)
    2,424 ( 0.00%)      PathFillConvex(col);
  440,758 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::PathFillConvex(unsigned int) (404x)
      808 ( 0.00%)  }
        .           
        .           void ImDrawList::AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)
        .           {
        .               if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
        .                   return;
        .           
        .               if (num_segments <= 0)
        .               {
-- line 1502 ----------------------------------------
-- line 1612 ----------------------------------------
        .                   return;
        .           
        .               PathLineTo(p1);
        .               PathBezierQuadraticCurveTo(p2, p3, num_segments);
        .               PathStroke(col, 0, thickness);
        .           }
        .           
        .           void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
   31,042 ( 0.00%)  {
    5,644 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
        .                   return;
        .           
        .               // Accept null ranges
   19,754 ( 0.00%)      if (text_begin == text_end || text_begin[0] == 0)
        .                   return;
    5,644 ( 0.00%)      if (text_end == NULL)
        .                   text_end = text_begin + strlen(text_begin);
        .           
        .               // Pull default font/size from the shared ImDrawListSharedData instance
    5,644 ( 0.00%)      if (font == NULL)
    1,616 ( 0.00%)          font = _Data->Font;
   16,932 ( 0.00%)      if (font_size == 0.0f)
    1,616 ( 0.00%)          font_size = _Data->FontSize;
        .           
   19,754 ( 0.00%)      IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
        .           
   14,110 ( 0.00%)      ImVec4 clip_rect = _CmdHeader.ClipRect;
    5,644 ( 0.00%)      if (cpu_fine_clip_rect)
        .               {
        8 ( 0.00%)          clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (1x)
        8 ( 0.00%)          clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (1x)
        8 ( 0.00%)          clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (1x)
        8 ( 0.00%)          clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (1x)
        .               }
   56,440 ( 0.00%)      font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
6,207,479 ( 0.01%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::RenderText(ImDrawList*, float, ImVec2 const&, unsigned int, ImVec4 const&, char const*, char const*, float, bool) const (2,822x)
    5,644 ( 0.00%)  }
        .           
        .           void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
        .           {
        .               AddText(NULL, 0.0f, pos, col, text_begin, text_end);
        .           }
        .           
        .           void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col)
        .           {
-- line 1655 ----------------------------------------
-- line 2022 ----------------------------------------
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImDrawListSplitter
        .           //-----------------------------------------------------------------------------
        .           // FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImDrawListSplitter::ClearFreeMemory()
        4 ( 0.00%)  {
        6 ( 0.00%)      for (int i = 0; i < _Channels.Size; i++)
        .               {
        .                   if (i == _Current)
        .                       memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
        .                   _Channels[i]._CmdBuffer.clear();
        .                   _Channels[i]._IdxBuffer.clear();
        .               }
        2 ( 0.00%)      _Current = 0;
        2 ( 0.00%)      _Count = 1;
        4 ( 0.00%)      _Channels.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::clear() (1x)
        3 ( 0.00%)  }
        .           
        .           void ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)
    2,418 ( 0.00%)  {
        .               IM_UNUSED(draw_list);
    3,224 ( 0.00%)      IM_ASSERT(_Current == 0 && _Count <= 1 && "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.");
    1,209 ( 0.00%)      int old_channels_count = _Channels.Size;
    1,209 ( 0.00%)      if (old_channels_count < channels_count)
        .               {
        6 ( 0.00%)          _Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable
      293 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::reserve(int) (1x)
        6 ( 0.00%)          _Channels.resize(channels_count);
       15 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::resize(int) (1x)
        .               }
    1,209 ( 0.00%)      _Count = channels_count;
        .           
        .               // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
        .               // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
        .               // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
    4,030 ( 0.00%)      memset(&_Channels[0], 0, sizeof(ImDrawChannel));
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::operator[](int) (403x)
    4,836 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (403x)
    3,627 ( 0.00%)      for (int i = 1; i < channels_count; i++)
        .               {
    1,209 ( 0.00%)          if (i >= old_channels_count)
        .                   {
       18 ( 0.00%)              IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::operator[](int) (1x)
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawChannel::ImDrawChannel() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        .                   }
        .                   else
        .                   {
    3,618 ( 0.00%)              _Channels[i]._CmdBuffer.resize(0);
    7,638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::operator[](int) (402x)
    6,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::resize(int) (402x)
    4,020 ( 0.00%)              _Channels[i]._IdxBuffer.resize(0);
    7,638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::operator[](int) (402x)
    6,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int) (402x)
        .                   }
        .               }
    1,612 ( 0.00%)  }
        .           
        .           void ImDrawListSplitter::Merge(ImDrawList* draw_list)
    2,015 ( 0.00%)  {
        .               // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
    1,612 ( 0.00%)      if (_Count <= 1)
        .                   return;
        .           
    2,418 ( 0.00%)      SetCurrentChannel(draw_list, 0);
   49,981 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::SetCurrentChannel(ImDrawList*, int) (403x)
    1,209 ( 0.00%)      draw_list->_PopUnusedDrawCmd();
   22,138 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_PopUnusedDrawCmd() (403x)
        .           
        .               // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
      403 ( 0.00%)      int new_cmd_buffer_count = 0;
      403 ( 0.00%)      int new_idx_buffer_count = 0;
    4,033 ( 0.00%)      ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::back() (1x)
    1,617 ( 0.00%)      int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
    4,433 ( 0.00%)      for (int i = 1; i < _Count; i++)
        .               {
    2,821 ( 0.00%)          ImDrawChannel& ch = _Channels[i];
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::operator[](int) (403x)
    8,060 ( 0.00%)          if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
   16,926 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::back() (806x)
    1,209 ( 0.00%)              ch._CmdBuffer.pop_back();
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::pop_back() (403x)
        .           
    1,612 ( 0.00%)          if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)
        .                   {
        .                       // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
        .                       // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
        .                       ImDrawCmd* next_cmd = &ch._CmdBuffer[0];
        .                       if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)
        .                       {
        .                           // Merge previous channel last draw command with current channel first draw command if matching.
        .                           last_cmd->ElemCount += next_cmd->ElemCount;
        .                           idx_offset += next_cmd->ElemCount;
        .                           ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
        .                       }
        .                   }
    1,612 ( 0.00%)          if (ch._CmdBuffer.Size > 0)
        .                       last_cmd = &ch._CmdBuffer.back();
    1,209 ( 0.00%)          new_cmd_buffer_count += ch._CmdBuffer.Size;
    1,209 ( 0.00%)          new_idx_buffer_count += ch._IdxBuffer.Size;
    2,418 ( 0.00%)          for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)
        .                   {
        .                       ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;
        .                       idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;
        .                   }
        .               }
    3,224 ( 0.00%)      draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::resize(int) (403x)
    3,627 ( 0.00%)      draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int) (403x)
        .           
        .               // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
    5,642 ( 0.00%)      ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;
    4,433 ( 0.00%)      ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;
    4,433 ( 0.00%)      for (int i = 1; i < _Count; i++)
        .               {
    2,821 ( 0.00%)          ImDrawChannel& ch = _Channels[i];
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::operator[](int) (403x)
    2,015 ( 0.00%)          if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
    2,015 ( 0.00%)          if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }
        .               }
    1,209 ( 0.00%)      draw_list->_IdxWritePtr = idx_write;
        .           
        .               // Ensure there's always a non-callback draw command trailing the command-buffer
    3,229 ( 0.00%)      if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::back() (1x)
    1,206 ( 0.00%)          draw_list->AddDrawCmd();
   52,260 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddDrawCmd() (402x)
        .           
        .               // If current command is used with different settings we need to add a new command
    4,836 ( 0.00%)      ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
    1,612 ( 0.00%)      if (curr_cmd->ElemCount == 0)
    3,618 ( 0.00%)          ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
    4,422 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (402x)
       10 ( 0.00%)      else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
       19 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1x)
        .                   draw_list->AddDrawCmd();
        .           
    1,209 ( 0.00%)      _Count = 1;
      806 ( 0.00%)  }
        .           
        .           void ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)
    7,260 ( 0.00%)  {
    7,260 ( 0.00%)      IM_ASSERT(idx >= 0 && idx < _Count);
    4,840 ( 0.00%)      if (_Current == idx)
      402 ( 0.00%)          return;
        .           
        .               // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
   10,504 ( 0.00%)      memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));
   11,312 ( 0.00%)      memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));
    2,424 ( 0.00%)      _Current = idx;
    8,888 ( 0.00%)      memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));
   10,504 ( 0.00%)      memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));
    7,272 ( 0.00%)      draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;
        .           
        .               // If current command is used with different settings we need to add a new command
    9,303 ( 0.00%)      ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
    1,616 ( 0.00%)      if (curr_cmd == NULL)
    1,612 ( 0.00%)          draw_list->AddDrawCmd();
   52,726 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddDrawCmd() (403x)
    1,620 ( 0.00%)      else if (curr_cmd->ElemCount == 0)
    3,636 ( 0.00%)          ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
    4,444 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (404x)
       10 ( 0.00%)      else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
       19 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1x)
        .                   draw_list->AddDrawCmd();
    2,420 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImDrawData
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImDrawData::Clear()
        8 ( 0.00%)  {
        4 ( 0.00%)      Valid = false;
       20 ( 0.00%)      CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
       10 ( 0.00%)      CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
       30 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::resize(int) (2x)
       38 ( 0.00%)      DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2x)
        4 ( 0.00%)      OwnerViewport = NULL;
        6 ( 0.00%)  }
        .           
        .           // Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list
        .           // as long at it is expected that the result will be later merged into draw_data->CmdLists[].
        .           void ImGui::AddDrawListToDrawDataEx(ImDrawData* draw_data, ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
    9,666 ( 0.00%)  {
    6,444 ( 0.00%)      if (draw_list->CmdBuffer.Size == 0)
        .                   return;
   29,389 ( 0.00%)      if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
   53,130 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::operator[](int) (2,415x)
    1,207 ( 0.00%)          return;
        .           
        .               // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
        .               // May trigger for you if you are using PrimXXX functions incorrectly.
    7,272 ( 0.00%)      IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    6,060 ( 0.00%)      IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    2,020 ( 0.00%)      if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
        .                   IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
        .           
        .               // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
        .               // If this assert triggers because you are drawing lots of stuff manually:
        .               // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
        .               //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
        .               // - If you want large meshes with more than 64K vertices, you can either:
        .               //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
-- line 2202 ----------------------------------------
-- line 2205 ----------------------------------------
        .               //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
        .               //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
        .               //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
        .               //       Your own engine or render API may use different parameters or function calls to specify index sizes.
        .               //       2 and 4 bytes indices are generally supported by most graphics API.
        .               // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
        .               //   the 64K limit to split your draw commands in multiple draw lists.
        .               if (sizeof(ImDrawIdx) == 2)
    1,616 ( 0.00%)          IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
        .           
        .               // Add to output list + records state in ImDrawData
    2,020 ( 0.00%)      out_list->push_back(draw_list);
   11,891 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::push_back(ImDrawList* const&) (404x)
    2,020 ( 0.00%)      draw_data->CmdListsCount++;
    2,828 ( 0.00%)      draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
    3,232 ( 0.00%)      draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
    3,222 ( 0.00%)  }
        .           
        .           void ImDrawData::AddDrawList(ImDrawList* draw_list)
        .           {
        .               IM_ASSERT(CmdLists.Size == CmdListsCount);
        .               draw_list->_PopUnusedDrawCmd();
        .               ImGui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);
        .           }
        .           
-- line 2228 ----------------------------------------
-- line 2315 ----------------------------------------
        .               for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
        .                   vertex->pos = ImRotate(vertex->pos- pivot_in, cos_a, sin_a) + pivot_out;
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImFontConfig
        .           //-----------------------------------------------------------------------------
        .           
       24 ( 0.00%)  ImFontConfig::ImFontConfig()
       48 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (4x)
        .           {
       12 ( 0.00%)      memset(this, 0, sizeof(*this));
       52 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2x)
        4 ( 0.00%)      FontDataOwnedByAtlas = true;
        4 ( 0.00%)      OversampleH = 2;
        4 ( 0.00%)      OversampleV = 1;
        6 ( 0.00%)      GlyphMaxAdvanceX = FLT_MAX;
        6 ( 0.00%)      RasterizerMultiply = 1.0f;
        6 ( 0.00%)      RasterizerDensity = 1.0f;
        4 ( 0.00%)      EllipsisChar = (ImWchar)-1;
        6 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImFontAtlas
        .           //-----------------------------------------------------------------------------
        .           
        .           // A work of art lies ahead! (. = white layer, X = black layer, others are blank)
        .           // The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
        .           // (This is used when io.MouseDrawCursor = true)
-- line 2341 ----------------------------------------
-- line 2381 ----------------------------------------
        .               { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
        .               { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
        .               { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
        .               { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
        .               { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
        .               { ImVec2(109,0),ImVec2(13,15), ImVec2( 6, 7) }, // ImGuiMouseCursor_NotAllowed
        .           };
        .           
       31 ( 0.00%)  ImFontAtlas::ImFontAtlas()
       78 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (2x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::ImVector() (1x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::ImVector() (1x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontAtlasCustomRect>::ImVector() (1x)
        .           {
        6 ( 0.00%)      memset(this, 0, sizeof(*this));
       85 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        2 ( 0.00%)      TexGlyphPadding = 1;
        6 ( 0.00%)      PackIdMouseCursors = PackIdLines = -1;
        3 ( 0.00%)  }
        .           
        .           ImFontAtlas::~ImFontAtlas()
        .           {
        .               IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        .               Clear();
        .           }
        .           
        .           void    ImFontAtlas::ClearInputData()
-- line 2402 ----------------------------------------
-- line 2418 ----------------------------------------
        .                   }
        .               ConfigData.clear();
        .               CustomRects.clear();
        .               PackIdMouseCursors = PackIdLines = -1;
        .               // Important: we leave TexReady untouched
        .           }
        .           
        .           void    ImFontAtlas::ClearTexData()
       12 ( 0.00%)  {
       15 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       12 ( 0.00%)      if (TexPixelsAlpha8)
        .                   IM_FREE(TexPixelsAlpha8);
       12 ( 0.00%)      if (TexPixelsRGBA32)
        .                   IM_FREE(TexPixelsRGBA32);
        6 ( 0.00%)      TexPixelsAlpha8 = NULL;
        6 ( 0.00%)      TexPixelsRGBA32 = NULL;
        6 ( 0.00%)      TexPixelsUseColors = false;
        .               // Important: we leave TexReady untouched
        9 ( 0.00%)  }
        .           
        .           void    ImFontAtlas::ClearFonts()
        .           {
        .               IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        .               Fonts.clear_delete();
        .               TexReady = false;
        .           }
        .           
-- line 2444 ----------------------------------------
-- line 2445 ----------------------------------------
        .           void    ImFontAtlas::Clear()
        .           {
        .               ClearInputData();
        .               ClearTexData();
        .               ClearFonts();
        .           }
        .           
        .           void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
        8 ( 0.00%)  {
        .               // Build atlas on demand
        4 ( 0.00%)      if (TexPixelsAlpha8 == NULL)
        3 ( 0.00%)          Build();
99,921,400 ( 0.08%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::Build() (1x)
        .           
        4 ( 0.00%)      *out_pixels = TexPixelsAlpha8;
        2 ( 0.00%)      if (out_width) *out_width = TexWidth;
        2 ( 0.00%)      if (out_height) *out_height = TexHeight;
        2 ( 0.00%)      if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
        3 ( 0.00%)  }
        .           
        .           void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
        8 ( 0.00%)  {
        .               // Convert to RGBA32 format on demand
        .               // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
        4 ( 0.00%)      if (!TexPixelsRGBA32)
        .               {
        1 ( 0.00%)          unsigned char* pixels = NULL;
        7 ( 0.00%)          GetTexDataAsAlpha8(&pixels, NULL, NULL);
99,921,428 ( 0.08%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::GetTexDataAsAlpha8(unsigned char**, int*, int*, int*) (1x)
        3 ( 0.00%)          if (pixels)
        .                   {
       12 ( 0.00%)              TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
      936 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        2 ( 0.00%)              const unsigned char* src = pixels;
        3 ( 0.00%)              unsigned int* dst = TexPixelsRGBA32;
  786,441 ( 0.00%)              for (int n = TexWidth * TexHeight; n > 0; n--)
3,145,728 ( 0.00%)                  *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
        .                   }
        .               }
        .           
        4 ( 0.00%)      *out_pixels = (unsigned char*)TexPixelsRGBA32;
        6 ( 0.00%)      if (out_width) *out_width = TexWidth;
        6 ( 0.00%)      if (out_height) *out_height = TexHeight;
        2 ( 0.00%)      if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
        3 ( 0.00%)  }
        .           
        .           ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
       18 ( 0.00%)  {
       10 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       16 ( 0.00%)      IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
       10 ( 0.00%)      IM_ASSERT(font_cfg->SizePixels > 0.0f);
        .           
        .               // Create new font
       10 ( 0.00%)      if (!font_cfg->MergeMode)
       19 ( 0.00%)          Fonts.push_back(IM_NEW(ImFont));
      497 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::push_back(ImFont* const&) (1x)
      126 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::ImFont() (1x)
      118 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        .               else
        7 ( 0.00%)          IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::empty() const (1x)
        .           
       12 ( 0.00%)      ConfigData.push_back(*font_cfg);
      663 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::push_back(ImFontConfig const&) (2x)
       10 ( 0.00%)      ImFontConfig& new_font_cfg = ConfigData.back();
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::back() (2x)
        8 ( 0.00%)      if (new_font_cfg.DstFont == NULL)
       14 ( 0.00%)          new_font_cfg.DstFont = Fonts.back();
       36 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::back() (2x)
       10 ( 0.00%)      if (!new_font_cfg.FontDataOwnedByAtlas)
        .               {
        .                   new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
        .                   new_font_cfg.FontDataOwnedByAtlas = true;
        .                   memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
        .               }
        .           
       10 ( 0.00%)      if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
        5 ( 0.00%)          new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
        .           
        6 ( 0.00%)      ImFontAtlasUpdateConfigDataPointers(this);
      160 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasUpdateConfigDataPointers(ImFontAtlas*) (2x)
        .           
        .               // Invalidate texture
        4 ( 0.00%)      TexReady = false;
        6 ( 0.00%)      ClearTexData();
       52 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::ClearTexData() (2x)
        6 ( 0.00%)      return new_font_cfg.DstFont;
       14 ( 0.00%)  }
        .           
        .           // Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
        .           static unsigned int stb_decompress_length(const unsigned char* input);
        .           static unsigned int stb_decompress(unsigned char* output, const unsigned char* input, unsigned int length);
        .           static const char*  GetDefaultCompressedFontDataTTFBase85();
1,723,059 ( 0.00%)  static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
        .           static void         Decode85(const unsigned char* src, unsigned char* dst)
       18 ( 0.00%)  {
  134,162 ( 0.00%)      while (*src)
        .               {
1,408,596 ( 0.00%)          unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
1,723,059 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:Decode85Byte(char) (167,690x)
  737,836 ( 0.00%)          dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
   33,538 ( 0.00%)          src += 5;
   33,538 ( 0.00%)          dst += 4;
        .               }
       18 ( 0.00%)  }
        .           
        .           // Load embedded ProggyClean.ttf at size 13, disable oversampling
        .           ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
        7 ( 0.00%)  {
        5 ( 0.00%)      ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
       88 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontConfig::ImFontConfig() (1x)
        2 ( 0.00%)      if (!font_cfg_template)
        .               {
        3 ( 0.00%)          font_cfg.OversampleH = font_cfg.OversampleV = 1;
        1 ( 0.00%)          font_cfg.PixelSnapH = true;
        .               }
        4 ( 0.00%)      if (font_cfg.SizePixels <= 0.0f)
        2 ( 0.00%)          font_cfg.SizePixels = 13.0f * 1.0f;
        3 ( 0.00%)      if (font_cfg.Name[0] == '\0')
        9 ( 0.00%)          ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
    1,757 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImFormatString(char*, unsigned long, char const*, ...) (1x)
        1 ( 0.00%)      font_cfg.EllipsisChar = (ImWchar)0x0085;
        6 ( 0.00%)      font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
        .           
        2 ( 0.00%)      const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
        5 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:GetDefaultCompressedFontDataTTFBase85() (1x)
        7 ( 0.00%)      const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
        6 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::GetGlyphRangesDefault() (1x)
        9 ( 0.00%)      ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
1,467,065 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(char const*, float, ImFontConfig const*, unsigned short const*) (1x)
        1 ( 0.00%)      return font;
        3 ( 0.00%)  }
        .           
        .           ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
        .           {
        .               IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        .               size_t data_size = 0;
        .               void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
        .               if (!data)
        .               {
-- line 2566 ----------------------------------------
-- line 2575 ----------------------------------------
        .                   for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
        .                   ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
        .               }
        .               return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
        .           }
        .           
        .           // NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
        .           ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
       18 ( 0.00%)  {
       10 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       32 ( 0.00%)      ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
        6 ( 0.00%)      IM_ASSERT(font_cfg.FontData == NULL);
        4 ( 0.00%)      IM_ASSERT(font_data_size > 100 && "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
        4 ( 0.00%)      font_cfg.FontData = font_data;
        4 ( 0.00%)      font_cfg.FontDataSize = font_data_size;
       14 ( 0.00%)      font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
        4 ( 0.00%)      if (glyph_ranges)
        4 ( 0.00%)          font_cfg.GlyphRanges = glyph_ranges;
       10 ( 0.00%)      return AddFont(&font_cfg);
    1,905 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFont(ImFontConfig const*) (2x)
        4 ( 0.00%)  }
        .           
        .           ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
       22 ( 0.00%)  {
        8 ( 0.00%)      const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
       56 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb_decompress_length(unsigned char const*) (2x)
        8 ( 0.00%)      unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
      842 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (2x)
       12 ( 0.00%)      stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
5,104,153 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb_decompress(unsigned char*, unsigned char const*, unsigned int) (2x)
        .           
       32 ( 0.00%)      ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
        6 ( 0.00%)      IM_ASSERT(font_cfg.FontData == NULL);
        2 ( 0.00%)      font_cfg.FontDataOwnedByAtlas = true;
       18 ( 0.00%)      return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
    2,019 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFontFromMemoryTTF(void*, int, float, ImFontConfig const*, unsigned short const*) (2x)
        6 ( 0.00%)  }
        .           
        .           ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
       16 ( 0.00%)  {
       26 ( 0.00%)      int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
   13,188 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (2x)
       10 ( 0.00%)      void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
      869 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (2x)
       10 ( 0.00%)      Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
4,070,765 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:Decode85(unsigned char const*, unsigned char*) (2x)
       20 ( 0.00%)      ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
5,107,184 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFontFromMemoryCompressedTTF(void const*, int, float, ImFontConfig const*, unsigned short const*) (2x)
        6 ( 0.00%)      IM_FREE(compressed_ttf);
      524 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (2x)
        2 ( 0.00%)      return font;
        4 ( 0.00%)  }
        .           
        .           int ImFontAtlas::AddCustomRectRegular(int width, int height)
       12 ( 0.00%)  {
        8 ( 0.00%)      IM_ASSERT(width > 0 && width <= 0xFFFF);
        8 ( 0.00%)      IM_ASSERT(height > 0 && height <= 0xFFFF);
        6 ( 0.00%)      ImFontAtlasCustomRect r;
      130 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFontAtlasCustomRect::ImFontAtlasCustomRect() (2x)
        4 ( 0.00%)      r.Width = (unsigned short)width;
        4 ( 0.00%)      r.Height = (unsigned short)height;
       12 ( 0.00%)      CustomRects.push_back(r);
      233 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontAtlasCustomRect>::push_back(ImFontAtlasCustomRect const&) (2x)
        6 ( 0.00%)      return CustomRects.Size - 1; // Return index
        4 ( 0.00%)  }
        .           
        .           int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
        .           {
        .           #ifdef IMGUI_USE_WCHAR32
        .               IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);
        .           #endif
        .               IM_ASSERT(font != NULL);
        .               IM_ASSERT(width > 0 && width <= 0xFFFF);
-- line 2635 ----------------------------------------
-- line 2670 ----------------------------------------
        .               out_uv_border[1] = (pos + size) * TexUvScale;
        .               pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
        .               out_uv_fill[0] = (pos) * TexUvScale;
        .               out_uv_fill[1] = (pos + size) * TexUvScale;
        .               return true;
        .           }
        .           
        .           bool    ImFontAtlas::Build()
        4 ( 0.00%)  {
        5 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        .           
        .               // Default font is none are specified
        4 ( 0.00%)      if (ConfigData.Size == 0)
        .                   AddFontDefault();
        .           
        .               // Select builder
        .               // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
        .               //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
        .               //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
        .               //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
        3 ( 0.00%)      const ImFontBuilderIO* builder_io = FontBuilderIO;
        2 ( 0.00%)      if (builder_io == NULL)
        .               {
        .           #ifdef IMGUI_ENABLE_FREETYPE
        .                   builder_io = ImGuiFreeType::GetBuilderForFreeType();
        .           #elif defined(IMGUI_ENABLE_STB_TRUETYPE)
        2 ( 0.00%)          builder_io = ImFontAtlasGetBuilderForStbTruetype();
        6 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasGetBuilderForStbTruetype() (1x)
        .           #else
        .                   IM_ASSERT(0); // Invalid Build function
        .           #endif
        .               }
        .           
        .               // Build
        5 ( 0.00%)      return builder_io->FontBuilder_Build(this);
99,921,367 ( 0.08%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildWithStbTruetype(ImFontAtlas*) (1x)
        2 ( 0.00%)  }
        .           
        .           void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
        .           {
        .               for (unsigned int i = 0; i < 256; i++)
        .               {
        .                   unsigned int value = (unsigned int)(i * in_brighten_factor);
        .                   out_table[i] = value > 255 ? 255 : (value & 0xFF);
        .               }
-- line 2712 ----------------------------------------
-- line 2719 ----------------------------------------
        .               for (int j = h; j > 0; j--, data += stride - w)
        .                   for (int i = w; i > 0; i--, data++)
        .                       *data = table[*data];
        .           }
        .           
        .           #ifdef IMGUI_ENABLE_STB_TRUETYPE
        .           // Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
        .           // (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
       30 ( 0.00%)  struct ImFontBuildSrcData
      460 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::~ImVector() (2x)
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::~ImBitVector() (2x)
        .           {
        .               stbtt_fontinfo      FontInfo;
        .               stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
        .               stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.
        .               stbtt_packedchar*   PackedChars;        // Output glyphs
        .               const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
        .               int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
        .               int                 GlyphsHighest;      // Highest requested codepoint
-- line 2735 ----------------------------------------
-- line 2743 ----------------------------------------
        .           {
        .               int                 SrcCount;           // Number of source fonts targeting this destination font.
        .               int                 GlyphsHighest;
        .               int                 GlyphsCount;
        .               ImBitVector         GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
        .           };
        .           
        .           static void UnpackBitVectorToFlatIndexList(const ImBitVector* in, ImVector<int>* out)
       10 ( 0.00%)  {
        .               IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
        8 ( 0.00%)      const ImU32* it_begin = in->Storage.begin();
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::begin() const (2x)
        8 ( 0.00%)      const ImU32* it_end = in->Storage.end();
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::end() const (2x)
    7,820 ( 0.00%)      for (const ImU32* it = it_begin; it < it_end; it++)
    9,760 ( 0.00%)          if (ImU32 entries_32 = *it)
    3,100 ( 0.00%)              for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
    5,952 ( 0.00%)                  if (entries_32 & ((ImU32)1 << bit_n))
   11,726 ( 0.00%)                      out->push_back((int)(((it - it_begin) << 5) + bit_n));
   26,158 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::push_back(int const&) (902x)
        8 ( 0.00%)  }
        .           
        .           static bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
        7 ( 0.00%)  {
        4 ( 0.00%)      IM_ASSERT(atlas->ConfigData.Size > 0);
        .           
        3 ( 0.00%)      ImFontAtlasBuildInit(atlas);
      546 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildInit(ImFontAtlas*) (1x)
        .           
        .               // Clear atlas
        2 ( 0.00%)      atlas->TexID = (ImTextureID)NULL;
        6 ( 0.00%)      atlas->TexWidth = atlas->TexHeight = 0;
        9 ( 0.00%)      atlas->TexUvScale = ImVec2(0.0f, 0.0f);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      atlas->ClearTexData();
       26 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::ClearTexData() (1x)
        .           
        .               // Temporary storage for building
        3 ( 0.00%)      ImVector<ImFontBuildSrcData> src_tmp_array;
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::ImVector() (1x)
        3 ( 0.00%)      ImVector<ImFontBuildDstData> dst_tmp_array;
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::ImVector() (1x)
        6 ( 0.00%)      src_tmp_array.resize(atlas->ConfigData.Size);
    2,896 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::resize(int) (1x)
        6 ( 0.00%)      dst_tmp_array.resize(atlas->Fonts.Size);
      188 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::resize(int) (1x)
        9 ( 0.00%)      memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
       50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        8 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::size_in_bytes() const (1x)
        9 ( 0.00%)      memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
       12 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        8 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::size_in_bytes() const (1x)
        .           
        .               // 1. Initialize font loading structure, check font data validity
       16 ( 0.00%)      for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
        .               {
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
       14 ( 0.00%)          ImFontConfig& cfg = atlas->ConfigData[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::operator[](int) (2x)
       22 ( 0.00%)          IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
       18 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFont::IsLoaded() const (2x)
        .           
        .                   // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
        4 ( 0.00%)          src_tmp.DstIndex = -1;
       30 ( 0.00%)          for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
       26 ( 0.00%)              if (cfg.DstFont == atlas->Fonts[output_i])
       38 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::operator[](int) (2x)
        6 ( 0.00%)                  src_tmp.DstIndex = output_i;
        8 ( 0.00%)          if (src_tmp.DstIndex == -1)
        .                   {
        .                       IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
        .                       return false;
        .                   }
        .                   // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
       16 ( 0.00%)          const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
      148 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_GetFontOffsetForIndex (2x)
        4 ( 0.00%)          IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
       22 ( 0.00%)          if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
    5,548 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_InitFont (2x)
        .                   {
        .                       IM_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.");
        .                       return false;
        .                   }
        .           
        .                   // Measure highest codepoints
       14 ( 0.00%)          ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
       38 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::operator[](int) (2x)
       18 ( 0.00%)          src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
       36 ( 0.00%)          for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
        .                   {
        .                       // Check for valid range. This may also help detect *some* dangling pointers, because a common
        .                       // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent.
       14 ( 0.00%)              IM_ASSERT(src_range[0] <= src_range[1]);
       22 ( 0.00%)              src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
       20 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImMax<int>(int, int) (2x)
        .                   }
       10 ( 0.00%)          dst_tmp.SrcCount++;
       18 ( 0.00%)          dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
       20 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImMax<int>(int, int) (2x)
        .               }
        .           
        .               // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
        1 ( 0.00%)      int total_glyphs_count = 0;
       13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        .               {
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
       14 ( 0.00%)          ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
       38 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::operator[](int) (2x)
       16 ( 0.00%)          src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
    8,592 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::Create(int) (2x)
       12 ( 0.00%)          if (dst_tmp.GlyphsSet.Storage.empty())
       18 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::empty() const (2x)
        8 ( 0.00%)              dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
    8,279 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::Create(int) (1x)
        .           
       36 ( 0.00%)          for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
    6,749 ( 0.00%)              for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
        .                       {
    7,688 ( 0.00%)                  if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
   24,986 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::TestBit(int) const (961x)
        .                               continue;
    8,649 ( 0.00%)                  if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
  431,686 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_FindGlyphIndex (961x)
       59 ( 0.00%)                      continue;
        .           
        .                           // Add to avail set/counters
    4,510 ( 0.00%)                  src_tmp.GlyphsCount++;
    4,510 ( 0.00%)                  dst_tmp.GlyphsCount++;
    5,412 ( 0.00%)                  src_tmp.GlyphsSet.SetBit(codepoint);
   41,492 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::SetBit(int) (902x)
    5,412 ( 0.00%)                  dst_tmp.GlyphsSet.SetBit(codepoint);
   41,492 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::SetBit(int) (902x)
    1,804 ( 0.00%)                  total_glyphs_count++;
        .                       }
        .               }
        .           
        .               // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
       13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        .               {
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
       14 ( 0.00%)          src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
      556 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::reserve(int) (2x)
       14 ( 0.00%)          UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
   64,588 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:UnpackBitVectorToFlatIndexList(ImBitVector const*, ImVector<int>*) (2x)
        8 ( 0.00%)          src_tmp.GlyphsSet.Clear();
      508 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::Clear() (2x)
       12 ( 0.00%)          IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
        .               }
        9 ( 0.00%)      for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
        8 ( 0.00%)          dst_tmp_array[dst_i].GlyphsSet.Clear();
      316 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitVector::Clear() (1x)
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::operator[](int) (1x)
        3 ( 0.00%)      dst_tmp_array.clear();
      182 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::clear() (1x)
        .           
        .               // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
        .               // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
        3 ( 0.00%)      ImVector<stbrp_rect> buf_rects;
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::ImVector() (1x)
        3 ( 0.00%)      ImVector<stbtt_packedchar> buf_packedchars;
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbtt_packedchar>::ImVector() (1x)
        5 ( 0.00%)      buf_rects.resize(total_glyphs_count);
      638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::resize(int) (1x)
        5 ( 0.00%)      buf_packedchars.resize(total_glyphs_count);
      511 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbtt_packedchar>::resize(int) (1x)
        9 ( 0.00%)      memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
   21,665 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::size_in_bytes() const (1x)
        9 ( 0.00%)      memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
   25,273 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        8 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbtt_packedchar>::size_in_bytes() const (1x)
        .           
        .               // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
        1 ( 0.00%)      int total_surface = 0;
        1 ( 0.00%)      int buf_rects_out_n = 0;
        1 ( 0.00%)      int buf_packedchars_out_n = 0;
       13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        .               {
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
        8 ( 0.00%)          if (src_tmp.GlyphsCount == 0)
        .                       continue;
        .           
       14 ( 0.00%)          src_tmp.Rects = &buf_rects[buf_rects_out_n];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (2x)
       14 ( 0.00%)          src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbtt_packedchar>::operator[](int) (2x)
        6 ( 0.00%)          buf_rects_out_n += src_tmp.GlyphsCount;
        6 ( 0.00%)          buf_packedchars_out_n += src_tmp.GlyphsCount;
        .           
        .                   // Convert our ranges in the format stb_truetype wants
       14 ( 0.00%)          ImFontConfig& cfg = atlas->ConfigData[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::operator[](int) (2x)
       14 ( 0.00%)          src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
        4 ( 0.00%)          src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
        8 ( 0.00%)          src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
        8 ( 0.00%)          src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
        8 ( 0.00%)          src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
       10 ( 0.00%)          src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
       10 ( 0.00%)          src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
        .           
        .                   // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
       36 ( 0.00%)          const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
      130 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_ScaleForPixelHeight (2x)
        6 ( 0.00%)          const int padding = atlas->TexGlyphPadding;
    4,524 ( 0.00%)          for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
        .                   {
        .                       int x0, y0, x1, y1;
   10,824 ( 0.00%)              const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
  407,787 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_FindGlyphIndex (902x)
   17,138 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::operator[](int) (902x)
    1,804 ( 0.00%)              IM_ASSERT(glyph_index_in_font != 0);
   18,040 ( 0.00%)              stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
  335,889 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBoxSubpixel (902x)
   17,138 ( 0.00%)              src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
   17,138 ( 0.00%)              src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
   19,844 ( 0.00%)              total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
        .                   }
        .               }
        .           
        .               // We need a width for the skyline algorithm, any width!
        .               // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
        .               // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
       12 ( 0.00%)      const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
    1,122 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        8 ( 0.00%)  => ???:sqrtf (1x)
        2 ( 0.00%)      atlas->TexHeight = 0;
        4 ( 0.00%)      if (atlas->TexDesiredWidth > 0)
        .                   atlas->TexWidth = atlas->TexDesiredWidth;
        .               else
       12 ( 0.00%)          atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
        .           
        .               // 5. Start packing
        .               // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
        1 ( 0.00%)      const int TEX_HEIGHT_MAX = 1024 * 32;
        3 ( 0.00%)      stbtt_pack_context spc = {};
       14 ( 0.00%)      stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
   10,379 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_PackBegin (1x)
        5 ( 0.00%)      ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
    2,839 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildPackCustomRects(ImFontAtlas*, void*) (1x)
        .           
        .               // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
       13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        .               {
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
        8 ( 0.00%)          if (src_tmp.GlyphsCount == 0)
        .                       continue;
        .           
       16 ( 0.00%)          stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
5,162,150 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_rectpack.h:stbrp_pack_rects (2x)
        .           
        .                   // Extend texture height and mark missing glyphs as non-packed so we won't render them.
        .                   // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
    4,524 ( 0.00%)          for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
   10,824 ( 0.00%)              if (src_tmp.Rects[glyph_i].was_packed)
   25,256 ( 0.00%)                  atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
    9,914 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImMax<int>(int, int) (902x)
        .               }
        .           
        .               // 7. Allocate texture
       11 ( 0.00%)      atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
       23 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImUpperPowerOfTwo(int) (1x)
       19 ( 0.00%)      atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
       10 ( 0.00%)      atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
      405 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
       12 ( 0.00%)      memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
  262,161 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        3 ( 0.00%)      spc.pixels = atlas->TexPixelsAlpha8;
        3 ( 0.00%)      spc.height = atlas->TexHeight;
        .           
        .               // 8. Render/rasterize font characters into the texture
       13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        .               {
       14 ( 0.00%)          ImFontConfig& cfg = atlas->ConfigData[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::operator[](int) (2x)
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
        8 ( 0.00%)          if (src_tmp.GlyphsCount == 0)
        .                       continue;
        .           
       20 ( 0.00%)          stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
86,531,789 ( 0.07%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_PackFontRangesRenderIntoRects (2x)
        .           
        .                   // Apply multiply operator
       16 ( 0.00%)          if (cfg.RasterizerMultiply != 1.0f)
        .                   {
        .                       unsigned char multiply_table[256];
        .                       ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
        .                       stbrp_rect* r = &src_tmp.Rects[0];
        .                       for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
        .                           if (r->was_packed)
        .                               ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
        .                   }
        6 ( 0.00%)          src_tmp.Rects = NULL;
        .               }
        .           
        .               // End packing
        3 ( 0.00%)      stbtt_PackEnd(&spc);
      457 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_PackEnd (1x)
        3 ( 0.00%)      buf_rects.clear();
      306 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::clear() (1x)
        .           
        .               // 9. Setup ImFont and glyphs for runtime
       13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        .               {
        .                   // When merging fonts with MergeMode=true:
        .                   // - We can have multiple input fonts writing into a same destination font.
        .                   // - dst_font->ConfigData is != from cfg which is our source configuration.
       12 ( 0.00%)          ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::operator[](int) (2x)
       14 ( 0.00%)          ImFontConfig& cfg = atlas->ConfigData[src_i];
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::operator[](int) (2x)
        6 ( 0.00%)          ImFont* dst_font = cfg.DstFont;
        .           
       16 ( 0.00%)          const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
      130 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_ScaleForPixelHeight (2x)
        .                   int unscaled_ascent, unscaled_descent, unscaled_line_gap;
       12 ( 0.00%)          stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
      194 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_GetFontVMetrics (2x)
        .           
       18 ( 0.00%)          const float ascent = ImCeil(unscaled_ascent * font_scale);
        6 ( 0.00%)  => ???:0x00000000000771d0 (2x)
       16 ( 0.00%)          const float descent = ImFloor(unscaled_descent * font_scale);
       40 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2x)
       20 ( 0.00%)          ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
      124 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildSetupFont(ImFontAtlas*, ImFont*, ImFontConfig*, float, float) (2x)
        6 ( 0.00%)          const float font_off_x = cfg.GlyphOffset.x;
       20 ( 0.00%)          const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
        .           
       10 ( 0.00%)          const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;
        .           
    4,522 ( 0.00%)          for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
        .                   {
        .                       // Register glyph
    7,216 ( 0.00%)              const int codepoint = src_tmp.GlyphsList[glyph_i];
   17,138 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::operator[](int) (902x)
    9,020 ( 0.00%)              const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
        .                       stbtt_aligned_quad q;
    3,608 ( 0.00%)              float unused_x = 0.0f, unused_y = 0.0f;
   13,530 ( 0.00%)              stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
   85,690 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_GetPackedQuad (902x)
    4,510 ( 0.00%)              float x0 = q.x0 * inv_rasterization_scale + font_off_x;
    4,510 ( 0.00%)              float y0 = q.y0 * inv_rasterization_scale + font_off_y;
    4,510 ( 0.00%)              float x1 = q.x1 * inv_rasterization_scale + font_off_x;
    4,510 ( 0.00%)              float y1 = q.y1 * inv_rasterization_scale + font_off_y;
   20,746 ( 0.00%)              dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
  279,751 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::AddGlyph(ImFontConfig const*, unsigned short, float, float, float, float, float, float, float, float, float) (902x)
        .                   }
        .               }
        .           
        .               // Cleanup
        3 ( 0.00%)      src_tmp_array.clear_destruct();
      874 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::clear_destruct() (1x)
        .           
        3 ( 0.00%)      ImFontAtlasBuildFinish(atlas);
5,860,841 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildFinish(ImFontAtlas*) (1x)
        1 ( 0.00%)      return true;
       19 ( 0.00%)  }
      298 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbtt_packedchar>::~ImVector() (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::~ImVector() (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildDstData>::~ImVector() (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::~ImVector() (1x)
        .           
        .           const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype()
        2 ( 0.00%)  {
        .               static ImFontBuilderIO io;
        1 ( 0.00%)      io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
        1 ( 0.00%)      return &io;
        2 ( 0.00%)  }
        .           
        .           #endif // IMGUI_ENABLE_STB_TRUETYPE
        .           
        .           void ImFontAtlasUpdateConfigDataPointers(ImFontAtlas* atlas)
        8 ( 0.00%)  {
       48 ( 0.00%)      for (ImFontConfig& font_cfg : atlas->ConfigData)
       30 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::end() (2x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::begin() (2x)
        .               {
        9 ( 0.00%)          ImFont* font = font_cfg.DstFont;
       15 ( 0.00%)          if (!font_cfg.MergeMode)
        .                   {
        6 ( 0.00%)              font->ConfigData = &font_cfg;
        4 ( 0.00%)              font->ConfigDataCount = 0;
        .                   }
       18 ( 0.00%)          font->ConfigDataCount++;
        .               }
        8 ( 0.00%)  }
        .           
        .           void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
       16 ( 0.00%)  {
       10 ( 0.00%)      if (!font_config->MergeMode)
        .               {
        3 ( 0.00%)          font->ClearOutputData();
       72 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::ClearOutputData() (1x)
        4 ( 0.00%)          font->FontSize = font_config->SizePixels;
        4 ( 0.00%)          IM_ASSERT(font->ConfigData == font_config);
        3 ( 0.00%)          font->ContainerAtlas = atlas;
        3 ( 0.00%)          font->Ascent = ascent;
        3 ( 0.00%)          font->Descent = descent;
        .               }
        6 ( 0.00%)  }
        .           
        .           void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)
        6 ( 0.00%)  {
        2 ( 0.00%)      stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
        2 ( 0.00%)      IM_ASSERT(pack_context != NULL);
        .           
        3 ( 0.00%)      ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
        4 ( 0.00%)      IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
        .           #ifdef __GNUC__
        3 ( 0.00%)      if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
        .           #endif
        .           
        3 ( 0.00%)      ImVector<stbrp_rect> pack_rects;
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::ImVector() (1x)
        6 ( 0.00%)      pack_rects.resize(user_rects.Size);
      191 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::resize(int) (1x)
        9 ( 0.00%)      memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
       12 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::size_in_bytes() const (1x)
       16 ( 0.00%)      for (int i = 0; i < user_rects.Size; i++)
        .               {
       26 ( 0.00%)          pack_rects[i].w = user_rects[i].Width;
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (2x)
       38 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (2x)
       26 ( 0.00%)          pack_rects[i].h = user_rects[i].Height;
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (2x)
       38 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (2x)
        .               }
       11 ( 0.00%)      stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
    1,462 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_rectpack.h:stbrp_pack_rects (1x)
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (1x)
       13 ( 0.00%)      for (int i = 0; i < pack_rects.Size; i++)
       20 ( 0.00%)          if (pack_rects[i].was_packed)
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (2x)
        .                   {
       26 ( 0.00%)              user_rects[i].X = (unsigned short)pack_rects[i].x;
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (2x)
       38 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (2x)
       26 ( 0.00%)              user_rects[i].Y = (unsigned short)pack_rects[i].y;
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (2x)
       38 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (2x)
       60 ( 0.00%)              IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
       88 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (4x)
       76 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (4x)
       40 ( 0.00%)              atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
       88 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::operator[](int) (4x)
       20 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImMax<int>(int, int) (2x)
        .                   }
        7 ( 0.00%)  }
      174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::~ImVector() (1x)
        .           
        .           void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value)
       26 ( 0.00%)  {
       18 ( 0.00%)      IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
       18 ( 0.00%)      IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
       22 ( 0.00%)      unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
      604 ( 0.00%)      for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
   26,622 ( 0.00%)          for (int off_x = 0; off_x < w; off_x++)
   86,768 ( 0.00%)              out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
        8 ( 0.00%)  }
        .           
        .           void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value)
        .           {
        .               IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
        .               IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
        .               unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);
        .               for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
        .                   for (int off_x = 0; off_x < w; off_x++)
        .                       out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;
        .           }
        .           
        .           static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
        4 ( 0.00%)  {
        7 ( 0.00%)      ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
       34 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFontAtlas::GetCustomRectByIndex(int) (1x)
        5 ( 0.00%)      IM_ASSERT(r->IsPacked());
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFontAtlasCustomRect::IsPacked() const (1x)
        .           
        3 ( 0.00%)      const int w = atlas->TexWidth;
        5 ( 0.00%)      if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        .               {
        .                   // Render/copy pixels
        8 ( 0.00%)          IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
        4 ( 0.00%)          const int x_for_white = r->X;
        5 ( 0.00%)          const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
        4 ( 0.00%)          if (atlas->TexPixelsAlpha8 != NULL)
        .                   {
       13 ( 0.00%)              ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
   57,062 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas*, int, int, int, int, char const*, char, unsigned char) (1x)
       14 ( 0.00%)              ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
   57,024 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas*, int, int, int, int, char const*, char, unsigned char) (1x)
        .                   }
        .                   else
        .                   {
        .                       ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
        .                       ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
        .                   }
        .               }
        .               else
-- line 3134 ----------------------------------------
-- line 3140 ----------------------------------------
        .                   {
        .                       atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
        .                   }
        .                   else
        .                   {
        .                       atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
        .                   }
        .               }
       27 ( 0.00%)      atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)  }
        .           
        .           static void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas* atlas)
        5 ( 0.00%)  {
        5 ( 0.00%)      if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
        .                   return;
        .           
        .               // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
        7 ( 0.00%)      ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
       34 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFontAtlas::GetCustomRectByIndex(int) (1x)
        5 ( 0.00%)      IM_ASSERT(r->IsPacked());
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFontAtlasCustomRect::IsPacked() const (1x)
      197 ( 0.00%)      for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
        .               {
        .                   // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
      128 ( 0.00%)          unsigned int y = n;
      128 ( 0.00%)          unsigned int line_width = n;
      384 ( 0.00%)          unsigned int pad_left = (r->Width - line_width) / 2;
      512 ( 0.00%)          unsigned int pad_right = r->Width - (pad_left + line_width);
        .           
        .                   // Write each slice
      960 ( 0.00%)          IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
      256 ( 0.00%)          if (atlas->TexPixelsAlpha8 != NULL)
        .                   {
    1,088 ( 0.00%)              unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
    4,544 ( 0.00%)              for (unsigned int i = 0; i < pad_left; i++)
    4,224 ( 0.00%)                  *(write_ptr + i) = 0x00;
        .           
    8,384 ( 0.00%)              for (unsigned int i = 0; i < line_width; i++)
   12,096 ( 0.00%)                  *(write_ptr + pad_left + i) = 0xFF;
        .           
    4,736 ( 0.00%)              for (unsigned int i = 0; i < pad_right; i++)
    8,704 ( 0.00%)                  *(write_ptr + pad_left + line_width + i) = 0x00;
        .                   }
        .                   else
        .                   {
        .                       unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
        .                       for (unsigned int i = 0; i < pad_left; i++)
        .                           *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
        .           
        .                       for (unsigned int i = 0; i < line_width; i++)
        .                           *(write_ptr + pad_left + i) = IM_COL32_WHITE;
        .           
        .                       for (unsigned int i = 0; i < pad_right; i++)
        .                           *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
        .                   }
        .           
        .                   // Calculate UVs for this line
    2,240 ( 0.00%)          ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
    2,496 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, ImVec2 const&) (64x)
      896 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (64x)
    2,432 ( 0.00%)          ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
    2,496 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, ImVec2 const&) (64x)
      896 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (64x)
      384 ( 0.00%)          float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
    1,280 ( 0.00%)          atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
    1,408 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (64x)
        .               }
        3 ( 0.00%)  }
        .           
        .           // Note: this is called / shared by both the stb_truetype and the FreeType builder
        .           void ImFontAtlasBuildInit(ImFontAtlas* atlas)
        4 ( 0.00%)  {
        .               // Round font size
        .               // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
        .               // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
        .               // - We may support it better later and remove this rounding.
       27 ( 0.00%)      for (ImFontConfig& cfg : atlas->ConfigData)
       15 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::end() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontConfig>::begin() (1x)
       14 ( 0.00%)         cfg.SizePixels = ImTrunc(cfg.SizePixels);
       16 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(float) (2x)
        .           
        .               // Register texture region for mouse cursors or standard white pixels
        4 ( 0.00%)      if (atlas->PackIdMouseCursors < 0)
        .               {
        5 ( 0.00%)          if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        8 ( 0.00%)              atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
      301 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddCustomRectRegular(int, int) (1x)
        .                   else
        .                       atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
        .               }
        .           
        .               // Register texture region for thick lines
        .               // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
        4 ( 0.00%)      if (atlas->PackIdLines < 0)
        .               {
        5 ( 0.00%)          if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
        7 ( 0.00%)              atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
      126 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddCustomRectRegular(int, int) (1x)
        .               }
        3 ( 0.00%)  }
        .           
        .           // This is called/shared by both the stb_truetype and the FreeType builder.
        .           void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
        4 ( 0.00%)  {
        .               // Render into our custom data blocks
        4 ( 0.00%)      IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
        3 ( 0.00%)      ImFontAtlasBuildRenderDefaultTexData(atlas);
  114,245 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas*) (1x)
        3 ( 0.00%)      ImFontAtlasBuildRenderLinesTexData(atlas);
   60,937 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildRenderLinesTexData(ImFontAtlas*) (1x)
        .           
        .               // Register custom rectangle glyphs
       16 ( 0.00%)      for (int i = 0; i < atlas->CustomRects.Size; i++)
        .               {
       14 ( 0.00%)          const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
       38 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (2x)
        8 ( 0.00%)          if (r->Font == NULL || r->GlyphID == 0)
        2 ( 0.00%)              continue;
        .           
        .                   // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
        .                   IM_ASSERT(r->Font->ContainerAtlas == atlas);
        .                   ImVec2 uv0, uv1;
        .                   atlas->CalcCustomRectUV(r, &uv0, &uv1);
        .                   r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
        .               }
        .           
        .               // Build all fonts lookup tables
       22 ( 0.00%)      for (ImFont* font : atlas->Fonts)
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::end() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFont*>::begin() (1x)
        4 ( 0.00%)          if (font->DirtyLookupTables)
        3 ( 0.00%)              font->BuildLookupTable();
5,685,514 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::BuildLookupTable() (1x)
        .           
        2 ( 0.00%)      atlas->TexReady = true;
        3 ( 0.00%)  }
        .           
        .           // Retrieve list of range (2 int per range, values are inclusive)
        .           const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
        3 ( 0.00%)  {
        .               static const ImWchar ranges[] =
        .               {
        .                   0x0020, 0x00FF, // Basic Latin + Latin Supplement
        .                   0,
        .               };
        1 ( 0.00%)      return &ranges[0];
        2 ( 0.00%)  }
        .           
        .           const ImWchar*   ImFontAtlas::GetGlyphRangesGreek()
        .           {
        .               static const ImWchar ranges[] =
        .               {
        .                   0x0020, 0x00FF, // Basic Latin + Latin Supplement
        .                   0x0370, 0x03FF, // Greek and Coptic
        .                   0,
-- line 3277 ----------------------------------------
-- line 3559 ----------------------------------------
        .                   }
        .               out_ranges->push_back(0);
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImFont
        .           //-----------------------------------------------------------------------------
        .           
       30 ( 0.00%)  ImFont::ImFont()
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::ImVector() (2x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::ImVector() (2x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::ImVector() (2x)
        .           {
        6 ( 0.00%)      FontSize = 0.0f;
        6 ( 0.00%)      FallbackAdvanceX = 0.0f;
        4 ( 0.00%)      FallbackChar = (ImWchar)-1;
        4 ( 0.00%)      EllipsisChar = (ImWchar)-1;
       14 ( 0.00%)      EllipsisWidth = EllipsisCharStep = 0.0f;
        4 ( 0.00%)      EllipsisCharCount = 0;
        4 ( 0.00%)      FallbackGlyph = NULL;
        4 ( 0.00%)      ContainerAtlas = NULL;
        4 ( 0.00%)      ConfigData = NULL;
        4 ( 0.00%)      ConfigDataCount = 0;
        4 ( 0.00%)      DirtyLookupTables = false;
        6 ( 0.00%)      Scale = 1.0f;
       14 ( 0.00%)      Ascent = Descent = 0.0f;
        4 ( 0.00%)      MetricsTotalSurface = 0;
       14 ( 0.00%)      memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
       36 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2x)
        6 ( 0.00%)  }
        .           
        .           ImFont::~ImFont()
        .           {
        .               ClearOutputData();
        .           }
        .           
        .           void    ImFont::ClearOutputData()
        4 ( 0.00%)  {
        3 ( 0.00%)      FontSize = 0.0f;
        3 ( 0.00%)      FallbackAdvanceX = 0.0f;
        4 ( 0.00%)      Glyphs.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::clear() (1x)
        3 ( 0.00%)      IndexAdvanceX.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::clear() (1x)
        4 ( 0.00%)      IndexLookup.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::clear() (1x)
        2 ( 0.00%)      FallbackGlyph = NULL;
        2 ( 0.00%)      ContainerAtlas = NULL;
        2 ( 0.00%)      DirtyLookupTables = true;
        7 ( 0.00%)      Ascent = Descent = 0.0f;
        2 ( 0.00%)      MetricsTotalSurface = 0;
        3 ( 0.00%)  }
        .           
        .           static ImWchar FindFirstExistingGlyph(ImFont* font, const ImWchar* candidate_chars, int candidate_chars_count)
       12 ( 0.00%)  {
       14 ( 0.00%)      for (int n = 0; n < candidate_chars_count; n++)
       45 ( 0.00%)          if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
       75 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyphNoFallback(unsigned short) const (3x)
       14 ( 0.00%)              return candidate_chars[n];
        .               return (ImWchar)-1;
        4 ( 0.00%)  }
        .           
        .           void ImFont::BuildLookupTable()
        5 ( 0.00%)  {
        1 ( 0.00%)      int max_codepoint = 0;
    4,516 ( 0.00%)      for (int i = 0; i != Glyphs.Size; i++)
   12,628 ( 0.00%)          max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
   19,844 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::operator[](int) (902x)
    9,020 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImMax<int>(int, int) (902x)
        .           
        .               // Build lookup table
        4 ( 0.00%)      IM_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
        4 ( 0.00%)      IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
        3 ( 0.00%)      IndexAdvanceX.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::clear() (1x)
        4 ( 0.00%)      IndexLookup.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::clear() (1x)
        2 ( 0.00%)      DirtyLookupTables = false;
        7 ( 0.00%)      memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
       18 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        6 ( 0.00%)      GrowIndex(max_codepoint + 1);
1,617,886 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::GrowIndex(int) (1x)
    4,516 ( 0.00%)      for (int i = 0; i < Glyphs.Size; i++)
        .               {
    8,118 ( 0.00%)          int codepoint = (int)Glyphs[i].Codepoint;
   19,844 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::operator[](int) (902x)
   13,530 ( 0.00%)          IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
   17,138 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::operator[](int) (902x)
   19,844 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::operator[](int) (902x)
    8,118 ( 0.00%)          IndexLookup[codepoint] = (ImWchar)i;
   17,138 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::operator[](int) (902x)
        .           
        .                   // Mark 4K page as used
    5,412 ( 0.00%)          const int page_n = codepoint / 4096;
   16,236 ( 0.00%)          Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
        .               }
        .           
        .               // Create a glyph to handle TAB
        .               // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
        8 ( 0.00%)      if (FindGlyph((ImWchar)' '))
       30 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyph(unsigned short) const (1x)
        .               {
       10 ( 0.00%)          if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::back() (1x)
        8 ( 0.00%)              Glyphs.resize(Glyphs.Size + 1);
       15 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::resize(int) (1x)
        5 ( 0.00%)          ImFontGlyph& tab_glyph = Glyphs.back();
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::back() (1x)
        9 ( 0.00%)          tab_glyph = *FindGlyph((ImWchar)' ');
       30 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyph(unsigned short) const (1x)
        5 ( 0.00%)          tab_glyph.Codepoint = '\t';
        6 ( 0.00%)          tab_glyph.AdvanceX *= IM_TABSIZE;
       12 ( 0.00%)          IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::operator[](int) (1x)
       12 ( 0.00%)          IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::operator[](int) (1x)
        .               }
        .           
        .               // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
        5 ( 0.00%)      SetGlyphVisible((ImWchar)' ', false);
       60 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::SetGlyphVisible(unsigned short, bool) (1x)
        5 ( 0.00%)      SetGlyphVisible((ImWchar)'\t', false);
       60 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::SetGlyphVisible(unsigned short, bool) (1x)
        .           
        .               // Setup Fallback character
        3 ( 0.00%)      const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
        9 ( 0.00%)      FallbackGlyph = FindGlyphNoFallback(FallbackChar);
       15 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyphNoFallback(unsigned short) const (1x)
        4 ( 0.00%)      if (FallbackGlyph == NULL)
        .               {
        8 ( 0.00%)          FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
       99 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:FindFirstExistingGlyph(ImFont*, unsigned short const*, int) (1x)
        9 ( 0.00%)          FallbackGlyph = FindGlyphNoFallback(FallbackChar);
       30 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyphNoFallback(unsigned short) const (1x)
        4 ( 0.00%)          if (FallbackGlyph == NULL)
        .                   {
        .                       FallbackGlyph = &Glyphs.back();
        .                       FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
        .                   }
        .               }
        5 ( 0.00%)      FallbackAdvanceX = FallbackGlyph->AdvanceX;
  248,713 ( 0.00%)      for (int i = 0; i < max_codepoint + 1; i++)
  683,947 ( 0.00%)          if (IndexAdvanceX[i] < 0.0f)
1,181,363 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::operator[](int) (62,177x)
  612,740 ( 0.00%)              IndexAdvanceX[i] = FallbackAdvanceX;
1,164,206 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::operator[](int) (61,274x)
        .           
        .               // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
        .               // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
        .               // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
        2 ( 0.00%)      const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
        2 ( 0.00%)      const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
        4 ( 0.00%)      if (EllipsisChar == (ImWchar)-1)
        .                   EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
        7 ( 0.00%)      const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
       65 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:FindFirstExistingGlyph(ImFont*, unsigned short const*, int) (1x)
        4 ( 0.00%)      if (EllipsisChar != (ImWchar)-1)
        .               {
        2 ( 0.00%)          EllipsisCharCount = 1;
       14 ( 0.00%)          EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
       30 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyph(unsigned short) const (1x)
        .               }
        .               else if (dot_char != (ImWchar)-1)
        .               {
        .                   const ImFontGlyph* glyph = FindGlyph(dot_char);
        .                   EllipsisChar = dot_char;
        .                   EllipsisCharCount = 3;
        .                   EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
        .                   EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
        .               }
        5 ( 0.00%)  }
        .           
        .           // API is designed this way to avoid exposing the 4K page size
        .           // e.g. use with IsGlyphRangeUnused(0, 255)
        .           bool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last)
        .           {
        .               unsigned int page_begin = (c_begin / 4096);
        .               unsigned int page_last = (c_last / 4096);
        .               for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)
        .                   if ((page_n >> 3) < sizeof(Used4kPagesMap))
        .                       if (Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7)))
        .                           return false;
        .               return true;
        .           }
        .           
        .           void ImFont::SetGlyphVisible(ImWchar c, bool visible)
       18 ( 0.00%)  {
       16 ( 0.00%)      if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
       60 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyph(unsigned short) const (2x)
       20 ( 0.00%)          glyph->Visible = visible ? 1 : 0;
        6 ( 0.00%)  }
        .           
        .           void ImFont::GrowIndex(int new_size)
        5 ( 0.00%)  {
        6 ( 0.00%)      IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
        4 ( 0.00%)      if (new_size <= IndexLookup.Size)
        .                   return;
        8 ( 0.00%)      IndexAdvanceX.resize(new_size, -1.0f);
  809,027 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::resize(int, float const&) (1x)
        9 ( 0.00%)      IndexLookup.resize(new_size, (ImWchar)-1);
  808,825 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int, unsigned short const&) (1x)
        2 ( 0.00%)  }
        .           
        .           // x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
        .           // Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
        .           // 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.
        .           void ImFont::AddGlyph(const ImFontConfig* cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
   13,530 ( 0.00%)  {
    1,804 ( 0.00%)      if (cfg != NULL)
        .               {
        .                   // Clamp & recenter if needed
    1,804 ( 0.00%)          const float advance_x_original = advance_x;
    9,922 ( 0.00%)          advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
   11,430 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImClamp<float>(float, float, float) (902x)
    5,412 ( 0.00%)          if (advance_x != advance_x_original)
        .                   {
    8,386 ( 0.00%)              float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
    4,792 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(float) (599x)
    1,797 ( 0.00%)              x0 += char_off_x;
    1,797 ( 0.00%)              x1 += char_off_x;
        .                   }
        .           
        .                   // Snap to pixel
    3,608 ( 0.00%)          if (cfg->PixelSnapH)
    5,412 ( 0.00%)              advance_x = IM_ROUND(advance_x);
        .           
        .                   // Bake spacing
    4,510 ( 0.00%)          advance_x += cfg->GlyphExtraSpacing.x;
        .               }
        .           
    7,216 ( 0.00%)      Glyphs.resize(Glyphs.Size + 1);
   82,942 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::resize(int) (902x)
    4,510 ( 0.00%)      ImFontGlyph& glyph = Glyphs.back();
   18,942 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImFontGlyph>::back() (902x)
    7,216 ( 0.00%)      glyph.Codepoint = (unsigned int)codepoint;
   18,875 ( 0.00%)      glyph.Visible = (x0 != x1) && (y0 != y1);
    3,608 ( 0.00%)      glyph.Colored = false;
    2,706 ( 0.00%)      glyph.X0 = x0;
    2,706 ( 0.00%)      glyph.Y0 = y0;
    2,706 ( 0.00%)      glyph.X1 = x1;
    2,706 ( 0.00%)      glyph.Y1 = y1;
    2,706 ( 0.00%)      glyph.U0 = u0;
    2,706 ( 0.00%)      glyph.V0 = v0;
    2,706 ( 0.00%)      glyph.U1 = u1;
    2,706 ( 0.00%)      glyph.V1 = v1;
    2,706 ( 0.00%)      glyph.AdvanceX = advance_x;
        .           
        .               // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
        .               // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
    6,314 ( 0.00%)      float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
    1,804 ( 0.00%)      DirtyLookupTables = true;
   27,060 ( 0.00%)      MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
    2,706 ( 0.00%)  }
        .           
        .           void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
        .           {
        .               IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
        .               unsigned int index_size = (unsigned int)IndexLookup.Size;
        .           
        .               if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
        .                   return;
-- line 3778 ----------------------------------------
-- line 3780 ----------------------------------------
        .                   return;
        .           
        .               GrowIndex(dst + 1);
        .               IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
        .               IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
        .           }
        .           
        .           const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
  114,985 ( 0.00%)  {
  137,982 ( 0.00%)      if (c >= (size_t)IndexLookup.Size)
        .                   return FallbackGlyph;
  160,979 ( 0.00%)      const ImWchar i = IndexLookup.Data[c];
   45,994 ( 0.00%)      if (i == (ImWchar)-1)
        .                   return FallbackGlyph;
  183,976 ( 0.00%)      return &Glyphs.Data[i];
   45,994 ( 0.00%)  }
        .           
        .           const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
       25 ( 0.00%)  {
       30 ( 0.00%)      if (c >= (size_t)IndexLookup.Size)
        4 ( 0.00%)          return NULL;
       21 ( 0.00%)      const ImWchar i = IndexLookup.Data[c];
        6 ( 0.00%)      if (i == (ImWchar)-1)
        .                   return NULL;
       24 ( 0.00%)      return &Glyphs.Data[i];
       10 ( 0.00%)  }
        .           
        .           // Wrapping skips upcoming blanks
        .           static inline const char* CalcWordWrapNextLineStartA(const char* text, const char* text_end)
        .           {
        .               while (text < text_end && ImCharIsBlankA(*text))
        .                   text++;
        .               if (*text == '\n')
        .                   text++;
-- line 3813 ----------------------------------------
-- line 3911 ----------------------------------------
        .               // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
        .               // +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
        .               if (s == text && text < text_end)
        .                   return s + 1;
        .               return s;
        .           }
        .           
        .           ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
   28,220 ( 0.00%)  {
    5,644 ( 0.00%)      if (!text_end)
        .                   text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
        .           
    5,644 ( 0.00%)      const float line_height = size;
   14,110 ( 0.00%)      const float scale = size / FontSize;
        .           
   11,288 ( 0.00%)      ImVec2 text_size = ImVec2(0, 0);
    5,644 ( 0.00%)      float line_width = 0.0f;
        .           
   14,110 ( 0.00%)      const bool word_wrap_enabled = (wrap_width > 0.0f);
    2,822 ( 0.00%)      const char* word_wrap_eol = NULL;
        .           
    5,644 ( 0.00%)      const char* s = text_begin;
   80,264 ( 0.00%)      while (s < text_end)
        .               {
   45,984 ( 0.00%)          if (word_wrap_enabled)
        .                   {
        .                       // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
        .                       if (!word_wrap_eol)
        .                           word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
        .           
        .                       if (s >= word_wrap_eol)
        .                       {
        .                           if (text_size.x < line_width)
-- line 3943 ----------------------------------------
-- line 3946 ----------------------------------------
        .                           line_width = 0.0f;
        .                           word_wrap_eol = NULL;
        .                           s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
        .                           continue;
        .                       }
        .                   }
        .           
        .                   // Decode and advance source
   45,984 ( 0.00%)          const char* prev_s = s;
   91,968 ( 0.00%)          unsigned int c = (unsigned int)*s;
   68,976 ( 0.00%)          if (c < 0x80)
   45,984 ( 0.00%)              s += 1;
        .                   else
        .                       s += ImTextCharFromUtf8(&c, s, text_end);
        .           
   68,976 ( 0.00%)          if (c < 32)
        .                   {
        .                       if (c == '\n')
        .                       {
        .                           text_size.x = ImMax(text_size.x, line_width);
        .                           text_size.y += line_height;
        .                           line_width = 0.0f;
        .                           continue;
        .                       }
        .                       if (c == '\r')
        .                           continue;
        .                   }
        .           
  344,880 ( 0.00%)          const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
   91,968 ( 0.00%)          if (line_width + char_width >= max_width)
        .                   {
        .                       s = prev_s;
        .                       break;
        .                   }
        .           
   91,968 ( 0.00%)          line_width += char_width;
        .               }
        .           
   11,288 ( 0.00%)      if (text_size.x < line_width)
    5,644 ( 0.00%)          text_size.x = line_width;
        .           
   11,288 ( 0.00%)      if (line_width > 0 || text_size.y == 0.0f)
    8,466 ( 0.00%)          text_size.y += line_height;
        .           
    5,644 ( 0.00%)      if (remaining)
        .                   *remaining = s;
        .           
    2,822 ( 0.00%)      return text_size;
    8,466 ( 0.00%)  }
        .           
        .           // Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
        .           void ImFont::RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const
        .           {
        .               const ImFontGlyph* glyph = FindGlyph(c);
        .               if (!glyph || !glyph->Visible)
        .                   return;
        .               if (glyph->Colored)
-- line 4002 ----------------------------------------
-- line 4005 ----------------------------------------
        .               float x = IM_TRUNC(pos.x);
        .               float y = IM_TRUNC(pos.y);
        .               draw_list->PrimReserve(6, 4);
        .               draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
        .           }
        .           
        .           // Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
        .           void ImFont::RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
   36,686 ( 0.00%)  {
    5,644 ( 0.00%)      if (!text_end)
        .                   text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
        .           
        .               // Align to be pixel perfect
   14,110 ( 0.00%)      float x = IM_TRUNC(pos.x);
   14,110 ( 0.00%)      float y = IM_TRUNC(pos.y);
   14,110 ( 0.00%)      if (y > clip_rect.w)
        .                   return;
        .           
    5,644 ( 0.00%)      const float start_x = x;
   14,110 ( 0.00%)      const float scale = size / FontSize;
   14,110 ( 0.00%)      const float line_height = FontSize * scale;
   14,110 ( 0.00%)      const bool word_wrap_enabled = (wrap_width > 0.0f);
        .           
        .               // Fast-forward to first visible line
    5,644 ( 0.00%)      const char* s = text_begin;
   16,932 ( 0.00%)      if (y + line_height < clip_rect.y)
        .                   while (y + line_height < clip_rect.y && s < text_end)
        .                   {
        .                       const char* line_end = (const char*)memchr(s, '\n', text_end - s);
        .                       if (word_wrap_enabled)
        .                       {
        .                           // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
        .                           // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
        .                           // However it is still better than nothing performing the fast-forward!
-- line 4038 ----------------------------------------
-- line 4043 ----------------------------------------
        .                       {
        .                           s = line_end ? line_end + 1 : text_end;
        .                       }
        .                       y += line_height;
        .                   }
        .           
        .               // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
        .               // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
   11,288 ( 0.00%)      if (text_end - s > 10000 && !word_wrap_enabled)
        .               {
        .                   const char* s_end = s;
        .                   float y_end = y;
        .                   while (y_end < clip_rect.w && s_end < text_end)
        .                   {
        .                       s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
        .                       s_end = s_end ? s_end + 1 : text_end;
        .                       y_end += line_height;
        .                   }
        .                   text_end = s_end;
        .               }
    8,466 ( 0.00%)      if (s == text_end)
        .                   return;
        .           
        .               // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
   11,288 ( 0.00%)      const int vtx_count_max = (int)(text_end - s) * 4;
   22,576 ( 0.00%)      const int idx_count_max = (int)(text_end - s) * 6;
   14,110 ( 0.00%)      const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
   16,932 ( 0.00%)      draw_list->PrimReserve(idx_count_max, vtx_count_max);
  301,731 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (2,822x)
    8,466 ( 0.00%)      ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
    8,466 ( 0.00%)      ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
    8,466 ( 0.00%)      unsigned int vtx_index = draw_list->_VtxCurrentIdx;
        .           
    8,466 ( 0.00%)      const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
    2,822 ( 0.00%)      const char* word_wrap_eol = NULL;
        .           
   83,086 ( 0.00%)      while (s < text_end)
        .               {
   45,984 ( 0.00%)          if (word_wrap_enabled)
        .                   {
        .                       // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
        .                       if (!word_wrap_eol)
        .                           word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
        .           
        .                       if (s >= word_wrap_eol)
        .                       {
        .                           x = start_x;
-- line 4088 ----------------------------------------
-- line 4091 ----------------------------------------
        .                               break; // break out of main loop
        .                           word_wrap_eol = NULL;
        .                           s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
        .                           continue;
        .                       }
        .                   }
        .           
        .                   // Decode and advance source
   91,968 ( 0.00%)          unsigned int c = (unsigned int)*s;
   68,976 ( 0.00%)          if (c < 0x80)
   45,984 ( 0.00%)              s += 1;
        .                   else
        .                       s += ImTextCharFromUtf8(&c, s, text_end);
        .           
   68,976 ( 0.00%)          if (c < 32)
        .                   {
        .                       if (c == '\n')
        .                       {
        .                           x = start_x;
        .                           y += line_height;
        .                           if (y > clip_rect.w)
        .                               break; // break out of main loop
        .                           continue;
        .                       }
        .                       if (c == '\r')
        .                           continue;
        .                   }
        .           
  160,944 ( 0.00%)          const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
  689,760 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::FindGlyph(unsigned short) const (22,992x)
   45,984 ( 0.00%)          if (glyph == NULL)
        .                       continue;
        .           
  114,960 ( 0.00%)          float char_width = glyph->AdvanceX * scale;
  114,960 ( 0.00%)          if (glyph->Visible)
        .                   {
        .                       // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
  137,946 ( 0.00%)              float x1 = x + glyph->X0 * scale;
  137,946 ( 0.00%)              float x2 = x + glyph->X1 * scale;
  137,946 ( 0.00%)              float y1 = y + glyph->Y0 * scale;
  137,946 ( 0.00%)              float y2 = y + glyph->Y1 * scale;
  206,819 ( 0.00%)              if (x1 <= clip_rect.z && x2 >= clip_rect.x)
        .                       {
        .                           // Render a character
   68,913 ( 0.00%)                  float u1 = glyph->U0;
   68,913 ( 0.00%)                  float v1 = glyph->V0;
   68,913 ( 0.00%)                  float u2 = glyph->U1;
   68,913 ( 0.00%)                  float v2 = glyph->V1;
        .           
        .                           // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
   45,942 ( 0.00%)                  if (cpu_fine_clip)
        .                           {
        .                               if (x1 < clip_rect.x)
        .                               {
        .                                   u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
        .                                   x1 = clip_rect.x;
        .                               }
        .                               if (y1 < clip_rect.y)
        .                               {
-- line 4148 ----------------------------------------
-- line 4162 ----------------------------------------
        .                               if (y1 >= y2)
        .                               {
        .                                   x += char_width;
        .                                   continue;
        .                               }
        .                           }
        .           
        .                           // Support for untinted glyphs
  206,739 ( 0.00%)                  ImU32 glyph_col = glyph->Colored ? col_untinted : col;
        .           
        .                           // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
        .                           {
  344,565 ( 0.00%)                      vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
  459,420 ( 0.00%)                      vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
  459,420 ( 0.00%)                      vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
  459,420 ( 0.00%)                      vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
  367,536 ( 0.00%)                      idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
  367,536 ( 0.00%)                      idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
   22,971 ( 0.00%)                      vtx_write += 4;
   22,971 ( 0.00%)                      vtx_index += 4;
   22,971 ( 0.00%)                      idx_write += 6;
        .                           }
        .                       }
        .                   }
   91,968 ( 0.00%)          x += char_width;
        .               }
        .           
        .               // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
   28,220 ( 0.00%)      draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
   25,398 ( 0.00%)      draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
   42,330 ( 0.00%)      draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
   62,084 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::operator[](int) (2,822x)
    8,466 ( 0.00%)      draw_list->_VtxWritePtr = vtx_write;
    8,466 ( 0.00%)      draw_list->_IdxWritePtr = idx_write;
   11,288 ( 0.00%)      draw_list->_VtxCurrentIdx = vtx_index;
    5,644 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImGui Internal Render Helpers
        .           //-----------------------------------------------------------------------------
        .           // Vaguely redesigned to stop accessing ImGui global state:
        .           // - RenderArrow()
        .           // - RenderBullet()
        .           // - RenderCheckMark()
-- line 4204 ----------------------------------------
-- line 4208 ----------------------------------------
        .           // - RenderRectFilledWithHole()
        .           //-----------------------------------------------------------------------------
        .           // Function in need of a redesign (legacy mess)
        .           // - RenderColorRectWithAlphaCheckerboard()
        .           //-----------------------------------------------------------------------------
        .           
        .           // Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
        .           void ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)
    3,636 ( 0.00%)  {
    1,616 ( 0.00%)      const float h = draw_list->_Data->FontSize * 1.00f;
    2,424 ( 0.00%)      float r = h * 0.40f * scale;
    8,080 ( 0.00%)      ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
   15,756 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
        .           
    4,848 ( 0.00%)      ImVec2 a, b, c;
    3,232 ( 0.00%)      switch (dir)
        .               {
        .               case ImGuiDir_Up:
        .               case ImGuiDir_Down:
      808 ( 0.00%)          if (dir == ImGuiDir_Up) r = -r;
    5,252 ( 0.00%)          a = ImVec2(+0.000f, +0.750f) * r;
   13,736 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
    5,252 ( 0.00%)          b = ImVec2(-0.866f, -0.750f) * r;
   13,736 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
    5,252 ( 0.00%)          c = ImVec2(+0.866f, -0.750f) * r;
   13,736 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
      404 ( 0.00%)          break;
        .               case ImGuiDir_Left:
        .               case ImGuiDir_Right:
        .                   if (dir == ImGuiDir_Left) r = -r;
        .                   a = ImVec2(+0.750f, +0.000f) * r;
        .                   b = ImVec2(-0.750f, +0.866f) * r;
        .                   c = ImVec2(-0.750f, -0.866f) * r;
        .                   break;
        .               case ImGuiDir_None:
        .               case ImGuiDir_COUNT:
        .                   IM_ASSERT(0);
        .                   break;
        .               }
   12,120 ( 0.00%)      draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
  506,206 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddTriangleFilled(ImVec2 const&, ImVec2 const&, ImVec2 const&, unsigned int) (404x)
   47,268 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (1,212x)
    1,616 ( 0.00%)  }
        .           
        .           void ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)
        .           {
        .               // FIXME-OPT: This should be baked in font.
        .               draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);
        .           }
        .           
        .           void ImGui::RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz)
-- line 4252 ----------------------------------------
-- line 4427 ----------------------------------------
        .           //-----------------------------------------------------------------------------
        .           // Compressed with stb_compress() then converted to a C array and encoded as base85.
        .           // Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
        .           // The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
        .           // Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
        .           //-----------------------------------------------------------------------------
        .           
        .           static unsigned int stb_decompress_length(const unsigned char *input)
       12 ( 0.00%)  {
       92 ( 0.00%)      return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
        8 ( 0.00%)  }
        .           
        .           static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
        .           static const unsigned char *stb__barrier_in_b;
        .           static unsigned char *stb__dout;
        .           static void stb__match(const unsigned char *data, unsigned int length)
   58,860 ( 0.00%)  {
        .               // INVERSE of memmove... write each byte before copying the next...
   70,632 ( 0.00%)      IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
   70,632 ( 0.00%)      if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
   35,316 ( 0.00%)      if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
1,723,494 ( 0.00%)      while (length--) *stb__dout++ = *data++;
   23,544 ( 0.00%)  }
        .           
        .           static void stb__lit(const unsigned char *data, unsigned int length)
   40,695 ( 0.00%)  {
   48,834 ( 0.00%)      IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
   48,834 ( 0.00%)      if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
   24,417 ( 0.00%)      if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
   56,973 ( 0.00%)      memcpy(stb__dout, data, length);
  124,679 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (8,139x)
   32,556 ( 0.00%)      stb__dout += length;
   16,278 ( 0.00%)  }
        .           
        .           #define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
        .           #define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
        .           #define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
        .           
        .           static const unsigned char *stb_decompress_token(const unsigned char *i)
   79,652 ( 0.00%)  {
   79,652 ( 0.00%)      if (*i >= 0x20) { // use fewer if's for cases that expand small
  206,769 ( 0.00%)          if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
  995,258 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb__match(unsigned char const*, unsigned int) (7,717x)
  137,262 ( 0.00%)          else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
  886,863 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb__match(unsigned char const*, unsigned int) (3,702x)
  127,092 ( 0.00%)          else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
  359,908 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb__lit(unsigned char const*, unsigned int) (7,476x)
        .               } else { // more ifs for cases that expand large, since overhead is amortized
   15,721 ( 0.00%)          if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
  100,357 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb__match(unsigned char const*, unsigned int) (353x)
    2,660 ( 0.00%)          else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
   23,213 ( 0.00%)          else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
   33,358 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb__lit(unsigned char const*, unsigned int) (663x)
        8 ( 0.00%)          else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
        8 ( 0.00%)          else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
        8 ( 0.00%)          else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
        .               }
   19,913 ( 0.00%)      return i;
   39,826 ( 0.00%)  }
        .           
        .           static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
       10 ( 0.00%)  {
        2 ( 0.00%)      const unsigned long ADLER_MOD = 65521;
       14 ( 0.00%)      unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
       20 ( 0.00%)      unsigned long blocklen = buflen % 5552;
        .           
        .               unsigned long i;
       82 ( 0.00%)      while (buflen) {
  129,448 ( 0.00%)          for (i=0; i + 7 < blocklen; i += 8) {
  155,064 ( 0.00%)              s1 += buffer[0], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[1], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[2], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[3], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[4], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[5], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[6], s2 += s1;
  180,908 ( 0.00%)              s1 += buffer[7], s2 += s1;
        .           
   25,844 ( 0.00%)              buffer += 8;
        .                   }
        .           
      168 ( 0.00%)          for (; i < blocklen; ++i)
       32 ( 0.00%)              s1 += *buffer++, s2 += s1;
        .           
      988 ( 0.00%)          s1 %= ADLER_MOD, s2 %= ADLER_MOD;
       76 ( 0.00%)          buflen -= blocklen;
       38 ( 0.00%)          blocklen = 5552;
        .               }
        8 ( 0.00%)      return (unsigned int)(s2 << 16) + (unsigned int)s1;
        4 ( 0.00%)  }
        .           
        .           static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
       12 ( 0.00%)  {
       52 ( 0.00%)      if (stb__in4(0) != 0x57bC0000) return 0;
       54 ( 0.00%)      if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
        8 ( 0.00%)      const unsigned int olen = stb_decompress_length(i);
       56 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb_decompress_length(unsigned char const*) (2x)
        4 ( 0.00%)      stb__barrier_in_b = i;
        8 ( 0.00%)      stb__barrier_out_e = output + olen;
        4 ( 0.00%)      stb__barrier_out_b = output;
        2 ( 0.00%)      i += 16;
        .           
        4 ( 0.00%)      stb__dout = output;
        .               for (;;) {
   39,826 ( 0.00%)          const unsigned char *old_i = i;
   79,652 ( 0.00%)          i = stb_decompress_token(i);
3,107,528 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb_decompress_token(unsigned char const*) (19,913x)
   59,739 ( 0.00%)          if (i == old_i) {
       18 ( 0.00%)              if (*i == 0x05 && i[1] == 0xfa) {
       12 ( 0.00%)                  IM_ASSERT(stb__dout == output + olen);
       12 ( 0.00%)                  if (stb__dout != output + olen) return 0;
       68 ( 0.00%)                  if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
1,578,154 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:stb_adler32(unsigned int, unsigned char*, unsigned int) (2x)
        .                               return 0;
        4 ( 0.00%)                  return olen;
        .                       } else {
        .                           IM_ASSERT(0); /* NOTREACHED */
        .                           return 0;
        .                       }
        .                   }
  119,466 ( 0.00%)          IM_ASSERT(stb__dout <= output + olen);
  119,466 ( 0.00%)          if (stb__dout > output + olen)
        .                       return 0;
        .               }
        4 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] Default font data (ProggyClean.ttf)
        .           //-----------------------------------------------------------------------------
        .           // ProggyClean.ttf
        .           // Copyright (c) 2004, 2005 Tristan Grimmer
        .           // MIT license (see License.txt in http://www.proggyfonts.net/index.php?menu=download)
        .           // Download and more information at http://www.proggyfonts.net or http://upperboundsinteractive.com/fonts.php
-- line 4550 ----------------------------------------
-- line 4637 ----------------------------------------
        .               "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
        .               "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
        .               "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
        .               "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
        .               "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
        .               "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";
        .           
        .           static const char* GetDefaultCompressedFontDataTTFBase85()
        2 ( 0.00%)  {
        1 ( 0.00%)      return proggy_clean_ttf_compressed_data_base85;
        2 ( 0.00%)  }
        .           
        .           #endif // #ifndef IMGUI_DISABLE

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/utility.h
--------------------------------------------------------------------------------
Ir                 

-- line 102 ----------------------------------------
        .               };
        .           
        .           #if __cplusplus >= 201402L
        .           
        .             // Return the index of _Tp in _Types, if it occurs exactly once.
        .             // Otherwise, return sizeof...(_Types).
        .             template<typename _Tp, typename... _Types>
        .               constexpr size_t
  294,864 ( 0.00%)      __find_uniq_type_in_pack()
        .               {
  147,432 ( 0.00%)        constexpr size_t __sz = sizeof...(_Types);
  294,864 ( 0.00%)        constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
  147,432 ( 0.00%)        size_t __n = __sz;
1,474,320 ( 0.00%)        for (size_t __i = 0; __i < __sz; ++__i)
        .           	{
1,769,184 ( 0.00%)  	  if (__found[__i])
        .           	    {
  294,864 ( 0.00%)  	      if (__n < __sz) // more than one _Tp found
        .           		return __sz;
  294,864 ( 0.00%)  	      __n = __i;
        .           	    }
        .           	}
  147,432 ( 0.00%)        return __n;
  294,864 ( 0.00%)      }
        .           #endif // C++14
        .           
        .           // The standard says this macro and alias template should be in <tuple> but we
        .           // define them here, to be available in <array>, <utility> and <ranges> too.
        .           // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .           // 3378. tuple_size_v/tuple_element_t should be available when
        .           //       tuple_size/tuple_element are
        .           #ifdef __glibcxx_tuple_element_t // C++ >= 14
-- line 133 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/array
--------------------------------------------------------------------------------
Ir                   

-- line 92 ----------------------------------------
          .              *  <a href="tables.html#67">sequence</a>.
          .              *
          .              *  Sets support random access iterators.
          .              *
          .              *  @tparam  Tp  Type of element. Required to be a complete type.
          .              *  @tparam  Nm  Number of elements.
          .             */
          .             template<typename _Tp, std::size_t _Nm>
         73 ( 0.00%)      struct array
          .               {
          .                 typedef _Tp 	    			      value_type;
          .                 typedef value_type*			      pointer;
          .                 typedef const value_type*                       const_pointer;
          .                 typedef value_type&                   	      reference;
          .                 typedef const value_type&             	      const_reference;
          .                 typedef value_type*          		      iterator;
          .                 typedef const value_type*			      const_iterator;
-- line 108 ----------------------------------------
-- line 124 ----------------------------------------
          .                 _GLIBCXX20_CONSTEXPR void
          .                 swap(array& __other)
          .                 noexcept(__array_traits<_Tp, _Nm>::_Is_nothrow_swappable::value)
          .                 { std::swap_ranges(begin(), end(), __other.begin()); }
          .           
          .                 // Iterators.
          .                 [[__gnu__::__const__, __nodiscard__]]
          .                 _GLIBCXX17_CONSTEXPR iterator
      2,150 ( 0.00%)        begin() noexcept
        860 ( 0.00%)        { return iterator(data()); }
          .           
          .                 [[__nodiscard__]]
          .                 _GLIBCXX17_CONSTEXPR const_iterator
          .                 begin() const noexcept
          .                 { return const_iterator(data()); }
          .           
          .                 [[__gnu__::__const__, __nodiscard__]]
          .                 _GLIBCXX17_CONSTEXPR iterator
-- line 141 ----------------------------------------
-- line 185 ----------------------------------------
          .                 [[__nodiscard__]]
          .                 _GLIBCXX17_CONSTEXPR const_reverse_iterator
          .                 crend() const noexcept
          .                 { return const_reverse_iterator(begin()); }
          .           
          .                 // Capacity.
          .                 [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
          .                 constexpr size_type
 56,964,682 ( 0.05%)        size() const noexcept { return _Nm; }
          .           
          .                 [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
          .                 constexpr size_type
          .                 max_size() const noexcept { return _Nm; }
          .           
          .                 [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
          .                 constexpr bool
          .                 empty() const noexcept { return size() == 0; }
          .           
          .                 // Element access.
          .                 [[__nodiscard__]]
          .                 _GLIBCXX17_CONSTEXPR reference
     96,760 ( 0.00%)        operator[](size_type __n) noexcept
          .                 {
          .           	__glibcxx_requires_subscript(__n);
     72,570 ( 0.00%)  	return _M_elems[__n];
     48,380 ( 0.00%)        }
          .           
          .                 [[__nodiscard__]]
          .                 constexpr const_reference
478,286,680 ( 0.40%)        operator[](size_type __n) const noexcept
          .                 {
          .           #if __cplusplus >= 201402L
          .           	__glibcxx_requires_subscript(__n);
          .           #endif
478,237,540 ( 0.40%)  	return _M_elems[__n];
239,143,340 ( 0.20%)        }
          .           
          .                 _GLIBCXX17_CONSTEXPR reference
          .                 at(size_type __n)
          .                 {
          .           	if (__n >= _Nm)
          .           	  std::__throw_out_of_range_fmt(__N("array::at: __n (which is %zu) "
          .           					    ">= _Nm (which is %zu)"),
          .           					__n, _Nm);
         12 ( 0.00%)  	return _M_elems[__n];
          .                 }
          .           
          .                 constexpr const_reference
          .                 at(size_type __n) const
          .                 {
          .           	// Result of conditional expression must be an lvalue so use
          .           	// boolean ? lvalue : (throw-expr, lvalue)
          .           	return __n < _Nm ? _M_elems[__n]
-- line 237 ----------------------------------------
-- line 275 ----------------------------------------
          .           	__glibcxx_requires_nonempty();
          .           #endif
          .           	return _M_elems[_Nm - 1];
          .                 }
          .           
          .                 [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
          .                 _GLIBCXX17_CONSTEXPR pointer
          .                 data() noexcept
      2,410 ( 0.00%)        { return static_cast<pointer>(_M_elems); }
          .           
          .                 [[__nodiscard__]]
          .                 _GLIBCXX17_CONSTEXPR const_pointer
          .                 data() const noexcept
          .                 { return static_cast<const_pointer>(_M_elems); }
          .               };
          .           
          .           #if __cpp_deduction_guides >= 201606
-- line 291 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/new
--------------------------------------------------------------------------------
Ir                  

-- line 172 ----------------------------------------
         .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
         .           void operator delete[](void*, std::size_t, std::align_val_t)
         .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
         .           #endif // __cpp_sized_deallocation
         .           #endif // __cpp_aligned_new
         .           
         .           // Default placement versions of operator new.
         .           _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
10,182,571 ( 0.01%)  { return __p; }
         .           _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
         .           { return __p; }
         .           
         .           // Default placement versions of operator delete.
         .           inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
         .           inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
         .           //@}
         .           } // extern "C++"
-- line 188 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/invoke.h
--------------------------------------------------------------------------------
Ir                 

-- line 52 ----------------------------------------
        .             // reference_wrapper is converted to an lvalue-reference.
        .             template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
        .               constexpr _Up&&
        .               __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
        .               { return static_cast<_Up&&>(__t); }
        .           
        .             template<typename _Res, typename _Fn, typename... _Args>
        .               constexpr _Res
3,023,619 ( 0.00%)      __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
7,117,533 ( 0.01%)      { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
      120 ( 0.00%)  => /usr/include/c++/14/bits/move.h:BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}& std::forward<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}&>(std::remove_reference<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}&>::type&) (20x)
      120 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/threadpool-src/include/BS_thread_pool.hpp:BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}::operator()() const (20x)
        .           
        .             template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
        .               constexpr _Res
        .               __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
        .           		  _Args&&... __args)
        .               { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }
        .           
        .             template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
        .               constexpr _Res
  981,840 ( 0.00%)      __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
        .           		  _Args&&... __args)
        .               {
2,673,867 ( 0.00%)        return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
125,265,792 ( 0.10%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_do_set(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:bool*&& std::forward<bool*>(std::remove_reference<bool*>::type&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__future_base::_State_baseV2*&& std::forward<std::__future_base::_State_baseV2*>(std::remove_reference<std::__future_base::_State_baseV2*>::type&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&& std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*>(std::remove_reference<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*>::type&) (98,164x)
  592,715 ( 0.00%)      }
        .           
        .             template<typename _Res, typename _MemPtr, typename _Tp>
        .               constexpr _Res
        .               __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
        .               { return __invfwd<_Tp>(__t).*__f; }
        .           
        .             template<typename _Res, typename _MemPtr, typename _Tp>
        .               constexpr _Res
        .               __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
        .               { return (*std::forward<_Tp>(__t)).*__f; }
        .           
        .             /// Invoke a callable object.
        .             template<typename _Callable, typename... _Args>
        .               constexpr typename __invoke_result<_Callable, _Args...>::type
2,532,025 ( 0.00%)      __invoke(_Callable&& __fn, _Args&&... __args)
        .               noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
        .               {
        .                 using __result = __invoke_result<_Callable, _Args...>;
        .                 using __type = typename __result::type;
        .                 using __tag = typename __result::__invoke_type;
4,857,285 ( 0.00%)        return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
131,253,796 ( 0.11%)  => /usr/include/c++/14/bits/invoke.h:void std::__invoke_impl<void, void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::__invoke_memfun_deref, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:bool*&& std::forward<bool*>(std::remove_reference<bool*>::type&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:void (std::__future_base::_State_baseV2::*&&std::forward<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)>(std::remove_reference<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)>::type&))(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&& std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*>(std::remove_reference<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*>::type&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__future_base::_State_baseV2*&& std::forward<std::__future_base::_State_baseV2*>(std::remove_reference<std::__future_base::_State_baseV2*>::type&) (98,164x)
  305,462 ( 0.00%)  					std::forward<_Args>(__args)...);
84,201,473 ( 0.07%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource> std::__invoke_impl<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> (Ship::ResourceManager::* const&)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>), Ship::ResourceManager* const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool const&, std::shared_ptr<Ship::ResourceInitData> const&>(std::__invoke_memfun_deref, std::shared_ptr<Ship::IResource> (Ship::ResourceManager::* const&)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>), Ship::ResourceManager* const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool const&, std::shared_ptr<Ship::ResourceInitData> const&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager* const& std::forward<Ship::ResourceManager* const&>(std::remove_reference<Ship::ResourceManager* const&>::type&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:bool const& std::forward<bool const&>(std::remove_reference<bool const&>::type&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::ResourceInitData> const& std::forward<std::shared_ptr<Ship::ResourceInitData> const&>(std::remove_reference<std::shared_ptr<Ship::ResourceInitData> const&>::type&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource> (Ship::ResourceManager::* const&std::forward<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::* const&)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>(std::remove_reference<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::* const&)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>::type&))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (533x)
1,557,783 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201703L
        .             // INVOKE<R>: Invoke a callable object and convert the result to R.
        .             template<typename _Res, typename _Callable, typename... _Args>
        .               constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
1,673,270 ( 0.00%)      __invoke_r(_Callable&& __fn, _Args&&... __args)
        .               noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
        .               {
        .                 using __result = __invoke_result<_Callable, _Args...>;
        .                 using __type = typename __result::type;
        .                 using __tag = typename __result::__invoke_type;
        .                 if constexpr (is_void_v<_Res>)
1,969,825 ( 0.00%)  	std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
       24 ( 0.00%)  => /usr/include/c++/14/bits/invoke.h:void std::__invoke_impl<void, spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#2}&>(std::__invoke_other, spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#2}&) (1x)
        6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#2}& std::forward<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#2}&>(std::remove_reference<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#2}&>::type&) (1x)
        .           					std::forward<_Args>(__args)...);
        .                 else
1,079,804 ( 0.00%)  	return std::__invoke_impl<__type>(__tag{},
  201,474 ( 0.00%)  => /usr/include/c++/14/bits/invoke.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter> std::__invoke_impl<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&>(std::__invoke_other, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&) (533x)
   32,513 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::~unique_ptr() (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>& std::forward<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&>(std::remove_reference<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&>::type&) (533x)
        .           					  std::forward<_Callable>(__fn),
  588,984 ( 0.00%)  					  std::forward<_Args>(__args)...);
  196,677 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter, void>(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&&) (533x)
1,082,977 ( 0.00%)      }
        .           #else // C++11 or C++14
        .             // This is a non-SFINAE-friendly std::invoke_r<R>(fn, args...) for C++11/14.
        .             // It's used in std::function, std::bind, and std::packaged_task. Only
        .             // std::function is constrained on is_invocable_r, but that is checked on
        .             // construction so doesn't need to be checked again when calling __invoke_r.
        .             // Consequently, these __invoke_r overloads do not check for invocable
        .             // arguments, nor check that the invoke result is convertible to R.
        .           
-- line 125 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/shared_ptr_base.h
--------------------------------------------------------------------------------
Ir                   

-- line 121 ----------------------------------------
          .                 enum { _S_need_barriers = 1 };
          .               };
          .           
          .             template<_Lock_policy _Lp = __default_lock_policy>
          .               class _Sp_counted_base
          .               : public _Mutex_base<_Lp>
          .               {
          .               public:
    613,290 ( 0.00%)        _Sp_counted_base() noexcept
  2,248,734 ( 0.00%)        : _M_use_count(1), _M_weak_count(1) { }
          .           
          .                 virtual
    608,634 ( 0.00%)        ~_Sp_counted_base() noexcept
  1,420,146 ( 0.00%)        { }
          .           
          .                 // Called when _M_use_count drops to zero, to release the resources
          .                 // managed by *this.
          .                 virtual void
          .                 _M_dispose() noexcept = 0;
          .           
          .                 // Called when _M_weak_count drops to zero.
          .                 virtual void
-- line 142 ----------------------------------------
-- line 143 ----------------------------------------
          .                 _M_destroy() noexcept
          .                 { delete this; }
          .           
          .                 virtual void*
          .                 _M_get_deleter(const std::type_info&) noexcept = 0;
          .           
          .                 // Increment the use count (used when the count is greater than zero).
          .                 void
  4,574,358 ( 0.00%)        _M_add_ref_copy()
 10,673,502 ( 0.01%)        { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
          .           
          .                 // Increment the use count if it is non-zero, throw otherwise.
          .                 void
          .                 _M_add_ref_lock()
          .                 {
          .           	if (!_M_add_ref_lock_nothrow())
          .           	  __throw_bad_weak_ptr();
          .                 }
-- line 160 ----------------------------------------
-- line 167 ----------------------------------------
          .                 void
          .                 _M_release() noexcept;
          .           
          .                 // Called by _M_release() when the use count reaches zero.
          .                 void
          .                 _M_release_last_use() noexcept
          .                 {
          .           	_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
          2 ( 0.00%)  	_M_dispose();
     92,422 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<spdlog::details::thread_pool, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
          .           	// There must be a memory barrier between dispose() and destroy()
          .           	// to ensure that the effects of dispose() are observed in the
          .           	// thread that runs destroy().
          .           	// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
          .           	if (_Mutex_base<_Lp>::_S_need_barriers)
          .           	  {
          .           	    __atomic_thread_fence (__ATOMIC_ACQ_REL);
          .           	  }
          .           
          .           	// Be race-detector-friendly.  For more info see bits/c++config.
          .           	_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
          2 ( 0.00%)  	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
          .           						   -1) == 1)
          .           	  {
          .           	    _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
          .           	    _M_destroy();
          .           	  }
          .                 }
          .           
          .                 // As above, but 'noinline' to reduce code size on the cold path.
          .                 __attribute__((__noinline__))
          .                 void
          6 ( 0.00%)        _M_release_last_use_cold() noexcept
          3 ( 0.00%)        { _M_release_last_use(); }
          .           
          .                 // Increment the weak count.
          .                 void
          9 ( 0.00%)        _M_weak_add_ref() noexcept
         21 ( 0.00%)        { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
          .           
          .                 // Decrement the weak count.
          .                 void
          4 ( 0.00%)        _M_weak_release() noexcept
          .                 {
          .                   // Be race-detector-friendly. For more info see bits/c++config.
          .                   _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
          8 ( 0.00%)  	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
          .           	  {
          .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
          .           	    if (_Mutex_base<_Lp>::_S_need_barriers)
          .           	      {
          .           	        // See _M_release(),
          .           	        // destroy() must observe results of dispose()
          .           		__atomic_thread_fence (__ATOMIC_ACQ_REL);
          .           	      }
          .           	    _M_destroy();
          .           	  }
          3 ( 0.00%)        }
          .           
          .                 long
  3,125,349 ( 0.00%)        _M_get_use_count() const noexcept
          .                 {
          .                   // No memory barrier is used here so there is no synchronization
          .                   // with other threads.
  4,176,982 ( 0.00%)          return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
  2,083,566 ( 0.00%)        }
          .           
          .               private:
          .                 _Sp_counted_base(_Sp_counted_base const&) = delete;
          .                 _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;
          .           
          .                 _Atomic_word  _M_use_count;     // #shared
          .                 _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)
          .               };
-- line 239 ----------------------------------------
-- line 262 ----------------------------------------
          .           	}
          .                 return true;
          .               }
          .           
          .             template<>
          .               inline bool
          .               _Sp_counted_base<_S_atomic>::
          .               _M_add_ref_lock_nothrow() noexcept
  1,597,352 ( 0.00%)      {
          .                 // Perform lock-free add-if-not-zero operation.
  1,597,352 ( 0.00%)        _Atomic_word __count = _M_get_use_count();
  3,594,042 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (399,338x)
          .                 do
          .           	{
  1,205,894 ( 0.00%)  	  if (__count == 0)
          .           	    return false;
          .           	  // Replace the current counter value with the old value + 1, as
          .           	  // long as it's not changed meanwhile.
          .           	}
  6,001,890 ( 0.00%)        while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
          .           					  true, __ATOMIC_ACQ_REL,
          .           					  __ATOMIC_RELAXED));
    399,338 ( 0.00%)        return true;
    798,676 ( 0.00%)      }
          .           
          .             template<>
          .               inline void
          .               _Sp_counted_base<_S_single>::_M_add_ref_copy()
          .               { ++_M_use_count; }
          .           
          .             template<>
          .               inline void
-- line 292 ----------------------------------------
-- line 310 ----------------------------------------
          .           	{
          .           	  _M_release_last_use();
          .           	}
          .               }
          .           
          .             template<>
          .               inline void
          .               _Sp_counted_base<_S_atomic>::_M_release() noexcept
  8,445,735 ( 0.01%)      {
          .                 _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
          .           #if ! _GLIBCXX_TSAN
  2,110,447 ( 0.00%)        constexpr bool __lock_free
          .           	= __atomic_always_lock_free(sizeof(long long), 0)
          .           	&& __atomic_always_lock_free(sizeof(_Atomic_word), 0);
  2,110,447 ( 0.00%)        constexpr bool __double_word
          .           	= sizeof(long long) == 2 * sizeof(_Atomic_word);
          .                 // The ref-count members follow the vptr, so are aligned to
          .                 // alignof(void*).
  2,110,447 ( 0.00%)        constexpr bool __aligned = __alignof(long long) <= alignof(void*);
          .                 if _GLIBCXX17_CONSTEXPR (__lock_free && __double_word && __aligned)
          .           	{
  2,110,447 ( 0.00%)  	  constexpr int __wordbits = __CHAR_BIT__ * sizeof(_Atomic_word);
  2,110,447 ( 0.00%)  	  constexpr int __shiftbits = __double_word ? __wordbits : 0;
  4,220,894 ( 0.00%)  	  constexpr long long __unique_ref = 1LL + (1LL << __shiftbits);
  6,331,344 ( 0.01%)  	  auto __both_counts = reinterpret_cast<long long*>(&_M_use_count);
          .           
          .           	  _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
 14,788,921 ( 0.01%)  	  if (__atomic_load_n(__both_counts, __ATOMIC_ACQUIRE) == __unique_ref)
          .           	    {
          .           	      // Both counts are 1, so there are no weak references and
          .           	      // we are releasing the last strong reference. No other
          .           	      // threads can observe the effects of this _M_release()
          .           	      // call (e.g. calling use_count()) without a data race.
  1,217,276 ( 0.00%)  	      _M_weak_count = _M_use_count = 0;
          .           	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
          .           	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
  1,420,159 ( 0.00%)  	      _M_dispose();
 85,223,277 ( 0.07%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (98,164x)
 49,237,402 ( 0.04%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (98,082x)
  1,454,264 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::File, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (657x)
    660,816 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (2,610x)
    127,958 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::MemoryStream, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (654x)
    114,450 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::BinaryReader, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (654x)
      1,090 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<nlohmann::json_abi_v3_11_3::detail::output_string_adapter<char, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (10x)
        714 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<spdlog::logger, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
        325 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::filesystem::__cxx11::_Dir, std::allocator<std::filesystem::__cxx11::_Dir>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
        194 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
         79 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TrainCrossing, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
  1,420,160 ( 0.00%)  	      _M_destroy();
 23,171,812 ( 0.02%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (98,164x)
 23,147,762 ( 0.02%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (98,082x)
    617,750 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (2,610x)
    155,324 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::File, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (657x)
    154,968 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::MemoryStream, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (654x)
    154,764 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::BinaryReader, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (654x)
      2,330 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<nlohmann::json_abi_v3_11_3::detail::output_string_adapter<char, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (10x)
        266 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (1x)
        264 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TrainCrossing, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (1x)
         98 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::filesystem::__cxx11::_Dir, std::allocator<std::filesystem::__cxx11::_Dir>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (1x)
         93 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<spdlog::logger, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (1x)
    202,880 ( 0.00%)  	      return;
          .           	    }
 15,276,319 ( 0.01%)  	  if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
          .           	    [[__unlikely__]]
          .           	    {
          1 ( 0.00%)  	      _M_release_last_use_cold();
     92,441 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release_last_use_cold() (1x)
          .           	      return;
          .           	    }
          .           	}
          .                 else
          .           #endif
          .                 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
          .           	{
          .           	  _M_release_last_use();
          .           	}
  4,220,895 ( 0.00%)      }
          .           
          .             template<>
          .               inline void
          .               _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
          .               { ++_M_weak_count; }
          .           
          .             template<>
          .               inline void
-- line 371 ----------------------------------------
-- line 462 ----------------------------------------
          .             template<int _Nm, typename _Tp,
          .           	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
          .               struct _Sp_ebo_helper;
          .           
          .             /// Specialization using EBO.
          .             template<int _Nm, typename _Tp>
          .               struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
          .               {
  1,431,010 ( 0.00%)        explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
          .                 explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }
          .           
          .                 static _Tp&
  2,434,542 ( 0.00%)        _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
          .               };
          .           
          .             /// Specialization not using EBO.
          .             template<int _Nm, typename _Tp>
          .               struct _Sp_ebo_helper<_Nm, _Tp, false>
          .               {
          .                 explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
          .                 explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }
-- line 482 ----------------------------------------
-- line 582 ----------------------------------------
          .             template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
          .               class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
          .               {
          .                 class _Impl : _Sp_ebo_helper<0, _Alloc>
          .                 {
          .           	typedef _Sp_ebo_helper<0, _Alloc>	_A_base;
          .           
          .                 public:
  2,453,160 ( 0.00%)  	explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }
         21 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_ebo_helper<0, std::allocator<void>, true>::_Sp_ebo_helper(std::allocator<void> const&) (3x)
          .           
  3,651,813 ( 0.00%)  	_Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }
     39,228 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_ebo_helper<0, std::allocator<void>, true>::_S_get(std::_Sp_ebo_helper<0, std::allocator<void>, true>&) (6,538x)
          .           
          .           	__gnu_cxx::__aligned_buffer<_Tp> _M_storage;
          .                 };
          .           
          .               public:
          .                 using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
          .           
          .                 // Alloc parameter is not a reference so doesn't alias anything in __args
          .                 template<typename... _Args>
    929,521 ( 0.00%)  	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
  2,044,367 ( 0.00%)  	: _M_impl(__a)
         19 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<spdlog::sinks::rotating_file_sink<std::mutex>, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_Impl::_Impl(std::allocator<void>) (1x)
         14 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_Sp_counted_base() (1x)
          .           	{
          .           	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .           	  // 2070.  allocate_shared should use allocator_traits<A>::construct
    851,790 ( 0.00%)  	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
         25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<spdlog::sinks::rotating_file_sink<std::mutex>, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() (1x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:int&& std::forward<int>(std::remove_reference<int>::type&) (2x)
          6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&) (1x)
          .           	      std::forward<_Args>(__args)...); // might throw
    719,691 ( 0.00%)  	}
          .           
  2,637,415 ( 0.00%)        ~_Sp_counted_ptr_inplace() noexcept { }
         10 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::~_Sp_counted_base() (1x)
          .           
          .                 virtual void
  1,014,397 ( 0.00%)        _M_dispose() noexcept
          .                 {
  2,028,790 ( 0.00%)  	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
        250 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<nlohmann::json_abi_v3_11_3::detail::output_string_adapter<char, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() (10x)
        150 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<nlohmann::json_abi_v3_11_3::detail::output_string_adapter<char, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_Impl::_M_alloc() (10x)
    811,516 ( 0.00%)        }
          .           
          .                 // Override because the allocator needs to know the dynamic type
          .                 virtual void
    811,514 ( 0.00%)        _M_destroy() noexcept
          .                 {
  1,420,146 ( 0.00%)  	__allocator_type __a(_M_impl._M_alloc());
         15 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_Impl::_M_alloc() (1x)
  1,217,268 ( 0.00%)  	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
         23 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::__allocated_ptr(std::allocator<std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >&, std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>*) (1x)
    608,634 ( 0.00%)  	this->~_Sp_counted_ptr_inplace();
         23 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::~_Sp_counted_ptr_inplace() (1x)
  1,217,268 ( 0.00%)        }
        176 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<Ship::CVar, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::~__allocated_ptr() (1x)
          .           
          .               private:
          .                 friend class __shared_count<_Lp>; // To be able to call _M_ptr().
          .           
          .                 // No longer used, but code compiled against old libstdc++ headers
          .                 // might still call it from __shared_ptr ctor to get the pointer out.
          .                 virtual void*
          .                 _M_get_deleter(const std::type_info& __ti) noexcept override
-- line 634 ----------------------------------------
-- line 645 ----------------------------------------
          .           #else
          .           	    _Sp_make_shared_tag::_S_eq(__ti)
          .           #endif
          .           	   )
          .           	  return __ptr;
          .           	return nullptr;
          .                 }
          .           
  6,117,390 ( 0.01%)        _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
         30 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<Ship::InputEditorWindow>::_M_ptr() (2x)
          .           
          .                 _Impl _M_impl;
          .               };
          .           
          .           #ifdef __glibcxx_smart_ptr_for_overwrite // C++ >= 20 && HOSTED
          .             struct _Sp_overwrite_tag { };
          .           
          .             // Partial specialization used for make_shared_for_overwrite<non-array>().
-- line 661 ----------------------------------------
-- line 898 ----------------------------------------
          .           	struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };
          .           
          .           #if __glibcxx_shared_ptr_arrays >= 201707L // C++ >= 20 && HOSTED
          .                 template<typename _Alloc>
          .           	struct __not_alloc_shared_tag<_Sp_counted_array_base<_Alloc>> { };
          .           #endif
          .           
          .               public:
  3,109,206 ( 0.00%)        constexpr __shared_count() noexcept : _M_pi(0)
  1,865,523 ( 0.00%)        { }
          .           
          .                 template<typename _Ptr>
          .                   explicit
          .           	__shared_count(_Ptr __p) : _M_pi(0)
          .           	{
          .           	  __try
          .           	    {
          .           	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
-- line 915 ----------------------------------------
-- line 954 ----------------------------------------
          .           	  __catch(...)
          .           	    {
          .           	      __d(__p); // Call _Deleter on __p.
          .           	      __throw_exception_again;
          .           	    }
          .           	}
          .           
          .                 template<typename _Tp, typename _Alloc, typename... _Args>
  1,748,423 ( 0.00%)  	__shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
          .           		       _Args&&... __args)
          .           	{
          .           	  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
    817,720 ( 0.00%)  	  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
  1,022,150 ( 0.00%)  	  auto __guard = std::__allocate_guarded(__a2);
     97,158 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > > std::__allocate_guarded<std::allocator<std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >(std::allocator<std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> >&) (657x)
    817,720 ( 0.00%)  	  _Sp_cp_type* __mem = __guard.get();
     10,512 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::get() (657x)
  1,767,673 ( 0.00%)  	  auto __pi = ::new (__mem)
  2,061,691 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_Sp_counted_ptr_inplace<unsigned int&>(std::allocator<void>, unsigned int&) (657x)
      4,599 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (657x)
      3,942 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned int& std::forward<unsigned int&>(std::remove_reference<unsigned int&>::type&) (657x)
          .           	    _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
    817,720 ( 0.00%)  	  __guard = nullptr;
      5,913 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::operator=(decltype(nullptr)) (657x)
    613,290 ( 0.00%)  	  _M_pi = __pi;
  1,022,150 ( 0.00%)  	  __p = __pi->_M_ptr();
     16,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_ptr() (657x)
  1,845,147 ( 0.00%)  	}
      7,227 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::vector<char, std::allocator<char> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2> > >::~__allocated_ptr() (657x)
          .           
          .           #if __glibcxx_shared_ptr_arrays >= 201707L // C++ >= 20 && HOSTED
          .                 template<typename _Tp, typename _Alloc, typename _Init>
          .           	__shared_count(_Tp*& __p, const _Sp_counted_array_base<_Alloc>& __a,
          .           		       _Init __init)
          .           	{
          .           	  using _Up = remove_all_extents_t<_Tp>;
          .           	  static_assert(is_same_v<_Up, typename _Alloc::value_type>);
-- line 982 ----------------------------------------
-- line 1058 ----------------------------------------
          .           
          .                 // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
          .                 explicit __shared_count(const __weak_count<_Lp>& __r);
          .           
          .                 // Does not throw if __r._M_get_use_count() == 0, caller must check.
          .                 explicit
          .                 __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept;
          .           
 11,462,720 ( 0.01%)        ~__shared_count() noexcept
          .                 {
 11,512,955 ( 0.01%)  	if (_M_pi != nullptr)
  8,294,248 ( 0.01%)  	  _M_pi->_M_release();
269,261,907 ( 0.22%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() (1,869,052x)
  8,597,040 ( 0.01%)        }
          .           
  7,928,710 ( 0.01%)        __shared_count(const __shared_count& __r) noexcept
  6,342,970 ( 0.01%)        : _M_pi(__r._M_pi)
          .                 {
  6,342,972 ( 0.01%)  	if (_M_pi != nullptr)
  5,675,812 ( 0.00%)  	  _M_pi->_M_add_ref_copy();
 35,473,837 ( 0.03%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_copy() (1,418,953x)
  4,757,226 ( 0.00%)        }
          .           
          .                 __shared_count&
  1,022,940 ( 0.00%)        operator=(const __shared_count& __r) noexcept
          .                 {
    613,764 ( 0.00%)  	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
    818,358 ( 0.00%)  	if (__tmp != _M_pi)
          .           	  {
    224,184 ( 0.00%)  	    if (__tmp != nullptr)
    317,499 ( 0.00%)  	      __tmp->_M_add_ref_copy();
  2,645,825 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_copy() (105,833x)
    448,367 ( 0.00%)  	    if (_M_pi != nullptr)
    159,368 ( 0.00%)  	      _M_pi->_M_release();
  2,370,748 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() (39,842x)
    336,274 ( 0.00%)  	    _M_pi = __tmp;
          .           	  }
    204,588 ( 0.00%)  	return *this;
    409,176 ( 0.00%)        }
          .           
          .                 void
  1,421,064 ( 0.00%)        _M_swap(__shared_count& __r) noexcept
          .                 {
  1,069,745 ( 0.00%)  	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
  1,421,066 ( 0.00%)  	__r._M_pi = _M_pi;
  1,065,798 ( 0.00%)  	_M_pi = __tmp;
  1,065,798 ( 0.00%)        }
          .           
          .                 long
  2,569,780 ( 0.00%)        _M_get_use_count() const noexcept
  7,066,895 ( 0.01%)        { return _M_pi ? _M_pi->_M_get_use_count() : 0; }
  5,782,005 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (642,445x)
          .           
          .                 bool
    392,656 ( 0.00%)        _M_unique() const noexcept
    687,148 ( 0.00%)        { return this->_M_get_use_count() == 1; }
  2,355,936 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (98,164x)
          .           
          .                 void*
          .                 _M_get_deleter(const std::type_info& __ti) const noexcept
          .                 { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }
          .           
          .                 bool
      1,110 ( 0.00%)        _M_less(const __shared_count& __rhs) const noexcept
      2,220 ( 0.00%)        { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
      3,108 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>*>::operator()(std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>*, std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>*) const (222x)
          .           
          .                 bool
          .                 _M_less(const __weak_count<_Lp>& __rhs) const noexcept
          .                 { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
          .           
          .                 // Friend function injected into enclosing namespace and found by ADL
          .                 friend inline bool
          .                 operator==(const __shared_count& __a, const __shared_count& __b) noexcept
-- line 1124 ----------------------------------------
-- line 1136 ----------------------------------------
          .                 _Sp_counted_base<_Lp>*  _M_pi;
          .               };
          .           
          .           
          .             template<_Lock_policy _Lp>
          .               class __weak_count
          .               {
          .               public:
          5 ( 0.00%)        constexpr __weak_count() noexcept : _M_pi(nullptr)
          3 ( 0.00%)        { }
          .           
          5 ( 0.00%)        __weak_count(const __shared_count<_Lp>& __r) noexcept
          4 ( 0.00%)        : _M_pi(__r._M_pi)
          .                 {
          4 ( 0.00%)  	if (_M_pi != nullptr)
          4 ( 0.00%)  	  _M_pi->_M_weak_add_ref();
         24 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_weak_add_ref() (1x)
          3 ( 0.00%)        }
          .           
          .                 __weak_count(const __weak_count& __r) noexcept
          .                 : _M_pi(__r._M_pi)
          .                 {
          .           	if (_M_pi != nullptr)
          .           	  _M_pi->_M_weak_add_ref();
          .                 }
          .           
          4 ( 0.00%)        __weak_count(__weak_count&& __r) noexcept
          4 ( 0.00%)        : _M_pi(__r._M_pi)
          5 ( 0.00%)        { __r._M_pi = nullptr; }
          .           
          8 ( 0.00%)        ~__weak_count() noexcept
          .                 {
          8 ( 0.00%)  	if (_M_pi != nullptr)
          4 ( 0.00%)  	  _M_pi->_M_weak_release();
         29 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_weak_release() (1x)
          6 ( 0.00%)        }
          .           
          .                 __weak_count&
         10 ( 0.00%)        operator=(const __shared_count<_Lp>& __r) noexcept
          .                 {
          6 ( 0.00%)  	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
          4 ( 0.00%)  	if (__tmp != nullptr)
          6 ( 0.00%)  	  __tmp->_M_weak_add_ref();
         51 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_weak_add_ref() (2x)
          8 ( 0.00%)  	if (_M_pi != nullptr)
          .           	  _M_pi->_M_weak_release();
          6 ( 0.00%)  	_M_pi = __tmp;
          2 ( 0.00%)  	return *this;
          4 ( 0.00%)        }
          .           
          .                 __weak_count&
          .                 operator=(const __weak_count& __r) noexcept
          .                 {
          .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
          .           	if (__tmp != nullptr)
          .           	  __tmp->_M_weak_add_ref();
          .           	if (_M_pi != nullptr)
-- line 1189 ----------------------------------------
-- line 1206 ----------------------------------------
          .                 _M_swap(__weak_count& __r) noexcept
          .                 {
          .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
          .           	__r._M_pi = _M_pi;
          .           	_M_pi = __tmp;
          .                 }
          .           
          .                 long
          8 ( 0.00%)        _M_get_use_count() const noexcept
         14 ( 0.00%)        { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }
          .           
          .                 bool
          .                 _M_less(const __weak_count& __rhs) const noexcept
          .                 { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
          .           
          .                 bool
          .                 _M_less(const __shared_count<_Lp>& __rhs) const noexcept
          .                 { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
-- line 1223 ----------------------------------------
-- line 1235 ----------------------------------------
          .           
          .                 _Sp_counted_base<_Lp>*  _M_pi;
          .               };
          .           
          .             // Now that __weak_count is defined we can define this constructor:
          .             template<_Lock_policy _Lp>
          .               inline
          .               __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
      3,940 ( 0.00%)      : _M_pi(__r._M_pi)
          .               {
      3,940 ( 0.00%)        if (_M_pi == nullptr || !_M_pi->_M_add_ref_lock_nothrow())
          .           	__throw_bad_weak_ptr();
          .               }
          .           
          .             // Now that __weak_count is defined we can define this constructor:
          .             template<_Lock_policy _Lp>
          .               inline
  1,996,690 ( 0.00%)      __shared_count<_Lp>::
          .               __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept
  1,597,352 ( 0.00%)      : _M_pi(__r._M_pi)
          .               {
  5,594,672 ( 0.00%)        if (_M_pi && !_M_pi->_M_add_ref_lock_nothrow())
 15,174,844 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_add_ref_lock_nothrow() (399,338x)
          .           	_M_pi = nullptr;
  1,198,014 ( 0.00%)      }
          .           
          .             // Helper traits for shared_ptr of array:
          .           
          .             // A pointer type Y* is said to be compatible with a pointer type T* when
          .             // either Y* is convertible to T* or Y is U[N] and T is U cv [].
          .             template<typename _Yp_ptr, typename _Tp_ptr>
          .               struct __sp_compatible_with
          .               : false_type
-- line 1266 ----------------------------------------
-- line 1340 ----------------------------------------
          .             template<typename _Tp, _Lock_policy _Lp,
          .           	   bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
          .               class __shared_ptr_access
          .               {
          .               public:
          .                 using element_type = _Tp;
          .           
          .                 element_type&
    458,872 ( 0.00%)        operator*() const noexcept
          .                 {
    229,436 ( 0.00%)  	__glibcxx_assert(_M_get() != nullptr);
    344,154 ( 0.00%)  	return *_M_get();
  1,570,624 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const (98,164x)
    229,436 ( 0.00%)        }
          .           
          .                 element_type*
241,147,252 ( 0.20%)        operator->() const noexcept
          .                 {
          .           	_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);
180,860,439 ( 0.15%)  	return _M_get();
         48 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<spdlog::logger, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get() const (3x)
120,573,626 ( 0.10%)        }
          .           
          .               private:
          .                 element_type*
241,606,124 ( 0.20%)        _M_get() const noexcept
302,007,655 ( 0.25%)        { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    942,186 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2>::get() const (134,598x)
          .               };
          .           
          .             // Define operator-> for shared_ptr<cv void>.
          .             template<typename _Tp, _Lock_policy _Lp>
          .               class __shared_ptr_access<_Tp, _Lp, false, true>
          .               {
          .               public:
          .                 using element_type = _Tp;
-- line 1372 ----------------------------------------
-- line 1455 ----------------------------------------
          .           	using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;
          .           
          .               public:
          .           
          .           #if __cplusplus > 201402L
          .                 using weak_type = __weak_ptr<_Tp, _Lp>;
          .           #endif
          .           
  1,085,408 ( 0.00%)        constexpr __shared_ptr() noexcept
  1,630,090 ( 0.00%)        : _M_ptr(0), _M_refcount()
          8 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() (1x)
    814,056 ( 0.00%)        { }
          .           
          .                 template<typename _Yp, typename = _SafeConv<_Yp>>
          .           	explicit
          .           	__shared_ptr(_Yp* __p)
          .           	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
          .           	{
          .           	  static_assert( !is_void<_Yp>::value, "incomplete type" );
          .           	  static_assert( sizeof(_Yp) > 0, "incomplete type" );
-- line 1473 ----------------------------------------
-- line 1500 ----------------------------------------
          .           
          .                 template<typename _Deleter, typename _Alloc>
          .                   __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
          .           	: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
          .           	{ }
          .           
          .                 // Aliasing constructor
          .                 template<typename _Yp>
    364,308 ( 0.00%)  	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
          .           		     element_type* __p) noexcept
    607,180 ( 0.00%)  	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
    130,230 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (2,894x)
    182,154 ( 0.00%)  	{ }
          .           
          .                 // Aliasing constructor
          .                 template<typename _Yp>
    297,810 ( 0.00%)  	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r,
          .           		     element_type* __p) noexcept
    347,445 ( 0.00%)  	: _M_ptr(__p), _M_refcount()
         24 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() (3x)
          .           	{
    347,445 ( 0.00%)  	  _M_refcount._M_swap(__r._M_refcount);
         51 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) (3x)
     99,270 ( 0.00%)  	  __r._M_ptr = nullptr;
    148,905 ( 0.00%)  	}
          .           
 28,950,230 ( 0.02%)        __shared_ptr(const __shared_ptr&) noexcept = default;
         90 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (2x)
  3,887,178 ( 0.00%)        __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
         52 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1x)
 31,522,480 ( 0.03%)        ~__shared_ptr() = default;
         83 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() (3x)
          .           
          .                 template<typename _Yp, typename = _Compatible<_Yp>>
      6,640 ( 0.00%)  	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
     14,806 ( 0.00%)  	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         45 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1x)
      3,984 ( 0.00%)  	{ }
          .           
  1,500,670 ( 0.00%)        __shared_ptr(__shared_ptr&& __r) noexcept
  2,408,965 ( 0.00%)        : _M_ptr(__r._M_ptr), _M_refcount()
         24 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() (3x)
          .                 {
  2,100,938 ( 0.00%)  	_M_refcount._M_swap(__r._M_refcount);
         51 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) (3x)
    612,106 ( 0.00%)  	__r._M_ptr = nullptr;
    900,402 ( 0.00%)        }
          .           
          .                 template<typename _Yp, typename = _Compatible<_Yp>>
      3,600 ( 0.00%)  	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
      5,882 ( 0.00%)  	: _M_ptr(__r._M_ptr), _M_refcount()
          8 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count() (1x)
          .           	{
      5,040 ( 0.00%)  	  _M_refcount._M_swap(__r._M_refcount);
         17 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) (1x)
      1,440 ( 0.00%)  	  __r._M_ptr = nullptr;
      2,160 ( 0.00%)  	}
          .           
          .                 template<typename _Yp, typename = _Compatible<_Yp>>
          .           	explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
          .           	: _M_refcount(__r._M_refcount) // may throw
          .           	{
          .           	  // It is now safe to copy __r._M_ptr, as
          .           	  // _M_refcount(__r._M_refcount) did not throw.
      3,940 ( 0.00%)  	  _M_ptr = __r._M_ptr;
          .           	}
          .           
          .                 // If an exception is thrown this constructor has no effect.
          .                 template<typename _Yp, typename _Del,
          .           	       typename = _UniqCompatible<_Yp, _Del>>
          .           	__shared_ptr(unique_ptr<_Yp, _Del>&& __r)
          .           	: _M_ptr(__r.get()), _M_refcount()
          .           	{
-- line 1561 ----------------------------------------
-- line 1611 ----------------------------------------
          .           	{
          .           	  __shared_ptr(std::move(__r)).swap(*this);
          .           	  return *this;
          .           	}
          .           #pragma GCC diagnostic pop
          .           #endif
          .           
          .                 __shared_ptr&
     23,855 ( 0.00%)        operator=(__shared_ptr&& __r) noexcept
          .                 {
     76,336 ( 0.00%)  	__shared_ptr(std::move(__r)).swap(*this);
      6,960 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>::swap(std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>&) (87x)
      4,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>::__shared_ptr(std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>&&) (87x)
      1,914 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() (87x)
        522 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>&>::type&& std::move<std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>&>(std::__shared_ptr<Ship::CVar, (__gnu_cxx::_Lock_policy)2>&) (87x)
      4,771 ( 0.00%)  	return *this;
      9,542 ( 0.00%)        }
          .           
          .                 template<class _Yp>
          .           	_Assignable<_Yp>
         30 ( 0.00%)  	operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
          .           	{
         96 ( 0.00%)  	  __shared_ptr(std::move(__r)).swap(*this);
         80 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::GuiWindow, (__gnu_cxx::_Lock_policy)2>::swap(std::__shared_ptr<Ship::GuiWindow, (__gnu_cxx::_Lock_policy)2>&) (1x)
         50 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::GuiWindow, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<Freecam::FreecamWindow, void>(std::__shared_ptr<Freecam::FreecamWindow, (__gnu_cxx::_Lock_policy)2>&&) (1x)
         22 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::GuiWindow, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() (1x)
          6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__shared_ptr<Freecam::FreecamWindow, (__gnu_cxx::_Lock_policy)2>&>::type&& std::move<std::__shared_ptr<Freecam::FreecamWindow, (__gnu_cxx::_Lock_policy)2>&>(std::__shared_ptr<Freecam::FreecamWindow, (__gnu_cxx::_Lock_policy)2>&) (1x)
          6 ( 0.00%)  	  return *this;
         12 ( 0.00%)  	}
          .           
          .                 template<typename _Yp, typename _Del>
          .           	_UniqAssignable<_Yp, _Del>
          .           	operator=(unique_ptr<_Yp, _Del>&& __r)
          .           	{
          .           	  __shared_ptr(std::move(__r)).swap(*this);
          .           	  return *this;
          .           	}
-- line 1639 ----------------------------------------
-- line 1658 ----------------------------------------
          .           
          .                 template<typename _Yp, typename _Deleter, typename _Alloc>
          .           	_SafeConv<_Yp>
          .           	reset(_Yp* __p, _Deleter __d, _Alloc __a)
          .                   { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }
          .           
          .                 /// Return the stored pointer.
          .                 element_type*
181,535,730 ( 0.15%)        get() const noexcept
242,055,522 ( 0.20%)        { return _M_ptr; }
          .           
          .                 /// Return true if the stored pointer is not null.
  2,562,186 ( 0.00%)        explicit operator bool() const noexcept
  5,124,374 ( 0.00%)        { return _M_ptr != nullptr; }
          .           
          .                 /// Return true if use_count() == 1.
          .                 bool
    392,656 ( 0.00%)        unique() const noexcept
    588,984 ( 0.00%)        { return _M_refcount._M_unique(); }
  3,435,740 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_unique() const (98,164x)
          .           
          .                 /// If *this owns a pointer, return the number of owners, otherwise zero.
          .                 long
    579,772 ( 0.00%)        use_count() const noexcept
    869,658 ( 0.00%)        { return _M_refcount._M_get_use_count(); }
  3,478,632 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (144,943x)
          .           
          .                 /// Exchange both the owned pointer and the stored pointer.
          .                 void
     23,885 ( 0.00%)        swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
          .                 {
     23,885 ( 0.00%)  	std::swap(_M_ptr, __other._M_ptr);
        172 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<Ship::ControllerGyro*> >, std::is_move_constructible<Ship::ControllerGyro*>, std::is_move_assignable<Ship::ControllerGyro*> >::value, void>::type std::swap<Ship::ControllerGyro*>(Ship::ControllerGyro*&, Ship::ControllerGyro*&) (4x)
     33,439 ( 0.00%)  	_M_refcount._M_swap(__other._M_refcount);
         68 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_swap(std::__shared_count<(__gnu_cxx::_Lock_policy)2>&) (4x)
     14,331 ( 0.00%)        }
          .           
          .                 /** @brief Define an ordering based on ownership.
          .                  *
          .                  * This function defines a strict weak ordering between two shared_ptr
          .                  * or weak_ptr objects, such that one object is less than the other
          .                  * unless they share ownership of the same pointer, or are both empty.
          .                  * @{
          .                 */
          .                 template<typename _Tp1>
          .           	bool
      1,110 ( 0.00%)  	owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
      1,998 ( 0.00%)  	{ return _M_refcount._M_less(__rhs._M_refcount); }
        377 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_less(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) const (13x)
          .           
          .                 template<typename _Tp1>
          .           	bool
          .           	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
          .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
          .                 /// @}
          .           
          .               protected:
          .                 // This constructor is non-standard, it is used by allocate_shared.
          .                 template<typename _Alloc, typename... _Args>
  1,035,776 ( 0.00%)  	__shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
  1,868,589 ( 0.00%)  	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
      4,037 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>, std::allocator<void>>(spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>*&, std::_Sp_alloc_shared_tag<std::allocator<void> >) (1x)
  1,848,098 ( 0.00%)  	{ _M_enable_shared_from_this_with(_M_ptr); }
          7 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::enable_if<!std::__shared_ptr<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>, (__gnu_cxx::_Lock_policy)2>::__has_esft_base<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>, void>::value, void>::type std::__shared_ptr<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>, (__gnu_cxx::_Lock_policy)2>::_M_enable_shared_from_this_with<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>, spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex> >(spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>*) (1x)
          .           
          .                 template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
          .           	       typename... _Args>
          .           	friend __shared_ptr<_Tp1, _Lp1>
          .           	__allocate_shared(const _Alloc& __a, _Args&&... __args);
          .           
          .           #if __glibcxx_shared_ptr_arrays >= 201707L // C++ >= 20 && HOSTED
          .                 // This constructor is non-standard, it is used by allocate_shared<T[]>.
-- line 1722 ----------------------------------------
-- line 1724 ----------------------------------------
          .           	__shared_ptr(const _Sp_counted_array_base<_Alloc>& __a,
          .           		     _Init __init = nullptr)
          .           	: _M_ptr(), _M_refcount(_M_ptr, __a, __init)
          .           	{ }
          .           #endif
          .           
          .                 // This constructor is used by __weak_ptr::lock() and
          .                 // shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).
  1,996,690 ( 0.00%)        __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t) noexcept
  2,795,366 ( 0.00%)        : _M_refcount(__r._M_refcount, std::nothrow)
 25,557,632 ( 0.02%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count(std::__weak_count<(__gnu_cxx::_Lock_policy)2> const&, std::nothrow_t) (399,338x)
          .                 {
  4,398,628 ( 0.00%)  	_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
  9,584,112 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_count<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (399,338x)
  1,198,014 ( 0.00%)        }
          .           
          .                 friend class __weak_ptr<_Tp, _Lp>;
          .           
          .               private:
          .           
          .                 template<typename _Yp>
          .           	using __esft_base_t = decltype(__enable_shared_from_this_base(
          .           	      std::declval<const __shared_count<_Lp>&>(),
-- line 1744 ----------------------------------------
-- line 1750 ----------------------------------------
          .           	: false_type { };
          .           
          .                 template<typename _Yp>
          .           	struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
          .           	: __not_<is_array<_Tp>> { }; // No enable shared_from_this for arrays
          .           
          .                 template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
          .           	typename enable_if<__has_esft_base<_Yp2>::value>::type
          5 ( 0.00%)  	_M_enable_shared_from_this_with(_Yp* __p) noexcept
          .           	{
         13 ( 0.00%)  	  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
          7 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::__enable_shared_from_this_base(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&, std::enable_shared_from_this<spdlog::async_logger> const*) (1x)
          7 ( 0.00%)  	    __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
        108 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:void std::enable_shared_from_this<spdlog::async_logger>::_M_weak_assign<spdlog::async_logger>(spdlog::async_logger*, std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) const (1x)
          3 ( 0.00%)  	}
          .           
          .                 template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
          .           	typename enable_if<!__has_esft_base<_Yp2>::value>::type
    817,716 ( 0.00%)  	_M_enable_shared_from_this_with(_Yp*) noexcept
    613,287 ( 0.00%)  	{ }
          .           
          .                 void*
          .                 _M_get_deleter(const std::type_info& __ti) const noexcept
          .                 { return _M_refcount._M_get_deleter(__ti); }
          .           
          .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
          .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
          .           
-- line 1775 ----------------------------------------
-- line 1983 ----------------------------------------
          .           
          .                 // Constraint for assignment from shared_ptr and weak_ptr:
          .                 template<typename _Yp>
          .           	using _Assignable = _Compatible<_Yp, __weak_ptr&>;
          .           
          .               public:
          .                 using element_type = typename remove_extent<_Tp>::type;
          .           
          4 ( 0.00%)        constexpr __weak_ptr() noexcept
          6 ( 0.00%)        : _M_ptr(nullptr), _M_refcount()
          8 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::__weak_count() (1x)
          3 ( 0.00%)        { }
          .           
          .                 __weak_ptr(const __weak_ptr&) noexcept = default;
          .           
         22 ( 0.00%)        ~__weak_ptr() = default;
         11 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::~__weak_count() (1x)
          .           
          .                 // The "obvious" converting constructor implementation:
          .                 //
          .                 //  template<typename _Tp1>
          .                 //    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
          .                 //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws
          .                 //    { }
          .                 //
-- line 2005 ----------------------------------------
-- line 2011 ----------------------------------------
          .                 // It is not possible to avoid spurious access violations since
          .                 // in multithreaded programs __r._M_ptr may be invalidated at any point.
          .                 template<typename _Yp, typename = _Compatible<_Yp>>
          .           	__weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
          .           	: _M_refcount(__r._M_refcount)
          .                   { _M_ptr = __r.lock().get(); }
          .           
          .                 template<typename _Yp, typename = _Compatible<_Yp>>
          5 ( 0.00%)  	__weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
         11 ( 0.00%)  	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         44 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::__weak_count(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1x)
          3 ( 0.00%)  	{ }
          .           
          6 ( 0.00%)        __weak_ptr(__weak_ptr&& __r) noexcept
         13 ( 0.00%)        : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
         13 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::__weak_count(std::__weak_count<(__gnu_cxx::_Lock_policy)2>&&) (1x)
          6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__weak_count<(__gnu_cxx::_Lock_policy)2>&>::type&& std::move<std::__weak_count<(__gnu_cxx::_Lock_policy)2>&>(std::__weak_count<(__gnu_cxx::_Lock_policy)2>&) (1x)
          6 ( 0.00%)        { __r._M_ptr = nullptr; }
          .           
          .                 template<typename _Yp, typename = _Compatible<_Yp>>
          .           	__weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
          .           	: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
          .                   { __r._M_ptr = nullptr; }
          .           
          .                 __weak_ptr&
          .                 operator=(const __weak_ptr& __r) noexcept = default;
-- line 2033 ----------------------------------------
-- line 2038 ----------------------------------------
          .           	{
          .           	  _M_ptr = __r.lock().get();
          .           	  _M_refcount = __r._M_refcount;
          .           	  return *this;
          .           	}
          .           
          .                 template<typename _Yp>
          .           	_Assignable<_Yp>
          5 ( 0.00%)  	operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
          .           	{
          4 ( 0.00%)  	  _M_ptr = __r._M_ptr;
          7 ( 0.00%)  	  _M_refcount = __r._M_refcount;
         50 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1x)
          1 ( 0.00%)  	  return *this;
          2 ( 0.00%)  	}
          .           
          .                 __weak_ptr&
          .                 operator=(__weak_ptr&& __r) noexcept
          .                 {
          .           	__weak_ptr(std::move(__r)).swap(*this);
          .           	return *this;
          .                 }
          .           
-- line 2059 ----------------------------------------
-- line 2067 ----------------------------------------
          .           	  return *this;
          .           	}
          .           
          .                 __shared_ptr<_Tp, _Lp>
          .                 lock() const noexcept
          .                 { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }
          .           
          .                 long
          4 ( 0.00%)        use_count() const noexcept
          6 ( 0.00%)        { return _M_refcount._M_get_use_count(); }
         11 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (1x)
          .           
          .                 bool
          4 ( 0.00%)        expired() const noexcept
          8 ( 0.00%)        { return _M_refcount._M_get_use_count() == 0; }
         11 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::_M_get_use_count() const (1x)
          .           
          .                 template<typename _Tp1>
          .           	bool
          .           	owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
          .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
          .           
          .                 template<typename _Tp1>
          .           	bool
-- line 2088 ----------------------------------------
-- line 2098 ----------------------------------------
          .                 {
          .           	std::swap(_M_ptr, __s._M_ptr);
          .           	_M_refcount._M_swap(__s._M_refcount);
          .                 }
          .           
          .               private:
          .                 // Used by __enable_shared_from_this.
          .                 void
          6 ( 0.00%)        _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
          .                 {
          7 ( 0.00%)  	if (use_count() == 0)
         21 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<spdlog::async_logger, (__gnu_cxx::_Lock_policy)2>::use_count() const (1x)
          .           	  {
          3 ( 0.00%)  	    _M_ptr = __ptr;
          6 ( 0.00%)  	    _M_refcount = __refcount;
         47 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_count<(__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_count<(__gnu_cxx::_Lock_policy)2> const&) (1x)
          .           	  }
          3 ( 0.00%)        }
          .           
          .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
          .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
          .                 friend class __enable_shared_from_this<_Tp, _Lp>;
          .                 friend class enable_shared_from_this<_Tp>;
          .           #ifdef __glibcxx_atomic_shared_ptr
          .                 friend _Sp_atomic<weak_ptr<_Tp>>;
          .           #endif
-- line 2121 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/functional_hash.h
--------------------------------------------------------------------------------
Ir                  

-- line 84 ----------------------------------------
         .                 ~__hash_enum();
         .               };
         .           
         .             // Helper struct for hash with enum types.
         .             template<typename _Tp>
         .               struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
         .               {
         .                 size_t
57,465,140 ( 0.05%)        operator()(_Tp __val) const noexcept
         .                 {
         .                  using __type = typename underlying_type<_Tp>::type;
57,465,140 ( 0.05%)         return hash<__type>{}(static_cast<__type>(__val));
       161 ( 0.00%)  => /usr/include/c++/14/bits/functional_hash.h:std::hash<unsigned int>::operator()(unsigned int) const (23x)
22,986,056 ( 0.02%)        }
         .               };
         .           
         .             /// Primary class template hash, usable for enum types only.
         .             // Use with non-enum types still SFINAES.
         .             template<typename _Tp>
         .               struct hash : __hash_enum<_Tp>
         .               { };
         .           
-- line 104 ----------------------------------------
-- line 146 ----------------------------------------
         .           
         .             /// Explicit specialization for char32_t.
         .             _Cxx_hashtable_define_trivial_hash(char32_t)
         .           
         .             /// Explicit specialization for short.
         .             _Cxx_hashtable_define_trivial_hash(short)
         .           
         .             /// Explicit specialization for int.
    32,232 ( 0.00%)    _Cxx_hashtable_define_trivial_hash(int)
         .           
         .             /// Explicit specialization for long.
         .             _Cxx_hashtable_define_trivial_hash(long)
         .           
         .             /// Explicit specialization for long long.
         .             _Cxx_hashtable_define_trivial_hash(long long)
         .           
         .             /// Explicit specialization for unsigned short.
   144,272 ( 0.00%)    _Cxx_hashtable_define_trivial_hash(unsigned short)
         .           
         .             /// Explicit specialization for unsigned int.
80,451,196 ( 0.07%)    _Cxx_hashtable_define_trivial_hash(unsigned int)
         .           
         .             /// Explicit specialization for unsigned long.
 2,507,057 ( 0.00%)    _Cxx_hashtable_define_trivial_hash(unsigned long)
         .           
         .             /// Explicit specialization for unsigned long long.
         .             _Cxx_hashtable_define_trivial_hash(unsigned long long)
         .           
         .           #ifdef __GLIBCXX_TYPE_INT_N_0
         .             __extension__
         .             _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_0)
         .             __extension__
-- line 177 ----------------------------------------
-- line 196 ----------------------------------------
         .             _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_3 unsigned)
         .           #endif
         .           
         .           #undef _Cxx_hashtable_define_trivial_hash
         .           
         .             struct _Hash_impl
         .             {
         .               static size_t
 1,105,422 ( 0.00%)      hash(const void* __ptr, size_t __clength,
         .           	 size_t __seed = static_cast<size_t>(0xc70f6907UL))
 1,658,152 ( 0.00%)      { return _Hash_bytes(__ptr, __clength, __seed); }
17,809,330 ( 0.01%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/hash_bytes.cc:std::_Hash_bytes(void const*, unsigned long, unsigned long) (184,237x)
     1,256 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
         .           
         .               template<typename _Tp>
         .                 static size_t
         .                 hash(const _Tp& __val)
         .                 { return hash(&__val, sizeof(__val)); }
         .           
         .               template<typename _Tp>
         .                 static size_t
-- line 214 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/port/GBIMiddleware.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 2 ----------------------------------------
        .           
        .           #include "Engine.h"
        .           #include "DisplayList.h"
        .           #include "resource/type/ResourceType.h"
        .           #include "resource/type/Array.h"
        .           
        .           extern "C" int GameEngine_OTRSigCheck(const char* data);
        .           
  463,992 ( 0.00%)  extern "C" void gSPDisplayList(Gfx* pkt, Gfx* dl) {
  154,664 ( 0.00%)      char* imgData = (char*) dl;
        .           
  541,324 ( 0.00%)      if (GameEngine_OTRSigCheck(imgData) == 1) {
4,810,453 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (77,332x)
2,448,700 ( 0.00%)          auto resource = Ship::Context::GetInstance()->GetResourceManager()->LoadResource(imgData);
532,248,908 ( 0.44%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (52,100x)
27,823,045 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (52,100x)
13,702,358 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (52,100x)
7,867,100 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (52,100x)
4,741,100 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (52,100x)
4,272,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (52,100x)
4,272,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (52,100x)
2,188,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(decltype(nullptr)) (52,100x)
1,667,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (52,100x)
1,302,500 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (52,100x)
1,302,500 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (52,100x)
  260,500 ( 0.00%)          auto res = std::static_pointer_cast<LUS::DisplayList>(resource);
5,366,300 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::DisplayList> std::static_pointer_cast<LUS::DisplayList, Ship::IResource>(std::shared_ptr<Ship::IResource> const&) (52,100x)
  416,800 ( 0.00%)          dl = &res->Instructions[0];
1,302,500 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::DisplayList, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (52,100x)
  573,100 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Gfx, std::allocator<Gfx> >::operator[](unsigned long) (52,100x)
  312,600 ( 0.00%)      }
4,272,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (52,100x)
4,272,200 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::DisplayList>::~shared_ptr() (52,100x)
        .           
  541,324 ( 0.00%)      __gSPDisplayList(pkt, dl);
  309,328 ( 0.00%)  }
        .           
  150,500 ( 0.00%)  extern "C" void gSPVertex(Gfx* pkt, uintptr_t v, int n, int v0) {
        .           
  150,500 ( 0.00%)      if (GameEngine_OTRSigCheck((char*) v) == 1) {
1,315,447 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (21,500x)
    9,096 ( 0.00%)          v = (uintptr_t) ResourceGetDataByName((char*) v);
26,799,560 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (2,274x)
        .               }
        .           
  494,500 ( 0.00%)      __gSPVertex(pkt, v, n, v0);
   64,500 ( 0.00%)  }
        .           
        .           extern "C" void gSPInvalidateTexCache(Gfx* pkt, uintptr_t texAddr) {
        .               auto data = reinterpret_cast<char*>(texAddr);
        .           
        .               if (texAddr != 0 && GameEngine_OTRSigCheck(data)) {
        .                   const auto res = Ship::Context::GetInstance()->GetResourceManager()->LoadResource(data);
        .                   const auto type = static_cast<LUS::ResourceType>(res->GetInitData()->Type);
        .           
-- line 37 ----------------------------------------
-- line 40 ----------------------------------------
        .                   } else if (res->GetInitData()->Type == static_cast<uint32_t>(MK64::ResourceType::MK_Array)) {
        .                       texAddr = reinterpret_cast<uintptr_t>(std::static_pointer_cast<MK64::Array>(res)->Vertices.data());
        .                   } else {
        .                       texAddr = reinterpret_cast<uintptr_t>(res->GetRawPointer());
        .                   }
        .               }
        .           
        .               __gSPInvalidateTexCache(pkt, texAddr);
       10 ( 0.00%)  }
        9 ( 0.00%)  => src/port/GBIMiddleware.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/basic_string.h
--------------------------------------------------------------------------------
Ir                  

-- line 121 ----------------------------------------
         .           #if __cplusplus < 201103L
         .                 typedef iterator __const_iterator;
         .           #else
         .                 typedef const_iterator __const_iterator;
         .           #endif
         .           
         .               private:
         .                 static _GLIBCXX20_CONSTEXPR pointer
 5,845,918 ( 0.00%)        _S_allocate(_Char_alloc_type& __a, size_type __n)
         .                 {
   449,686 ( 0.00%)  	pointer __p = _Alloc_traits::allocate(__a, __n);
         .           #if __glibcxx_constexpr_string >= 201907L
         .           	// std::char_traits begins the lifetime of characters,
         .           	// but custom traits might not, so do it here.
         .           	if constexpr (!is_same_v<_Traits, char_traits<_CharT>>)
         .           	  if (std::__is_constant_evaluated())
         .           	    // Begin the lifetime of characters in allocated storage.
         .           	    for (size_type __i = 0; __i < __n; ++__i)
         .           	      std::construct_at(__builtin_addressof(__p[__i]));
         .           #endif
   449,686 ( 0.00%)  	return __p;
   899,372 ( 0.00%)        }
         .           
         .           #if __cplusplus >= 201703L
         .                 // A helper type for avoiding boiler-plate.
         .                 typedef basic_string_view<_CharT, _Traits> __sv_type;
         .           
         .                 template<typename _Tp, typename _Res>
         .           	using _If_sv = enable_if_t<
         .           	  __and_<is_convertible<const _Tp&, __sv_type>,
         .           		 __not_<is_convertible<const _Tp*, const basic_string*>>,
         .           		 __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
         .           	  _Res>;
         .           
         .                 // Allows an implicit conversion to __sv_type.
         .                 _GLIBCXX20_CONSTEXPR
         .                 static __sv_type
   149,229 ( 0.00%)        _S_to_string_view(__sv_type __svt) noexcept
    66,324 ( 0.00%)        { return __svt; }
         .           
         .                 // Wraps a string_view by explicit conversion and thus
         .                 // allows to add an internal constructor that does not
         .                 // participate in overload resolution when a string_view
         .                 // is provided.
         .                 struct __sv_wrapper
         .                 {
         .           	_GLIBCXX20_CONSTEXPR explicit
   298,458 ( 0.00%)  	__sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
         .           
         .           	__sv_type _M_sv;
         .                 };
         .           
         .                 /**
         .                  *  @brief  Only internally used: Construct string from a string view
         .                  *          wrapper.
         .                  *  @param  __svw  string view wrapper.
         .                  *  @param  __a  Allocator to use.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 explicit
   215,553 ( 0.00%)        basic_string(__sv_wrapper __svw, const _Alloc& __a)
   298,458 ( 0.00%)        : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
 8,280,699 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, unsigned long, std::allocator<char> const&) (16,581x)
   116,067 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const (16,581x)
   116,067 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::data() const (16,581x)
         .           #endif
         .           
         .                 // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
 4,764,072 ( 0.00%)        struct _Alloc_hider : allocator_type // TODO check __is_final
         .                 {
         .           #if __cplusplus < 201103L
         .           	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
         .           	: allocator_type(__a), _M_p(__dat) { }
         .           #else
         .           	_GLIBCXX20_CONSTEXPR
 4,547,205 ( 0.00%)  	_Alloc_hider(pointer __dat, const _Alloc& __a)
 2,098,744 ( 0.00%)  	: allocator_type(__a), _M_p(__dat) { }
         .           
         .           	_GLIBCXX20_CONSTEXPR
 1,684,116 ( 0.00%)  	_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 4,491,000 ( 0.00%)  	: allocator_type(std::move(__a)), _M_p(__dat) { }
 1,684,116 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::allocator<char>&>::type&& std::move<std::allocator<char>&>(std::allocator<char>&) (280,686x)
         .           #endif
         .           
         .           	pointer _M_p; // The actual data.
         .                 };
         .           
         .                 _Alloc_hider	_M_dataplus;
         .                 size_type		_M_string_length;
         .           
-- line 206 ----------------------------------------
-- line 209 ----------------------------------------
         .                 union
         .                 {
         .           	_CharT           _M_local_buf[_S_local_capacity + 1];
         .           	size_type        _M_allocated_capacity;
         .                 };
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
 1,908,976 ( 0.00%)        _M_data(pointer __p)
 2,863,484 ( 0.00%)        { _M_dataplus._M_p = __p; }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
 2,882,164 ( 0.00%)        _M_length(size_type __length)
 4,323,378 ( 0.00%)        { _M_string_length = __length; }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 pointer
12,125,505 ( 0.01%)        _M_data() const
16,210,870 ( 0.01%)        { return _M_dataplus._M_p; }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 pointer
 2,616,052 ( 0.00%)        _M_local_data()
         .                 {
         .           #if __cplusplus >= 201103L
 2,616,146 ( 0.00%)  	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
15,696,312 ( 0.01%)  => /usr/include/c++/14/bits/ptr_traits.h:std::__ptr_traits_ptr_to<char*, char, false>::pointer_to(char&) (654,013x)
         .           #else
         .           	return pointer(_M_local_buf);
         .           #endif
 1,308,026 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 const_pointer
 2,923,548 ( 0.00%)        _M_local_data() const
         .                 {
         .           #if __cplusplus >= 201103L
 2,923,608 ( 0.00%)  	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
17,541,288 ( 0.01%)  => /usr/include/c++/14/bits/ptr_traits.h:std::__ptr_traits_ptr_to<char const*, char const, false>::pointer_to(char const&) (730,887x)
         .           #else
         .           	return const_pointer(_M_local_buf);
         .           #endif
 1,461,774 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
 1,814,808 ( 0.00%)        _M_capacity(size_type __capacity)
 2,722,227 ( 0.00%)        { _M_allocated_capacity = __capacity; }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
 3,484,990 ( 0.00%)        _M_set_length(size_type __n)
         .                 {
 3,484,990 ( 0.00%)  	_M_length(__n);
 6,969,980 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_length(unsigned long) (696,998x)
 6,969,980 ( 0.01%)  	traits_type::assign(_M_data()[__n], _CharT());
10,454,970 ( 0.01%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::assign(char&, char const&) (696,998x)
 4,878,986 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (696,998x)
 2,091,008 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 bool
 3,654,435 ( 0.00%)        _M_is_local() const
         .                 {
 8,039,967 ( 0.01%)  	if (_M_data() == _M_local_data())
24,850,158 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() const (730,887x)
 5,116,209 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (730,887x)
         .           	  {
   874,649 ( 0.00%)  	    if (_M_string_length > _S_local_capacity)
         .           	      __builtin_unreachable();
   583,098 ( 0.00%)  	    return true;
         .           	  }
   439,338 ( 0.00%)  	return false;
 2,192,661 ( 0.00%)        }
         .           
         .                 // Create & Destroy
         .                 _GLIBCXX20_CONSTEXPR
         .                 pointer
         .                 _M_create(size_type&, size_type);
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
 2,535,164 ( 0.00%)        _M_dispose()
         .                 {
 3,802,746 ( 0.00%)  	if (!_M_is_local())
39,536,787 ( 0.03%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const (633,791x)
 2,489,442 ( 0.00%)  	  _M_destroy(_M_allocated_capacity);
66,878,645 ( 0.06%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_destroy(unsigned long) (414,907x)
 1,901,373 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
 2,904,349 ( 0.00%)        _M_destroy(size_type __size) throw()
 9,957,768 ( 0.01%)        { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
 2,904,349 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (414,907x)
 2,489,442 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() (414,907x)
         .           
         .           #if __cplusplus < 201103L || defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .                 // _M_construct_aux is used to implement the 21.3.1 para 15 which
         .                 // requires special behaviour if _InIterator is an integral type
         .                 template<typename _InIterator>
         .                   void
         .                   _M_construct_aux(_InIterator __beg, _InIterator __end,
         .           			 std::__false_type)
-- line 302 ----------------------------------------
-- line 333 ----------------------------------------
         .           		     std::forward_iterator_tag);
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
         .                 _M_construct(size_type __req, _CharT __c);
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 allocator_type&
 2,680,440 ( 0.00%)        _M_get_allocator()
 2,680,440 ( 0.00%)        { return _M_dataplus; }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 const allocator_type&
 1,742,325 ( 0.00%)        _M_get_allocator() const
 1,742,325 ( 0.00%)        { return _M_dataplus; }
         .           
         .                 // Ensure that _M_local_buf is the active member of the union.
         .                 __attribute__((__always_inline__))
         .                 _GLIBCXX14_CONSTEXPR
         .                 void
         .                 _M_init_local_buf() _GLIBCXX_NOEXCEPT
         .                 {
         .           #if __glibcxx_is_constant_evaluated
   716,226 ( 0.00%)  	if (std::is_constant_evaluated())
    20,890 ( 0.00%)  => /usr/include/c++/14/type_traits:std::is_constant_evaluated() (4,178x)
         .           	  for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
         .           	    _M_local_buf[__i] = _CharT();
         .           #endif
   238,742 ( 0.00%)        }
         .           
         .                 __attribute__((__always_inline__))
         .                 _GLIBCXX14_CONSTEXPR
         .                 pointer
         .                 _M_use_local_data() _GLIBCXX_NOEXCEPT
         .                 {
         .           #if __cpp_lib_is_constant_evaluated
         .           	_M_init_local_buf();
         .           #endif
   117,710 ( 0.00%)  	return _M_local_data();
     4,998 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (147x)
         .                 }
         .           
         .               private:
         .           
         .           #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
         .                 // The explicit instantiations in misc-inst.cc require this due to
         .                 // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063
         .                 template<typename _Tp, bool _Requires =
-- line 378 ----------------------------------------
-- line 383 ----------------------------------------
         .           	struct __enable_if_not_native_iterator
         .           	{ typedef basic_string& __type; };
         .                 template<typename _Tp>
         .           	struct __enable_if_not_native_iterator<_Tp, false> { };
         .           #endif
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 size_type
 1,619,172 ( 0.00%)        _M_check(size_type __pos, const char* __s) const
         .                 {
 1,889,034 ( 0.00%)  	if (__pos > this->size())
 1,889,034 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (269,862x)
         .           	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
         .           				       "this->size() (which is %zu)"),
         .           				   __s, __pos, this->size());
   269,862 ( 0.00%)  	return __pos;
   539,724 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
   152,680 ( 0.00%)        _M_check_length(size_type __n1, size_type __n2, const char* __s) const
         .                 {
   267,190 ( 0.00%)  	if (this->max_size() - (this->size() - __n1) < __n2)
   362,615 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::max_size() const (19,085x)
   133,595 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (19,085x)
         .           	  __throw_length_error(__N(__s));
    76,340 ( 0.00%)        }
         .           
         .           
         .                 // NB: _M_limit doesn't check for a bad __pos value.
         .                 _GLIBCXX20_CONSTEXPR
         .                 size_type
   809,586 ( 0.00%)        _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
         .                 {
   944,517 ( 0.00%)  	const bool __testoff =  __off < this->size() - __pos;
   944,517 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (134,931x)
   788,579 ( 0.00%)  	return __testoff ? __off : this->size() - __pos;
   870,982 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (124,426x)
   269,862 ( 0.00%)        }
         .           
         .                 // True if _Rep and source do not overlap.
         .                 bool
     1,374 ( 0.00%)        _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
         .                 {
     2,061 ( 0.00%)  	return (less<const _CharT*>()(__s, _M_data())
     3,206 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<char const*>::operator()(char const*, char const*) const (229x)
     1,603 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (229x)
     3,736 ( 0.00%)  		|| less<const _CharT*>()(_M_data() + this->size(), __s));
     2,632 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<char const*>::operator()(char const*, char const*) const (188x)
     1,316 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (188x)
     1,316 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (188x)
       687 ( 0.00%)        }
         .           
         .                 // When __n = 1 way faster than the general multichar
         .                 // traits_type::copy/move/assign.
         .                 _GLIBCXX20_CONSTEXPR
         .                 static void
 3,754,602 ( 0.00%)        _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
         .                 {
 1,251,624 ( 0.00%)  	if (__n == 1)
   131,680 ( 0.00%)  	  traits_type::assign(*__d, *__s);
   395,040 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::assign(char&, char const&) (26,336x)
         .           	else
 3,596,586 ( 0.00%)  	  traits_type::copy(__d, __s, __n);
20,678,737 ( 0.02%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::copy(char*, char const*, unsigned long) (599,431x)
 1,903,638 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 static void
     1,266 ( 0.00%)        _S_move(_CharT* __d, const _CharT* __s, size_type __n)
         .                 {
       422 ( 0.00%)  	if (__n == 1)
        10 ( 0.00%)  	  traits_type::assign(*__d, *__s);
        30 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::assign(char&, char const&) (2x)
         .           	else
     1,254 ( 0.00%)  	  traits_type::move(__d, __s, __n);
     8,301 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::move(char*, char const*, unsigned long) (209x)
       635 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 static void
        84 ( 0.00%)        _S_assign(_CharT* __d, size_type __n, _CharT __c)
         .                 {
        24 ( 0.00%)  	if (__n == 1)
         .           	  traits_type::assign(*__d, __c);
         .           	else
        84 ( 0.00%)  	  traits_type::assign(__d, __n, __c);
     8,934 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::assign(char*, unsigned long, char) (12x)
        36 ( 0.00%)        }
         .           
         .                 // _S_copy_chars is a separate template to permit specialization
         .                 // to optimize for the common case of pointers as iterators.
         .                 template<class _Iterator>
         .           	_GLIBCXX20_CONSTEXPR
         .                   static void
         .                   _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
         .                   {
-- line 464 ----------------------------------------
-- line 474 ----------------------------------------
         .                 _GLIBCXX20_CONSTEXPR
         .                 static void
         .                 _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
         .                 _GLIBCXX_NOEXCEPT
         .                 { _S_copy_chars(__p, __k1.base(), __k2.base()); }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 static void
   515,202 ( 0.00%)        _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
   944,537 ( 0.00%)        { _S_copy(__p, __k1, __k2 - __k1); }
 4,498,217 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (85,867x)
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 static void
 2,883,144 ( 0.00%)        _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
         .                 _GLIBCXX_NOEXCEPT
 5,285,764 ( 0.00%)        { _S_copy(__p, __k1, __k2 - __k1); }
24,208,699 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (480,524x)
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 static int
    69,524 ( 0.00%)        _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
         .                 {
    52,143 ( 0.00%)  	const difference_type __d = difference_type(__n1 - __n2);
         .           
    52,143 ( 0.00%)  	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
         .           	  return __gnu_cxx::__numeric_traits<int>::__max;
    52,143 ( 0.00%)  	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
         .           	  return __gnu_cxx::__numeric_traits<int>::__min;
         .           	else
    17,381 ( 0.00%)  	  return int(__d);
    34,762 ( 0.00%)        }
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
         .                 _M_assign(const basic_string&);
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
         .                 _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
-- line 511 ----------------------------------------
-- line 519 ----------------------------------------
         .                 // Construct/copy/destroy:
         .                 // NB: We overload ctors in some cases instead of using default
         .                 // arguments, per 17.4.4.4 para. 2 item 2.
         .           
         .                 /**
         .                  *  @brief  Default constructor creates an empty string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
   182,475 ( 0.00%)        basic_string()
         .                 _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)
   437,940 ( 0.00%)        : _M_dataplus(_M_local_data())
 1,240,830 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (36,495x)
 1,094,850 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char>&&) (36,495x)
         .                 {
         .           	_M_init_local_buf();
   145,980 ( 0.00%)  	_M_set_length(0);
 2,007,225 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (36,495x)
   145,980 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct an empty string using allocator @a a.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 explicit
    25,068 ( 0.00%)        basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT
    50,136 ( 0.00%)        : _M_dataplus(_M_local_data(), __a)
   142,052 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (4,178x)
    87,738 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char> const&) (4,178x)
         .                 {
         .           	_M_init_local_buf();
    16,712 ( 0.00%)  	_M_set_length(0);
   229,790 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (4,178x)
    16,712 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct string with copy of value of @a __str.
         .                  *  @param  __str  Source string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
   515,202 ( 0.00%)        basic_string(const basic_string& __str)
   858,670 ( 0.00%)        : _M_dataplus(_M_local_data(),
 2,919,478 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (85,867x)
 2,576,010 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char>&&) (85,867x)
 1,202,138 ( 0.00%)  		    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
   515,202 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() const (85,867x)
         .                 {
 1,459,758 ( 0.00%)  	_M_construct(__str._M_data(), __str._M_data() + __str.length(),
29,168,169 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char*>(char*, char*, std::forward_iterator_tag) (85,867x)
 1,202,138 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (171,734x)
   601,069 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (85,867x)
         .           		     std::forward_iterator_tag());
   343,468 ( 0.00%)        }
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2583. no way to supply an allocator for basic_string(str, pos)
         .                 /**
         .                  *  @brief  Construct string as copy of a substring.
         .                  *  @param  __str  Source string.
         .                  *  @param  __pos  Index of first character to copy from.
         .                  *  @param  __a  Allocator to use.
-- line 566 ----------------------------------------
-- line 578 ----------------------------------------
         .           
         .                 /**
         .                  *  @brief  Construct string as copy of a substring.
         .                  *  @param  __str  Source string.
         .                  *  @param  __pos  Index of first character to copy from.
         .                  *  @param  __n  Number of characters to copy.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
 1,079,432 ( 0.00%)        basic_string(const basic_string& __str, size_type __pos,
         .           		   size_type __n)
 1,619,148 ( 0.00%)        : _M_dataplus(_M_local_data())
 4,587,586 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (134,929x)
 4,047,870 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char>&&) (134,929x)
         .                 {
   809,574 ( 0.00%)  	const _CharT* __start = __str._M_data()
   944,503 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (134,929x)
   809,574 ( 0.00%)  	  + __str._M_check(__pos, "basic_string::basic_string");
 3,103,367 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check(unsigned long, char const*) const (134,929x)
 1,754,080 ( 0.00%)  	_M_construct(__start, __start + __str._M_limit(__pos, __n),
50,150,937 ( 0.04%)  => /usr/include/c++/14/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) (134,929x)
 4,627,988 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_limit(unsigned long, unsigned long) const (134,929x)
         .           		     std::forward_iterator_tag());
   539,717 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct string as copy of a substring.
         .                  *  @param  __str  Source string.
         .                  *  @param  __pos  Index of first character to copy from.
         .                  *  @param  __n  Number of characters to copy.
         .                  *  @param  __a  Allocator to use.
         .                  */
-- line 602 ----------------------------------------
-- line 616 ----------------------------------------
         .                  *  @param  __s  Source character %array.
         .                  *  @param  __n  Number of characters to copy.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  *
         .                  *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
         .                  *  has no special meaning.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
   134,376 ( 0.00%)        basic_string(const _CharT* __s, size_type __n,
         .           		   const _Alloc& __a = _Alloc())
   167,970 ( 0.00%)        : _M_dataplus(_M_local_data(), __a)
   571,098 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (16,797x)
   352,737 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char> const&) (16,797x)
         .                 {
         .           	// NB: Not required, but considered best practice.
    33,622 ( 0.00%)  	if (__s == 0 && __n > 0)
         .           	  std::__throw_logic_error(__N("basic_string: "
         .           				       "construction from null is not valid"));
   134,420 ( 0.00%)  	_M_construct(__s, __s + __n, std::forward_iterator_tag());
 6,885,671 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) (16,797x)
    67,188 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct string as copy of a C string.
         .                  *  @param  __s  Source C string.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 3076. basic_string CTAD ambiguity
         .                 template<typename = _RequireAllocator<_Alloc>>
         .           #endif
         .                 _GLIBCXX20_CONSTEXPR
 2,301,586 ( 0.00%)        basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
 3,287,980 ( 0.00%)        : _M_dataplus(_M_local_data(), __a)
11,179,132 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (328,798x)
 6,904,758 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char> const&) (328,798x)
         .                 {
         .           	// NB: Not required, but considered best practice.
   657,596 ( 0.00%)  	if (__s == 0)
         .           	  std::__throw_logic_error(__N("basic_string: "
         .           				       "construction from null is not valid"));
 1,972,788 ( 0.00%)  	const _CharT* __end = __s + traits_type::length(__s);
10,501,582 ( 0.01%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (328,798x)
 1,972,836 ( 0.00%)  	_M_construct(__s, __end, forward_iterator_tag());
115,762,229 ( 0.10%)  => /usr/include/c++/14/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) (328,798x)
 1,315,192 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct string as multiple characters.
         .                  *  @param  __n  Number of characters.
         .                  *  @param  __c  Character to use.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 3076. basic_string CTAD ambiguity
         .                 template<typename = _RequireAllocator<_Alloc>>
         .           #endif
         .                 _GLIBCXX20_CONSTEXPR
       108 ( 0.00%)        basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
       120 ( 0.00%)        : _M_dataplus(_M_local_data(), __a)
       408 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (12x)
       252 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char> const&) (12x)
       120 ( 0.00%)        { _M_construct(__n, __c); }
   113,464 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct(unsigned long, char) (12x)
         .           
         .           #if __cplusplus >= 201103L
         .                 /**
         .                  *  @brief  Move construct string.
         .                  *  @param  __str  Source string.
         .                  *
         .                  *  The newly-created string contains the exact contents of @a __str.
         .                  *  @a __str is a valid, but unspecified string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
   163,767 ( 0.00%)        basic_string(basic_string&& __str) noexcept
   327,530 ( 0.00%)        : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
   795,430 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_local_data() (23,395x)
   701,850 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider(char*, std::allocator<char>&&) (23,395x)
   140,370 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() (23,395x)
   140,370 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::allocator<char>&>::type&& std::move<std::allocator<char>&>(std::allocator<char>&) (23,395x)
         .                 {
   156,031 ( 0.00%)  	if (__str._M_is_local())
 1,505,207 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const (23,395x)
         .           	  {
         .           	    _M_init_local_buf();
   175,768 ( 0.00%)  	    traits_type::copy(_M_local_buf, __str._M_local_buf,
   721,330 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::copy(char*, char const*, unsigned long) (19,528x)
    58,584 ( 0.00%)  			      __str.length() + 1);
   136,696 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (19,528x)
         .           	  }
         .           	else
         .           	  {
    30,936 ( 0.00%)  	    _M_data(__str._M_data());
    38,670 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (3,867x)
    27,069 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (3,867x)
    23,202 ( 0.00%)  	    _M_capacity(__str._M_allocated_capacity);
    38,670 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (3,867x)
         .           	  }
         .           
         .           	// Must use _M_length() here not _M_set_length() because
         .           	// basic_stringbuf relies on writing into unallocated capacity so
         .           	// we mess up the contents if we put a '\0' in the string.
   280,740 ( 0.00%)  	_M_length(__str.length());
   163,765 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (23,395x)
   233,950 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_length(unsigned long) (23,395x)
    93,580 ( 0.00%)  	__str._M_data(__str._M_use_local_data());
   233,950 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (23,395x)
    93,580 ( 0.00%)  	__str._M_set_length(0);
 1,286,725 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (23,395x)
   140,371 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Construct string from an initializer %list.
         .                  *  @param  __l  std::initializer_list of characters.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
-- line 711 ----------------------------------------
-- line 792 ----------------------------------------
         .                 /**
         .                  *  @brief  Construct string from a string_view.
         .                  *  @param  __t  Source object convertible to string view.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .                 template<typename _Tp, typename = _If_sv<_Tp, void>>
         .           	_GLIBCXX20_CONSTEXPR
         .           	explicit
    99,486 ( 0.00%)  	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
   331,620 ( 0.00%)  	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
 9,026,844 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__sv_wrapper, std::allocator<char> const&) (16,581x)
   298,458 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__sv_wrapper::__sv_wrapper(std::basic_string_view<char, std::char_traits<char> >) (16,581x)
   215,553 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_to_string_view(std::basic_string_view<char, std::char_traits<char> >) (16,581x)
         .           #endif // C++17
         .           
         .                 /**
         .                  *  @brief  Destroy the string instance.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
 2,382,036 ( 0.00%)        ~basic_string()
 5,359,581 ( 0.00%)        { _M_dispose(); }
113,944,614 ( 0.09%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_dispose() (595,509x)
 5,359,581 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::~_Alloc_hider() (595,509x)
         .           
         .                 /**
         .                  *  @brief  Assign the value of @a str to this string.
         .                  *  @param  __str  Source string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
   169,020 ( 0.00%)        operator=(const basic_string& __str)
         .                 {
   169,020 ( 0.00%)  	return this->assign(__str);
25,165,622 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (33,804x)
    67,608 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Copy contents of @a s into this string.
         .                  *  @param  __s  Source null-terminated string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
     4,080 ( 0.00%)        operator=(const _CharT* __s)
     5,712 ( 0.00%)        { return this->assign(__s); }
   640,607 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::assign(char const*) (816x)
         .           
         .                 /**
         .                  *  @brief  Set value to string of length 1.
         .                  *  @param  __c  Source character.
         .                  *
         .                  *  Assigning to a character makes this string length 1 and
         .                  *  (*this)[0] == @a c.
         .                  */
-- line 837 ----------------------------------------
-- line 850 ----------------------------------------
         .                  *
         .                  *  The contents of @a str are moved into this string (without copying).
         .                  *  @a str is a valid, but unspecified string.
         .                  */
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2063. Contradictory requirements for string move assignment
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
    19,306 ( 0.00%)        operator=(basic_string&& __str)
         .                 noexcept(_Alloc_traits::_S_nothrow_move())
         .                 {
     2,746 ( 0.00%)  	const bool __equal_allocs = _Alloc_traits::_S_always_equal()
         .           	  || _M_get_allocator() == __str._M_get_allocator();
    22,097 ( 0.00%)  	if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
   177,974 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const (2,746x)
     2,746 ( 0.00%)  	    && !__equal_allocs)
         .           	  {
         .           	    // Destroy existing storage before replacing allocator.
         .           	    _M_destroy(_M_allocated_capacity);
         .           	    _M_data(_M_local_data());
         .           	    _M_set_length(0);
         .           	  }
         .           	// Replace allocator if POCMA is true.
    24,714 ( 0.00%)  	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
    32,952 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() (5,492x)
         .           
    13,730 ( 0.00%)  	if (__str._M_is_local())
   177,898 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const (2,746x)
         .           	  {
         .           	    // We've always got room for a short string, just copy it
         .           	    // (unless this is a self-move, because that would violate the
         .           	    // char_traits::copy precondition that the ranges don't overlap).
    26,008 ( 0.00%)  	    if (__builtin_expect(std::__addressof(__str) != this, true))
    15,588 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >* std::__addressof<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (2,598x)
         .           	      {
    18,214 ( 0.00%)  		if (__str.size())
    18,186 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (2,598x)
    38,970 ( 0.00%)  		  this->_S_copy(_M_data(), __str._M_data(), __str.size());
   139,733 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (2,598x)
    18,186 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (2,598x)
    36,372 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (5,196x)
    23,382 ( 0.00%)  		_M_set_length(__str.size());
   142,890 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (2,598x)
    18,186 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (2,598x)
         .           	      }
         .           	  }
       444 ( 0.00%)  	else if (_Alloc_traits::_S_propagate_on_move_assign() || __equal_allocs)
         .           	  {
         .           	    // Just move the allocated pointer, our allocator can free it.
       148 ( 0.00%)  	    pointer __data = nullptr;
         .           	    size_type __capacity;
       888 ( 0.00%)  	    if (!_M_is_local())
     9,616 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const (148x)
         .           	      {
         .           		if (__equal_allocs)
         .           		  {
         .           		    // __str can reuse our existing storage.
         4 ( 0.00%)  		    __data = _M_data();
         7 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (1x)
         3 ( 0.00%)  		    __capacity = _M_allocated_capacity;
         .           		  }
         .           		else // __str can't use it, so free it.
         .           		  _M_destroy(_M_allocated_capacity);
         .           	      }
         .           
     1,184 ( 0.00%)  	    _M_data(__str._M_data());
     1,036 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (148x)
     1,480 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (148x)
     1,184 ( 0.00%)  	    _M_length(__str.length());
     1,480 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_length(unsigned long) (148x)
     1,036 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (148x)
       888 ( 0.00%)  	    _M_capacity(__str._M_allocated_capacity);
     1,480 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (148x)
       296 ( 0.00%)  	    if (__data)
         .           	      {
         5 ( 0.00%)  		__str._M_data(__data);
        10 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (1x)
       594 ( 0.00%)  		__str._M_capacity(__capacity);
        10 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (1x)
         .           	      }
         .           	    else
       735 ( 0.00%)  	      __str._M_data(__str._M_use_local_data());
     1,470 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (147x)
         .           	  }
         .           	else // Need to do a deep copy
         .           	  _M_assign(__str);
     8,238 ( 0.00%)  	__str.clear();
   181,236 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::clear() (2,746x)
     2,746 ( 0.00%)  	return *this;
    13,790 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Set value to string constructed from initializer %list.
         .                  *  @param  __l  std::initializer_list.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
         .                 operator=(initializer_list<_CharT> __l)
-- line 926 ----------------------------------------
-- line 941 ----------------------------------------
         .                  operator=(const _Tp& __svt)
         .                  { return this->assign(__svt); }
         .           
         .                 /**
         .                  *  @brief  Convert to a string_view.
         .                  *  @return A string_view.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
   315,150 ( 0.00%)        operator __sv_type() const noexcept
 1,134,540 ( 0.00%)        { return __sv_type(data(), size()); }
 1,008,480 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (63,030x)
   882,420 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::basic_string_view(char const*, unsigned long) (63,030x)
   441,210 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (63,030x)
         .           #endif // C++17
         .           
         .                 // Iterators:
         .                 /**
         .                  *  Returns a read/write iterator that points to the first character in
         .                  *  the %string.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
-- line 958 ----------------------------------------
-- line 961 ----------------------------------------
         .                 { return iterator(_M_data()); }
         .           
         .                 /**
         .                  *  Returns a read-only (constant) iterator that points to the first
         .                  *  character in the %string.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 const_iterator
     3,376 ( 0.00%)        begin() const _GLIBCXX_NOEXCEPT
    10,128 ( 0.00%)        { return const_iterator(_M_data()); }
     9,284 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::__normal_iterator(char const* const&) (844x)
     5,908 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (844x)
         .           
         .                 /**
         .                  *  Returns a read/write iterator that points one past the last
         .                  *  character in the %string.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 iterator
         .                 end() _GLIBCXX_NOEXCEPT
-- line 978 ----------------------------------------
-- line 979 ----------------------------------------
         .                 { return iterator(_M_data() + this->size()); }
         .           
         .                 /**
         .                  *  Returns a read-only (constant) iterator that points one past the
         .                  *  last character in the %string.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 const_iterator
     4,220 ( 0.00%)        end() const _GLIBCXX_NOEXCEPT
    15,196 ( 0.00%)        { return const_iterator(_M_data() + this->size()); }
     9,284 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::__normal_iterator(char const* const&) (844x)
     5,908 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (844x)
     5,908 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (844x)
         .           
         .                 /**
         .                  *  Returns a read/write reverse iterator that points to the last
         .                  *  character in the %string.  Iteration is done in reverse element
         .                  *  order.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 reverse_iterator
-- line 996 ----------------------------------------
-- line 1068 ----------------------------------------
         .           #endif
         .           
         .               public:
         .                 // Capacity:
         .                 ///  Returns the number of characters in the string, not including any
         .                 ///  null-termination.
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
 4,187,118 ( 0.00%)        size() const _GLIBCXX_NOEXCEPT
 5,582,874 ( 0.00%)        { return _M_string_length; }
         .           
         .                 ///  Returns the number of characters in the string, not including any
         .                 ///  null-termination.
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
 1,165,242 ( 0.00%)        length() const _GLIBCXX_NOEXCEPT
 1,553,671 ( 0.00%)        { return _M_string_length; }
         .           
         .                 ///  Returns the size() of the largest possible %string.
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
 1,962,924 ( 0.00%)        max_size() const _GLIBCXX_NOEXCEPT
 3,925,848 ( 0.00%)        { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
 2,944,386 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() const (490,731x)
         .           
         .                 /**
         .                  *  @brief  Resizes the %string to the specified number of characters.
         .                  *  @param  __n  Number of characters the %string should contain.
         .                  *  @param  __c  Character to fill any new elements.
         .                  *
         .                  *  This function will %resize the %string to the specified
         .                  *  number of characters.  If the number is smaller than the
-- line 1098 ----------------------------------------
-- line 1110 ----------------------------------------
         .                  *  This function will resize the %string to the specified length.  If
         .                  *  the new size is smaller than the %string's current size the %string
         .                  *  is truncated, otherwise the %string is extended and new characters
         .                  *  are default-constructed.  For basic types such as char, this means
         .                  *  setting them to 0.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
        10 ( 0.00%)        resize(size_type __n)
        18 ( 0.00%)        { this->resize(__n, _CharT()); }
       174 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::resize(unsigned long, char) (2x)
         .           
         .           #if __cplusplus >= 201103L
         .           #pragma GCC diagnostic push
         .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .                 ///  A non-binding request to reduce capacity() to size().
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
         .                 shrink_to_fit() noexcept
-- line 1127 ----------------------------------------
-- line 1172 ----------------------------------------
         .           #endif
         .           
         .                 /**
         .                  *  Returns the total number of characters that the %string can hold
         .                  *  before needing to allocate more memory.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
   272,244 ( 0.00%)        capacity() const _GLIBCXX_NOEXCEPT
         .                 {
   428,672 ( 0.00%)  	return _M_is_local() ? size_type(_S_local_capacity)
 4,342,821 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_is_local() const (68,061x)
    47,775 ( 0.00%)  	                     : _M_allocated_capacity;
   136,122 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Attempt to preallocate enough memory for specified number of
         .                  *          characters.
         .                  *  @param  __res_arg  Number of characters required.
         .                  *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
         .                  *
         .                  *  This function attempts to reserve enough memory for the
-- line 1192 ----------------------------------------
-- line 1214 ----------------------------------------
         .                 void
         .                 reserve();
         .           
         .                 /**
         .                  *  Erases the string, making it empty.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
    12,632 ( 0.00%)        clear() _GLIBCXX_NOEXCEPT
    22,106 ( 0.00%)        { _M_set_length(0); }
   173,690 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (3,158x)
         .           
         .                 /**
         .                  *  Returns true if the %string is empty.  Equivalent to 
         .                  *  <code>*this == ""</code>.
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 bool
    90,636 ( 0.00%)        empty() const _GLIBCXX_NOEXCEPT
   158,613 ( 0.00%)        { return this->size() == 0; }
   158,613 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (22,659x)
         .           
         .                 // Element access:
         .                 /**
         .                  *  @brief  Subscript access to the data contained in the %string.
         .                  *  @param  __pos  The index of the character to access.
         .                  *  @return  Read-only (constant) reference to the character.
         .                  *
         .                  *  This operator allows for easy, array-style, data access.
         .                  *  Note that data access with this operator is unchecked and
         .                  *  out_of_range lookups are not defined. (For checked lookups
         .                  *  see at().)
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 const_reference
   252,135 ( 0.00%)        operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
         .                 {
   100,854 ( 0.00%)  	__glibcxx_assert(__pos <= size());
   252,135 ( 0.00%)  	return _M_data()[__pos];
   352,989 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (50,427x)
   100,854 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Subscript access to the data contained in the %string.
         .                  *  @param  __pos  The index of the character to access.
         .                  *  @return  Read/write reference to the character.
         .                  *
         .                  *  This operator allows for easy, array-style, data access.
         .                  *  Note that data access with this operator is unchecked and
         .                  *  out_of_range lookups are not defined. (For checked lookups
         .                  *  see at().)
         .                  */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 reference
        10 ( 0.00%)        operator[](size_type __pos)
         .                 {
         .                   // Allow pos == size() both in C++98 mode, as v3 extension,
         .           	// and in C++11 mode.
         4 ( 0.00%)  	__glibcxx_assert(__pos <= size());
         .                   // In pedantic mode be strict in C++98 mode.
         .           	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
        10 ( 0.00%)  	return _M_data()[__pos];
        14 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (2x)
         4 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Provides access to the data contained in the %string.
         .                  *  @param __n The index of the character to access.
         .                  *  @return  Read-only (const) reference to the character.
         .                  *  @throw  std::out_of_range  If @a n is an invalid index.
         .                  *
         .                  *  This function provides for safer data access.  The parameter is
-- line 1281 ----------------------------------------
-- line 1369 ----------------------------------------
         .                 // Modifiers:
         .                 /**
         .                  *  @brief  Append a string to this string.
         .                  *  @param __str  The string to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
    16,980 ( 0.00%)        operator+=(const basic_string& __str)
    23,772 ( 0.00%)        { return this->append(__str); }
 2,286,068 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (3,396x)
         .           
         .                 /**
         .                  *  @brief  Append a C string.
         .                  *  @param __s  The C string to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
       125 ( 0.00%)        operator+=(const _CharT* __s)
       175 ( 0.00%)        { return this->append(__s); }
    25,295 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(char const*) (25x)
         .           
         .                 /**
         .                  *  @brief  Append a character.
         .                  *  @param __c  The character to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
     1,422 ( 0.00%)        operator+=(_CharT __c)
         .                 {
     1,185 ( 0.00%)  	this->push_back(__c);
    46,713 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::push_back(char) (237x)
       237 ( 0.00%)  	return *this;
       474 ( 0.00%)        }
         .           
         .           #if __cplusplus >= 201103L
         .                 /**
         .                  *  @brief  Append an initializer_list of characters.
         .                  *  @param __l  The initializer_list of characters to be appended.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
-- line 1409 ----------------------------------------
-- line 1416 ----------------------------------------
         .                 /**
         .                  *  @brief  Append a string_view.
         .                  *  @param __svt  An object convertible to string_view to be appended.
         .                  *  @return  Reference to this string.
         .                  */
         .                 template<typename _Tp>
         .           	_GLIBCXX20_CONSTEXPR
         .           	_If_sv<_Tp, basic_string&>
        20 ( 0.00%)  	operator+=(const _Tp& __svt)
        28 ( 0.00%)  	{ return this->append(__svt); }
     1,404 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::enable_if<std::__and_<std::is_convertible<std::basic_string_view<char, std::char_traits<char> > const&, std::basic_string_view<char, std::char_traits<char> > >, std::__not_<std::is_convertible<std::basic_string_view<char, std::char_traits<char> > const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*> >, std::__not_<std::is_convertible<std::basic_string_view<char, std::char_traits<char> > const&, char const*> > >::value, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append<std::basic_string_view<char, std::char_traits<char> > >(std::basic_string_view<char, std::char_traits<char> > const&) (4x)
         .           #endif // C++17
         .           
         .                 /**
         .                  *  @brief  Append a string to this string.
         .                  *  @param __str  The string to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
    23,244 ( 0.00%)        append(const basic_string& __str)
    61,984 ( 0.00%)        { return this->append(__str._M_data(), __str.size()); }
 2,317,743 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(char const*, unsigned long) (3,874x)
    27,118 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (3,874x)
    27,118 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (3,874x)
         .           
         .                 /**
         .                  *  @brief  Append a substring.
         .                  *  @param __str  The string to append.
         .                  *  @param __pos  Index of the first character of str to append.
         .                  *  @param __n  The number of characters to append.
         .                  *  @return  Reference to this string.
         .                  *  @throw  std::out_of_range if @a __pos is not a valid index.
-- line 1444 ----------------------------------------
-- line 1458 ----------------------------------------
         .                 /**
         .                  *  @brief  Append a C substring.
         .                  *  @param __s  The C string to append.
         .                  *  @param __n  The number of characters to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
   108,072 ( 0.00%)        append(const _CharT* __s, size_type __n)
         .                 {
         .           	__glibcxx_requires_string_len(__s, __n);
   108,072 ( 0.00%)  	_M_check_length(size_type(0), __n, "basic_string::append");
   936,624 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check_length(unsigned long, unsigned long, char const*) const (18,012x)
   108,072 ( 0.00%)  	return _M_append(__s, __n);
 5,596,713 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_append(char const*, unsigned long) (18,012x)
    36,024 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Append a C string.
         .                  *  @param __s  The C string to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
       185 ( 0.00%)        append(const _CharT* __s)
         .                 {
         .           	__glibcxx_requires_string(__s);
       148 ( 0.00%)  	const size_type __n = traits_type::length(__s);
     1,036 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (37x)
       222 ( 0.00%)  	_M_check_length(size_type(0), __n, "basic_string::append");
     1,924 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check_length(unsigned long, unsigned long, char const*) const (37x)
       222 ( 0.00%)  	return _M_append(__s, __n);
    25,526 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_append(char const*, unsigned long) (37x)
        74 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Append multiple characters.
         .                  *  @param __n  The number of characters to append.
         .                  *  @param __c  The character to use.
         .                  *  @return  Reference to this string.
         .                  *
         .                  *  Appends __n copies of __c to this string.
-- line 1494 ----------------------------------------
-- line 1533 ----------------------------------------
         .                 /**
         .                  *  @brief  Append a string_view.
         .                  *  @param __svt  An object convertible to string_view to be appended.
         .                  *  @return  Reference to this string.
         .                  */
         .                 template<typename _Tp>
         .           	_GLIBCXX20_CONSTEXPR
         .                   _If_sv<_Tp, basic_string&>
        24 ( 0.00%)          append(const _Tp& __svt)
         .                   {
        20 ( 0.00%)            __sv_type __sv = __svt;
        52 ( 0.00%)            return this->append(__sv.data(), __sv.size());
     1,240 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(char const*, unsigned long) (4x)
        28 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::data() const (4x)
        28 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const (4x)
        12 ( 0.00%)          }
         .           
         .                 /**
         .                  *  @brief  Append a range of characters from a string_view.
         .                  *  @param __svt  An object convertible to string_view to be appended from.
         .                  *  @param __pos The position in the string_view to append from.
         .                  *  @param __n   The number of characters to append from the string_view.
         .                  *  @return  Reference to this string.
         .                  */
-- line 1553 ----------------------------------------
-- line 1564 ----------------------------------------
         .           #endif // C++17
         .           
         .                 /**
         .                  *  @brief  Append a single character.
         .                  *  @param __c  Character to append.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 void
    55,145 ( 0.00%)        push_back(_CharT __c)
         .                 {
    31,500 ( 0.00%)  	const size_type __size = this->size();
    55,125 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (7,875x)
    70,925 ( 0.00%)  	if (__size + 1 > this->capacity())
   583,078 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::capacity() const (7,875x)
        28 ( 0.00%)  	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
     2,829 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long) (4x)
    70,875 ( 0.00%)  	traits_type::assign(this->_M_data()[__size], __c);
   118,125 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::assign(char&, char const&) (7,875x)
    55,125 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (7,875x)
    47,250 ( 0.00%)  	this->_M_set_length(__size + 1);
   433,125 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (7,875x)
    31,500 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Set value to contents of another string.
         .                  *  @param  __str  Source string to use.
         .                  *  @return  Reference to this string.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
   202,824 ( 0.00%)        assign(const basic_string& __str)
         .                 {
         .           #if __cplusplus >= 201103L
    67,608 ( 0.00%)  	if (_Alloc_traits::_S_propagate_on_copy_assign())
         .           	  {
         .           	    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
         .           		&& _M_get_allocator() != __str._M_get_allocator())
         .           	      {
         .           		// Propagating allocator cannot free existing storage so must
         .           		// deallocate it before replacing current allocator.
         .           		if (__str.size() <= _S_local_capacity)
         .           		  {
-- line 1599 ----------------------------------------
-- line 1611 ----------------------------------------
         .           		    _M_data(__ptr);
         .           		    _M_capacity(__len);
         .           		    _M_set_length(__len);
         .           		  }
         .           	      }
         .           	    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
         .           	  }
         .           #endif
   169,023 ( 0.00%)  	this->_M_assign(__str);
24,523,346 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (33,804x)
    67,608 ( 0.00%)  	return *this;
   101,412 ( 0.00%)        }
         .           
         .           #if __cplusplus >= 201103L
         .                 /**
         .                  *  @brief  Set value to contents of another string.
         .                  *  @param  __str  Source string to use.
         .                  *  @return  Reference to this string.
         .                  *
         .                  *  This function sets this string to the exact contents of @a __str.
-- line 1629 ----------------------------------------
-- line 1684 ----------------------------------------
         .                  *  @return  Reference to this string.
         .                  *
         .                  *  This function sets the value of this string to the value of @a __s.
         .                  *  The data is copied, so there is no dependence on @a __s once the
         .                  *  function returns.
         .                  */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
     4,896 ( 0.00%)        assign(const _CharT* __s)
         .                 {
         .           	__glibcxx_requires_string(__s);
    13,056 ( 0.00%)  	return _M_replace(size_type(0), this->size(), __s,
   582,947 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_replace(unsigned long, unsigned long, char const*, unsigned long) (816x)
    31,548 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (816x)
     5,712 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (816x)
         .           			  traits_type::length(__s));
     2,448 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Set value to multiple characters.
         .                  *  @param __n  Length of the resulting string.
         .                  *  @param __c  The character to use.
         .                  *  @return  Reference to this string.
         .                  *
         .                  *  This function sets the value of this string to @a __n copies of
-- line 1705 ----------------------------------------
-- line 1999 ----------------------------------------
         .                  *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
         .                  *  adding characters causes the length to exceed max_size(),
         .                  *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
         .                  *  thrown.  The value of the string doesn't change if an error is
         .                  *  thrown.
         .                 */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
        12 ( 0.00%)        insert(size_type __pos, const _CharT* __s)
         .                 {
         .           	__glibcxx_requires_string(__s);
        24 ( 0.00%)  	return this->replace(__pos, size_type(0), __s,
     1,976 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::replace(unsigned long, unsigned long, char const*, unsigned long) (2x)
        56 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (2x)
         .           			     traits_type::length(__s));
         4 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Insert multiple characters.
         .                  *  @param __pos  Index in string to insert at.
         .                  *  @param __n  Number of characters to insert
         .                  *  @param __c  The character to insert.
         .                  *  @return  Reference to this string.
         .                  *  @throw  std::length_error  If new length exceeds @c max_size().
-- line 2020 ----------------------------------------
-- line 2106 ----------------------------------------
         .                  *  __pos.  The length of the string is reduced by @a __n.  If
         .                  *  there are < @a __n characters to remove, the remainder of
         .                  *  the string is truncated.  If @a __p is beyond end of string,
         .                  *  out_of_range is thrown.  The value of the string doesn't
         .                  *  change if an error is thrown.
         .                 */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
        12 ( 0.00%)        erase(size_type __pos = 0, size_type __n = npos)
         .                 {
        12 ( 0.00%)  	_M_check(__pos, "basic_string::erase");
        46 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check(unsigned long, char const*) const (2x)
         4 ( 0.00%)  	if (__n == npos)
        12 ( 0.00%)  	  this->_M_set_length(__pos);
       110 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (2x)
         .           	else if (__n != 0)
         .           	  this->_M_erase(__pos, _M_limit(__pos, __n));
         2 ( 0.00%)  	return *this;
         4 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Remove one character.
         .                  *  @param __position  Iterator referencing the character to remove.
         .                  *  @return  iterator referencing same location after removal.
         .                  *
         .                  *  Removes the character at @a __position from this string. The value
         .                  *  of the string doesn't change if an error is thrown.
-- line 2130 ----------------------------------------
-- line 2241 ----------------------------------------
         .                  *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
         .                  *  @a __pos is beyond end of string, out_of_range is thrown.  If
         .                  *  the length of result exceeds max_size(), length_error is
         .                  *  thrown.  The value of the string doesn't change if an error
         .                  *  is thrown.
         .                 */
         .                 _GLIBCXX20_CONSTEXPR
         .                 basic_string&
        18 ( 0.00%)        replace(size_type __pos, size_type __n1, const _CharT* __s,
         .           	      size_type __n2)
         .                 {
         .           	__glibcxx_requires_string_len(__s, __n2);
        44 ( 0.00%)  	return _M_replace(_M_check(__pos, "basic_string::replace"),
     1,810 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_replace(unsigned long, unsigned long, char const*, unsigned long) (2x)
        52 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_limit(unsigned long, unsigned long) const (2x)
        46 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check(unsigned long, char const*) const (2x)
         .           			  _M_limit(__pos, __n1), __s, __n2);
         6 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Replace characters with value of a C string.
         .                  *  @param __pos  Index of first character to replace.
         .                  *  @param __n1  Number of characters to be replaced.
         .                  *  @param __s  C string to insert.
         .                  *  @return  Reference to this string.
         .                  *  @throw  std::out_of_range  If @a pos > size().
-- line 2263 ----------------------------------------
-- line 2632 ----------------------------------------
         .                 /**
         .                  *  @brief  Return const pointer to null-terminated contents.
         .                  *
         .                  *  This is a handle to internal data.  Do not modify or dire things may
         .                  *  happen.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 const _CharT*
 1,642,916 ( 0.00%)        c_str() const _GLIBCXX_NOEXCEPT
 2,053,645 ( 0.00%)        { return _M_data(); }
 2,875,103 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (410,729x)
         .           
         .                 /**
         .                  *  @brief  Return const pointer to contents.
         .                  *
         .                  *  This is a pointer to internal data.  It is undefined to modify
         .                  *  the contents through the returned pointer. To get a pointer that
         .                  *  allows modifying the contents use @c &str[0] instead,
         .                  *  (or in C++17 the non-const @c str.data() overload).
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 const _CharT*
 2,771,932 ( 0.00%)        data() const _GLIBCXX_NOEXCEPT
 3,464,915 ( 0.00%)        { return _M_data(); }
 4,850,881 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (692,983x)
         .           
         .           #if __cplusplus >= 201703L
         .                 /**
         .                  *  @brief  Return non-const pointer to contents.
         .                  *
         .                  *  This is a pointer to the character sequence held by the string.
         .                  *  Modifying the characters in the sequence is allowed.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 _CharT*
       816 ( 0.00%)        data() noexcept
     1,020 ( 0.00%)        { return _M_data(); }
     1,428 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (204x)
         .           #endif
         .           
         .                 /**
         .                  *  @brief  Return copy of allocator used to construct this string.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 allocator_type
    20,885 ( 0.00%)        get_allocator() const _GLIBCXX_NOEXCEPT
    58,478 ( 0.00%)        { return _M_get_allocator(); }
    25,062 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() const (4,177x)
         .           
         .                 /**
         .                  *  @brief  Find position of a C substring.
         .                  *  @param __s  C string to locate.
         .                  *  @param __pos  Index of character to search from.
         .                  *  @param __n  Number of characters from @a s to search for.
         .                  *  @return  Index of start of first occurrence.
         .                  *
-- line 2683 ----------------------------------------
-- line 2698 ----------------------------------------
         .                  *  @return  Index of start of first occurrence.
         .                  *
         .                  *  Starting from @a __pos, searches forward for value of @a __str within
         .                  *  this string.  If found, returns the index where it begins.  If not
         .                  *  found, returns npos.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
   165,060 ( 0.00%)        find(const basic_string& __str, size_type __pos = 0) const
         .                 _GLIBCXX_NOEXCEPT
   377,280 ( 0.00%)        { return this->find(__str.data(), __pos, __str.size()); }
 2,919,842 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::find(char const*, unsigned long, unsigned long) const (23,580x)
   377,280 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (23,580x)
   165,060 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (23,580x)
         .           
         .           #if __cplusplus >= 201703L
         .                 /**
         .                  *  @brief  Find position of a string_view.
         .                  *  @param __svt  The object convertible to string_view to locate.
         .                  *  @param __pos  Index of character to search from (default 0).
         .                  *  @return  Index of start of first occurrence.
         .                 */
-- line 2716 ----------------------------------------
-- line 2732 ----------------------------------------
         .                  *  @return  Index of start of first occurrence.
         .                  *
         .                  *  Starting from @a __pos, searches forward for the value of @a
         .                  *  __s within this string.  If found, returns the index where
         .                  *  it begins.  If not found, returns npos.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
       144 ( 0.00%)        find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
         .                 {
         .           	__glibcxx_requires_string(__s);
       216 ( 0.00%)  	return this->find(__s, __pos, traits_type::length(__s));
     3,474 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::find(char const*, unsigned long, unsigned long) const (24x)
       672 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (24x)
        48 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Find position of a character.
         .                  *  @param __c  Character to locate.
         .                  *  @param __pos  Index of character to search from (default 0).
         .                  *  @return  Index of first occurrence.
         .                  *
         .                  *  Starting from @a __pos, searches forward for @a __c within
-- line 2752 ----------------------------------------
-- line 2921 ----------------------------------------
         .                  *  Starting from @a __pos, searches forward for the character
         .                  *  @a __c within this string.  If found, returns the index
         .                  *  where it was found.  If not found, returns npos.
         .                  *
         .                  *  Note: equivalent to find(__c, __pos).
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
   152,145 ( 0.00%)        find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
   173,880 ( 0.00%)        { return this->find(__c, __pos); }
 2,029,870 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::find(char, unsigned long) const (21,735x)
         .           
         .                 /**
         .                  *  @brief  Find last position of a character of string.
         .                  *  @param __str  String containing characters to locate.
         .                  *  @param __pos  Index of character to search back from (default end).
         .                  *  @return  Index of last occurrence.
         .                  *
         .                  *  Starting from @a __pos, searches backward for one of the
-- line 2938 ----------------------------------------
-- line 2989 ----------------------------------------
         .                  *  @return  Index of last occurrence.
         .                  *
         .                  *  Starting from @a __pos, searches backward for one of the
         .                  *  characters of @a __s within this string.  If found, returns
         .                  *  the index where it was found.  If not found, returns npos.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 size_type
        12 ( 0.00%)        find_last_of(const _CharT* __s, size_type __pos = npos) const
         .                 _GLIBCXX_NOEXCEPT
         .                 {
         .           	__glibcxx_requires_string(__s);
        18 ( 0.00%)  	return this->find_last_of(__s, __pos, traits_type::length(__s));
     2,958 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::find_last_of(char const*, unsigned long, unsigned long) const (2x)
        56 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (2x)
         4 ( 0.00%)        }
         .           
         .                 /**
         .                  *  @brief  Find last position of a character.
         .                  *  @param __c  Character to locate.
         .                  *  @param __pos  Index of character to search back from (default end).
         .                  *  @return  Index of last occurrence.
         .                  *
         .                  *  Starting from @a __pos, searches backward for @a __c within
-- line 3010 ----------------------------------------
-- line 3200 ----------------------------------------
         .                  *
         .                  *  Construct and return a new string using the @a __n
         .                  *  characters starting at @a __pos.  If the string is too
         .                  *  short, use the remainder of the characters.  If @a __pos is
         .                  *  beyond the end of the string, out_of_range is thrown.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 basic_string
   944,503 ( 0.00%)        substr(size_type __pos = 0, size_type __n = npos) const
         .                 { return basic_string(*this,
 2,293,793 ( 0.00%)  			    _M_check(__pos, "basic_string::substr"), __n); }
74,478,559 ( 0.06%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, unsigned long) (134,929x)
 3,103,367 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check(unsigned long, char const*) const (134,929x)
         .           
         .                 /**
         .                  *  @brief  Compare to a string.
         .                  *  @param __str  String to compare against.
         .                  *  @return  Integer < 0, 0, or > 0.
         .                  *
         .                  *  Returns an integer < 0 if this string is ordered before @a
         .                  *  __str, 0 if their values are equivalent, or > 0 if this
-- line 3218 ----------------------------------------
-- line 3220 ----------------------------------------
         .                  *  length rlen of the strings to compare as the smallest of
         .                  *  size() and str.size().  The function then compares the two
         .                  *  strings by calling traits::compare(data(), str.data(),rlen).
         .                  *  If the result of the comparison is nonzero returns it,
         .                  *  otherwise the shorter one is ordered first.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 int
   233,790 ( 0.00%)        compare(const basic_string& __str) const
         .                 {
   155,860 ( 0.00%)  	const size_type __size = this->size();
   272,755 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (38,965x)
   155,860 ( 0.00%)  	const size_type __osize = __str.size();
   272,755 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (38,965x)
   272,755 ( 0.00%)  	const size_type __len = std::min(__size, __osize);
   517,547 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (38,965x)
         .           
   545,510 ( 0.00%)  	int __r = traits_type::compare(_M_data(), __str.data(), __len);
 1,640,295 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) (38,965x)
   623,440 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (38,965x)
   272,755 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (38,965x)
    77,930 ( 0.00%)  	if (!__r)
   104,286 ( 0.00%)  	  __r = _S_compare(__size, __osize);
   278,096 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_compare(unsigned long, unsigned long) (17,381x)
    38,965 ( 0.00%)  	return __r;
   116,895 ( 0.00%)        }
         .           
         .           #if __cplusplus >= 201703L
         .                 /**
         .                  *  @brief  Compare to a string_view.
         .                  *  @param __svt An object convertible to string_view to compare against.
         .                  *  @return  Integer < 0, 0, or > 0.
         .                  */
         .                 template<typename _Tp>
-- line 3246 ----------------------------------------
-- line 3385 ----------------------------------------
         .                  *  compare as the smallest of size() and the length of a string
         .                  *  constructed from @a __s.  The function then compares the two strings
         .                  *  by calling traits::compare(data(),s,rlen).  If the result of the
         .                  *  comparison is nonzero returns it, otherwise the shorter one is
         .                  *  ordered first.
         .                 */
         .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .                 int
       680 ( 0.00%)        compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT
         .                 {
         .           	__glibcxx_requires_string(__s);
       544 ( 0.00%)  	const size_type __size = this->size();
       952 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (136x)
       544 ( 0.00%)  	const size_type __osize = traits_type::length(__s);
     3,808 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (136x)
       952 ( 0.00%)  	const size_type __len = std::min(__size, __osize);
     1,904 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (136x)
     1,360 ( 0.00%)  	int __r = traits_type::compare(_M_data(), __s, __len);
     5,862 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) (136x)
       952 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (136x)
       272 ( 0.00%)  	if (!__r)
         .           	  __r = _S_compare(__size, __osize);
       136 ( 0.00%)  	return __r;
       272 ( 0.00%)        }
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 5 String::compare specification questionable
         .                 /**
         .                  *  @brief  Compare substring to a C string.
         .                  *  @param __pos  Index of first character of substring.
         .                  *  @param __n1  Number of characters in substring.
         .                  *  @param __s  C string to compare against.
-- line 3411 ----------------------------------------
-- line 3475 ----------------------------------------
         .           	if (!__r)
         .           	  __r = _S_compare(__n1, __n2);
         .           	return __r;
         .                 }
         .           
         .           #if __cplusplus >= 202002L
         .                 [[nodiscard]]
         .                 constexpr bool
   557,352 ( 0.00%)        starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
 1,021,812 ( 0.00%)        { return __sv_type(this->data(), this->size()).starts_with(__x); }
12,095,371 ( 0.01%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::starts_with(std::basic_string_view<char, std::char_traits<char> >) const (46,446x)
   743,136 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (46,446x)
   650,244 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::basic_string_view(char const*, unsigned long) (46,446x)
   325,122 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (46,446x)
         .           
         .                 [[nodiscard]]
         .                 constexpr bool
         .                 starts_with(_CharT __x) const noexcept
         .                 { return __sv_type(this->data(), this->size()).starts_with(__x); }
         .           
         .                 [[nodiscard, __gnu__::__nonnull__]]
         .                 constexpr bool
-- line 3492 ----------------------------------------
-- line 3565 ----------------------------------------
         .           		 const _Allocator& = _Allocator())
         .                 -> basic_string<_CharT, _Traits, _Allocator>;
         .           _GLIBCXX_END_NAMESPACE_CXX11
         .           #endif
         .           
         .             template<typename _Str>
         .               _GLIBCXX20_CONSTEXPR
         .               inline _Str
    91,894 ( 0.00%)      __str_concat(typename _Str::value_type const* __lhs,
         .           		 typename _Str::size_type __lhs_len,
         .           		 typename _Str::value_type const* __rhs,
         .           		 typename _Str::size_type __rhs_len,
         .           		 typename _Str::allocator_type const& __a)
         .               {
         .                 typedef typename _Str::allocator_type allocator_type;
         .                 typedef __gnu_cxx::__alloc_traits<allocator_type> _Alloc_traits;
    20,885 ( 0.00%)        _Str __str(_Alloc_traits::_S_select_on_copy(__a));
   605,665 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::allocator<char> const&) (4,177x)
    29,239 ( 0.00%)        __str.reserve(__lhs_len + __rhs_len);
   967,572 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reserve(unsigned long) (4,177x)
    25,062 ( 0.00%)        __str.append(__lhs, __lhs_len);
 1,276,034 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(char const*, unsigned long) (4,177x)
    25,062 ( 0.00%)        __str.append(__rhs, __rhs_len);
 1,350,078 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(char const*, unsigned long) (4,177x)
     4,177 ( 0.00%)        return __str;
    16,708 ( 0.00%)      }
         .           
         .             // operator+
         .             /**
         .              *  @brief  Concatenate two strings.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Last string.
         .              *  @return  New string with value of @a __lhs followed by @a __rhs.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
       999 ( 0.00%)      operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
         .               {
         .                 typedef basic_string<_CharT, _Traits, _Alloc> _Str;
         .                 return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(),
         .           				     __rhs.c_str(), __rhs.size(),
     3,330 ( 0.00%)  				     __lhs.get_allocator());
   144,904 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::__str_concat<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type const&) (111x)
     3,552 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (222x)
     2,997 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::get_allocator() const (111x)
     1,554 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (222x)
       777 ( 0.00%)      }
         .           
         .             /**
         .              *  @brief  Concatenate C string and string.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Last string.
         .              *  @return  New string with value of @a __lhs followed by @a __rhs.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT,_Traits,_Alloc>
    27,312 ( 0.00%)      operator+(const _CharT* __lhs,
         .           	      const basic_string<_CharT,_Traits,_Alloc>& __rhs)
         .               {
         .                 __glibcxx_requires_string(__lhs);
         .                 typedef basic_string<_CharT, _Traits, _Alloc> _Str;
         .                 return std::__str_concat<_Str>(__lhs, _Traits::length(__lhs),
         .           				     __rhs.c_str(), __rhs.size(),
    92,178 ( 0.00%)  				     __rhs.get_allocator());
 3,390,563 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::__str_concat<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type const&) (3,414x)
    95,624 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (3,414x)
    92,178 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::get_allocator() const (3,414x)
    54,624 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (3,414x)
    23,898 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (3,414x)
    20,484 ( 0.00%)      }
         .           
         .             /**
         .              *  @brief  Concatenate character and string.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Last string.
         .              *  @return  New string with @a __lhs followed by @a __rhs.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
-- line 3632 ----------------------------------------
-- line 3644 ----------------------------------------
         .              *  @brief  Concatenate string and C string.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Last string.
         .              *  @return  New string with @a __lhs followed by @a __rhs.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
     5,216 ( 0.00%)      operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	      const _CharT* __rhs)
         .               {
         .                 __glibcxx_requires_string(__rhs);
         .                 typedef basic_string<_CharT, _Traits, _Alloc> _Str;
         .                 return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(),
         .           				     __rhs, _Traits::length(__rhs),
    18,256 ( 0.00%)  				     __lhs.get_allocator());
   897,794 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::__str_concat<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type const&) (652x)
    18,256 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (652x)
    17,604 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::get_allocator() const (652x)
    10,432 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (652x)
     4,564 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (652x)
     3,912 ( 0.00%)      }
         .             /**
         .              *  @brief  Concatenate string and character.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Last string.
         .              *  @return  New string with @a __lhs followed by @a __rhs.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
-- line 3668 ----------------------------------------
-- line 3674 ----------------------------------------
         .           				     __builtin_addressof(__rhs), 1,
         .           				     __lhs.get_allocator());
         .               }
         .           
         .           #if __cplusplus >= 201103L
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
        60 ( 0.00%)      operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .           	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
       150 ( 0.00%)      { return std::move(__lhs.append(__rhs)); }
     5,149 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (10x)
     3,743 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (10x)
        60 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&& std::move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (10x)
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
         .               operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
         .               { return std::move(__rhs.insert(0, __lhs)); }
         .           
-- line 3692 ----------------------------------------
-- line 3711 ----------------------------------------
         .           	    return std::move(__rhs.insert(0, __lhs));
         .           	}
         .                 return std::move(__lhs.append(__rhs));
         .               }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
        12 ( 0.00%)      operator+(const _CharT* __lhs,
         .           	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
        30 ( 0.00%)      { return std::move(__rhs.insert(0, __lhs)); }
     2,072 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::insert(unsigned long, char const*) (2x)
       720 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (2x)
        12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&& std::move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (2x)
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
         .               operator+(_CharT __lhs,
         .           	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
         .               { return std::move(__rhs.insert(0, 1, __lhs)); }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
        72 ( 0.00%)      operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .           	      const _CharT* __rhs)
       180 ( 0.00%)      { return std::move(__lhs.append(__rhs)); }
     4,623 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (12x)
     4,042 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(char const*) (12x)
        72 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&& std::move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (12x)
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline basic_string<_CharT, _Traits, _Alloc>
         .               operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .           	      _CharT __rhs)
         .               { return std::move(__lhs.append(1, __rhs)); }
         .           #endif
-- line 3743 ----------------------------------------
-- line 3747 ----------------------------------------
         .              *  @brief  Test equivalence of two strings.
         .              *  @param __lhs  First string.
         .              *  @param __rhs  Second string.
         .              *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline bool
 1,028,230 ( 0.00%)      operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
         .               _GLIBCXX_NOEXCEPT
         .               {
 1,028,230 ( 0.00%)        return __lhs.size() == __rhs.size()
 2,056,460 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (293,780x)
 3,068,191 ( 0.00%)  	       && !_Traits::compare(__lhs.data(), __rhs.data(), __lhs.size());
 5,811,638 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) (145,980x)
 4,671,360 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (291,960x)
 1,021,860 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (145,980x)
   734,450 ( 0.00%)      }
         .           
         .             /**
         .              *  @brief  Test equivalence of string and C string.
         .              *  @param __lhs  String.
         .              *  @param __rhs  C string.
         .              *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .               inline bool
   107,754 ( 0.00%)      operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           	       const _CharT* __rhs)
         .               {
   125,713 ( 0.00%)        return __lhs.size() == _Traits::length(__rhs)
   502,916 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (17,959x)
   125,713 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (17,959x)
   302,462 ( 0.00%)  	       && !_Traits::compare(__lhs.data(), __rhs, __lhs.size());
   712,457 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) (16,571x)
   265,136 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (16,571x)
   115,997 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (16,571x)
    53,877 ( 0.00%)      }
         .           
         .           #if __cpp_lib_three_way_comparison
         .             /**
         .              *  @brief  Three-way comparison of a string and a C string.
         .              *  @param __lhs  A string.
         .              *  @param __rhs  A null-terminated string.
         .              *  @return  A value indicating whether `__lhs` is less than, equal to,
         .              *	       greater than, or incomparable with `__rhs`.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               [[nodiscard]]
         .               constexpr auto
   194,825 ( 0.00%)      operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           		const basic_string<_CharT, _Traits, _Alloc>& __rhs) noexcept
         .               -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
   350,685 ( 0.00%)      { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
 5,579,494 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (38,965x)
   415,446 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:auto std::__detail::__char_traits_cmp_cat<std::char_traits<char> >(int) (38,965x)
         .           
         .             /**
         .              *  @brief  Three-way comparison of a string and a C string.
         .              *  @param __lhs  A string.
         .              *  @param __rhs  A null-terminated string.
         .              *  @return  A value indicating whether `__lhs` is less than, equal to,
         .              *	       greater than, or incomparable with `__rhs`.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               [[nodiscard]]
         .               constexpr auto
       680 ( 0.00%)      operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .           		const _CharT* __rhs) noexcept
         .               -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
     1,224 ( 0.00%)      { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
    18,238 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::compare(char const*) const (136x)
     1,632 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:auto std::__detail::__char_traits_cmp_cat<std::char_traits<char> >(int) (136x)
         .           #else
         .             /**
         .              *  @brief  Test equivalence of C string and string.
         .              *  @param __lhs  C string.
         .              *  @param __rhs  String.
         .              *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
         .              */
         .             template<typename _CharT, typename _Traits, typename _Alloc>
-- line 3816 ----------------------------------------
-- line 4608 ----------------------------------------
         .           
         .             template<typename _CharT, typename _Alloc,
         .           	   typename _StrT = basic_string<_CharT, char_traits<_CharT>, _Alloc>>
         .               struct __str_hash_base
         .               : public __hash_base<size_t, _StrT>
         .               {
         .                 [[__nodiscard__]]
         .                 size_t
 1,105,422 ( 0.00%)        operator()(const _StrT& __s) const noexcept
 2,947,792 ( 0.00%)        { return _Hash_impl::hash(__s.data(), __s.length() * sizeof(_CharT)); }
20,574,145 ( 0.02%)  => /usr/include/c++/14/bits/functional_hash.h:std::_Hash_impl::hash(void const*, unsigned long, unsigned long) (184,237x)
 2,947,792 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (184,237x)
 1,289,659 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (184,237x)
         .               };
         .           
         .           #ifndef _GLIBCXX_COMPATIBILITY_CXX0X
         .             /// std::hash specialization for string.
         .             template<typename _Alloc>
         .               struct hash<basic_string<char, char_traits<char>, _Alloc>>
         .               : public __str_hash_base<char, _Alloc>
         .               { };
-- line 4625 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/hashtable.h
--------------------------------------------------------------------------------
Ir                   

-- line 297 ----------------------------------------
          .           	__detail::_AllocNode<__node_alloc_type>;
          .                 using __node_builder_t =
          .           	__detail::_NodeBuilder<_ExtractKey>;
          .           
          .                 // Simple RAII type for managing a node containing an element
          .                 struct _Scoped_node
          .                 {
          .           	// Take ownership of a node with a constructed element.
        255 ( 0.00%)  	_Scoped_node(__node_ptr __n, __hashtable_alloc* __h)
        459 ( 0.00%)  	: _M_h(__h), _M_node(__n) { }
          .           
          .           	// Allocate a node and construct an element within it.
          .           	template<typename... _Args>
    558,740 ( 0.00%)  	  _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
    152,820 ( 0.00%)  	  : _M_h(__h),
    963,860 ( 0.00%)  	    _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
      4,484 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true>* std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true> > >::_M_allocate_node<std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>, std::tuple<> >(std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>&&, std::tuple<>&&) (4x)
         24 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>&& std::forward<std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&> >(std::remove_reference<std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&> >::type&) (4x)
         24 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::piecewise_construct_t const& std::forward<std::piecewise_construct_t const&>(std::remove_reference<std::piecewise_construct_t const&>::type&) (4x)
         24 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<>&& std::forward<std::tuple<> >(std::remove_reference<std::tuple<> >::type&) (4x)
    355,380 ( 0.00%)  	  { }
          .           
          .           	// Destroy element and deallocate node.
    560,901 ( 0.00%)  	~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };
          .           
          .           	_Scoped_node(const _Scoped_node&) = delete;
          .           	_Scoped_node& operator=(const _Scoped_node&) = delete;
          .           
          .           	__hashtable_alloc* _M_h;
          .           	__node_ptr _M_node;
          .                 };
          .           
          .                 template<typename _Ht>
          .           	static constexpr
          .           	__conditional_t<std::is_lvalue_reference<_Ht>::value,
          .           			const value_type&, value_type&&>
     94,512 ( 0.00%)  	__fwd_value_for(value_type& __val) noexcept
    118,140 ( 0.00%)  	{ return std::move(__val); }
     26,796 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >&>::type&& std::move<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >&) (4,466x)
          .           
          .                 // Compile-time diagnostics.
          .           
          .                 // _Hash_code_base has everything protected, so use this derived type to
          .                 // access it.
          .                 struct __hash_code_base_access : __hash_code_base
          .                 { using __hash_code_base::_M_bucket_index; };
          .           
-- line 338 ----------------------------------------
-- line 399 ----------------------------------------
          .                 // interesting in move semantic to leave hashtable with only 1 bucket
          .                 // which is not allocated so that we can have those operations noexcept
          .                 // qualified.
          .                 // Note that we can't leave hashtable with 0 bucket without adding
          .                 // numerous checks in the code to avoid 0 modulus.
          .                 __node_base_ptr		_M_single_bucket	= nullptr;
          .           
          .                 void
     42,144 ( 0.00%)        _M_update_bbegin()
          .                 {
     42,150 ( 0.00%)  	if (auto __begin = _M_begin())
     31,262 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_begin() const (4,466x)
     91,312 ( 0.00%)  	  _M_buckets[_M_bucket_index(*__begin)] = &_M_before_begin;
    178,640 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, true> const&) const (4,466x)
     42,144 ( 0.00%)        }
          .           
          .                 void
     35,120 ( 0.00%)        _M_update_bbegin(__node_ptr __n)
          .                 {
     21,072 ( 0.00%)  	_M_before_begin._M_nxt = __n;
     21,072 ( 0.00%)  	_M_update_bbegin();
     99,840 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_update_bbegin() (1,280x)
     21,072 ( 0.00%)        }
          .           
          .                 bool
    119,408 ( 0.00%)        _M_uses_single_bucket(__buckets_ptr __bkts) const
    268,679 ( 0.00%)        { return __builtin_expect(__bkts == &_M_single_bucket, false); }
          .           
          .                 bool
          .                 _M_uses_single_bucket() const
          .                 { return _M_uses_single_bucket(_M_buckets); }
          .           
          .                 static constexpr size_t
 23,764,572 ( 0.02%)        __small_size_threshold() noexcept
          .                 {
          .           	return
 11,882,286 ( 0.01%)  	  __detail::_Hashtable_hash_traits<_Hash>::__small_size_threshold();
         20 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_hash_traits<std::hash<Ship::Stick> >::__small_size_threshold() (4x)
 23,764,572 ( 0.02%)        }
          .           
          .                 __hashtable_alloc&
          .                 _M_base_alloc() { return *this; }
          .           
          .                 __buckets_ptr
    147,205 ( 0.00%)        _M_allocate_buckets(size_type __bkt_count)
          .                 {
    147,207 ( 0.00%)  	if (__builtin_expect(__bkt_count == 1, false))
          .           	  {
     44,634 ( 0.00%)  	    _M_single_bucket = nullptr;
     66,951 ( 0.00%)  	    return &_M_single_bucket;
          .           	  }
          .           
     42,744 ( 0.00%)  	return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
      1,605 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >::_M_allocate_buckets(unsigned long) (1x)
     58,882 ( 0.00%)        }
          .           
          .                 void
    179,112 ( 0.00%)        _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
          .                 {
    208,984 ( 0.00%)  	if (_M_uses_single_bucket(__bkts))
         52 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_uses_single_bucket(std::__detail::_Hash_node_base**) const (4x)
     22,767 ( 0.00%)  	  return;
          .           
     49,595 ( 0.00%)  	__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
        436 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false> > >::_M_deallocate_buckets(std::__detail::_Hash_node_base**, unsigned long) (2x)
     59,704 ( 0.00%)        }
          .           
          .                 void
    119,408 ( 0.00%)        _M_deallocate_buckets()
    328,382 ( 0.00%)        { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
        564 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_deallocate_buckets(std::__detail::_Hash_node_base**, unsigned long) (4x)
          .           
          .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
          .                 // their before begin node.
          .                 __node_ptr
          .                 _M_bucket_begin(size_type __bkt) const
          .                 {
          .           	__node_base_ptr __n = _M_buckets[__bkt];
          .           	return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;
          .                 }
          .           
          .                 __node_ptr
    467,853 ( 0.00%)        _M_begin() const
    623,836 ( 0.00%)        { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }
          .           
          .                 // Assign *this using another _Hashtable instance. Whether elements
          .                 // are copied or moved depends on the _Ht reference.
          .                 template<typename _Ht>
          .           	void
          .           	_M_assign_elements(_Ht&&);
          .           
          .                 template<typename _Ht, typename _NodeGenerator>
-- line 482 ----------------------------------------
-- line 487 ----------------------------------------
          .                 _M_move_assign(_Hashtable&&, true_type);
          .           
          .                 void
          .                 _M_move_assign(_Hashtable&&, false_type);
          .           
          .                 void
          .                 _M_reset() noexcept;
          .           
         35 ( 0.00%)        _Hashtable(const _Hash& __h, const _Equal& __eq,
          .           		 const allocator_type& __a)
          .                 : __hashtable_base(__h, __eq),
          .           	__hashtable_alloc(__node_alloc_type(__a)),
        190 ( 0.00%)  	__enable_default_ctor(_Enable_default_constructor_tag{})
         66 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<Ship::Direction, std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable_base(std::hash<Ship::Direction> const&, std::equal_to<Ship::Direction> const&) (1x)
         48 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >(std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> >&&) (1x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Prime_rehash_policy::_Prime_rehash_policy(float) (1x)
          8 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node_base::_Hash_node_base() (1x)
          6 ( 0.00%)  => /usr/include/c++/14/bits/enable_special_members.h:std::_Enable_default_constructor<true, std::__detail::_Hash_node_base>::_Enable_default_constructor(std::_Enable_default_constructor_tag) (1x)
         15 ( 0.00%)        { }
          .           
          .                 template<bool _No_realloc = true>
          .           	static constexpr bool
          .           	_S_nothrow_move()
          .           	{
          .           #if __cplusplus <= 201402L
          .           	  return __and_<__bool_constant<_No_realloc>,
          .           			is_nothrow_copy_constructible<_Hash>,
-- line 508 ----------------------------------------
-- line 531 ----------------------------------------
          .                 template<typename _InputIterator>
          .           	_Hashtable(_InputIterator __first, _InputIterator __last,
          .           		   size_type __bkt_count_hint,
          .           		   const _Hash&, const _Equal&, const allocator_type&,
          .           		   false_type __uks);
          .           
          .               public:
          .                 // Constructor, destructor, assignment, swap
     17,600 ( 0.00%)        _Hashtable() = default;
        140 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable_base() (4x)
         88 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> > >::_Hashtable_alloc() (4x)
         48 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Prime_rehash_policy::_Prime_rehash_policy(float) (4x)
         32 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node_base::_Hash_node_base() (4x)
          .           
          .                 _Hashtable(const _Hashtable&);
          .           
          .                 _Hashtable(const _Hashtable&, const allocator_type&);
          .           
          .                 explicit
          .                 _Hashtable(size_type __bkt_count_hint,
          .           		 const _Hash& __hf = _Hash(),
-- line 547 ----------------------------------------
-- line 572 ----------------------------------------
          .           		   size_type __bkt_count_hint = 0,
          .           		   const _Hash& __hf = _Hash(),
          .           		   const key_equal& __eql = key_equal(),
          .           		   const allocator_type& __a = allocator_type())
          .           	: _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          .           		     __unique_keys{})
          .           	{ }
          .           
         75 ( 0.00%)        _Hashtable(initializer_list<value_type> __l,
          .           		 size_type __bkt_count_hint = 0,
          .           		 const _Hash& __hf = _Hash(),
          .           		 const key_equal& __eql = key_equal(),
          .           		 const allocator_type& __a = allocator_type())
          .                 : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
        105 ( 0.00%)  		   __hf, __eql, __a, __unique_keys{})
      7,447 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*>(std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*, std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*, unsigned long, std::hash<Ship::Direction> const&, std::equal_to<Ship::Direction> const&, std::allocator<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::integral_constant<bool, true>) (1x)
         35 ( 0.00%)  => /usr/include/c++/14/initializer_list:std::initializer_list<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::end() const (1x)
          7 ( 0.00%)  => /usr/include/c++/14/initializer_list:std::initializer_list<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::begin() const (1x)
         20 ( 0.00%)        { }
          .           
          .                 _Hashtable&
          .                 operator=(const _Hashtable& __ht);
          .           
          .                 _Hashtable&
          .                 operator=(_Hashtable&& __ht)
          .                 noexcept(__node_alloc_traits::_S_nothrow_move()
          .           	       && is_nothrow_move_assignable<_Hash>::value
-- line 595 ----------------------------------------
-- line 624 ----------------------------------------
          .           
          .                 void
          .                 swap(_Hashtable&)
          .                 noexcept(__and_<__is_nothrow_swappable<_Hash>,
          .           		      __is_nothrow_swappable<_Equal>>::value);
          .           
          .                 // Basic container operations
          .                 iterator
    232,352 ( 0.00%)        begin() noexcept
    638,968 ( 0.00%)        { return iterator(_M_begin()); }
      9,269 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::Overlay>, false, true>::_Node_iterator(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::Overlay>, true>*) (403x)
      2,821 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::Overlay>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::Overlay> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_begin() const (403x)
          .           
          .                 const_iterator
          .                 begin() const noexcept
          .                 { return const_iterator(_M_begin()); }
          .           
          .                 iterator
  1,092,140 ( 0.00%)        end() noexcept
  1,911,245 ( 0.00%)        { return iterator(nullptr); }
    768,913 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::_Node_iterator(std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>*) (33,431x)
          .           
          .                 const_iterator
 23,919,652 ( 0.02%)        end() const noexcept
 41,859,391 ( 0.03%)        { return const_iterator(nullptr); }
  2,439,104 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<MtxS* const, MtxF>, false, false>::_Node_const_iterator(std::__detail::_Hash_node<std::pair<MtxS* const, MtxF>, false>*) (106,048x)
          .           
          .                 const_iterator
          .                 cbegin() const noexcept
          .                 { return const_iterator(_M_begin()); }
          .           
          .                 const_iterator
          .                 cend() const noexcept
          .                 { return const_iterator(nullptr); }
          .           
          .                 size_type
 35,713,215 ( 0.03%)        size() const noexcept
 47,617,620 ( 0.04%)        { return _M_element_count; }
          .           
          .                 _GLIBCXX_NODISCARD bool
     30,652 ( 0.00%)        empty() const noexcept
     53,641 ( 0.00%)        { return size() == 0; }
     53,599 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<int, std::pair<int const, bool>, std::allocator<std::pair<int const, bool> >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const (7,657x)
          .           
          .                 allocator_type
          .                 get_allocator() const noexcept
          .                 { return allocator_type(this->_M_node_allocator()); }
          .           
          .                 size_type
          .                 max_size() const noexcept
          .                 { return __node_alloc_traits::max_size(this->_M_node_allocator()); }
-- line 669 ----------------------------------------
-- line 791 ----------------------------------------
          .           	       typename = __has_is_transparent_t<_Equal, _Kt>>
          .           	pair<const_iterator, const_iterator>
          .           	_M_equal_range_tr(const _Kt& __k) const;
          .           #endif // __glibcxx_generic_unordered_lookup
          .           
          .               private:
          .                 // Bucket index computation helpers.
          .                 size_type
  1,045,120 ( 0.00%)        _M_bucket_index(const __node_value_type& __n) const noexcept
  1,881,216 ( 0.00%)        { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
  2,317,178 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::shared_ptr<Ship::Archive> >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> >, false> const&, unsigned long) const (20,506x)
          .           
          .                 size_type
 59,484,015 ( 0.05%)        _M_bucket_index(__hash_code __c) const
107,071,230 ( 0.09%)        { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }
        575 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_bucket_index(unsigned long, unsigned long) const (23x)
          .           
          .                 __node_base_ptr
          .                 _M_find_before_node(const key_type&);
          .           
          .                 // Find and insert helper functions and types
          .                 // Find the node before the one matching the criteria.
          .                 __node_base_ptr
          .                 _M_find_before_node(size_type, const key_type&, __hash_code) const;
          .           
          .                 template<typename _Kt>
          .           	__node_base_ptr
          .           	_M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;
          .           
          .                 __node_ptr
 83,276,452 ( 0.07%)        _M_find_node(size_type __bkt, const key_type& __key,
          .           		   __hash_code __c) const
          .                 {
 83,276,464 ( 0.07%)  	__node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
      1,419 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_find_before_node(unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long) const (20x)
 23,793,278 ( 0.02%)  	if (__before_n)
 35,423,131 ( 0.03%)  	  return static_cast<__node_ptr>(__before_n->_M_nxt);
     88,926 ( 0.00%)  	return nullptr;
 23,793,272 ( 0.02%)        }
          .           
          .                 template<typename _Kt>
          .           	__node_ptr
        189 ( 0.00%)  	_M_find_node_tr(size_type __bkt, const _Kt& __key,
          .           			__hash_code __c) const
          .           	{
        189 ( 0.00%)  	  auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
        240 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::__detail::_Hash_node_base* std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_before_node_tr<Attribute>(unsigned long, Attribute const&, unsigned long) const (12x)
         54 ( 0.00%)  	  if (__before_n)
          3 ( 0.00%)  	    return static_cast<__node_ptr>(__before_n->_M_nxt);
         26 ( 0.00%)  	  return nullptr;
         54 ( 0.00%)  	}
          .           
          .                 // Insert a node at the beginning of a bucket.
          .                 void
    407,928 ( 0.00%)        _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
          .                 {
    407,938 ( 0.00%)  	if (_M_buckets[__bkt])
          .           	  {
          .           	    // Bucket is not empty, we just need to insert the new node
          .           	    // after the bucket before begin.
    228,771 ( 0.00%)  	    __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
    203,352 ( 0.00%)  	    _M_buckets[__bkt]->_M_nxt = __node;
          .           	  }
          .           	else
          .           	  {
          .           	    // The bucket is empty, the new node is inserted at the
          .           	    // beginning of the singly-linked list and the bucket will
          .           	    // contain _M_before_begin pointer.
    102,292 ( 0.00%)  	    __node->_M_nxt = _M_before_begin._M_nxt;
     76,718 ( 0.00%)  	    _M_before_begin._M_nxt = __node;
          .           
    102,294 ( 0.00%)  	    if (__node->_M_nxt)
          .           	      // We must update former begin bucket that is pointing to
          .           	      // _M_before_begin.
    357,379 ( 0.00%)  	      _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;
        417 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&) const (3x)
         21 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>::_M_next() const (3x)
          .           
    204,582 ( 0.00%)  	    _M_buckets[__bkt] = &_M_before_begin;
          .           	  }
    331,365 ( 0.00%)        }
          .           
          .                 // Remove the bucket first node
          .                 void
          6 ( 0.00%)        _M_remove_bucket_begin(size_type __bkt, __node_ptr __next_n,
          .           			     size_type __next_bkt)
          .                 {
          2 ( 0.00%)  	if (!__next_n)
          .           	  _M_buckets[__bkt] = nullptr;
          3 ( 0.00%)  	else if (__next_bkt != __bkt)
          .           	  {
          .           	    _M_buckets[__next_bkt] = _M_buckets[__bkt];
          1 ( 0.00%)  	    _M_buckets[__bkt] = nullptr;
          .           	  }
          3 ( 0.00%)        }
          .           
          .                 // Get the node before __n in the bucket __bkt
          .                 __node_base_ptr
          .                 _M_get_previous_node(size_type __bkt, __node_ptr __n);
          .           
          .                 pair<__node_ptr, __hash_code>
          .                 _M_compute_hash_code(__node_ptr __hint, const key_type& __k) const;
          .           
-- line 887 ----------------------------------------
-- line 925 ----------------------------------------
          .           	static __conditional_t<
          .           	  __and_<__is_nothrow_invocable<_Hash&, const key_type&>,
          .           		 __not_<__is_nothrow_invocable<_Hash&, _Kt>>>::value,
          .           	  key_type, _Kt&&>
          .           	_S_forward_key(_Kt&& __k)
          .           	{ return std::forward<_Kt>(__k); }
          .           
          .                 static const key_type&
        159 ( 0.00%)        _S_forward_key(const key_type& __k)
        159 ( 0.00%)        { return __k; }
          .           
          .                 static key_type&&
          .                 _S_forward_key(key_type&& __k)
          .                 { return std::move(__k); }
          .           
          .                 template<typename _Arg, typename _NodeGenerator>
          .           	std::pair<iterator, bool>
        371 ( 0.00%)  	_M_insert_unique_aux(_Arg&& __arg, const _NodeGenerator& __node_gen)
          .           	{
        530 ( 0.00%)  	  return _M_insert_unique(
      7,441 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::pair<std::__detail::_Node_iterator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>, bool> std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique<Ship::Stick const&, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > > >(Ship::Stick const&, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > > const&) (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const& std::forward<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::remove_reference<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&) (2x)
        583 ( 0.00%)  	    _S_forward_key(_ExtractKey{}(std::forward<_Arg>(__arg))),
         32 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&& std::__detail::_Select1st::operator()<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) const (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const& std::forward<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::remove_reference<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&) (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_S_forward_key(Ship::Stick const&) (2x)
          .           	    std::forward<_Arg>(__arg), __node_gen);
        159 ( 0.00%)  	}
          .           
          .                 template<typename _Arg, typename _NodeGenerator>
          .           	std::pair<iterator, bool>
        318 ( 0.00%)  	_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
          .           		  true_type /* __uks */)
          .           	{
          .           	  using __to_value
          .           	    = __detail::_ConvertToValueType<_ExtractKey, value_type>;
        742 ( 0.00%)  	  return _M_insert_unique_aux(
      7,571 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::pair<std::__detail::_Node_iterator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>, bool> std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_aux<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > > >(std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > > const&) (2x)
         14 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_ConvertToValueType<std::__detail::_Select1st, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::operator()(std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) const (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const& std::forward<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::remove_reference<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&) (2x)
          .           	    __to_value{}(std::forward<_Arg>(__arg)), __node_gen);
        106 ( 0.00%)  	}
          .           
          .                 template<typename _Arg, typename _NodeGenerator>
          .           	iterator
          .           	_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
          .           		  false_type __uks)
          .           	{
          .           	  using __to_value
          .           	    = __detail::_ConvertToValueType<_ExtractKey, value_type>;
-- line 966 ----------------------------------------
-- line 992 ----------------------------------------
          .           
          .                 iterator
          .                 _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n);
          .           
          .               public:
          .                 // Emplace
          .                 template<typename... _Args>
          .           	__ireturn_type
      2,000 ( 0.00%)  	emplace(_Args&&... __args)
      4,000 ( 0.00%)  	{ return _M_emplace(__unique_keys{}, std::forward<_Args>(__args)...); }
    571,718 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::pair<std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>, bool> std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_emplace<std::pair<TextureCacheKey, TextureCacheValue> >(std::integral_constant<bool, true>, std::pair<TextureCacheKey, TextureCacheValue>&&) (400x)
      2,400 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<TextureCacheKey, TextureCacheValue>&& std::forward<std::pair<TextureCacheKey, TextureCacheValue> >(std::remove_reference<std::pair<TextureCacheKey, TextureCacheValue> >::type&) (400x)
          .           
          .                 template<typename... _Args>
          .           	iterator
          .           	emplace_hint(const_iterator __hint, _Args&&... __args)
          .           	{
          .           	  return _M_emplace(__hint, __unique_keys{},
          .           			    std::forward<_Args>(__args)...);
          .           	}
-- line 1009 ----------------------------------------
-- line 1015 ----------------------------------------
          .                 erase(const_iterator);
          .           
          .                 // LWG 2059.
          .                 iterator
          .                 erase(iterator __it)
          .                 { return erase(const_iterator(__it)); }
          .           
          .                 size_type
         70 ( 0.00%)        erase(const key_type& __k)
         99 ( 0.00%)        { return _M_erase(__unique_keys{}, __k); }
      6,531 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_erase(std::integral_constant<bool, true>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (14x)
          .           
          .                 iterator
          .                 erase(const_iterator, const_iterator);
          .           
          .                 void
          .                 clear() noexcept;
          .           
          .                 // Set number of buckets keeping it appropriate for container's number
-- line 1032 ----------------------------------------
-- line 1240 ----------------------------------------
          .                 void _M_rehash(size_type __bkt_count, false_type __uks);
          .               };
          .           
          .             // Definitions of class template _Hashtable's out-of-line member functions.
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
         45 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _Hashtable(size_type __bkt_count_hint,
          .           	       const _Hash& __h, const _Equal& __eq, const allocator_type& __a)
         30 ( 0.00%)      : _Hashtable(__h, __eq, __a)
        191 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable(std::hash<Ship::Stick> const&, std::equal_to<Ship::Stick> const&, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&) (1x)
          .               {
         44 ( 0.00%)        auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
      1,431 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
          8 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/hashtable_c++0x.cc:std::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const (1x)
         20 ( 0.00%)        if (__bkt_count > _M_bucket_count)
          .           	{
          .           	  _M_buckets = _M_allocate_buckets(__bkt_count);
          .           	  _M_bucket_count = __bkt_count;
          .           	}
         20 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _InputIterator>
         50 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .                 _Hashtable(_InputIterator __f, _InputIterator __l,
          .           		 size_type __bkt_count_hint,
          .           		 const _Hash& __h, const _Equal& __eq,
          .           		 const allocator_type& __a, true_type /* __uks */)
         40 ( 0.00%)        : _Hashtable(__bkt_count_hint, __h, __eq, __a)
      1,665 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable(unsigned long, std::hash<Ship::Stick> const&, std::equal_to<Ship::Stick> const&, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&) (1x)
         50 ( 0.00%)        { this->insert(__f, __l); }
      7,726 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:void std::__detail::_Insert_base<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::insert<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*>(std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*) (1x)
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _InputIterator>
          .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1282 ----------------------------------------
-- line 1303 ----------------------------------------
          .           	  _M_insert(*__f, __node_gen, __uks);
          .                 }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
          6 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               operator=(const _Hashtable& __ht)
          .               -> _Hashtable&
          .               {
          3 ( 0.00%)        if (&__ht == this)
          .           	return *this;
          .           
          2 ( 0.00%)        if (__node_alloc_traits::_S_propagate_on_copy_assign())
          .           	{
          .           	  auto& __this_alloc = this->_M_node_allocator();
          .           	  auto& __that_alloc = __ht._M_node_allocator();
          .           	  if (!__node_alloc_traits::_S_always_equal()
          .           	      && __this_alloc != __that_alloc)
          .           	    {
          .           	      // Replacement allocator cannot free existing storage.
          .           	      this->_M_deallocate_nodes(_M_begin());
-- line 1327 ----------------------------------------
-- line 1346 ----------------------------------------
          .           		  __throw_exception_again;
          .           		}
          .           	      return *this;
          .           	    }
          .           	  std::__alloc_on_copy(__this_alloc, __that_alloc);
          .           	}
          .           
          .                 // Reuse allocated buckets and nodes.
          5 ( 0.00%)        _M_assign_elements(__ht);
        211 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:void std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> >::_M_assign_elements<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&>(std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&) (1x)
          2 ( 0.00%)        return *this;
          3 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _Ht>
          .                 void
          6 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .                 _M_assign_elements(_Ht&& __ht)
          .                 {
          1 ( 0.00%)  	__buckets_ptr __former_buckets = nullptr;
          3 ( 0.00%)  	std::size_t __former_bucket_count = _M_bucket_count;
          6 ( 0.00%)  	__rehash_guard_t __rehash_guard(_M_rehash_policy);
         31 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_RehashStateGuard<std::__detail::_Prime_rehash_policy>::_RehashStateGuard(std::__detail::_Prime_rehash_policy&) (1x)
          .           
          6 ( 0.00%)  	if (_M_bucket_count != __ht._M_bucket_count)
          .           	  {
          .           	    __former_buckets = _M_buckets;
          .           	    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
          .           	    _M_bucket_count = __ht._M_bucket_count;
          .           	  }
          .           	else
          7 ( 0.00%)  	  __builtin_memset(_M_buckets, 0,
         13 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
          2 ( 0.00%)  			   _M_bucket_count * sizeof(__node_base_ptr));
          .           
          .           	__try
          .           	  {
          3 ( 0.00%)  	    __hashtable_base::operator=(std::forward<_Ht>(__ht));
          6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const& std::forward<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&>(std::remove_reference<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&>::type&) (1x)
          4 ( 0.00%)  	    _M_element_count = __ht._M_element_count;
          6 ( 0.00%)  	    _M_rehash_policy = __ht._M_rehash_policy;
          9 ( 0.00%)  	    __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
         14 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<unsigned int, false> > >::_ReuseOrAllocNode(std::__detail::_Hash_node<unsigned int, false>*, std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<unsigned int, false> > >&) (1x)
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> >::_M_begin() const (1x)
          2 ( 0.00%)  	    _M_before_begin._M_nxt = nullptr;
          9 ( 0.00%)  	    _M_assign(std::forward<_Ht>(__ht), __roan);
         20 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:void std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> >::_M_assign<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&, std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<unsigned int, false> > > >(std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&, std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<unsigned int, false> > > const&) (1x)
          6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const& std::forward<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&>(std::remove_reference<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&>::type&) (1x)
          2 ( 0.00%)  	    if (__former_buckets)
          .           	      _M_deallocate_buckets(__former_buckets, __former_bucket_count);
          1 ( 0.00%)  	    __rehash_guard._M_guarded_obj = nullptr;
          3 ( 0.00%)  	  }
         26 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<unsigned int, false> > >::~_ReuseOrAllocNode() (1x)
          .           	__catch(...)
          .           	  {
          .           	    if (__former_buckets)
          .           	      {
          .           		// Restore previous buckets.
          .           		_M_deallocate_buckets();
          .           		_M_buckets = __former_buckets;
          .           		_M_bucket_count = __former_bucket_count;
          .           	      }
          .           	    __builtin_memset(_M_buckets, 0,
          .           			     _M_bucket_count * sizeof(__node_base_ptr));
          .           	    __throw_exception_again;
          .           	  }
          7 ( 0.00%)        }
         11 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_RehashStateGuard<std::__detail::_Prime_rehash_policy>::~_RehashStateGuard() (1x)
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _Ht, typename _NodeGenerator>
          .                 void
    205,394 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .                 _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)
          .                 {
     29,342 ( 0.00%)  	__buckets_ptr __buckets = nullptr;
    117,368 ( 0.00%)  	if (!_M_buckets)
    293,410 ( 0.00%)  	  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);
    249,015 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_allocate_buckets(unsigned long) (1,277x)
          .           
          .           	__try
          .           	  {
    117,368 ( 0.00%)  	    if (!__ht._M_before_begin._M_nxt)
     22,318 ( 0.00%)  	      return;
          .           
          .           	    // First deal with the special first node pointed to by
          .           	    // _M_before_begin.
     28,096 ( 0.00%)  	    __node_ptr __ht_n = __ht._M_begin();
      8,939 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_begin() const (1,277x)
          .           	    __node_ptr __this_n
     91,312 ( 0.00%)  	      = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
    480,245 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false>* std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> > >::operator()<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > const&>(std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > const&) const (1,277x)
     19,155 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::__conditional<std::is_lvalue_reference<std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> > const&>::value>::type<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > const&, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >&&> std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__fwd_value_for<std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> > const&>(std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >&) (1,277x)
     56,192 ( 0.00%)  	    this->_M_copy_code(*__this_n, *__ht_n);
     10,216 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::__detail::_Select1st, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_copy_code(std::__detail::_Hash_node_code_cache<false>&, std::__detail::_Hash_node_code_cache<false> const&) const (1,277x)
     35,120 ( 0.00%)  	    _M_update_bbegin(__this_n);
    231,137 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_update_bbegin(std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false>*) (1,277x)
          .           
          .           	    // Then deal with other nodes.
     14,048 ( 0.00%)  	    __node_ptr __prev_n = __this_n;
    148,792 ( 0.00%)  	    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
    125,146 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false>::_M_next() const (17,878x)
          .           	      {
    215,852 ( 0.00%)  		__this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
  6,734,464 ( 0.01%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false>* std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> > >::operator()<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > const&>(std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > const&) const (16,601x)
    249,015 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::__conditional<std::is_lvalue_reference<std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> > const&>::value>::type<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > const&, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >&&> std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__fwd_value_for<std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> > const&>(std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >&) (16,601x)
     49,812 ( 0.00%)  		__prev_n->_M_nxt = __this_n;
    132,832 ( 0.00%)  		this->_M_copy_code(*__this_n, *__ht_n);
    132,808 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::__detail::_Select1st, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_copy_code(std::__detail::_Hash_node_code_cache<false>&, std::__detail::_Hash_node_code_cache<false> const&) const (16,601x)
    116,228 ( 0.00%)  		size_type __bkt = _M_bucket_index(*__this_n);
  2,141,529 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned short, std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, std::allocator<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> > >, std::__detail::_Select1st, std::equal_to<unsigned short>, std::hash<unsigned short>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> const&) const (16,601x)
    132,832 ( 0.00%)  		if (!_M_buckets[__bkt])
    116,228 ( 0.00%)  		  _M_buckets[__bkt] = __prev_n;
     33,208 ( 0.00%)  		__prev_n = __this_n;
          .           	      }
          .           	  }
          .           	__catch(...)
          .           	  {
          .           	    clear();
          .           	    if (__buckets)
          .           	      _M_deallocate_buckets();
          .           	    __throw_exception_again;
          .           	  }
     95,050 ( 0.00%)        }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_reset() noexcept
          .               {
          .                 _M_rehash_policy._M_reset();
          3 ( 0.00%)        _M_bucket_count = 1;
          3 ( 0.00%)        _M_single_bucket = nullptr;
          4 ( 0.00%)        _M_buckets = &_M_single_bucket;
          3 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
          3 ( 0.00%)        _M_element_count = 0;
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 1480 ----------------------------------------
-- line 1524 ----------------------------------------
          .           	  __ht.clear();
          .           	}
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
    176,046 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _Hashtable(const _Hashtable& __ht)
          .               : __hashtable_base(__ht),
          .                 __map_base(__ht),
          .                 __rehash_base(__ht),
          .                 __hashtable_alloc(
    410,774 ( 0.00%)  	__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
        120 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > >::_M_node_allocator() const (8x)
          .                 __enable_default_ctor(__ht),
     58,682 ( 0.00%)        _M_buckets(nullptr),
    117,364 ( 0.00%)        _M_bucket_count(__ht._M_bucket_count),
    117,364 ( 0.00%)        _M_element_count(__ht._M_element_count),
    498,797 ( 0.00%)        _M_rehash_policy(__ht._M_rehash_policy)
        384 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > >::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > >(std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> >&&) (8x)
         64 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node_base::_Hash_node_base() (8x)
          .               {
    146,705 ( 0.00%)        __alloc_node_gen_t __alloc_node_gen(*this);
         80 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > >::_AllocNode(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > >&) (8x)
    176,046 ( 0.00%)        _M_assign(__ht, __alloc_node_gen);
     10,136 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:void std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, std::allocator<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_assign<std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, std::allocator<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > > >(std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, std::allocator<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > > const&) (8x)
    117,364 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
          .           	       true_type /* alloc always equal */)
          .               noexcept(_S_nothrow_move())
          .               : __hashtable_base(__ht),
          .                 __map_base(__ht),
          .                 __rehash_base(__ht),
          .                 __hashtable_alloc(std::move(__a)),
          .                 __enable_default_ctor(__ht),
          6 ( 0.00%)        _M_buckets(__ht._M_buckets),
          6 ( 0.00%)        _M_bucket_count(__ht._M_bucket_count),
          3 ( 0.00%)        _M_before_begin(__ht._M_before_begin._M_nxt),
          6 ( 0.00%)        _M_element_count(__ht._M_element_count),
          9 ( 0.00%)        _M_rehash_policy(__ht._M_rehash_policy)
          .               {
          .                 // Update buckets if __ht is using its single bucket.
          7 ( 0.00%)        if (__ht._M_uses_single_bucket())
          .           	{
          6 ( 0.00%)  	  _M_buckets = &_M_single_bucket;
          9 ( 0.00%)  	  _M_single_bucket = __ht._M_single_bucket;
          .           	}
          .           
          .                 // Fix bucket containing the _M_before_begin pointer that can't be moved.
          .                 _M_update_bbegin();
          .           
          .                 __ht._M_reset();
          .               }
          .           
-- line 1582 ----------------------------------------
-- line 1646 ----------------------------------------
          .           	  __ht.clear();
          .           	}
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
    119,072 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               ~_Hashtable() noexcept
          .               {
          .                 // Getting a bucket index from a node shall not throw because it is used
          .                 // in methods (erase, swap...) that shall not throw. Need a complete
          .                 // type to check this, so do it in the destructor not at class scope.
          .                 static_assert(noexcept(declval<const __hash_code_base_access&>()
          .           			._M_bucket_index(declval<const __node_value_type&>(),
          .           					 (std::size_t)0)),
          .           		    "Cache the hash code or qualify your functors involved"
          .           		    " in hash code and bucket index computation with noexcept");
          .           
     89,257 ( 0.00%)        clear();
        240 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::clear() (4x)
     89,256 ( 0.00%)        _M_deallocate_buckets();
        176 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_deallocate_buckets() (4x)
    178,560 ( 0.00%)      }
         76 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> >, true> > >::~_Hashtable_alloc() (4x)
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1677 ----------------------------------------
-- line 1715 ----------------------------------------
          .                 __x._M_update_bbegin();
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
  1,298,998 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               find(const key_type& __k)
          .               -> iterator
          .               {
  1,948,497 ( 0.00%)        if (size() <= __small_size_threshold())
    334,290 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() (33,429x)
    234,003 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const (33,429x)
          .           	{
      4,272 ( 0.00%)  	  for (auto __it = _M_begin(); __it; __it = __it->_M_next())
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_begin() const (1x)
      5,670 ( 0.00%)  	    if (this->_M_key_equals(__k, *__it))
     89,067 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_key_equals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true> const&) const (630x)
          .           	      return iterator(__it);
        256 ( 0.00%)  	  return end();
         34 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::end() (1x)
          .           	}
          .           
  1,298,586 ( 0.00%)        __hash_code __code = this->_M_hash_code(__k);
  1,403,976 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::__detail::_Select1st, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(TextureCacheKey const&) const (33,428x)
  1,298,586 ( 0.00%)        std::size_t __bkt = _M_bucket_index(__code);
  1,303,692 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const (33,428x)
  2,597,172 ( 0.00%)        return iterator(_M_find_node(__bkt, __k, __code));
 10,296,182 ( 0.01%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node(unsigned long, TextureCacheKey const&, unsigned long) const (33,428x)
    768,844 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::_Node_iterator(std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>*) (33,428x)
    649,532 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
 69,989,232 ( 0.06%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               find(const key_type& __k) const
          .               -> const_iterator
          .               {
104,983,848 ( 0.09%)        if (size() <= __small_size_threshold())
  1,339,410 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() (133,941x)
    937,587 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const (133,941x)
          .           	{
    375,174 ( 0.00%)  	  for (auto __it = _M_begin(); __it; __it = __it->_M_next())
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::ResourceFactoryKey, std::pair<Ship::ResourceFactoryKey const, std::shared_ptr<Ship::ResourceFactory> >, std::allocator<std::pair<Ship::ResourceFactoryKey const, std::shared_ptr<Ship::ResourceFactory> > >, std::__detail::_Select1st, std::equal_to<Ship::ResourceFactoryKey>, Ship::ResourceFactoryKeyHash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_begin() const (1x)
      1,566 ( 0.00%)  	    if (this->_M_key_equals(__k, *__it))
     23,790 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_key_equals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> const&) const (174x)
          7 ( 0.00%)  	      return const_iterator(__it);
         23 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>::_Node_const_iterator(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true>*) (1x)
    213,788 ( 0.00%)  	  return end();
         34 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::ResourceFactoryKey, std::pair<Ship::ResourceFactoryKey const, std::shared_ptr<Ship::ResourceFactory> >, std::allocator<std::pair<Ship::ResourceFactoryKey const, std::shared_ptr<Ship::ResourceFactory> > >, std::__detail::_Select1st, std::equal_to<Ship::ResourceFactoryKey>, Ship::ResourceFactoryKeyHash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::end() const (1x)
          .           	}
          .           
 69,668,544 ( 0.06%)        __hash_code __code = this->_M_hash_code(__k);
  5,089,758 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(unsigned long const&) const (133,941x)
 69,668,544 ( 0.06%)        std::size_t __bkt = _M_bucket_index(__code);
  5,223,699 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const (133,941x)
139,337,088 ( 0.12%)        return const_iterator(_M_find_node(__bkt, __k, __code));
 39,804,464 ( 0.03%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node(unsigned long, unsigned long const&, unsigned long) const (133,941x)
  3,080,643 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>::_Node_const_iterator(std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*) (133,941x)
 34,994,616 ( 0.03%)      }
          .           
          .           #if __cplusplus > 201703L
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _Kt, typename, typename>
          .                 auto
-- line 1770 ----------------------------------------
-- line 2029 ----------------------------------------
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_find_before_node(const key_type& __k)
          .               -> __node_base_ptr
          .               {
          1 ( 0.00%)        __node_base_ptr __prev_p = &_M_before_begin;
          3 ( 0.00%)        if (!__prev_p->_M_nxt)
          .           	return nullptr;
          .           
          .                 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);
          2 ( 0.00%)  	   __p != nullptr;
          .           	   __p = __p->_M_next())
          .           	{
          .           	  if (this->_M_key_equals(__k, *__p))
          .           	    return __prev_p;
          .           
          .           	  __prev_p = __p;
          .           	}
          .           
-- line 2050 ----------------------------------------
-- line 2053 ----------------------------------------
          .           
          .             // Find the node before the one whose key compares equal to k in the bucket
          .             // bkt. Return nullptr if no node is found.
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
 83,276,577 ( 0.07%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_find_before_node(size_type __bkt, const key_type& __k,
          .           			__hash_code __code) const
          .               -> __node_base_ptr
          .               {
 83,276,553 ( 0.07%)        __node_base_ptr __prev_p = _M_buckets[__bkt];
 23,793,306 ( 0.02%)        if (!__prev_p)
     72,656 ( 0.00%)  	return nullptr;
          .           
 35,580,971 ( 0.03%)        for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
    429,212 ( 0.00%)  	   __p = __p->_M_next())
      6,146 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_next() const (878x)
          .           	{
107,815,928 ( 0.09%)  	  if (this->_M_equals(__k, __code, *__p))
    993,684 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_equals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> const&) const (27,945x)
 23,615,422 ( 0.02%)  	    return __prev_p;
          .           
  2,770,539 ( 0.00%)  	  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
  1,081,240 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> const&) const (27,031x)
    189,217 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_next() const (27,031x)
     52,611 ( 0.00%)  	    break;
    214,606 ( 0.00%)  	  __prev_p = __p;
          .           	}
          .           
     52,611 ( 0.00%)        return nullptr;
 23,793,327 ( 0.02%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _Kt>
          .                 auto
        189 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .                 _M_find_before_node_tr(size_type __bkt, const _Kt& __k,
          .           			     __hash_code __code) const
          .                 -> __node_base_ptr
          .                 {
        189 ( 0.00%)  	__node_base_ptr __prev_p = _M_buckets[__bkt];
         54 ( 0.00%)  	if (!__prev_p)
         38 ( 0.00%)  	  return nullptr;
          .           
         24 ( 0.00%)  	for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
         40 ( 0.00%)  	     __p = __p->_M_next())
         70 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true>::_M_next() const (10x)
          .           	  {
        172 ( 0.00%)  	    if (this->_M_equals_tr(__k, __code, *__p))
        738 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:bool std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_equals_tr<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> const&) const (18x)
          2 ( 0.00%)  	      return __prev_p;
          .           
        276 ( 0.00%)  	    if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
        600 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> const&) const (15x)
        105 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true>::_M_next() const (15x)
          7 ( 0.00%)  	      break;
         20 ( 0.00%)  	    __prev_p = __p;
          .           	  }
          .           
          7 ( 0.00%)  	return nullptr;
         54 ( 0.00%)        }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2121 ----------------------------------------
-- line 2129 ----------------------------------------
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename... _Args>
          .                 auto
      3,200 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .                 _M_emplace(true_type /* __uks */, _Args&&... __args)
          .                 -> pair<iterator, bool>
          .                 {
          .           	// First build the node to get access to the hash code
      3,600 ( 0.00%)  	_Scoped_node __node { this, std::forward<_Args>(__args)...  };
    158,099 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Scoped_node::_Scoped_node<std::pair<TextureCacheKey, TextureCacheValue> >(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false> > >*, std::pair<TextureCacheKey, TextureCacheValue>&&) (400x)
      2,400 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<TextureCacheKey, TextureCacheValue>&& std::forward<std::pair<TextureCacheKey, TextureCacheValue> >(std::remove_reference<std::pair<TextureCacheKey, TextureCacheValue> >::type&) (400x)
      4,000 ( 0.00%)  	const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());
      6,400 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<TextureCacheKey const, TextureCacheValue>&>::type&& std::__detail::_Select1st::operator()<std::pair<TextureCacheKey const, TextureCacheValue>&>(std::pair<TextureCacheKey const, TextureCacheValue>&) const (400x)
      1,600 ( 0.00%)  	const size_type __size = size();
      2,800 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const (400x)
      2,000 ( 0.00%)  	if (__size <= __small_size_threshold())
      4,000 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() (400x)
          .           	  {
          7 ( 0.00%)  	    for (auto __it = _M_begin(); __it; __it = __it->_M_next())
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_begin() const (1x)
          .           	      if (this->_M_key_equals(__k, *__it))
          .           		// There is already an equivalent node, no insertion
          .           		return { iterator(__it), false };
          .           	  }
          .           
      2,400 ( 0.00%)  	__hash_code __code = this->_M_hash_code(__k);
     16,800 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::__detail::_Select1st, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(TextureCacheKey const&) const (400x)
      2,400 ( 0.00%)  	size_type __bkt = _M_bucket_index(__code);
     15,600 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const (400x)
      2,000 ( 0.00%)  	if (__size > __small_size_threshold())
      4,000 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() (400x)
      3,591 ( 0.00%)  	  if (__node_ptr __p = _M_find_node(__bkt, __k, __code))
     94,995 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node(unsigned long, TextureCacheKey const&, unsigned long) const (399x)
          .           	    // There is already an equivalent node, no insertion
          .           	    return { iterator(__p), false };
          .           
          .           	// Insert the node
      3,200 ( 0.00%)  	auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
    203,819 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>*, unsigned long) (400x)
        400 ( 0.00%)  	__node._M_node = nullptr;
      3,600 ( 0.00%)  	return { __pos, true };
     13,200 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>, bool>::pair<std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>&, bool>(std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>&, bool&&) (400x)
      4,800 ( 0.00%)        }
      4,400 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Scoped_node::~_Scoped_node() (400x)
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename... _Args>
          .                 auto
          .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 2173 ----------------------------------------
-- line 2216 ----------------------------------------
          .                 return { __hint, this->_M_hash_code(__k) };
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
    458,945 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
          .           			  __node_ptr __node, size_type __n_elt)
          .               -> iterator
          .               {
    305,948 ( 0.00%)        __rehash_guard_t __rehash_guard(_M_rehash_policy);
     12,400 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_RehashStateGuard<std::__detail::_Prime_rehash_policy>::_RehashStateGuard(std::__detail::_Prime_rehash_policy&) (400x)
          .                 std::pair<bool, std::size_t> __do_rehash
    713,888 ( 0.00%)  	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
      6,910 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/hashtable_c++0x.cc:std::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const (400x)
          .           					  __n_elt);
          .           
    152,977 ( 0.00%)        if (__do_rehash.first)
          .           	{
        501 ( 0.00%)  	  _M_rehash(__do_rehash.second, true_type{});
     93,584 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_rehash(unsigned long, std::integral_constant<bool, true>) (6x)
        600 ( 0.00%)  	  __bkt = _M_bucket_index(__code);
        234 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const (6x)
          .           	}
          .           
     50,991 ( 0.00%)        __rehash_guard._M_guarded_obj = nullptr;
    356,937 ( 0.00%)        this->_M_store_code(*__node, __code);
      3,200 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::__detail::_Select1st, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_store_code(std::__detail::_Hash_node_code_cache<false>&, unsigned long) const (400x)
          .           
          .                 // Always insert at the beginning of the bucket.
    305,946 ( 0.00%)        _M_insert_bucket_begin(__bkt, __node);
     47,825 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_bucket_begin(unsigned long, std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>*) (400x)
    254,957 ( 0.00%)        ++_M_element_count;
    407,928 ( 0.00%)        return iterator(__node);
      9,200 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::_Node_iterator(std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>*) (400x)
    305,964 ( 0.00%)      }
      4,400 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_RehashStateGuard<std::__detail::_Prime_rehash_policy>::~_RehashStateGuard() (400x)
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2256 ----------------------------------------
-- line 2305 ----------------------------------------
          .           
          .             // Insert v if no element with its key is already present.
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _Kt, typename _Arg, typename _NodeGenerator>
          .                 auto
        530 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .                 _M_insert_unique(_Kt&& __k, _Arg&& __v,
          .           		       const _NodeGenerator& __node_gen)
          .                 -> pair<iterator, bool>
          .                 {
        212 ( 0.00%)  	const size_type __size = size();
         14 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const (2x)
        265 ( 0.00%)  	if (__size <= __small_size_threshold())
         20 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() (2x)
      1,514 ( 0.00%)  	  for (auto __it = _M_begin(); __it; __it = __it->_M_next())
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_begin() const (1x)
      2,007 ( 0.00%)  	    if (this->_M_key_equals_tr(__k, *__it))
     32,233 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:bool std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_key_equals_tr<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> const&) const (223x)
         15 ( 0.00%)  	      return { iterator(__it), false };
         33 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>, bool>::pair<std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>, bool>(std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>&&, bool&&) (1x)
         23 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>::_Node_iterator(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true>*) (1x)
          .           
        312 ( 0.00%)  	__hash_code __code = this->_M_hash_code_tr(__k);
        100 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:unsigned long std::__detail::_Hash_code_base<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code_tr<Ship::Stick>(Ship::Stick const&) const (2x)
        312 ( 0.00%)  	size_type __bkt = _M_bucket_index(__code);
         78 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const (2x)
          .           
        260 ( 0.00%)  	if (__size > __small_size_threshold())
         20 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__small_size_threshold() (2x)
        243 ( 0.00%)  	  if (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))
         39 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>* std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node_tr<Ship::Stick>(unsigned long, Ship::Stick const&, unsigned long) const (1x)
         15 ( 0.00%)  	    return { iterator(__node), false };
         33 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>, bool>::pair<std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>, bool>(std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>&&, bool&&) (1x)
         23 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, false, true>::_Node_iterator(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true>*) (1x)
          .           
        969 ( 0.00%)  	_Scoped_node __node {
      2,846 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >::__node_ptr std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<Ship::Stick const&, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > > >(Ship::Stick const&, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > > const&) (2x)
         28 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Scoped_node::_Scoped_node(std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*, std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >*) (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::Stick const& std::forward<Ship::Stick const&>(std::remove_reference<Ship::Stick const&>::type&) (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const& std::forward<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::remove_reference<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&) (2x)
          .           	  __node_builder_t::_S_build(std::forward<_Kt>(__k),
          .           				     std::forward<_Arg>(__v),
          .           				     __node_gen),
          .           	  this
          .           	};
          .           	auto __pos
        408 ( 0.00%)  	  = _M_insert_unique_node(__bkt, __code, __node._M_node);
      3,991 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*, unsigned long) (2x)
         51 ( 0.00%)  	__node._M_node = nullptr;
        459 ( 0.00%)  	return { __pos, true };
         66 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__detail::_Node_iterator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>, bool>::pair<std::__detail::_Node_iterator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>&, bool>(std::__detail::_Node_iterator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>&, bool&&) (2x)
        630 ( 0.00%)        }
         22 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Scoped_node::~_Scoped_node() (2x)
          .           
          .             // Insert v unconditionally.
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _Arg, typename _NodeGenerator>
          .                 auto
-- line 2350 ----------------------------------------
-- line 2388 ----------------------------------------
          .                 return _M_erase(__bkt, __prev_n, __n);
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
          8 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n)
          .               -> iterator
          .               {
         12 ( 0.00%)        if (__prev_n == _M_buckets[__bkt])
         14 ( 0.00%)  	_M_remove_bucket_begin(__bkt, __n->_M_next(),
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_next() const (1x)
         14 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_remove_bucket_begin(unsigned long, std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>*, unsigned long) (1x)
         13 ( 0.00%)  	  __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);
         40 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> const&) const (1x)
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_next() const (1x)
          .                 else if (__n->_M_nxt)
          .           	{
          .           	  size_type __next_bkt = _M_bucket_index(*__n->_M_next());
          .           	  if (__next_bkt != __bkt)
          .           	    _M_buckets[__next_bkt] = __prev_n;
          .           	}
          .           
          6 ( 0.00%)        __prev_n->_M_nxt = __n->_M_nxt;
          8 ( 0.00%)        iterator __result(__n->_M_next());
         23 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, false, true>::_Node_iterator(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>*) (1x)
          7 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_next() const (1x)
          5 ( 0.00%)        this->_M_deallocate_node(__n);
        614 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> > >::_M_deallocate_node(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>*) (1x)
          6 ( 0.00%)        --_M_element_count;
          .           
          1 ( 0.00%)        return __result;
          3 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
         95 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_erase(true_type /* __uks */, const key_type& __k)
          .               -> size_type
          .               {
          .                 __node_base_ptr __prev_n;
          .                 __node_ptr __n;
          .                 std::size_t __bkt;
        128 ( 0.00%)        if (size() <= __small_size_threshold())
        140 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::__small_size_threshold() (14x)
         98 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::size() const (14x)
          .           	{
          .           	  __prev_n = _M_find_before_node(__k);
          .           	  if (!__prev_n)
          .           	    return 0;
          .           
          .           	  // We found a matching node, erase it.
          1 ( 0.00%)  	  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
          .           	  __bkt = _M_bucket_index(*__n);
          .           	}
          .                 else
          .           	{
         84 ( 0.00%)  	  __hash_code __code = this->_M_hash_code(__k);
      2,420 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::__detail::_Select1st, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>::_M_hash_code(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (14x)
         84 ( 0.00%)  	  __bkt = _M_bucket_index(__code);
        546 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_bucket_index(unsigned long) const (14x)
          .           
          .           	  // Look for the node before the first matching node.
         98 ( 0.00%)  	  __prev_n = _M_find_before_node(__bkt, __k, __code);
      1,967 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_find_before_node(unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long) const (14x)
         28 ( 0.00%)  	  if (!__prev_n)
         26 ( 0.00%)  	    return 0;
          .           
          .           	  // We found a matching node, erase it.
          3 ( 0.00%)  	  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
          .           	}
          .           
          6 ( 0.00%)        _M_erase(__bkt, __prev_n, __n);
        778 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_erase(unsigned long, std::__detail::_Hash_node_base*, std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>*) (1x)
          1 ( 0.00%)        return 1;
         50 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2466 ----------------------------------------
-- line 2572 ----------------------------------------
          .                 return iterator(__n);
          .               }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
    120,709 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               clear() noexcept
          .               {
    241,400 ( 0.00%)        this->_M_deallocate_nodes(_M_begin());
      4,678 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false> > >::_M_deallocate_nodes(std::__detail::_Hash_node<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, false>*) (10x)
         70 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > >, std::allocator<std::pair<Ship::Direction const, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::shared_ptr<Ship::ControllerAxisDirectionMapping>, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > > > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_begin() const (10x)
    211,270 ( 0.00%)        __builtin_memset(_M_buckets, 0,
        136 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (10x)
     60,350 ( 0.00%)  		       _M_bucket_count * sizeof(__node_base_ptr));
     60,359 ( 0.00%)        _M_element_count = 0;
     60,359 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
     90,533 ( 0.00%)      }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2597 ----------------------------------------
-- line 2611 ----------------------------------------
          .               }
          .           
          .             // Rehash when there is no equivalent elements.
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
        500 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
          .               _M_rehash(size_type __bkt_count, true_type /* __uks */)
          .               {
        600 ( 0.00%)        __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
        509 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_allocate_buckets(unsigned long) (2x)
        400 ( 0.00%)        __node_ptr __p = _M_begin();
         14 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_begin() const (2x)
        201 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
        101 ( 0.00%)        std::size_t __bbegin_bkt = 0;
    122,988 ( 0.00%)        while (__p)
          .           	{
    245,372 ( 0.00%)  	  __node_ptr __next = __p->_M_next();
    278,313 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>::_M_next() const (39,759x)
          .           	  std::size_t __bkt
    490,744 ( 0.00%)  	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
  4,492,767 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::__detail::_Hash_node_value<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&, unsigned long) const (39,759x)
    429,401 ( 0.00%)  	  if (!__new_buckets[__bkt])
          .           	    {
    189,600 ( 0.00%)  	      __p->_M_nxt = _M_before_begin._M_nxt;
    142,200 ( 0.00%)  	      _M_before_begin._M_nxt = __p;
    331,801 ( 0.00%)  	      __new_buckets[__bkt] = &_M_before_begin;
    189,600 ( 0.00%)  	      if (__p->_M_nxt)
    284,070 ( 0.00%)  		__new_buckets[__bbegin_bkt] = __p;
    142,200 ( 0.00%)  	      __bbegin_bkt = __bkt;
          .           	    }
          .           	  else
          .           	    {
    111,544 ( 0.00%)  	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
     97,601 ( 0.00%)  	      __new_buckets[__bkt]->_M_nxt = __p;
          .           	    }
          .           
    122,686 ( 0.00%)  	  __p = __next;
          .           	}
          .           
        300 ( 0.00%)        _M_deallocate_buckets();
         88 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_deallocate_buckets() (2x)
        301 ( 0.00%)        _M_bucket_count = __bkt_count;
        301 ( 0.00%)        _M_buckets = __new_buckets;
        300 ( 0.00%)      }
          .           
          .             // Rehash when there can be equivalent elements, preserve their relative
          .             // order.
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               void
-- line 2661 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imstb_rectpack.h
--------------------------------------------------------------------------------
Ir               

-- line 238 ----------------------------------------
      .                    context->heuristic = heuristic;
      .                    break;
      .                 default:
      .                    STBRP_ASSERT(0);
      .              }
      .           }
      .           
      .           STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
      4 ( 0.00%)  {
      2 ( 0.00%)     if (allow_out_of_mem)
      .                 // if it's ok to run out of memory, then don't bother aligning them;
      .                 // this gives better packing, but may fail due to OOM (even though
      .                 // the rectangles easily fit). @TODO a smarter approach would be to only
      .                 // quantize once we've hit OOM, then we could get rid of this parameter.
      .                 context->align = 1;
      .              else {
      .                 // if it's not ok to run out of memory, then quantize the widths
      .                 // so that num_nodes is always enough nodes.
      .                 //
      .                 // I.e. num_nodes * align >= width
      .                 //                  align >= width / num_nodes
      .                 //                  align = ceil(width/num_nodes)
      .           
     14 ( 0.00%)        context->align = (context->width + context->num_nodes-1) / context->num_nodes;
      .              }
      3 ( 0.00%)  }
      .           
      .           STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
      8 ( 0.00%)  {
      .              int i;
      .           
  2,556 ( 0.00%)     for (i=0; i < num_nodes-1; ++i)
  7,140 ( 0.00%)        nodes[i].next = &nodes[i+1];
      7 ( 0.00%)     nodes[i].next = NULL;
      2 ( 0.00%)     context->init_mode = STBRP__INIT_skyline;
      2 ( 0.00%)     context->heuristic = STBRP_HEURISTIC_Skyline_default;
      3 ( 0.00%)     context->free_head = &nodes[0];
      4 ( 0.00%)     context->active_head = &context->extra[0];
      3 ( 0.00%)     context->width = width;
      3 ( 0.00%)     context->height = height;
      3 ( 0.00%)     context->num_nodes = num_nodes;
      4 ( 0.00%)     stbrp_setup_allow_out_of_mem(context, 0);
     23 ( 0.00%)  => build/_deps/imgui-src/imstb_rectpack.h:stbrp_setup_allow_out_of_mem (1x)
      .           
      .              // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
      2 ( 0.00%)     context->extra[0].x = 0;
      2 ( 0.00%)     context->extra[0].y = 0;
      4 ( 0.00%)     context->extra[0].next = &context->extra[1];
      3 ( 0.00%)     context->extra[1].x = (stbrp_coord) width;
      2 ( 0.00%)     context->extra[1].y = (1<<30);
      2 ( 0.00%)     context->extra[1].next = NULL;
      3 ( 0.00%)  }
      .           
      .           // find minimum y position if it starts at x1
      .           static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
273,720 ( 0.00%)  {
 68,430 ( 0.00%)     stbrp_node *node = first;
136,860 ( 0.00%)     int x1 = x0 + width;
      .              int min_y, visited_width, waste_area;
      .           
      .              STBRP__NOTUSED(c);
      .           
136,860 ( 0.00%)     STBRP_ASSERT(first->x <= x0);
      .           
      .              #if 0
      .              // skip in case we're past the node
      .              while (node->next->x <= x0)
      .                 ++node;
      .              #else
171,075 ( 0.00%)     STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
      .              #endif
      .           
136,860 ( 0.00%)     STBRP_ASSERT(node->x <= x0);
      .           
 34,215 ( 0.00%)     min_y = 0;
 34,215 ( 0.00%)     waste_area = 0;
 34,215 ( 0.00%)     visited_width = 0;
353,835 ( 0.00%)     while (node->x < x1) {
182,760 ( 0.00%)        if (node->y > min_y) {
      .                    // raise min_y higher.
      .                    // we've accounted for all waste up to min_y,
      .                    // but we'll now add more waste for everything we've visted
185,770 ( 0.00%)           waste_area += visited_width * (node->y - min_y);
111,462 ( 0.00%)           min_y = node->y;
      .                    // the first time through, visited_width might be reduced
148,616 ( 0.00%)           if (node->x < x0)
      .                       visited_width += node->next->x - x0;
      .                    else
297,232 ( 0.00%)              visited_width += node->next->x - node->x;
      .                 } else {
      .                    // add waste area
 59,752 ( 0.00%)           int under_width = node->next->x - node->x;
 42,680 ( 0.00%)           if (under_width + visited_width > width)
 15,093 ( 0.00%)              under_width = width - visited_width;
 59,752 ( 0.00%)           waste_area += under_width * (min_y - node->y);
 17,072 ( 0.00%)           visited_width += under_width;
      .                 }
137,070 ( 0.00%)        node = node->next;
      .              }
      .           
102,645 ( 0.00%)     *pwaste = waste_area;
 34,215 ( 0.00%)     return min_y;
 68,430 ( 0.00%)  }
      .           
      .           typedef struct
      .           {
      .              int x,y;
      .              stbrp_node **prev_link;
      .           } stbrp__findresult;
      .           
      .           static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
  5,424 ( 0.00%)  {
  1,808 ( 0.00%)     int best_waste = (1<<30), best_x, best_y = (1 << 30);
      .              stbrp__findresult fr;
    904 ( 0.00%)     stbrp_node **prev, *node, *tail, **best = NULL;
      .           
      .              // align to multiple of c->align
  5,424 ( 0.00%)     width = (width + c->align - 1);
  7,232 ( 0.00%)     width -= width % c->align;
  8,136 ( 0.00%)     STBRP_ASSERT(width % c->align == 0);
      .           
      .              // if it can't possibly fit, bail immediately
  7,232 ( 0.00%)     if (width > c->width || height > c->height) {
      .                 fr.prev_link = NULL;
      .                 fr.x = fr.y = 0;
      .                 return fr;
      .              }
      .           
  2,712 ( 0.00%)     node = c->active_head;
  2,712 ( 0.00%)     prev = &c->active_head;
281,856 ( 0.00%)     while (node->x + width <= c->width) {
      .                 int y,waste;
342,150 ( 0.00%)        y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
2,842,834 ( 0.00%)  => build/_deps/imgui-src/imstb_rectpack.h:stbrp__skyline_find_min_y(stbrp_context*, stbrp_node*, int, int, int*) (34,215x)
136,860 ( 0.00%)        if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
      .                    // bottom left
102,645 ( 0.00%)           if (y < best_y) {
  7,334 ( 0.00%)              best_y = y;
 11,001 ( 0.00%)              best = prev;
      .                    }
      .                 } else {
      .                    // best-fit
      .                    if (y + height <= c->height) {
      .                       // can only use it if it first vertically
      .                       if (y < best_y || (y == best_y && waste < best_waste)) {
      .                          best_y = y;
      .                          best_waste = waste;
      .                          best = prev;
      .                       }
      .                    }
      .                 }
102,645 ( 0.00%)        prev = &node->next;
102,645 ( 0.00%)        node = node->next;
      .              }
      .           
  6,328 ( 0.00%)     best_x = (best == NULL) ? 0 : (*best)->x;
      .           
      .              // if doing best-fit (BF), we also have to try aligning right edge to each node position
      .              //
      .              // e.g, if fitting
      .              //
      .              //     ____________________
      .              //    |____________________|
      .              //
-- line 399 ----------------------------------------
-- line 402 ----------------------------------------
      .              //   |                         |
      .              //   |             ____________|
      .              //   |____________|
      .              //
      .              // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
      .              //
      .              // This makes BF take about 2x the time
      .           
  3,616 ( 0.00%)     if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      .                 tail = c->active_head;
      .                 node = c->active_head;
      .                 prev = &c->active_head;
      .                 // find first node that's admissible
      .                 while (tail->x < width)
      .                    tail = tail->next;
      .                 while (tail) {
      .                    int xpos = tail->x - width;
-- line 418 ----------------------------------------
-- line 435 ----------------------------------------
      .                             best = prev;
      .                          }
      .                       }
      .                    }
      .                    tail = tail->next;
      .                 }
      .              }
      .           
  1,808 ( 0.00%)     fr.prev_link = best;
  1,808 ( 0.00%)     fr.x = best_x;
  1,808 ( 0.00%)     fr.y = best_y;
  1,808 ( 0.00%)     return fr;
  1,808 ( 0.00%)  }
      .           
      .           static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
  5,424 ( 0.00%)  {
      .              // find best position according to heuristic
  7,232 ( 0.00%)     stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
3,990,538 ( 0.00%)  => build/_deps/imgui-src/imstb_rectpack.h:stbrp__skyline_find_best_pos(stbrp_context*, int, int) (904x)
      .              stbrp_node *node, *cur;
      .           
      .              // bail if:
      .              //    1. it failed
      .              //    2. the best node doesn't fit (we don't always check this)
      .              //    3. we're out of memory
 12,656 ( 0.00%)     if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      .                 res.prev_link = NULL;
      .                 return res;
      .              }
      .           
      .              // on success, create new node
  2,712 ( 0.00%)     node = context->free_head;
  2,712 ( 0.00%)     node->x = (stbrp_coord) res.x;
  4,520 ( 0.00%)     node->y = (stbrp_coord) (res.y + height);
      .           
  3,616 ( 0.00%)     context->free_head = node->next;
      .           
      .              // insert the new node into the right starting point, and
      .              // let 'cur' point to the remaining nodes needing to be
      .              // stiched back in
      .           
  2,712 ( 0.00%)     cur = *res.prev_link;
  4,520 ( 0.00%)     if (cur->x < res.x) {
      .                 // preserve the existing one, so start testing with the next one
      .                 stbrp_node *next = cur->next;
      .                 cur->next = node;
      .                 cur = next;
      .              } else {
  2,712 ( 0.00%)        *res.prev_link = node;
      .              }
      .           
      .              // from here, traverse cur and free the nodes, until we get to one
      .              // that shouldn't be freed
 22,052 ( 0.00%)     while (cur->next && cur->next->x <= res.x + width) {
  2,595 ( 0.00%)        stbrp_node *next = cur->next;
      .                 // move the current node to the free list
  3,460 ( 0.00%)        cur->next = context->free_head;
  2,595 ( 0.00%)        context->free_head = cur;
  1,730 ( 0.00%)        cur = next;
      .              }
      .           
      .              // stitch the list back in
  2,712 ( 0.00%)     node->next = cur;
      .           
  6,328 ( 0.00%)     if (cur->x < res.x + width)
  3,820 ( 0.00%)        cur->x = (stbrp_coord) (res.x + width);
      .           
      .           #ifdef _DEBUG
      .              cur = context->active_head;
      .              while (cur->x < context->width) {
      .                 STBRP_ASSERT(cur->x < cur->next->x);
      .                 cur = cur->next;
      .              }
      .              STBRP_ASSERT(cur->next == NULL);
-- line 507 ----------------------------------------
-- line 517 ----------------------------------------
      .                 while (cur) {
      .                    cur = cur->next;
      .                    ++count;
      .                 }
      .                 STBRP_ASSERT(count == context->num_nodes+2);
      .              }
      .           #endif
      .           
  1,808 ( 0.00%)     return res;
  1,808 ( 0.00%)  }
      .           
      .           static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
 27,220 ( 0.00%)  {
 13,610 ( 0.00%)     const stbrp_rect *p = (const stbrp_rect *) a;
 13,610 ( 0.00%)     const stbrp_rect *q = (const stbrp_rect *) b;
 40,830 ( 0.00%)     if (p->h > q->h)
  1,424 ( 0.00%)        return -1;
 36,558 ( 0.00%)     if (p->h < q->h)
  2,174 ( 0.00%)        return  1;
 70,848 ( 0.00%)     return (p->w > q->w) ? -1 : (p->w < q->w);
 13,610 ( 0.00%)  }
      .           
      .           static int STBRP__CDECL rect_original_order(const void *a, const void *b)
 24,368 ( 0.00%)  {
 12,184 ( 0.00%)     const stbrp_rect *p = (const stbrp_rect *) a;
 12,184 ( 0.00%)     const stbrp_rect *q = (const stbrp_rect *) b;
 60,228 ( 0.00%)     return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
 12,184 ( 0.00%)  }
      .           
      .           STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
     18 ( 0.00%)  {
      3 ( 0.00%)     int i, all_rects_packed = 1;
      .           
      .              // we use the 'was_packed' field internally to allow sorting/unsorting
  3,631 ( 0.00%)     for (i=0; i < num_rects; ++i) {
  9,944 ( 0.00%)        rects[i].was_packed = i;
      .              }
      .           
      .              // sort according to heuristic
     21 ( 0.00%)     STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);
539,474 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImQsort(void*, unsigned long, unsigned long, int (*)(void const*, void const*)) (3x)
      .           
  3,631 ( 0.00%)     for (i=0; i < num_rects; ++i) {
 21,696 ( 0.00%)        if (rects[i].w == 0 || rects[i].h == 0) {
      .                    rects[i].x = rects[i].y = 0;  // empty rect needs no space
      .                 } else {
 24,408 ( 0.00%)           stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
4,088,262 ( 0.00%)  => build/_deps/imgui-src/imstb_rectpack.h:stbrp__skyline_pack_rectangle(stbrp_context*, int, int) (904x)
  2,712 ( 0.00%)           if (fr.prev_link) {
  9,944 ( 0.00%)              rects[i].x = (stbrp_coord) fr.x;
 10,848 ( 0.00%)              rects[i].y = (stbrp_coord) fr.y;
      .                    } else {
      .                       rects[i].x = rects[i].y = STBRP__MAXVAL;
      .                    }
      .                 }
      .              }
      .           
      .              // unsort
     21 ( 0.00%)     STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);
411,911 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImQsort(void*, unsigned long, unsigned long, int (*)(void const*, void const*)) (3x)
      .           
      .              // set was_packed flags and all_rects_packed status
  3,631 ( 0.00%)     for (i=0; i < num_rects; ++i) {
 22,600 ( 0.00%)        rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
 10,848 ( 0.00%)        if (!rects[i].was_packed)
      .                    all_rects_packed = 0;
      .              }
      .           
      .              // return the all_rects_packed status
      3 ( 0.00%)     return all_rects_packed;
      6 ( 0.00%)  }
      .           #endif
      .           
      .           /*
      .           ------------------------------------------------------------------------------
      .           This software is available under 2 licenses -- choose whichever you prefer.
      .           ------------------------------------------------------------------------------
      .           ALTERNATIVE A - MIT License
      .           Copyright (c) 2017 Sean Barrett
-- line 592 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/new_allocator.h
--------------------------------------------------------------------------------
Ir                 

-- line 80 ----------------------------------------
        .           #if __cplusplus >= 201103L
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 2103. propagate_on_container_move_assignment
        .                 typedef std::true_type propagate_on_container_move_assignment;
        .           #endif
        .           
        .                 __attribute__((__always_inline__))
        .                 _GLIBCXX20_CONSTEXPR
  946,295 ( 0.00%)        __new_allocator() _GLIBCXX_USE_NOEXCEPT { }
        .           
        .                 __attribute__((__always_inline__))
        .                 _GLIBCXX20_CONSTEXPR
  787,577 ( 0.00%)        __new_allocator(const __new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
        .           
        .                 template<typename _Tp1>
        .           	__attribute__((__always_inline__))
        .           	_GLIBCXX20_CONSTEXPR
        .           	__new_allocator(const __new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
        .           
        .           #if __cplusplus >= 201103L
        .                 __new_allocator& operator=(const __new_allocator&) = default;
-- line 100 ----------------------------------------
-- line 118 ----------------------------------------
        .           #else
        .           # define _GLIBCXX_OPERATOR_NEW ::operator new
        .           # define _GLIBCXX_OPERATOR_DELETE ::operator delete
        .           #endif
        .           
        .                 // NB: __n is permitted to be 0.  The C++ standard says nothing
        .                 // about what the return value is when __n == 0.
        .                 _GLIBCXX_NODISCARD _Tp*
6,055,368 ( 0.01%)        allocate(size_type __n, const void* = static_cast<const void*>(0))
        .                 {
        .           #if __cplusplus >= 201103L
        .           	// _GLIBCXX_RESOLVE_LIB_DEFECTS
        .           	// 3308. std::allocator<void>().allocate(n)
        .           	static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
        .           #endif
        .           
5,298,450 ( 0.00%)  	if (__builtin_expect(__n > this->_M_max_size(), false))
        .           	  {
        .           	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .           	    // 3190. allocator::allocate sometimes returns too little storage
        .           	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
        .           	      std::__throw_bad_array_new_length();
        .           	    std::__throw_bad_alloc();
        .           	  }
        .           
-- line 142 ----------------------------------------
-- line 143 ----------------------------------------
        .           #if __cpp_aligned_new
        .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
        .           	  {
        .           	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
        .           	    return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp),
        .           							   __al));
        .           	  }
        .           #endif
4,827,662 ( 0.00%)  	return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp)));
  827,748 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (12,620x)
1,513,842 ( 0.00%)        }
        .           
        .                 // __p is not permitted to be a null pointer.
        .                 void
4,015,896 ( 0.00%)        deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))
        .                 {
        .           #if __cpp_sized_deallocation
        .           # define _GLIBCXX_SIZED_DEALLOC(p, n) (p), (n) * sizeof(_Tp)
        .           #else
        .           # define _GLIBCXX_SIZED_DEALLOC(p, n) (p)
        .           #endif
        .           
        .           #if __cpp_aligned_new
        .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
        .           	  {
        .           	    _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n),
        .           				     std::align_val_t(alignof(_Tp)));
        .           	    return;
        .           	  }
        .           #endif
5,138,570 ( 0.00%)  	_GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));
  661,512 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/del_ops.cc:operator delete(void*, unsigned long) (7,085x)
    1,050 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
1,338,632 ( 0.00%)        }
        .           
        .           #undef _GLIBCXX_SIZED_DEALLOC
        .           #undef _GLIBCXX_OPERATOR_DELETE
        .           #undef _GLIBCXX_OPERATOR_NEW
        .           
        .           #if __cplusplus <= 201703L
        .                 __attribute__((__always_inline__))
        .                 size_type
-- line 181 ----------------------------------------
-- line 225 ----------------------------------------
        .           #endif
        .           
        .               private:
        .                 __attribute__((__always_inline__))
        .                 _GLIBCXX_CONSTEXPR size_type
        .                 _M_max_size() const _GLIBCXX_USE_NOEXCEPT
        .                 {
        .           #if __PTRDIFF_MAX__ < __SIZE_MAX__
  756,921 ( 0.00%)  	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
        .           #else
        .           	return std::size_t(-1) / sizeof(_Tp);
        .           #endif
        .                 }
        .               };
        .           
        .           _GLIBCXX_END_NAMESPACE_VERSION
        .           } // namespace
-- line 241 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/ext/aligned_buffer.h
--------------------------------------------------------------------------------
Ir                  

-- line 56 ----------------------------------------
         .                 alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
         .           
         .                 __aligned_membuf() = default;
         .           
         .                 // Can be used to avoid value-initialization zeroing _M_storage.
         .                 __aligned_membuf(std::nullptr_t) { }
         .           
         .                 void*
 3,500,571 ( 0.00%)        _M_addr() noexcept
 3,500,571 ( 0.00%)        { return static_cast<void*>(&_M_storage); }
         .           
         .                 const void*
   458,442 ( 0.00%)        _M_addr() const noexcept
   458,442 ( 0.00%)        { return static_cast<const void*>(&_M_storage); }
         .           
         .                 _Tp*
 4,667,428 ( 0.00%)        _M_ptr() noexcept
 5,834,285 ( 0.00%)        { return static_cast<_Tp*>(_M_addr()); }
        84 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<unsigned short>::_M_addr() (14x)
         .           
         .                 const _Tp*
   611,256 ( 0.00%)        _M_ptr() const noexcept
   764,070 ( 0.00%)        { return static_cast<const _Tp*>(_M_addr()); }
    22,830 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >::_M_addr() const (3,805x)
         .               };
         .           
         .           #if _GLIBCXX_INLINE_VERSION
         .             template<typename _Tp>
         .               using __aligned_buffer = __aligned_membuf<_Tp>;
         .           #else
         .           #pragma GCC diagnostic push
         .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-- line 85 ----------------------------------------
-- line 96 ----------------------------------------
         .           	std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
         .           
         .                 __aligned_buffer() = default;
         .           
         .                 // Can be used to avoid value-initialization
         .                 __aligned_buffer(std::nullptr_t) { }
         .           
         .                 void*
21,886,416 ( 0.02%)        _M_addr() noexcept
         .                 {
 7,295,477 ( 0.01%)          return static_cast<void*>(&_M_storage);
14,590,944 ( 0.01%)        }
         .           
         .                 const void*
36,314,388 ( 0.03%)        _M_addr() const noexcept
         .                 {
12,104,796 ( 0.01%)          return static_cast<const void*>(&_M_storage);
24,209,592 ( 0.02%)        }
         .           
         .                 _Tp*
28,789,232 ( 0.02%)        _M_ptr() noexcept
35,986,540 ( 0.03%)        { return static_cast<_Tp*>(_M_addr()); }
        18 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<spdlog::details::thread_pool>::_M_addr() (3x)
         .           
         .                 const _Tp*
48,419,184 ( 0.04%)        _M_ptr() const noexcept
60,523,980 ( 0.05%)        { return static_cast<const _Tp*>(_M_addr()); }
     7,824 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<Ship::ResourceFactoryKey const, std::shared_ptr<Ship::ResourceFactory> > >::_M_addr() const (1,304x)
         .               };
         .           #pragma GCC diagnostic pop
         .           #endif
         .           
         .           } // namespace
         .           
         .           #endif /* _ALIGNED_BUFFER_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/resource/archive/ArchiveManager.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 8 ----------------------------------------
        .           #include "resource/archive/OtrArchive.h"
        .           #endif
        .           #include "resource/archive/O2rArchive.h"
        .           #include "utils/StringHelper.h"
        .           #include "utils/glob.h"
        .           #include "utils/StrHash64.h"
        .           
        .           namespace Ship {
       23 ( 0.00%)  ArchiveManager::ArchiveManager() {
      120 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::shared_ptr<Ship::Archive>, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > > >::unordered_map() (1x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/unordered_set.h:std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> >::unordered_set() (1x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::unordered_map() (1x)
       48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<unsigned int, std::allocator<unsigned int> >::vector() (1x)
       48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<Ship::Archive>, std::allocator<std::shared_ptr<Ship::Archive> > >::vector() (1x)
        3 ( 0.00%)  }
        .           
        .           void ArchiveManager::Init(const std::vector<std::string>& archivePaths) {
        .               Init(archivePaths, {});
        .           }
        .           
        .           void ArchiveManager::Init(const std::vector<std::string>& archivePaths,
        7 ( 0.00%)                            const std::unordered_set<uint32_t>& validGameVersions) {
        6 ( 0.00%)      mValidGameVersions = validGameVersions;
      246 ( 0.00%)  => /usr/include/c++/14/bits/unordered_set.h:std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> >::operator=(std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> > const&) (1x)
        5 ( 0.00%)      auto archives = GetArchiveListInPaths(archivePaths);
   94,768 ( 0.00%)  => libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::GetArchiveListInPaths(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&) (1x)
       64 ( 0.00%)      for (const auto& archive : archives) {
      124 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:bool __gnu_cxx::operator==<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const&, __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const&) (4x)
       33 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::operator++() (3x)
       24 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::end() (1x)
       23 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::begin() (1x)
       21 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::operator*() const (3x)
       27 ( 0.00%)          AddArchive(archive);
326,350,274 ( 0.27%)  => libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::AddArchive(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (3x)
      246 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::~shared_ptr() (3x)
        .               }
        7 ( 0.00%)  }
    1,227 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::~vector() (1x)
        .           
        .           ArchiveManager::~ArchiveManager() {
        .               SPDLOG_TRACE("destruct archive manager");
        .               SetArchives({});
        .           }
        .           
        8 ( 0.00%)  bool ArchiveManager::IsArchiveLoaded() {
        8 ( 0.00%)      return !mArchives.empty();
      194 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<Ship::Archive>, std::allocator<std::shared_ptr<Ship::Archive> > >::empty() const (2x)
        4 ( 0.00%)  }
        .           
        .           std::shared_ptr<File> ArchiveManager::LoadFile(const std::string& filePath,
    5,216 ( 0.00%)                                                 std::shared_ptr<ResourceInitData> initData) {
    3,912 ( 0.00%)      if (filePath == "") {
   35,208 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:bool std::operator==<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*) (652x)
        .                   return nullptr;
        .               }
        .           
   14,344 ( 0.00%)      return LoadFile(CRC64(filePath.c_str()), initData);
58,999,056 ( 0.05%)  => libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::LoadFile(unsigned long, std::shared_ptr<Ship::ResourceInitData>) (652x)
  540,254 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/StrHash64.cpp:CRC64(char const*) (652x)
   31,296 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) (652x)
   20,864 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (652x)
   10,432 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (652x)
    3,260 ( 0.00%)  }
        .           
    5,868 ( 0.00%)  std::shared_ptr<File> ArchiveManager::LoadFile(uint64_t hash, std::shared_ptr<ResourceInitData> initData) {
    7,172 ( 0.00%)      const auto archive = mFileToArchive[hash];
  282,694 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::shared_ptr<Ship::Archive>, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > > >::operator[](unsigned long const&) (652x)
   50,204 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::shared_ptr(std::shared_ptr<Ship::Archive> const&) (652x)
    3,912 ( 0.00%)      if (archive == nullptr) {
   13,040 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::Archive>(std::shared_ptr<Ship::Archive> const&, decltype(nullptr)) (652x)
        .                   return nullptr;
        .               }
        .           
   13,692 ( 0.00%)      auto file = archive->LoadFile(hash, initData);
58,344,070 ( 0.05%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::LoadFile(unsigned long, std::shared_ptr<Ship::ResourceInitData>) (652x)
   31,296 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) (652x)
   20,864 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (652x)
   16,300 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (652x)
    5,216 ( 0.00%)      file->Parent = archive;
   54,768 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::operator=(std::shared_ptr<Ship::Archive> const&) (652x)
   16,300 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::File, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (652x)
    3,260 ( 0.00%)      return file;
   47,596 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::File>::shared_ptr(std::shared_ptr<Ship::File>&&) (652x)
    8,476 ( 0.00%)  }
   53,464 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::~shared_ptr() (652x)
   20,864 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::File>::~shared_ptr() (652x)
        .           
        .           bool ArchiveManager::HasFile(const std::string& filePath) {
        .               return HasFile(CRC64(filePath.c_str()));
        .           }
        .           
        .           bool ArchiveManager::HasFile(uint64_t hash) {
        .               return mFileToArchive.count(hash) > 0;
        .           }
-- line 67 ----------------------------------------
-- line 107 ----------------------------------------
        .               for (const auto& archive : archives) {
        .                   if (!archive->IsLoaded()) {
        .                       archive->Load();
        .                   }
        .                   AddArchive(archive);
        .               }
        .           }
        .           
  669,705 ( 0.00%)  const std::string* ArchiveManager::HashToString(uint64_t hash) const {
  937,587 ( 0.00%)      auto it = mHashes.find(hash);
62,708,375 ( 0.05%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::find(unsigned long const&) const (133,941x)
2,410,938 ( 0.00%)      return it != mHashes.end() ? &it->second : nullptr;
5,759,463 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::end() const (133,941x)
3,884,289 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>::operator->() const (133,941x)
1,607,292 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&, std::__detail::_Node_iterator_base<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&) (133,941x)
  267,882 ( 0.00%)  }
        .           
       10 ( 0.00%)  std::vector<std::string> ArchiveManager::GetArchiveListInPaths(const std::vector<std::string>& archivePaths) {
        4 ( 0.00%)      std::vector<std::string> fileList = {};
        .           
       64 ( 0.00%)      for (const auto& archivePath : archivePaths) {
      124 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:bool __gnu_cxx::operator==<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const&, __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const&) (4x)
       33 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::operator++() (3x)
       24 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::end() const (1x)
       23 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::begin() const (1x)
       21 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::operator*() const (3x)
       21 ( 0.00%)          if (archivePath.length() > 0) {
       21 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (3x)
       45 ( 0.00%)              if (std::filesystem::is_directory(archivePath)) {
    5,802 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::path<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::filesystem::__cxx11::path>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::filesystem::__cxx11::path::format) (3x)
    1,712 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (3x)
      327 ( 0.00%)  => /usr/include/c++/14/bits/fs_ops.h:std::filesystem::is_directory(std::filesystem::__cxx11::path const&) (3x)
        .                           for (const auto& p : std::filesystem::recursive_directory_iterator(archivePath)) {
        .                               if (StringHelper::IEquals(p.path().extension().string(), ".otr") ||
        .                                   StringHelper::IEquals(p.path().extension().string(), ".zip") ||
        .                                   StringHelper::IEquals(p.path().extension().string(), ".mpq") ||
        .                                   StringHelper::IEquals(p.path().extension().string(), ".o2r")) {
        .                                   fileList.push_back(std::filesystem::absolute(p).string());
        .                               }
        .                           }
       45 ( 0.00%)              } else if (std::filesystem::is_regular_file(archivePath)) {
    5,640 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::path<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::filesystem::__cxx11::path>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::filesystem::__cxx11::path::format) (3x)
    1,712 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (3x)
      327 ( 0.00%)  => /usr/include/c++/14/bits/fs_ops.h:std::filesystem::is_regular_file(std::filesystem::__cxx11::path const&) (3x)
      100 ( 0.00%)                  fileList.push_back(std::filesystem::absolute(archivePath).string());
   59,687 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++17/../../../../../libstdc++-v3/src/c++17/fs_ops.cc:std::filesystem::absolute(std::filesystem::__cxx11::path const&) (3x)
    5,640 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::path<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::filesystem::__cxx11::path>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::filesystem::__cxx11::path::format) (3x)
    3,831 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (6x)
    5,947 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::push_back(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (3x)
    1,934 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::string() const (3x)
    1,364 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      300 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
        .                       } else {
        .                           SPDLOG_WARN("The archive at path {} does not exist", std::filesystem::absolute(archivePath).string());
        .                       }
        .                   } else {
        .                       SPDLOG_WARN("No archive path supplied");
        .                   }
        .               }
        .           
        1 ( 0.00%)      return fileList;
        9 ( 0.00%)  }
        .           
       33 ( 0.00%)  std::shared_ptr<Archive> ArchiveManager::AddArchive(const std::string& archivePath) {
       18 ( 0.00%)      const std::filesystem::path path = archivePath;
    7,855 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::path<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::filesystem::__cxx11::path>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::filesystem::__cxx11::path::format) (3x)
       39 ( 0.00%)      const std::string extension = path.extension().string();
    4,383 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::extension() const (3x)
    1,116 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::string() const (3x)
      774 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (3x)
        6 ( 0.00%)      std::shared_ptr<Archive> archive = nullptr;
        .           
      112 ( 0.00%)      SPDLOG_INFO("Reading archive: {}", path.string());
   26,621 ( 0.00%)  => /usr/include/spdlog/logger.h:void spdlog::logger::log<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(spdlog::source_loc, spdlog::level::level_enum, fmt::v10::basic_format_string<char, fmt::v10::type_identity<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::type>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (3x)
    2,096 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::string() const (3x)
      819 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
    1,192 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       84 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::default_logger_raw() (3x)
       54 ( 0.00%)  => /usr/include/spdlog/common.h:spdlog::source_loc::source_loc(char const*, int, char const*) (3x)
        .           
      150 ( 0.00%)      if (StringHelper::IEquals(extension, ".o2r") || StringHelper::IEquals(extension, ".zip")) {
    4,143 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/StringHelper.cpp:StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (6x)
    2,004 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (6x)
      600 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (6x)
        .                   archive = dynamic_pointer_cast<Archive>(std::make_shared<O2rArchive>(archivePath));
        .           #ifndef EXCLUDE_MPQ_SUPPORT
       96 ( 0.00%)      } else if (StringHelper::IEquals(extension, ".otr") || StringHelper::IEquals(extension, ".mpq")) {
    2,922 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/StringHelper.cpp:StringHelper::IEquals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (3x)
    1,002 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (3x)
      300 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
       66 ( 0.00%)          archive = dynamic_pointer_cast<Archive>(std::make_shared<OtrArchive>(archivePath));
    6,481 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::OtrArchive> std::make_shared<Ship::OtrArchive, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (3x)
      615 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::operator=(std::shared_ptr<Ship::Archive>&&) (3x)
       96 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::~shared_ptr() (3x)
      363 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive> std::dynamic_pointer_cast<Ship::Archive, Ship::OtrArchive>(std::shared_ptr<Ship::OtrArchive>&&) (3x)
       96 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::OtrArchive>::~shared_ptr() (3x)
        .           #endif
        .               } else {
        .                   // Not recognized file extension, trying with o2r
        .                   SPDLOG_WARN("File extension \"{}\" not recognized, trying to create an o2r archive.", extension);
        .                   archive = std::make_shared<O2rArchive>(archivePath);
        .               }
        .           
       15 ( 0.00%)      archive->Load();
252,862,290 ( 0.21%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::Load() (3x)
       75 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (3x)
       48 ( 0.00%)      return AddArchive(archive);
73,420,674 ( 0.06%)  => libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::AddArchive(std::shared_ptr<Ship::Archive>) (3x)
       96 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::~shared_ptr() (3x)
      231 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::shared_ptr(std::shared_ptr<Ship::Archive> const&) (3x)
       54 ( 0.00%)  }
    2,091 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (3x)
      300 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
      246 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::~shared_ptr() (3x)
        .           
       33 ( 0.00%)  std::shared_ptr<Archive> ArchiveManager::AddArchive(std::shared_ptr<Archive> archive) {
       24 ( 0.00%)      if (!archive->IsLoaded()) {
       75 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (3x)
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::IsLoaded() (3x)
        .                   SPDLOG_WARN("Attempting to add unloaded Archive at {} to Archive Manager", archive->GetPath());
        .                   return nullptr;
        .               }
        .           
       30 ( 0.00%)      if (!mValidGameVersions.empty() && !mValidGameVersions.contains(archive->GetGameVersion())) {
       81 ( 0.00%)  => /usr/include/c++/14/bits/unordered_set.h:std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> >::empty() const (3x)
        .                   SPDLOG_WARN("Attempting to add Archive at {} with invalid Game Version {} to Archive Manager",
        .                               archive->GetPath(), archive->GetGameVersion());
        .                   return nullptr;
        .               }
        .           
       99 ( 0.00%)      SPDLOG_INFO("Adding Archive {} to Archive Manager", archive->GetPath());
   24,279 ( 0.00%)  => /usr/include/spdlog/logger.h:void spdlog::logger::log<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(spdlog::source_loc, spdlog::level::level_enum, fmt::v10::basic_format_string<char, fmt::v10::type_identity<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (3x)
       75 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (3x)
       84 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::default_logger_raw() (3x)
       54 ( 0.00%)  => /usr/include/spdlog/common.h:spdlog::source_loc::source_loc(char const*, int, char const*) (3x)
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::GetPath[abi:cxx11]() (3x)
        .           
       15 ( 0.00%)      mArchives.push_back(archive);
    3,278 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<Ship::Archive>, std::allocator<std::shared_ptr<Ship::Archive> > >::push_back(std::shared_ptr<Ship::Archive> const&) (3x)
       21 ( 0.00%)      if (archive->HasGameVersion()) {
       75 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (3x)
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::HasGameVersion() (3x)
       24 ( 0.00%)          mGameVersions.push_back(archive->GetGameVersion());
    1,769 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<unsigned int, std::allocator<unsigned int> >::push_back(unsigned int&&) (2x)
       50 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (2x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::GetGameVersion() (2x)
        .               }
       24 ( 0.00%)      const auto fileList = archive->ListFiles();
       75 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Archive, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (3x)
      273 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/Archive.cpp:Ship::Archive::ListFiles[abi:cxx11]() (3x)
  380,805 ( 0.00%)      for (auto& [hash, filename] : *fileList.get()) {
  529,728 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>::operator*() const (16,554x)
  496,620 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>::operator++() (16,554x)
  264,864 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::tuple_element<1ul, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::type& std::get<1ul, unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >&) (16,554x)
  248,310 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::tuple_element<0ul, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::type& std::get<0ul, unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >&) (16,554x)
  198,684 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&, std::__detail::_Node_iterator_base<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> const&) (16,557x)
      162 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::begin() (3x)
      129 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::end() (3x)
       21 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, (__gnu_cxx::_Lock_policy)2>::get() const (3x)
  182,094 ( 0.00%)          mHashes[hash] = filename;
29,556,824 ( 0.02%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::operator[](unsigned long const&) (16,554x)
12,556,050 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (16,554x)
  182,094 ( 0.00%)          mFileToArchive[hash] = archive;
27,402,569 ( 0.02%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<unsigned long, std::shared_ptr<Ship::Archive>, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > > >::operator[](unsigned long const&) (16,554x)
1,390,686 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::operator=(std::shared_ptr<Ship::Archive> const&) (16,554x)
        .               }
       15 ( 0.00%)      return archive;
      219 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::shared_ptr(std::shared_ptr<Ship::Archive>&&) (3x)
       39 ( 0.00%)  }
      246 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::unordered_map<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >::~shared_ptr() (3x)
        .           
       10 ( 0.00%)  bool ArchiveManager::IsGameVersionValid(uint32_t gameVersion) {
       16 ( 0.00%)      return mValidGameVersions.empty() || mValidGameVersions.contains(gameVersion);
       54 ( 0.00%)  => /usr/include/c++/14/bits/unordered_set.h:std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> >::empty() const (2x)
        4 ( 0.00%)  }
        .           
       10 ( 0.00%)  } // namespace Ship
        9 ( 0.00%)  => libultraship/src/resource/archive/ArchiveManager.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/utils/binarytools/MemoryStream.cpp
--------------------------------------------------------------------------------
Ir                 

        .           #include "MemoryStream.h"
        .           #include <cstring>
        .           
        .           #ifndef _MSC_VER
        .           #define memcpy_s(dest, destSize, source, sourceSize) memcpy(dest, source, destSize)
        .           #endif
        .           
   19,590 ( 0.00%)  Ship::MemoryStream::MemoryStream() {
   40,486 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::shared_ptr() (1,306x)
   11,754 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/binarytools/Stream.h:Ship::Stream::Stream() (1,306x)
   15,672 ( 0.00%)      mBuffer = std::make_shared<std::vector<char>>();
  615,275 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > > std::make_shared<std::vector<char, std::allocator<char> >>() (1,306x)
  267,730 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::operator=(std::shared_ptr<std::vector<char, std::allocator<char> > >&&) (1,306x)
   41,792 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::~shared_ptr() (1,306x)
        .               // mBuffer.reserve(1024 * 16);
    2,612 ( 0.00%)      mBufferSize = 0;
    2,612 ( 0.00%)      mBaseAddress = 0;
    5,224 ( 0.00%)  }
        .           
       20 ( 0.00%)  Ship::MemoryStream::MemoryStream(char* nBuffer, size_t nBufferSize) : MemoryStream() {
    1,715 ( 0.00%)  => libultraship/src/utils/binarytools/MemoryStream.cpp:Ship::MemoryStream::MemoryStream() (2x)
       38 ( 0.00%)      mBuffer = std::make_shared<std::vector<char>>(nBuffer, nBuffer + nBufferSize);
    2,594 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > > std::make_shared<std::vector<char, std::allocator<char> >, char*&, char*>(char*&, char*&&) (2x)
    1,334 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::operator=(std::shared_ptr<std::vector<char, std::allocator<char> > >&&) (2x)
       64 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::~shared_ptr() (2x)
        6 ( 0.00%)      mBufferSize = nBufferSize;
        4 ( 0.00%)      mBaseAddress = 0;
        8 ( 0.00%)  }
        .           
   10,432 ( 0.00%)  Ship::MemoryStream::MemoryStream(std::shared_ptr<std::vector<char>> buffer) : MemoryStream() {
1,021,032 ( 0.00%)  => libultraship/src/utils/binarytools/MemoryStream.cpp:Ship::MemoryStream::MemoryStream() (1,304x)
    7,824 ( 0.00%)      mBuffer = buffer;
  712,752 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::operator=(std::shared_ptr<std::vector<char, std::allocator<char> > > const&) (1,304x)
    9,128 ( 0.00%)      mBufferSize = buffer->size();
   32,600 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::vector<char, std::allocator<char> >, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1,304x)
   14,344 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::size() const (1,304x)
    2,608 ( 0.00%)      mBaseAddress = 0;
    3,912 ( 0.00%)  }
        .           
    9,142 ( 0.00%)  Ship::MemoryStream::~MemoryStream() {
   13,060 ( 0.00%)  }
  108,174 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::vector<char, std::allocator<char> > >::~shared_ptr() (1,306x)
   11,754 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/binarytools/Stream.h:Ship::Stream::~Stream() (1,306x)
        .           
        .           uint64_t Ship::MemoryStream::GetLength() {
        .               return mBuffer->size();
        .           }
        .           
    3,260 ( 0.00%)  void Ship::MemoryStream::Seek(int32_t offset, SeekOffsetType seekType) {
    1,304 ( 0.00%)      if (seekType == SeekOffsetType::Start) {
    2,608 ( 0.00%)          mBaseAddress = offset;
        .               } else if (seekType == SeekOffsetType::Current) {
        .                   mBaseAddress += offset;
        .               } else if (seekType == SeekOffsetType::End) {
        .                   mBaseAddress = mBufferSize - 1 - offset;
        .               }
    2,608 ( 0.00%)  }
        .           
        .           std::unique_ptr<char[]> Ship::MemoryStream::Read(size_t length) {
        .               std::unique_ptr<char[]> result = std::make_unique<char[]>(length);
        .           
        .               memcpy_s(result.get(), length, &mBuffer->at(mBaseAddress), length);
        .               mBaseAddress += length;
        .           
        .               return result;
        .           }
        .           
  505,560 ( 0.00%)  void Ship::MemoryStream::Read(const char* dest, size_t length) {
1,432,420 ( 0.00%)      memcpy_s((void*)dest, length, &mBuffer->at(mBaseAddress), length);
4,465,780 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::at(unsigned long) (84,260x)
2,106,500 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::vector<char, std::allocator<char> >, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (84,260x)
1,832,970 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (84,260x)
  505,560 ( 0.00%)      mBaseAddress += length;
  252,780 ( 0.00%)  }
        .           
   35,368 ( 0.00%)  int8_t Ship::MemoryStream::ReadByte() {
  114,946 ( 0.00%)      return mBuffer->at(mBaseAddress++);
  468,626 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::at(unsigned long) (8,842x)
  221,050 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::vector<char, std::allocator<char> >, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (8,842x)
   17,684 ( 0.00%)  }
        .           
        .           void Ship::MemoryStream::Write(char* srcBuffer, size_t length) {
        .               if (mBaseAddress + length >= mBuffer->size()) {
        .                   mBuffer->resize(mBaseAddress + length);
        .                   mBufferSize += length;
        .               }
        .           
        .               memcpy_s(&((*mBuffer)[mBaseAddress]), length, srcBuffer, length);
-- line 68 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/mutex
--------------------------------------------------------------------------------
Ir                 

-- line 78 ----------------------------------------
        .               typedef __gthread_recursive_mutex_t		__native_type;
        .           
        .               __recursive_mutex_base(const __recursive_mutex_base&) = delete;
        .               __recursive_mutex_base& operator=(const __recursive_mutex_base&) = delete;
        .           
        .           #ifdef __GTHREAD_RECURSIVE_MUTEX_INIT
        .               __native_type  _M_mutex = __GTHREAD_RECURSIVE_MUTEX_INIT;
        .           
        4 ( 0.00%)      __recursive_mutex_base() = default;
        .           #else
        .               __native_type  _M_mutex;
        .           
        .               __recursive_mutex_base()
        .               {
        .                 // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
        .                 __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);
        .               }
-- line 94 ----------------------------------------
-- line 778 ----------------------------------------
        .           
        .             template<typename _Mutex>
        .               class scoped_lock<_Mutex>
        .               {
        .               public:
        .                 using mutex_type = _Mutex;
        .           
        .                 [[nodiscard]]
    4,272 ( 0.00%)        explicit scoped_lock(mutex_type& __m) : _M_device(__m)
    3,738 ( 0.00%)        { _M_device.lock(); }
   37,380 ( 0.00%)  => /usr/include/c++/14/bits/std_mutex.h:std::mutex::lock() (534x)
        .           
        .                 [[nodiscard]]
        .                 explicit scoped_lock(adopt_lock_t, mutex_type& __m) noexcept
        .                 : _M_device(__m)
        .                 { } // calling thread owns mutex
        .           
    2,136 ( 0.00%)        ~scoped_lock()
    3,738 ( 0.00%)        { _M_device.unlock(); }
   33,642 ( 0.00%)  => /usr/include/c++/14/bits/std_mutex.h:std::mutex::unlock() (534x)
        .           
        .                 scoped_lock(const scoped_lock&) = delete;
        .                 scoped_lock& operator=(const scoped_lock&) = delete;
        .           
        .               private:
        .                 mutex_type&  _M_device;
        .               };
        .           #endif // __cpp_lib_scoped_lock
        .           
        .           #ifdef _GLIBCXX_HAS_GTHREADS
        .             /// Flag type used by std::call_once
        .             struct once_flag
        .             {
  785,312 ( 0.00%)      constexpr once_flag() noexcept = default;
        .           
        .               /// Deleted copy constructor
        .               once_flag(const once_flag&) = delete;
        .               /// Deleted assignment operator
        .               once_flag& operator=(const once_flag&) = delete;
        .           
        .             private:
        .               // For gthreads targets a pthread_once_t is used with pthread_once, but
-- line 817 ----------------------------------------
-- line 832 ----------------------------------------
        .             extern __thread void* __once_callable;
        .             extern __thread void (*__once_call)();
        .           
        .             // RAII type to set up state for pthread_once call.
        .             struct once_flag::_Prepare_execution
        .             {
        .               template<typename _Callable>
        .                 explicit
  490,820 ( 0.00%)        _Prepare_execution(_Callable& __c)
        .                 {
        .           	// Store address in thread-local pointer:
  490,820 ( 0.00%)  	__once_callable = std::__addressof(__c);
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&)::{lambda()#1}* std::__addressof<std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&)::{lambda()#1}>(void (std::__future_base::_State_baseV2::*&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)) (98,164x)
        .           	// Trampoline function to invoke the closure via thread-local pointer:
2,748,592 ( 0.00%)  	__once_call = [] { (*static_cast<_Callable*>(__once_callable))(); };
143,327,968 ( 0.12%)  => /usr/include/c++/14/mutex:std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&)::{lambda()#1}::operator()() const (98,164x)
  294,492 ( 0.00%)        }
        .           
  294,492 ( 0.00%)      ~_Prepare_execution()
        .               {
        .                 // PR libstdc++/82481
  196,328 ( 0.00%)        __once_callable = nullptr;
  196,328 ( 0.00%)        __once_call = nullptr;
  294,492 ( 0.00%)      }
        .           
        .               _Prepare_execution(const _Prepare_execution&) = delete;
        .               _Prepare_execution& operator=(const _Prepare_execution&) = delete;
        .             };
        .           
        .           # else
        .             // Without TLS use a global std::mutex and store the callable in a
        .             // global std::function.
-- line 861 ----------------------------------------
-- line 897 ----------------------------------------
        .           
        .             // This function is passed to pthread_once by std::call_once.
        .             // It runs __once_call() or __once_functor().
        .             extern "C" void __once_proxy(void);
        .           
        .             /// Invoke a callable and synchronize with other calls using the same flag
        .             template<typename _Callable, typename... _Args>
        .               void
  883,476 ( 0.00%)      call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)
        .               {
        .                 // Closure type that runs the function
2,159,608 ( 0.00%)        auto __callable = [&] {
2,355,936 ( 0.00%)  	  std::__invoke(std::forward<_Callable>(__f),
137,241,800 ( 0.11%)  => /usr/include/c++/14/bits/invoke.h:std::__invoke_result<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>::type std::__invoke<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:bool*&& std::forward<bool*>(std::remove_reference<bool*>::type&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&& std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*>(std::remove_reference<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*>::type&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:void (std::__future_base::_State_baseV2::*&&std::forward<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)>(std::remove_reference<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)>::type&))(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__future_base::_State_baseV2*&& std::forward<std::__future_base::_State_baseV2*>(std::remove_reference<std::__future_base::_State_baseV2*>::type&) (98,164x)
        .           			std::forward<_Args>(__args)...);
        .                 };
        .           
  490,820 ( 0.00%)        once_flag::_Prepare_execution __exec(__callable);
2,944,920 ( 0.00%)  => /usr/include/c++/14/mutex:std::once_flag::_Prepare_execution::_Prepare_execution<std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&)::{lambda()#1}>(void (std::__future_base::_State_baseV2::*&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)) (98,164x)
        .           
        .                 // XXX pthread_once does not reset the flag if an exception is thrown.
  687,148 ( 0.00%)        if (int __e = __gthread_once(&__once._M_once, &__once_proxy))
157,073,552 ( 0.13%)  => /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_once(int*, void (*)()) (98,164x)
        .           	__throw_system_error(__e);
  687,148 ( 0.00%)      }
  981,640 ( 0.00%)  => /usr/include/c++/14/mutex:std::once_flag::_Prepare_execution::~_Prepare_execution() (98,164x)
        .           
        .           #else // _GLIBCXX_HAS_GTHREADS
        .           
        .             /// Flag type used by std::call_once
        .             struct once_flag
        .             {
        .               constexpr once_flag() noexcept = default;
        .           
-- line 926 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/code_80057C60.c
--------------------------------------------------------------------------------
Ir               

-- line 404 ----------------------------------------
      .           
      .           s32 D_800E480C[] = {
      .               MAKE_RGB(0xB0, 0xB0, 0xB0), MAKE_RGB(0x80, 0x40, 0x11), MAKE_RGB(0xB0, 0x80, 0x50), MAKE_RGB(0xA0, 0x70, 0x40),
      .               MAKE_RGB(0x60, 0x30, 0x11), MAKE_RGB(0x80, 0x40, 0x10), MAKE_RGB(0x70, 0x90, 0xA0), MAKE_RGB(0xA0, 0x60, 0x30),
      .               MAKE_RGB(0xA0, 0x70, 0x10), MAKE_RGB(0x30, 0x10, 0x11), MAKE_RGB(0xB0, 0xA0, 0x80), MAKE_RGB(0x80, 0x60, 0x10),
      .           };
      .           
      .           // UI Code?
    664 ( 0.00%)  void func_80057C60(void) {
  3,984 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
  3,652 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
  3,984 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&D_80183D60), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    996 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void func_80057CE4(void) {
  7,968 ( 0.00%)      switch (D_8018D21C) {
      .                   case 0:
  2,656 ( 0.00%)              func_802A3730(D_800DC5EC);
 92,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/skybox_and_splitscreen.c:func_802A3730 (664x)
    664 ( 0.00%)              break;
      .                   case 1:
      .                       func_802A3730(D_800DC5EC);
      .                       break;
      .                   case 2:
      .                       func_802A3730(D_800DC5F0);
      .                       break;
      .                   case 3:
      .                       func_802A3730(D_800DC5EC);
-- line 430 ----------------------------------------
-- line 440 ----------------------------------------
      .                       break;
      .                   case 10:
      .                       func_802A3730(D_800DC5F4);
      .                       break;
      .                   case 11:
      .                       func_802A3730(D_800DC5F8);
      .                       break;
      .               }
  1,992 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_80057DD0(void) {
  1,328 ( 0.00%)      if (D_801657B2 != 0) {
      .                   func_8004C024(0xF, 0xB, 0x122, 0, 0xFF, 0, 0xFF);
      .                   func_8004C148(0x131, 0xB, 0xDA, 0, 0xFF, 0, 0xFF);
      .                   func_8004C024(0xF, 0xE5, 0x122, 0, 0xFF, 0, 0xFF);
      .                   func_8004C148(0xF, 0xB, 0xDA, 0, 0xFF, 0, 0xFF);
      .                   func_8004C024(0x16, 0x10, 0x114, 0xFF, 0, 0, 0xFF);
      .                   func_8004C148(0x12A, 0x10, 0xD0, 0xFF, 0, 0, 0xFF);
      .                   func_8004C024(0x16, 0xE0, 0x114, 0xFF, 0, 0, 0xFF);
      .                   func_8004C148(0x16, 0x10, 0xD0, 0xFF, 0, 0, 0xFF);
      .                   func_8004C024(0x18, 0x15, 0x110, 0, 0, 0xFF, 0xFF);
      .                   func_8004C148(0x128, 0x15, 0xC4, 0, 0, 0xFF, 0xFF);
      .                   func_8004C024(0x18, 0xDB, 0x110, 0, 0, 0xFF, 0xFF);
      .                   func_8004C148(0x18, 0x15, 0xC4, 0, 0, 0xFF, 0xFF);
      .               }
    996 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void func_80057FC4(u32 arg0) {
      .               UNUSED Gfx* temp_v1;
      .           
  1,328 ( 0.00%)      if ((gHUDDisable != 0)) {
      .                   return;
      .               }
  2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,452 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
    332 ( 0.00%)      set_matrix_hud_screen();
  9,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:set_matrix_hud_screen (332x)
      .           
  1,328 ( 0.00%)      if ((D_801657C8 != 0)) {
      .                   return;
      .               }
      .           
  3,320 ( 0.00%)      switch (arg0) {
      .                   case 0:
    332 ( 0.00%)              func_80051EBC();
38,223,169 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_80051EBC (332x)
    332 ( 0.00%)              break;
      .                   case 1:
      .                       func_80051EF8();
      .                       break;
      .                   case 2:
      .                       func_80051F9C();
      .                       break;
      .                   case 3:
      .                       func_80052044();
      .                       break;
      .                   case 4:
      .                       func_80052080();
      .                       break;
      .               }
    664 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void render_object(u32 arg0) {
      .               UNUSED Gfx* temp_v1;
      .           
  1,328 ( 0.00%)      if (gHUDDisable != 0) {
      .                   return;
      .               }
      .           
  2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,526 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
      .           
  1,328 ( 0.00%)      if (D_8018D22C != 0) {
      .                   return;
      .               }
      .           
  3,320 ( 0.00%)      switch (arg0) {
      .                   case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    332 ( 0.00%)              render_object_p1();
44,178,703 ( 0.04%)  => src/code_80057C60.c:render_object_p1 (332x)
    332 ( 0.00%)              break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                       render_object_p1();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
      .                       render_object_p2();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_ONE:
      .                       render_object_p1();
-- line 523 ----------------------------------------
-- line 542 ----------------------------------------
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_THREE:
      .                       render_object_p3();
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                       render_object_p4();
      .                       break;
      .               }
    664 ( 0.00%)  }
      .           
    996 ( 0.00%)  void render_object_p1(void) {
      .           
  3,652 ( 0.00%)      gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
  4,648 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[0]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
  4,648 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[0]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .           
    664 ( 0.00%)      func_8001C3C4(PLAYER_ONE);
  9,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80005FD0.c:func_8001C3C4 (332x)
  1,328 ( 0.00%)      if (gGamestate == ENDING) {
      .                   func_80055F48(PLAYER_ONE);
      .                   func_80056160(PLAYER_ONE);
      .                   func_8005217C(PLAYER_ONE);
      .                   func_80054BE8(PLAYER_ONE);
      .                   return;
      .               }
  1,328 ( 0.00%)      if (!gDemoMode) {
    664 ( 0.00%)          render_lakitu(PLAYER_ONE);
9,747,286 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_lakitu (332x)
      .               }
    664 ( 0.00%)      render_object_for_player(PLAYER_ONE);
34,402,201 ( 0.03%)  => src/code_80057C60.c:render_object_for_player (332x)
    664 ( 0.00%)  }
      .           
      .           void render_object_p2(void) {
      .           
      .               gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[1]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[1]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
-- line 580 ----------------------------------------
-- line 607 ----------------------------------------
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .               func_8001C3C4(PLAYER_FOUR);
      .               if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                   render_lakitu(PLAYER_FOUR);
      .               }
      .               render_object_for_player(PLAYER_FOUR);
      .           }
      .           
  1,328 ( 0.00%)  void render_player_snow_effect(u32 arg0) {
      .               UNUSED Gfx* temp_v1;
      .           
  1,328 ( 0.00%)      if (gHUDDisable != 0) {
      .                   return;
      .               }
      .           
  2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,553 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
      .           
  1,328 ( 0.00%)      if (D_8018D22C != 0) {
      .                   return;
      .               }
  3,320 ( 0.00%)      switch (arg0) {
      .                   case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    332 ( 0.00%)              render_player_snow_effect_one();
 31,208 ( 0.00%)  => src/code_80057C60.c:render_player_snow_effect_one (332x)
    332 ( 0.00%)              break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                       render_player_snow_effect_one();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
      .                       render_player_snow_effect_two();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_ONE:
      .                       render_player_snow_effect_one();
-- line 638 ----------------------------------------
-- line 648 ----------------------------------------
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_THREE:
      .                       render_player_snow_effect_three();
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                       render_player_snow_effect_four();
      .                       break;
      .               }
    664 ( 0.00%)  }
      .           
    996 ( 0.00%)  void render_player_snow_effect_one(void) {
  3,652 ( 0.00%)      gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
  4,648 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[0]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
  4,648 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[0]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
  1,328 ( 0.00%)      if (gGamestate != ENDING) {
    664 ( 0.00%)          render_snowing_effect(PLAYER_ONE);
 14,276 ( 0.00%)  => src/code_80057C60.c:render_snowing_effect (332x)
      .               }
    996 ( 0.00%)  }
      .           
      .           void render_player_snow_effect_two(void) {
      .               gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[1]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[1]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .               render_snowing_effect(PLAYER_TWO);
-- line 675 ----------------------------------------
-- line 688 ----------------------------------------
      .               gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[3]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[3]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .               render_snowing_effect(PLAYER_FOUR);
      .           }
      .           
  1,328 ( 0.00%)  void render_object_for_player(s32 cameraId) {
      .           
    996 ( 0.00%)      CourseManager_RenderCourseObjects(cameraId);
  9,628 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_RenderCourseObjects (332x)
    996 ( 0.00%)      CourseManager_TrainSmokeDraw(cameraId);
25,776,829 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_TrainSmokeDraw (332x)
      .           
      .               // switch (gCurrentCourseId) {
      .               //     case COURSE_MARIO_RACEWAY:
      .               //         break;
      .               //     case COURSE_CHOCO_MOUNTAIN:
      .               //         break;
      .               //     case COURSE_BOWSER_CASTLE:
      .               //         render_object_thwomps(cameraId);
-- line 707 ----------------------------------------
-- line 778 ----------------------------------------
      .               //         break;
      .               //     case COURSE_DK_JUNGLE:
      .               //         if (gGamestate != CREDITS_SEQUENCE) {
      .               //             render_object_paddle_boat_smoke_particles(cameraId);
      .               //         }
      .               //         break;
      .               // }
      .           
    996 ( 0.00%)      render_object_smoke_particles(cameraId);
4,327,038 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_object_smoke_particles (332x)
    996 ( 0.00%)      render_object_leaf_particle(cameraId);
4,279,742 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_object_leaf_particle (332x)
      .           
  1,328 ( 0.00%)      if (D_80165730 != 0) {
      .                   func_80053E6C(cameraId);
      .               }
  1,328 ( 0.00%)      if (gModeSelection == BATTLE) {
      .                   render_object_bomb_kart(cameraId);
      .               }
    996 ( 0.00%)  }
      .           
  1,660 ( 0.00%)  void render_snowing_effect(s32 arg0) {
  1,660 ( 0.00%)      if (GetCourse() == GetFrappeSnowland()) {
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (332x)
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetFrappeSnowland (332x)
      .                   if (gGamestate != 9) {
      .                       if ((D_8015F894 == 0) && (gPlayerCountSelection1 == 1)) {
      .                           render_object_snowflakes_particles();
      .                       }
      .                   } else {
      .                       render_object_snowflakes_particles();
      .                   }
  1,660 ( 0.00%)      } else if (GetCourse() == GetSherbetLand()) {
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (332x)
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetSherbetLand (332x)
      .                   render_ice_block(arg0);
      .               }
  1,328 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_80058BF4(void) {
  2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,404 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
    996 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void func_80058C20(u32 arg0) {
      .           
    996 ( 0.00%)      D_8018D21C = arg0;
  2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,404 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
      .           
  1,328 ( 0.00%)      if (D_8018D22C == 0) {
  3,320 ( 0.00%)          switch (arg0) {
      .                       case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    332 ( 0.00%)                  func_80058F48();
 13,280 ( 0.00%)  => src/code_80057C60.c:func_80058F48 (332x)
    332 ( 0.00%)                  break;
      .                       case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                           if (!gDemoMode) {
      .                               func_80059358();
      .                               break;
      .                           }
      .           
      .                           break;
      .                       case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
-- line 832 ----------------------------------------
-- line 873 ----------------------------------------
      .                           break;
      .                       case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                           if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                               func_800597B8();
      .                           }
      .                           break;
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void render_hud(u32 arg0) {
      .           
    996 ( 0.00%)      D_8018D21C = arg0;
  2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,318 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
  1,328 ( 0.00%)      if (D_8018D22C == 0) {
  3,320 ( 0.00%)          switch (arg0) {
      .                       case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    332 ( 0.00%)                  func_80058F78();
29,181,188 ( 0.02%)  => src/code_80057C60.c:func_80058F78 (332x)
    332 ( 0.00%)                  break;
      .                       case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                           if (!gDemoMode) {
      .                               render_hud_2p_horizontal_player_two_horizontal_player_one();
      .                               break;
      .                           }
      .           
      .                           break;
      .                       case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
-- line 899 ----------------------------------------
-- line 940 ----------------------------------------
      .                           break;
      .                       case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                           if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                               render_hud_4p_multi();
      .                           }
      .                           break;
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_80058F48(void) {
  1,328 ( 0.00%)      if (gHUDDisable == 0) {
    332 ( 0.00%)          set_matrix_hud_screen();
  9,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:set_matrix_hud_screen (332x)
      .               }
    996 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_80058F78(void) {
  1,328 ( 0.00%)      if (gHUDDisable == 0) {
    332 ( 0.00%)          set_matrix_hud_screen();
  9,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:set_matrix_hud_screen (332x)
  3,384 ( 0.00%)          if ((!gDemoMode) && (gIsHUDVisible != 0) && (D_801657D8 == 0)) {
    364 ( 0.00%)              draw_item_window(PLAYER_ONE);
  4,550 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:draw_item_window (182x)
    728 ( 0.00%)              if (D_801657E4 != 2) {
    364 ( 0.00%)                  render_hud_timer(PLAYER_ONE);
13,557,810 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_hud_timer (182x)
    364 ( 0.00%)                  draw_simplified_lap_count(PLAYER_ONE);
13,310,988 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:draw_simplified_lap_count (182x)
    364 ( 0.00%)                  func_8004EB38(0);
2,288,264 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004EB38 (182x)
    728 ( 0.00%)                  if (D_801657E6 != false) {
      .                               func_8004ED40(0);
      .                           }
      .                       }
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
      .           void func_80059024(void) {
      .           }
      .           
    664 ( 0.00%)  void func_8005902C(void) {
      .           
  1,328 ( 0.00%)      if (D_8018D2AC != 0) {
      .                   switch (gPlayerCountSelection1) {
      .                       case 2:
      .                           func_8004EB30(PLAYER_ONE);
      .                           func_8004EB30(PLAYER_TWO);
      .                           break;
      .                       case 3:
      .                           func_8004EB30(PLAYER_ONE);
      .                           func_8004EB30(PLAYER_TWO);
-- line 986 ----------------------------------------
-- line 989 ----------------------------------------
      .                       case 4:
      .                           func_8004EB30(PLAYER_ONE);
      .                           func_8004EB30(PLAYER_TWO);
      .                           func_8004EB30(PLAYER_THREE);
      .                           func_8004EB30(PLAYER_FOUR);
      .                           break;
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
    364 ( 0.00%)  void func_800590D4(void) {
    728 ( 0.00%)      if (D_8018D2A4 != 0) {
    292 ( 0.00%)          if (gModeSelection != BATTLE) {
    876 ( 0.00%)              switch (gPlayerCountSelection1) {
      .                           case 1:
    292 ( 0.00%)                      if (gModeSelection != TIME_TRIALS) {
    146 ( 0.00%)                          func_8004E800(PLAYER_ONE);
2,707,033 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004E800 (73x)
     73 ( 0.00%)                          break;
      .                               }
      .                               break;
      .                           case 2:
      .                               func_8004E800(PLAYER_ONE);
      .                               func_8004E800(PLAYER_TWO);
      .                               break;
      .                           case 3:
      .                               func_8004E998(PLAYER_ONE);
-- line 1014 ----------------------------------------
-- line 1019 ----------------------------------------
      .                               func_8004E998(PLAYER_ONE);
      .                               func_8004E998(PLAYER_TWO);
      .                               func_8004E998(PLAYER_THREE);
      .                               func_8004E998(PLAYER_FOUR);
      .                               break;
      .                       }
      .                   }
      .               }
    546 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_800591B4(void) {
      .           
  2,656 ( 0.00%)      if ((gHUDDisable == 0) && (D_800DC5B8 != 0)) {
    332 ( 0.00%)          func_80057C60();
 13,280 ( 0.00%)  => src/code_80057C60.c:func_80057C60 (332x)
  2,988 ( 0.00%)          gSPDisplayList(gDisplayListHead++, D_0D0076F8);
3,966,318 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
      .           
  1,328 ( 0.00%)          if (gIsHUDVisible != 0) {
    728 ( 0.00%)              if (D_801657D8 == 0) {
    728 ( 0.00%)                  if (D_801657F0 != false) {
      .                               func_800514BC();
      .                           }
  1,456 ( 0.00%)                  if ((!gDemoMode) && (D_801657E8 != false)) {
    728 ( 0.00%)                      if (D_80165800[0] != 0) {
    364 ( 0.00%)                          func_8004EE54(0);
2,265,207 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004EE54 (182x)
    728 ( 0.00%)                          if (gModeSelection != BATTLE) {
    364 ( 0.00%)                              func_8004F020(0);
13,302,856 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004F020 (182x)
      .                                   }
    364 ( 0.00%)                          func_8004F3E4(0);
51,074,555 ( 0.04%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004F3E4 (182x)
      .                               }
    728 ( 0.00%)                      if ((gScreenModeSelection == SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL) && (D_80165800[1] != 0)) {
      .                                   func_8004EE54(1);
      .                                   if (gModeSelection != BATTLE) {
      .                                       func_8004F020(1);
      .                                   }
      .                                   func_8004F3E4(1);
      .                               }
      .                           }
      .                       }
  2,184 ( 0.00%)              if ((D_801657E4 != 2) && (gModeSelection == GRAND_PRIX) && (D_8018D2BC != 0)) {
     73 ( 0.00%)                  func_80050320();
18,183,615 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_80050320 (73x)
      .                       }
    182 ( 0.00%)              func_800590D4();
2,710,350 ( 0.00%)  => src/code_80057C60.c:func_800590D4 (182x)
      .                   }
    332 ( 0.00%)          func_8005902C();
  2,988 ( 0.00%)  => src/code_80057C60.c:func_8005902C (332x)
    332 ( 0.00%)          func_80057DD0();
  2,988 ( 0.00%)  => src/code_80057C60.c:func_80057DD0 (332x)
    332 ( 0.00%)          func_80057CE4();
 53,784 ( 0.00%)  => src/code_80057C60.c:func_80057CE4 (332x)
      .               }
    996 ( 0.00%)  }
      .           
      .           void func_80059358(void) {
      .           }
      .           
      .           void render_hud_2p_horizontal_player_two_horizontal_player_one(void) {
      .               if (gHUDDisable == 0) {
      .                   render_hud_timer(PLAYER_ONE);
      .                   if (playerHUD[PLAYER_ONE].lapCount != 3) {
-- line 1074 ----------------------------------------
-- line 1185 ----------------------------------------
      .           
      .           void render_hud_4p_multi(void) {
      .               if (gHUDDisable == 0) {
      .                   set_matrix_hud_screen();
      .                   render_hud_lap_3p_4p(PLAYER_FOUR);
      .               }
      .           }
      .           
  2,988 ( 0.00%)  void func_80059820(s32 playerId) {
      .               hud_player* temp_v0;
      .           
  7,968 ( 0.00%)      D_8018CF1C = &gPlayerOne[playerId];
  7,968 ( 0.00%)      D_8018CF14 = &camera1[playerId];
  8,964 ( 0.00%)      temp_v0 = &playerHUD[playerId];
  5,976 ( 0.00%)      temp_v0->posXInt = (s32) D_8018CF1C->pos[0];
  5,976 ( 0.00%)      temp_v0->posYInt = (s32) D_8018CF1C->pos[1];
  5,976 ( 0.00%)      temp_v0->posZInt = (s32) D_8018CF1C->pos[2];
  2,988 ( 0.00%)  }
      .           
    996 ( 0.00%)  void randomize_seed_from_controller(s32 arg0) {
  2,324 ( 0.00%)      struct Controller* controller = &gControllerOne[arg0];
      .           
  1,328 ( 0.00%)      if ((controller->button & A_BUTTON) != 0) {
     95 ( 0.00%)          gControllerRandom++;
      .               }
  1,992 ( 0.00%)      if ((controller->button & B_BUTTON) != 0) {
      .                   gControllerRandom++;
      .               }
  1,992 ( 0.00%)      if ((controller->button & R_TRIG) != 0) {
      .                   gControllerRandom++;
      .               }
    996 ( 0.00%)  }
      .           
      .           void func_8005994C(void) {
      .               D_8018D214 = true;
      .           }
      .           
      .           void func_8005995C(void) {
      .               s32 i;
      .               Player* player = gPlayerOne;
-- line 1224 ----------------------------------------
-- line 1234 ----------------------------------------
      .                           --playerHUD[i].unk_75;
      .                       }
      .                   }
      .                   ++player;
      .               }
      .               D_80165890 = 0;
      .           }
      .           
  2,656 ( 0.00%)  void func_80059A88(s32 playerId) {
  1,992 ( 0.00%)      func_80059820(playerId);
 32,536 ( 0.00%)  => src/code_80057C60.c:func_80059820 (664x)
  2,656 ( 0.00%)      if (!gDemoMode) {
  1,992 ( 0.00%)          update_object_lakitu(playerId);
426,002 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:update_object_lakitu (664x)
  1,992 ( 0.00%)          func_8007BB9C(playerId);
 81,672 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_8007BB9C (664x)
      .               }
  1,992 ( 0.00%)  }
      .           
  1,992 ( 0.00%)  void func_80059AC8(void) {
      .               s32 i;
      .           
  2,656 ( 0.00%)      if (gIsGamePaused == false) {
  1,992 ( 0.00%)          func_8008C1D8(&D_80165678);
  3,984 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C1D8 (664x)
  3,320 ( 0.00%)          gRaceFrameCounter++;
 18,592 ( 0.00%)          for (i = 0; i < NUM_PLAYERS; i++) {
 69,056 ( 0.00%)              D_8018CF68[i] = func_8008A890(&camera1[i]);
159,360 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80086E70.c:func_8008A890 (5,312x)
 15,936 ( 0.00%)              func_800892E0(i);
1,035,840 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80086E70.c:func_800892E0 (5,312x)
      .                   }
  7,968 ( 0.00%)          switch (gScreenModeSelection) {
      .                       case SCREEN_MODE_1P:
  2,656 ( 0.00%)                  if (gGamestate != 9) {
  1,328 ( 0.00%)                      func_80059A88(PLAYER_ONE);
553,490 ( 0.00%)  => src/code_80057C60.c:func_80059A88 (664x)
  2,656 ( 0.00%)                      if (gModeSelection == TIME_TRIALS) {
      .                                   func_8005995C();
      .                               }
      .                           } else {
      .                               func_80059820(PLAYER_ONE);
      .                           }
    664 ( 0.00%)                  break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
      .                           func_80059A88(PLAYER_ONE);
      .                           func_80059A88(PLAYER_TWO);
      .                           break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL:
      .                           func_80059A88(PLAYER_ONE);
      .                           func_80059A88(PLAYER_TWO);
      .                           break;
      .                       case SCREEN_MODE_3P_4P_SPLITSCREEN:
      .                           func_80059A88(PLAYER_ONE);
      .                           func_80059A88(PLAYER_TWO);
      .                           func_80059A88(PLAYER_THREE);
      .                           func_80059A88(PLAYER_FOUR);
      .                           break;
      .                   }
    664 ( 0.00%)          func_8005A71C();
 16,600 ( 0.00%)  => src/code_80057C60.c:func_8005A71C (664x)
      .               }
  1,992 ( 0.00%)  }
      .           
      .           void func_80059C50(void) {
      .               s32 someIndex;
      .               s32 playerId;
      .           
      .               func_8005A3C0();
      .               for (someIndex = 0; someIndex < NUM_PLAYERS; someIndex++) {
      .                   playerId = gGPCurrentRacePlayerIdByRank[someIndex];
-- line 1296 ----------------------------------------
-- line 1297 ----------------------------------------
      .                   // I hate this dumb pointer access here
      .                   gGPCurrentRaceCharacterIdByRank[someIndex] = (gPlayerOne + playerId)->characterId;
      .               }
      .               for (someIndex = 0; someIndex < NUM_PLAYERS; someIndex++) {
      .                   D_8018CF98[someIndex] = gGPCurrentRaceRankByPlayerId[someIndex];
      .               }
      .           }
      .           
    664 ( 0.00%)  void func_80059D00(void) {
      .           
    332 ( 0.00%)      func_8005A99C();
  4,037 ( 0.00%)  => src/code_80057C60.c:func_8005A99C (332x)
    332 ( 0.00%)      func_8005A3C0();
 10,494 ( 0.00%)  => src/code_80057C60.c:func_8005A3C0 (332x)
    332 ( 0.00%)      func_8005A380();
497,532 ( 0.00%)  => src/code_80057C60.c:func_8005A380 (332x)
      .           
  1,328 ( 0.00%)      if (D_801657AE == 0) {
  3,984 ( 0.00%)          switch (gScreenModeSelection) {
      .                       case SCREEN_MODE_1P:
    664 ( 0.00%)                  randomize_seed_from_controller(PLAYER_ONE);
  9,723 ( 0.00%)  => src/code_80057C60.c:randomize_seed_from_controller (332x)
  1,660 ( 0.00%)                  if (D_8018D214 == false) {
    664 ( 0.00%)                      func_80059820(PLAYER_ONE);
 16,268 ( 0.00%)  => src/code_80057C60.c:func_80059820 (332x)
    332 ( 0.00%)                      func_8005B914();
 73,007 ( 0.00%)  => src/code_80057C60.c:func_8005B914 (332x)
  1,328 ( 0.00%)                      if (!gDemoMode) {
    664 ( 0.00%)                          func_8007AA44(0);
177,002 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_8007AA44 (332x)
      .                               }
    664 ( 0.00%)                      func_80078C70(0);
5,087,894 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_80078C70 (332x)
  1,328 ( 0.00%)                      if (playerHUD[PLAYER_ONE].raceCompleteBool == 0) {
  3,320 ( 0.00%)                          func_8005C360((gPlayerOneCopy->unk_094 / 18.0f) * 216.0f);
 13,934 ( 0.00%)  => src/code_80057C60.c:func_8005C360 (332x)
      .                               }
    996 ( 0.00%)                      func_8005D0FC(PLAYER_ONE);
 45,484 ( 0.00%)  => src/code_80057C60.c:func_8005D0FC (332x)
      .                           } else {
      .                               func_80059820(PLAYER_ONE);
      .                               func_80078C70(1);
      .                               func_80059820(PLAYER_TWO);
      .                               func_80078C70(2);
      .                           }
    332 ( 0.00%)                  update_object();
3,456,908 ( 0.00%)  => src/code_80057C60.c:update_object (332x)
    332 ( 0.00%)                  break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
      .                           randomize_seed_from_controller(PLAYER_ONE);
      .                           randomize_seed_from_controller(PLAYER_TWO);
      .                           func_80059820(PLAYER_ONE);
      .                           func_8005D0FC(PLAYER_ONE);
      .                           if (!gDemoMode) {
      .                               func_8007AA44(0);
      .                           }
-- line 1341 ----------------------------------------
-- line 1398 ----------------------------------------
      .                               if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                                   func_8007AA44(3);
      .                               }
      .                               func_8005D1F4(3);
      .                           }
      .                           update_object();
      .                           break;
      .                   }
    332 ( 0.00%)          func_800744CC();
  3,576 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_800744CC (332x)
      .               }
    996 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_8005A070(void) {
    996 ( 0.00%)      func_8008C1D8(&D_80165678);
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C1D8 (332x)
    664 ( 0.00%)      gMatrixHudCount = 0;
    664 ( 0.00%)      D_801655C0 = 0;
    332 ( 0.00%)      func_80041D34();
866,520 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:func_80041D34 (332x)
  1,328 ( 0.00%)      if (gIsGamePaused == false) {
    332 ( 0.00%)          func_8005C728();
208,847 ( 0.00%)  => src/code_80057C60.c:func_8005C728 (332x)
  1,328 ( 0.00%)          if (gGamestate == ENDING) {
      .                       func_80086604();
      .                       func_80086D80();
      .                       update_cheep_cheep(1);
      .                       func_80077640();
  1,328 ( 0.00%)          } else if (gGamestate == CREDITS_SEQUENCE) {
      .                       func_80059820(PLAYER_ONE);
      .                       func_80078C70(0);
      .                       update_object();
      .                   } else {
    332 ( 0.00%)              func_80059D00();
9,416,443 ( 0.01%)  => src/code_80057C60.c:func_80059D00 (332x)
      .                   }
      .               }
    332 ( 0.00%)      func_8008C204();
  1,660 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C204 (332x)
  1,660 ( 0.00%)      func_8008C1E0(&D_80165678, (s32) &D_801655F0);
  2,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C1E0 (332x)
    996 ( 0.00%)  }
      .           
 10,624 ( 0.00%)  void func_8005A14C(s32 playerId) {
      .               s32 objectIndex;
      .               s32 lapCount;
      .               Player* player;
      .               UNUSED s32 stackPadding;
      .           
 18,592 ( 0.00%)      player = &gPlayerOne[playerId];
 21,248 ( 0.00%)      objectIndex = D_8018CE10[playerId].objectIndex;
 13,280 ( 0.00%)      lapCount = gLapCountByPlayerId[playerId];
 10,624 ( 0.00%)      if (player->type & PLAYER_EXISTS) {
 13,280 ( 0.00%)          if (player->effects & 0x204C0) {
      .                       gObjectList[objectIndex].direction_angle[2] += 0x1000;
      .                   } else {
 31,872 ( 0.00%)              if (gObjectList[objectIndex].direction_angle[2] != 0) {
      .                           gObjectList[objectIndex].direction_angle[2] += 0x1000;
      .                       }
      .                   }
 13,280 ( 0.00%)          if (player->effects & LIGHTNING_EFFECT) {
      .                       f32_step_towards(&gObjectList[objectIndex].sizeScaling, 0.3f, 0.02f);
      .                   } else {
 34,528 ( 0.00%)              f32_step_towards(&gObjectList[objectIndex].sizeScaling, 0.6f, 0.02f);
 50,328 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:f32_step_towards (2,656x)
      .                   }
 13,280 ( 0.00%)          if (player->effects & HIT_EFFECT) {
      .                       u16_step_up_towards(&gObjectList[objectIndex].direction_angle[0], 0x0C00U, 0x0100U);
      .                   } else {
 37,184 ( 0.00%)              u16_step_down_towards(&gObjectList[objectIndex].direction_angle[0], 0, 0x00000100);
 42,496 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:u16_step_down_towards (2,656x)
      .                   }
 13,280 ( 0.00%)          if (player->effects & 0x03000000) {
      .                       func_80087D24(objectIndex, 6.0f, 1.5f, 0.0f);
      .                   } else {
 39,840 ( 0.00%)              f32_step_towards(&gObjectList[objectIndex].offset[1], 0.0f, 1.0f);
 47,808 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:f32_step_towards (2,656x)
      .                   }
 26,560 ( 0.00%)          if ((player->type & PLAYER_INVISIBLE_OR_BOMB) || (player->effects & BOO_EFFECT)) {
      .                       gObjectList[objectIndex].primAlpha = 0x0050;
      .                   } else {
 26,560 ( 0.00%)              gObjectList[objectIndex].primAlpha = 0x00FF;
      .                   }
  5,312 ( 0.00%)          if (lapCount >= 3) {
      .                       gObjectList[objectIndex].direction_angle[2] = 0;
      .                       gObjectList[objectIndex].direction_angle[1] = 0;
      .                       gObjectList[objectIndex].direction_angle[0] = 0;
      .                       gObjectList[objectIndex].offset[2] = 0.0f;
      .                       gObjectList[objectIndex].offset[1] = 0.0f;
      .                       gObjectList[objectIndex].offset[0] = 0.0f;
      .                       gObjectList[objectIndex].sizeScaling = 0.6f;
      .                       gObjectList[objectIndex].primAlpha = 0x00FF;
      .                   }
      .               }
  7,968 ( 0.00%)  }
      .           
    996 ( 0.00%)  void func_8005A380(void) {
      .               s32 temp_s0;
  9,296 ( 0.00%)      for (temp_s0 = 0; temp_s0 < NUM_PLAYERS; ++temp_s0) {
  7,968 ( 0.00%)          func_8005A14C(temp_s0);
477,944 ( 0.00%)  => src/code_80057C60.c:func_8005A14C (2,656x)
      .               }
  1,328 ( 0.00%)  }
      .           
    996 ( 0.00%)  void func_8005A3C0(void) {
    332 ( 0.00%)      bool b = false;
  3,984 ( 0.00%)      if ((gGamestate != ENDING) && (gGamestate != CREDITS_SEQUENCE) && !D_8018D204) {
  2,184 ( 0.00%)          switch (gPlayerCountSelection1) {
      .                       case 1:
  1,274 ( 0.00%)                  if (gControllerOne->buttonPressed & R_CBUTTONS) {
      .                               if (++D_801657E4 >= 3) {
      .                                   D_801657E4 = 0;
      .                               }
      .                               if (D_801657E4 == 2) {
      .                                   D_801657E8 = false;
      .                                   D_801657E6 = false;
      .                                   D_801657F0 = true;
      .                               } else if (D_801657E4 == 1) {
-- line 1504 ----------------------------------------
-- line 1507 ----------------------------------------
      .                                   D_801657F0 = false;
      .                               } else {
      .                                   D_801657E8 = true;
      .                                   D_801657E6 = false;
      .                                   D_801657F0 = false;
      .                               }
      .                               b = true;
      .                           }
    364 ( 0.00%)                  break;
      .                       case 2:
      .                           if (gModeSelection != BATTLE) {
      .                               if (gControllerOne->buttonPressed & R_CBUTTONS) {
      .                                   D_80165800[0] = (D_80165800[0] + 1) & 1;
      .                                   b = true;
      .                               }
      .                               if (gControllerTwo->buttonPressed & R_CBUTTONS) {
      .                                   D_80165800[1] = (D_80165800[1] + 1) & 1;
-- line 1523 ----------------------------------------
-- line 1551 ----------------------------------------
      .                               D_80165800[0] = (D_80165800[0] + 1) & 1;
      .                               if (gModeSelection != BATTLE) {
      .                                   D_801657F0 = (D_801657F0 + 1) & 1;
      .                               }
      .                               b = true;
      .                           }
      .                           break;
      .                   }
    364 ( 0.00%)          if (b) {
      .                       func_8006F824(1);
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
  2,656 ( 0.00%)  void func_8005A71C(void) {
  3,320 ( 0.00%)      if (GetCourse() == GetBowsersCastle()) {
  3,984 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBowsersCastle (664x)
  3,984 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (664x)
      .                   func_80081210();
      .               }
  2,656 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void update_object(void) {
      .           
    664 ( 0.00%)      CourseManager_UpdateCourseObjects();
  7,968 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_UpdateCourseObjects (332x)
    332 ( 0.00%)      CourseManager_TrainSmokeTick();
3,005,056 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_TrainSmokeTick (332x)
      .           
      .               // switch (gCurrentCourseId) {
      .               //     case COURSE_MARIO_RACEWAY:
      .               //     case COURSE_CHOCO_MOUNTAIN:
      .               //         break;
      .               //     case COURSE_BOWSER_CASTLE:
      .               //         func_80081208();
      .               //         update_flame_particle();
-- line 1582 ----------------------------------------
-- line 1636 ----------------------------------------
      .               //             update_neon();
      .               //             update_chain_chomps();
      .               //         }
      .               //         break;
      .               //     case COURSE_DK_JUNGLE:
      .               //         update_ferries_smoke_particle();
      .               //         break;
      .               // }
  1,328 ( 0.00%)      if (D_80165730 != 0) {
      .                   func_80074EE8();
      .               }
    332 ( 0.00%)      func_80076F2C();
216,132 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_80076F2C (332x)
  1,992 ( 0.00%)      if ((s16) GetCourse() != GetFrappeSnowland()) {
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (332x)
  1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetFrappeSnowland (332x)
    332 ( 0.00%)          update_leaf();
216,132 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:update_leaf (332x)
      .               }
  1,328 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_8005A99C(void) {
  1,328 ( 0.00%)      if (D_8018D170 == 0) {
    604 ( 0.00%)          if (D_8018D178 == 0) {
      4 ( 0.00%)              if (gPlayerCountSelection1 == 1) {
      1 ( 0.00%)                  func_8005AA34();
      9 ( 0.00%)  => src/code_80057C60.c:func_8005AA34 (1x)
      .                       }
      4 ( 0.00%)              if (gPlayerCountSelection1 == 3) {
      .                           D_801657E8 = true;
      .                       }
      2 ( 0.00%)              gIsHUDVisible = (s32) 1;
      2 ( 0.00%)              D_8018D170 = (s32) 1;
      2 ( 0.00%)              D_8018D190 = (s32) 1;
      2 ( 0.00%)              D_8018D204 = 0;
      1 ( 0.00%)              return;
      .                   }
    750 ( 0.00%)          --D_8018D178;
      .               }
    664 ( 0.00%)  }
      .           
      2 ( 0.00%)  void func_8005AA34(void) {
      2 ( 0.00%)      D_8018D1CC = 1;
      2 ( 0.00%)      D_8018D1A0 = 0;
      3 ( 0.00%)  }
      .           
     28 ( 0.00%)  void func_8005AA4C(void) {
     70 ( 0.00%)      ++D_8018D1CC;
     28 ( 0.00%)      D_8018D1A0 = 0;
     42 ( 0.00%)  }
      .           
      3 ( 0.00%)  void func_8005AA6C(s32 arg0) {
      3 ( 0.00%)      D_8018D1CC = arg0;
      2 ( 0.00%)      D_8018D1A0 = 0;
      3 ( 0.00%)  }
      .           
      4 ( 0.00%)  void func_8005AA80(void) {
      4 ( 0.00%)      D_8018D1CC = 0;
      4 ( 0.00%)      D_8018D1A0 = 0;
      6 ( 0.00%)  }
      .           
    112 ( 0.00%)  void func_8005AA94(s32 arg0) {
    112 ( 0.00%)      if (D_8018D1A0 == 0) {
     18 ( 0.00%)          D_8018D1D4 = arg0;
     12 ( 0.00%)          D_8018D1A0 = 1;
      .               }
      .           
    140 ( 0.00%)      --D_8018D1D4;
    112 ( 0.00%)      if (D_8018D1D4 < 0) {
     12 ( 0.00%)          D_8018D1A0 = 0;
      6 ( 0.00%)          func_8005AA4C();
     72 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (6x)
      .               }
     84 ( 0.00%)  }
      .           
      2 ( 0.00%)  void func_8005AAF0(void) {
      2 ( 0.00%)      D_8018D1B4 = 1;
      2 ( 0.00%)      D_8018D1A0 = 0;
      1 ( 0.00%)      func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      3 ( 0.00%)  }
      .           
      2 ( 0.00%)  void func_8005AB20(void) {
      8 ( 0.00%)      if ((gModeSelection == GRAND_PRIX) && (gPlayerCountSelection1 == 1)) {
      2 ( 0.00%)          func_8005AA6C(0x14);
     11 ( 0.00%)  => src/code_80057C60.c:func_8005AA6C (1x)
      .               }
      3 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_8005AB60(void) {
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_78) {
      .                   case 0:
    620 ( 0.00%)              break;
      .                   case 1:
     30 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 0x10);
    174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
     40 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 0x10) != 0) {
    174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      2 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_79 = 1;
      .                       }
     11 ( 0.00%)              break;
      .                   case 2:
     24 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x116, 4);
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xC6, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     24 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 4);
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     12 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x10E, 4);
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xBE, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     12 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 4);
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     12 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x10A, 2);
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xBA, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     12 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 2);
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_78 = 0;
      1 ( 0.00%)              break;
      .               }
  1,392 ( 0.00%)      if ((playerHUD[PLAYER_ONE].unk_79 != 0) && (playerHUD[PLAYER_ONE].unk_79 == 1)) {
    144 ( 0.00%)          if (++D_801657E7 >= 0x10) {
      2 ( 0.00%)              D_801657E7 = 0;
      2 ( 0.00%)              D_8016579E = 0xDD00;
      3 ( 0.00%)              playerHUD[PLAYER_ONE].unk_79 = 0U;
      .                   } else {
    135 ( 0.00%)              D_8016579E = D_800E55B0[D_801657E7] + 0xDD00;
      .                   }
      .               }
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_80) {
      .                   case 0:
    664 ( 0.00%)              break;
      .                   case 1:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].slideItemBoxY, 0x40, 8) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_80++;
      .                       }
      .                       break;
      .                   case 2:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].slideItemBoxY, 0x38, 8) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_80++;
-- line 1787 ----------------------------------------
-- line 1811 ----------------------------------------
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].slideItemBoxY, 0x40, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_80++;
      .                       }
      .                       break;
      .                   case 8:
      .                       playerHUD[PLAYER_ONE].unk_80 = 0;
      .                       break;
      .               }
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7A) {
      .                   case 0:
    620 ( 0.00%)              break;
      .                   case 1:
     40 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 0x10) != 0) {
    174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
     11 ( 0.00%)              break;
      .                   case 2:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xF4, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xEC, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE8, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7A = 0;
      1 ( 0.00%)              break;
      .               }
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7D) {
      .                   case 0:
    614 ( 0.00%)              break;
      .                   case 1:
     64 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 0x10) != 0) {
    253 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (8x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
     17 ( 0.00%)              break;
      .                   case 2:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x43, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x4B, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x4F, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7D = 0;
      1 ( 0.00%)              break;
      .               }
  2,324 ( 0.00%)      D_8018CFEC = (f32) (playerHUD[PLAYER_ONE].speedometerX + 0x18);
  2,324 ( 0.00%)      D_8018CFF4 = (f32) (playerHUD[PLAYER_ONE].speedometerY + 6);
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7B) {
      .                   case 0:
    620 ( 0.00%)              break;
      .                   case 1:
     40 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 0x10) != 0) {
    174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
     11 ( 0.00%)              break;
      .                   case 2:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xF4, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xEC, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE8, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7B = 0;
      1 ( 0.00%)              break;
      .               }
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7E) {
      .                   case 0:
    614 ( 0.00%)              break;
      .                   case 1:
     64 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 0x10) != 0) {
    253 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (8x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
     17 ( 0.00%)              break;
      .                   case 2:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x43, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x4B, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x4F, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7E = 0;
      1 ( 0.00%)              break;
      .               }
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7C) {
      .                   case 0:
    620 ( 0.00%)              break;
      .                   case 1:
     40 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 0x10) != 0) {
    174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
     11 ( 0.00%)              break;
      .                   case 2:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xF4, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xEC, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE8, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7C = 0;
      1 ( 0.00%)              break;
      .               }
  4,316 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7F) {
      .                   case 0:
    614 ( 0.00%)              break;
      .                   case 1:
     64 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 0x10) != 0) {
    253 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (8x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
     17 ( 0.00%)              break;
      .                   case 2:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x43, 4) != 0) {
    140 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 3:
     32 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 4) != 0) {
    129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      9 ( 0.00%)              break;
      .                   case 4:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x4B, 4) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 5:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 4) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 6:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x4F, 2) != 0) {
     72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      5 ( 0.00%)              break;
      .                   case 7:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 2) != 0) {
     67 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      5 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      3 ( 0.00%)              break;
      .                   case 8:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7F = 0;
      1 ( 0.00%)              break;
      .               }
    996 ( 0.00%)  }
      .           
      .           void func_8005B7A0(void) {
      .               f32 temp_f0;
      .               f32* temp_s2;
      .               f32* temp_s3;
      .               f32* temp_s4;
      .               UNUSED f32* var_s1;
      .               s32 var_s0;
-- line 2081 ----------------------------------------
-- line 2096 ----------------------------------------
      .                       }
      .                       if ((f64) temp_f0 <= -32.0) {
      .                           D_8018D050[var_s0] = -32.0f;
      .                       }
      .                   }
      .               }
      .           }
      .           
    996 ( 0.00%)  void func_8005B914(void) {
      .               s32 i;
      .               UNUSED s32 unk;
      .           
  3,984 ( 0.00%)      switch (D_8018D1CC) {
      .                   case 0:
      .                       break;
      .                   case 0x1:
      1 ( 0.00%)              func_8005AAF0();
     22 ( 0.00%)  => src/code_80057C60.c:func_8005AAF0 (1x)
      1 ( 0.00%)              break;
      .                   case 0x2:
      4 ( 0.00%)              if (gModeSelection == TIME_TRIALS) {
      .                           playerHUD[PLAYER_ONE].unk_80 = 1;
      .                       }
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_78 = 1;
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7A = 1;
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7D = 1;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x3:
      2 ( 0.00%)              func_8005AA94(0);
     40 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (1x)
      1 ( 0.00%)              break;
      .                   case 0x4:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7B = 1;
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7E = 1;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x5:
      2 ( 0.00%)              func_8005AA94(0);
     40 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (1x)
      1 ( 0.00%)              break;
      .                   case 0x6:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7C = 1;
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7F = 1;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              func_8005AA80();
      9 ( 0.00%)  => src/code_80057C60.c:func_8005AA80 (1x)
      1 ( 0.00%)              break;
      .                   case 0x14:
      3 ( 0.00%)              D_8018D078[0] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x15:
     10 ( 0.00%)              func_8005AA94(4);
    120 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (5x)
      5 ( 0.00%)              break;
      .                   case 0x16:
      3 ( 0.00%)              D_8018D078[1] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x17:
     10 ( 0.00%)              func_8005AA94(4);
    120 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (5x)
      5 ( 0.00%)              break;
      .                   case 0x18:
      3 ( 0.00%)              D_8018D078[2] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x19:
     10 ( 0.00%)              func_8005AA94(4);
    120 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (5x)
      5 ( 0.00%)              break;
      .                   case 0x1A:
      3 ( 0.00%)              D_8018D078[3] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
     12 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x1B:
     22 ( 0.00%)              func_8005AA94(0xA);
    240 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (11x)
     11 ( 0.00%)              break;
      .                   case 0x1C:
      1 ( 0.00%)              func_8005AA80();
      9 ( 0.00%)  => src/code_80057C60.c:func_8005AA80 (1x)
      1 ( 0.00%)              break;
      .                   case 0x64:
      .                       func_8005AA4C();
      .                       break;
      .                   case 0x65:
      .                       func_8005AA94(0x3A);
      .                       break;
      .                   case 0x66:
      .                       D_8018D078[0] = -8.0f;
-- line 2178 ----------------------------------------
-- line 2375 ----------------------------------------
      .                       break;
      .                   case 0x9B:
      .                       func_8005AA94(0x14);
      .                       break;
      .                   case 0x9C:
      .                       func_8005AA80();
      .                       break;
      .               }
  1,328 ( 0.00%)      if (D_8018D1CC < 0x64) {
    664 ( 0.00%)          func_8005AB60();
 55,494 ( 0.00%)  => src/code_80057C60.c:func_8005AB60 (332x)
      .               } else if (D_8018D1CC < 0xC8) {
      .                   func_8005B7A0();
      .               }
  1,588 ( 0.00%)      if ((D_8018D1CC != 0) && (D_8018D1CC >= 0x14) && (D_8018D1CC < 0x1E)) {
    480 ( 0.00%)          for (i = 0; i < 4; i++) {
  2,040 ( 0.00%)              f32_step_towards(&D_8018D028[i], D_8018D0C8[i], D_8018D078[i]);
  2,700 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:f32_step_towards (120x)
  1,440 ( 0.00%)              if (D_8018D028[i] == D_8018D0C8[i]) {
    360 ( 0.00%)                  D_8018D078[i] = 0.0f;
      .                       }
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
    996 ( 0.00%)  void func_8005C360(f32 arg0) {
  1,328 ( 0.00%)      if (!playerHUD[PLAYER_ONE].unk_79) {
      .                   u16 v;
    951 ( 0.00%)          if (arg0 < 10.0) {
  1,701 ( 0.00%)              v = (u16) (128.0f * arg0) + 0xDD00;
    222 ( 0.00%)          } else if (arg0 < 20.0) {
    315 ( 0.00%)              v = (u16) ((arg0 - 10.0) * 256.0) + 0xE200;
      .                   } else {
    312 ( 0.00%)              v = (u16) ((arg0 - 20.0) * 268.8) + 0xEC00;
      .                   }
  1,902 ( 0.00%)          if (arg0 == D_8018CFE4) {
    654 ( 0.00%)              if (arg0 > 5.0f) {
      .                           if (++D_801657E7 == 8) {
      .                               D_801657E7 = 0;
      .                           }
      .                       } else {
    436 ( 0.00%)                  D_801657E7 = 0;
      .                       }
      .                   }
  3,170 ( 0.00%)          D_8016579E = v + D_800E55A0[D_801657E7];
    951 ( 0.00%)          D_8018CFE4 = arg0;
      .               }
    996 ( 0.00%)  }
      .           
      .           void func_8005C64C(UNUSED s32* arg0) {
      .           }
      .           
      .           void func_8005C654(s32* arg0) {
      .               *arg0 = 0;
      .           }
      .           
      .           void func_8005C65C(s32 arg0) {
      .               D_8018D2C8[arg0] = 1;
      .           }
      .           
  2,324 ( 0.00%)  void func_8005C674(s8 index, s16* x, s16* y, s16* z) {
  2,988 ( 0.00%)      s16* src = &D_800E4730[index * 3];
  1,992 ( 0.00%)      *x = *src++;
  1,992 ( 0.00%)      *y = *src++;
  1,992 ( 0.00%)      *z = *src++;
    996 ( 0.00%)  }
      .           
      .           void func_8005C6B4(s8 arg0, s16* arg1, s16* arg2, s16* arg3) {
      .               switch (arg0) {
      .                   case 0:
      .                       *arg1 = 0xFF;
      .                       *arg2 = 0x40;
      .                       *arg3 = 0x40;
      .                       break;
-- line 2446 ----------------------------------------
-- line 2452 ----------------------------------------
      .                   case 2:
      .                       *arg1 = 0x40;
      .                       *arg2 = 0x40;
      .                       *arg3 = 0xFF;
      .                       break;
      .               }
      .           }
      .           
    996 ( 0.00%)  void func_8005C728(void) {
      .               s16 x;
      .               s16 y;
      .               s16 z;
      .               s32 temp_t7;
      .           
  2,656 ( 0.00%)      temp_t7 = ++D_8018D400;
  1,660 ( 0.00%)      D_8018D40C = temp_t7 & 0x3F; // temp_t7 % 64
  1,660 ( 0.00%)      D_8018D410 = temp_t7 & 0x1F; // temp_t7 % 32
  1,660 ( 0.00%)      D_80165590 = temp_t7 & 0xF;  // temp_t7 % 16
  1,660 ( 0.00%)      D_80165594 = temp_t7 & 7;    // temp_t7 % 8
  1,660 ( 0.00%)      D_80165598 = temp_t7 & 3;    // temp_t7 % 4
  1,660 ( 0.00%)      D_8016559C = temp_t7 & 1;    // temp_t7 % 2
  1,328 ( 0.00%)      if (D_8018D40C == 0) {
     25 ( 0.00%)          D_801655A4 += 1;
     30 ( 0.00%)          D_801655D8 ^= 1;
      .               }
  1,328 ( 0.00%)      if (D_8018D410 == 0) {
     50 ( 0.00%)          D_801655AC += 1;
     60 ( 0.00%)          D_801655E8 ^= 1;
      .               }
  1,328 ( 0.00%)      if (D_80165590 == 0) {
    100 ( 0.00%)          D_801655B4 += 1;
    120 ( 0.00%)          D_801655F8 ^= 1;
      .               }
  1,328 ( 0.00%)      if (D_80165594 == 0) {
    205 ( 0.00%)          D_801655BC += 1;
    246 ( 0.00%)          D_80165608 ^= 1;
      .               }
  1,328 ( 0.00%)      if (D_80165598 == 0) {
    415 ( 0.00%)          D_801655C4 += 1;
    498 ( 0.00%)          D_80165618 ^= 1;
      .               }
  1,328 ( 0.00%)      if (D_8016559C == 0) {
    830 ( 0.00%)          D_801655CC += 1;
    996 ( 0.00%)          D_80165628 ^= 1;
      .               }
  2,988 ( 0.00%)      if (--D_8018D2AC < 0) {
    664 ( 0.00%)          D_8018D2AC = 0;
      .               }
  1,992 ( 0.00%)      D_801658A8 += 1;
  1,328 ( 0.00%)      if (D_801658A8 >= 7) {
     94 ( 0.00%)          D_801658A8 = 0;
      .               }
  2,656 ( 0.00%)      func_8005C674(D_801658A8, &x, &y, &z);
 12,284 ( 0.00%)  => src/code_80057C60.c:func_8005C674 (332x)
  2,656 ( 0.00%)      D_801656C0 = x / 2;
  2,656 ( 0.00%)      D_801656D0 = y / 2;
  2,656 ( 0.00%)      D_801656E0 = z / 2;
    332 ( 0.00%)      func_8005C980();
152,390 ( 0.00%)  => src/code_80057C60.c:func_8005C980 (332x)
    996 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_8005C980(void) {
      .               s32 var_v0;
    332 ( 0.00%)      s32 sp0 = 0; //! @warning this variable was uninitialized in decomp. This was likely supposed to be random!
      .               s32 temp_v1;
  9,296 ( 0.00%)      for (var_v0 = 0; var_v0 < NUM_PLAYERS; var_v0++) {
 13,280 ( 0.00%)          temp_v1 = gGPCurrentRaceRankByPlayerId[var_v0];
 10,624 ( 0.00%)          if (D_80165590 == 0) {
    960 ( 0.00%)              D_8018CF98[var_v0] = temp_v1;
      .                   }
 26,560 ( 0.00%)          D_8018CF28[temp_v1] = &gPlayerOne[sp0];
  5,312 ( 0.00%)          if (sp0 == 0) {
 10,624 ( 0.00%)              D_80165794 = temp_v1;
      .                   }
      .               }
      .           
  9,296 ( 0.00%)      for (var_v0 = 0; var_v0 < NUM_PLAYERS; var_v0++) {
 15,936 ( 0.00%)          sp0 = gGPCurrentRacePlayerIdByRank[var_v0];
 15,936 ( 0.00%)          D_8018CF50[var_v0] = sp0;
 10,624 ( 0.00%)          if (D_80165590 == 0) {
  1,920 ( 0.00%)              gGPCurrentRaceCharacterIdByRank[var_v0] = (gPlayerOne + sp0)->characterId;
      .                   }
      .               }
      .           
  2,988 ( 0.00%)      if (--D_8018D314 <= 0) {
  1,328 ( 0.00%)          D_8018D314 = D_8018D3F4;
  3,984 ( 0.00%)          D_8018D3E4 = D_800E55D0[D_8018D3F8][0];
  4,316 ( 0.00%)          D_8018D3E8 = D_800E55D0[D_8018D3F8][1];
  4,316 ( 0.00%)          D_8018D3EC = D_800E55D0[D_8018D3F8][2];
  2,988 ( 0.00%)          if (++D_8018D3F8 == 6) {
    110 ( 0.00%)              D_8018D3F8 = 0;
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
  1,992 ( 0.00%)  void func_8005CB60(s32 playerId, s32 lapCount) {
      .               s32 temp_a0_2;
      .               UNUSED s32 stackPadding;
      .               s8* huh;
      .               s8* huhthedeuce;
      .               Player* player;
      .           
  2,324 ( 0.00%)      player = &gPlayerOne[playerId];
  3,652 ( 0.00%)      huh = &playerHUD[playerId].alsoLapCount;
  3,652 ( 0.00%)      huhthedeuce = &playerHUD[playerId].lapCount;
  4,980 ( 0.00%)      if (playerHUD[playerId].lapCount < D_8018D320) {
  5,312 ( 0.00%)          playerHUD[playerId].someTimer = (u32) (s32) (gCourseTimer * 100.0f);
  1,660 ( 0.00%)          if (*huh < lapCount) {
      .                       temp_a0_2 = gTimePlayerLastTouchedFinishLine[playerId] * 100.0f;
      .                       playerHUD[playerId].timeLastTouchedFinishLine = temp_a0_2;
      .                       playerHUD[playerId].lapCompletionTimes[*huh] = temp_a0_2;
      .                       if (*huh == 0) {
      .                           playerHUD[playerId].lapDurations[*huh] = playerHUD[playerId].timeLastTouchedFinishLine;
      .                       } else {
      .                           playerHUD[playerId].lapDurations[*huh] =
      .                               playerHUD[playerId].lapCompletionTimes[*huh] - playerHUD[playerId].lapCompletionTimes[*huh - 1];
-- line 2565 ----------------------------------------
-- line 2663 ----------------------------------------
      .                               s16_step_towards(&playerHUD[playerId].slideRankX, -8, 2);
      .                           } else {
      .                               s16_step_towards(&playerHUD[playerId].slideRankX, 8, 2);
      .                           }
      .                           s16_step_towards(&playerHUD[playerId].slideRankY, -0x0010, 4);
      .                           break;
      .                   }
      .               }
  3,984 ( 0.00%)      if (playerHUD[playerId].blinkTimer == 0) {
  6,640 ( 0.00%)          playerHUD[playerId].someTimer1 = playerHUD[playerId].someTimer;
    664 ( 0.00%)          D_801657E3 = 0;
    332 ( 0.00%)          return;
      .               }
      .               if (D_80165594 == 0) {
      .                   playerHUD[playerId].blinkState += 1;
      .                   playerHUD[playerId].blinkState &= 1;
      .               }
      .               playerHUD[playerId].blinkTimer -= 1;
      .               if (playerHUD[playerId].blinkTimer == 0) {
      .                   playerHUD[playerId].blinkState = 0;
      .               }
    996 ( 0.00%)  }
      .           
  1,328 ( 0.00%)  void func_8005D0FC(s32 playerId) {
  1,328 ( 0.00%)      if (gModeSelection != BATTLE) {
  3,320 ( 0.00%)          switch (playerId) { /* irregular */
      .                       case PLAYER_ONE:
  1,992 ( 0.00%)                  func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_ONE]);
 36,188 ( 0.00%)  => src/code_80057C60.c:func_8005CB60 (332x)
    332 ( 0.00%)                  break;
      .                       case PLAYER_TWO:
      .                           func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_TWO]);
      .                           break;
      .                       case PLAYER_THREE:
      .                           func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_THREE]);
      .                           break;
      .                       case PLAYER_FOUR:
      .                           func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_FOUR]);
      .                           break;
      .                   }
      .               }
    996 ( 0.00%)  }
      .           
      .           void func_8005D18C(void) {
      .               if ((gModeSelection == GRAND_PRIX) && (gPlayerCountSelection1 == TIME_TRIALS)) {
      .                   D_801657D8 = 1;
      .                   D_8018D2BC = 0;
      .                   D_8018D2A4 = 0;
      .                   if (gGPCurrentRaceRankByPlayerId[0] >= 4) {
      .                       D_8018D1FC = 1;
-- line 2711 ----------------------------------------
-- line 2736 ----------------------------------------
      .                       }
      .                       playerHUD[arg0].unk_74 = 1;
      .                       break;
      .                   }
      .               }
      .           }
      .           
      .           // Appears to load GP Mode race staging balloons and kart shadows.
      2 ( 0.00%)  void func_8005D290(void) {
      7 ( 0.00%)      D_8018D488 = dma_textures(gTexture69C80C, 0x400, 0x400);
 13,446 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D474 = dma_textures(gTextureKartShadow, 0x1000, 0x1000);
 14,961 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D420 = dma_textures(gTexture69B03C, 0x100, 0x100);
 14,234 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D424 = dma_textures(gTexture69B140, 0x400, 0x400);
 12,604 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D478 = dma_textures(gTexture69C1E8, 0x200, 0x200);
 13,447 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D480 = dma_textures(gTexture69BA28, 0x400, 0x400);
 13,235 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D484 = dma_textures(gTexture69B960, 0x400, 0x400);
 13,623 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D48C = dma_textures(gTexture69C354, 0x400, 0x400);
 14,086 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D494 = dma_textures(gTexture69C4E4, 0x400, 0x400);
 13,984 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      4 ( 0.00%)      D_8018D490 = D_8018D48C;
      7 ( 0.00%)      D_8018D498 = dma_textures(gTexture69B378, 0x1000, 0x1000);
 14,230 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4BC = dma_textures(gTextureBalloon1, 0x800, 0x800);
 13,950 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4C0 = dma_textures(gTextureBalloon2, 0x800, 0x800);
 13,881 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D49C = dma_textures(gTexture69C9C4, 0x200, 0x200);
 14,061 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4A0 = dma_textures(gTextureBoingExclamation, 0x800, 0x800);
 14,078 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4A4 = dma_textures(gTextureOnomatopoeiaPoomp1, 0x800, 0x800);
 13,685 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4A8 = dma_textures(gTextureOnomatopoeiaPoomp2, 0x800, 0x800);
 14,536 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4AC = dma_textures(gTextureOnomatopoeiaWhrrrr1, 0x800, 0x800);
 13,496 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4B0 = dma_textures(gTextureOnomatopoeiaWhrrrr2, 0x800, 0x800);
 13,633 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4B4 = dma_textures(gTextureOnomatopoeiaCrash1, 0x800, 0x800);
 13,688 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4B8 = dma_textures(gTextureOnomatopoeiaCrash2, 0x800, 0x800);
 13,893 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D438 = dma_textures(gTexture69CB84, 0x800, 0x800);
 14,213 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D43C = dma_textures(gTexture69CCEC, 0x800, 0x800);
 14,430 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D440 = dma_textures(gTexture69CEB8, 0x800, 0x800);
 13,990 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D444 = dma_textures(gTexture69D148, 0x800, 0x800);
 13,769 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D448 = dma_textures(gTexture69D4E0, 0x800, 0x800);
 13,874 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D44C = dma_textures(gTexture69D8FC, 0x800, 0x800);
 13,138 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D450 = dma_textures(gTexture69DCB4, 0x800, 0x800);
 13,918 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D454 = dma_textures(gTexture69DFA0, 0x800, 0x800);
 13,033 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D458 = dma_textures(gTexture69E25C, 0x800, 0x800);
 14,023 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D45C = dma_textures(gTexture69E518, 0x800, 0x800);
 14,708 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D460 = dma_textures(gTexture69E7A8, 0x800, 0x800);
 14,664 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D464 = dma_textures(gTexture69EA18, 0x800, 0x800);
 14,664 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D468 = dma_textures(gTexture69EC54, 0x800, 0x800);
 13,620 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D46C = dma_textures(gTexture69EE38, 0x800, 0x800);
 13,103 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D470 = dma_textures(gTexture69EFE0, 0x800, 0x800);
 13,936 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4C4 = dma_textures(gTextureLightningBolt0, 0x800, 0x800);
 13,898 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      7 ( 0.00%)      D_8018D4C8 = dma_textures(gTextureLightningBolt1, 0x800, 0x800);
 13,793 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      3 ( 0.00%)  }
      .           
     24 ( 0.00%)  void func_8005D6C0(Player* player) {
      .               s32 temp_v0;
      .           
    272 ( 0.00%)      for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
    800 ( 0.00%)          player->unk_258[temp_v0].unk_01C = 0;
    800 ( 0.00%)          player->unk_258[temp_v0].unk_01E = 0;
    800 ( 0.00%)          player->unk_258[temp_v0].unk_012 = 0;
      .               }
      .           
    272 ( 0.00%)      for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
    880 ( 0.00%)          player->unk_258[30 + temp_v0].unk_01C = 0;
    880 ( 0.00%)          player->unk_258[30 + temp_v0].unk_01E = 0;
    880 ( 0.00%)          player->unk_258[30 + temp_v0].unk_012 = 0;
      .               }
      .           
    272 ( 0.00%)      for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
    880 ( 0.00%)          player->unk_258[10 + temp_v0].unk_01C = 0;
    880 ( 0.00%)          player->unk_258[10 + temp_v0].unk_01E = 0;
    880 ( 0.00%)          player->unk_258[10 + temp_v0].unk_012 = 0;
      .               }
      .           
    272 ( 0.00%)      for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
    880 ( 0.00%)          player->unk_258[20 + temp_v0].unk_01C = 0;
    880 ( 0.00%)          player->unk_258[20 + temp_v0].unk_01E = 0;
    880 ( 0.00%)          player->unk_258[20 + temp_v0].unk_012 = 0;
      .               }
     32 ( 0.00%)  }
      .           
 11,530 ( 0.00%)  void func_8005D794(Player* player, UnkPlayerStruct258* arg1, f32 arg2, f32 arg3, f32 arg4, s8 surfaceType, s8 arg6) {
  3,459 ( 0.00%)      arg1->unk_000[2] = arg4;
  3,459 ( 0.00%)      arg1->unk_000[0] = arg2;
  3,459 ( 0.00%)      arg1->unk_000[1] = arg3;
  6,918 ( 0.00%)      arg1->unk_020 = -player->rotation[1];
  4,612 ( 0.00%)      arg1->unk_014 = surfaceType;
  3,459 ( 0.00%)      arg1->unk_010 = arg6;
  3,459 ( 0.00%)  }
      .           
  6,918 ( 0.00%)  s32 func_8005D7D8(UnkPlayerStruct258* arg0, s8 arg1, f32 arg2) {
  2,306 ( 0.00%)      arg0->unk_01C = 1;
  3,459 ( 0.00%)      arg0->unk_012 = arg1;
  2,306 ( 0.00%)      arg0->unk_01E = 0;
  3,459 ( 0.00%)      arg0->unk_00C = arg2;
  3,459 ( 0.00%)  }
      .           
 78,438 ( 0.00%)  s32 func_8005D800(UnkPlayerStruct258* arg0, s32 arg1, s16 arg2) {
 65,365 ( 0.00%)      arg0->unk_038 = (u8) (arg1 >> 16);
 65,365 ( 0.00%)      arg0->unk_03A = (u8) (arg1 >> 8);
 52,292 ( 0.00%)      arg0->unk_03C = (u8) arg1;
 39,219 ( 0.00%)      arg0->unk_03E = arg2;
 39,219 ( 0.00%)  }
      .           
      .           s32 func_8005D82C(UnkPlayerStruct258* arg0, s32 arg1, s16 arg2) {
      .               s32 temp_v0;
      .               temp_v0 = random_int(0x30);
      .           
      .               arg0->unk_038 = (u8) ((u8) (arg1 >> 0x10) - temp_v0);
      .               arg0->unk_03A = (u8) ((u8) (arg1 >> 8) - temp_v0);
      .               arg0->unk_03C = (u8) ((u8) arg1 - temp_v0);
-- line 2842 ----------------------------------------
-- line 2893 ----------------------------------------
      .           }
      .           
      .           void func_8005DAD8(UnkPlayerStruct258* arg0, s16 arg1, s16 arg2, s16 arg3) {
      .               arg0->unk_038 = arg1;
      .               arg0->unk_03E = arg3;
      .               arg0->unk_040 = arg2;
      .           }
      .           
345,280 ( 0.00%)  void func_8005DAF4(Player* player, s16 arg1, s32 arg2, UNUSED s8 arg3, UNUSED s8 arg4) {
      .               UNUSED s32 stackPadding;
      .               s32 surfaceType;
      .               s32 var_t3;
      .               f32 var_f2;
      .               f32 var_f12;
      .               f32 var_f14;
      .               s32 temp_v0;
      .               static s32 test = 8;
      .           
 26,560 ( 0.00%)      surfaceType = 0x000000FF;
159,360 ( 0.00%)      temp_v0 = random_int(test);
1,633,278 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_int (26,560x)
 99,440 ( 0.00%)      if ((temp_v0 == 0) || (temp_v0 == 4)) {
 20,193 ( 0.00%)          var_f2 = player->tyres[BACK_LEFT].pos[0];
 33,655 ( 0.00%)          var_f12 = player->tyres[BACK_LEFT].baseHeight + 2.0f;
 20,193 ( 0.00%)          var_f14 = player->tyres[BACK_LEFT].pos[2];
  6,731 ( 0.00%)          var_t3 = 1;
 26,924 ( 0.00%)          surfaceType = player->tyres[BACK_LEFT].surfaceType;
      .               }
 99,624 ( 0.00%)      if ((temp_v0 == 2) || (temp_v0 == 6)) {
 19,818 ( 0.00%)          var_f2 = player->tyres[BACK_RIGHT].pos[0];
 33,030 ( 0.00%)          var_f12 = player->tyres[BACK_RIGHT].baseHeight + 2.0f;
 19,818 ( 0.00%)          var_f14 = player->tyres[BACK_RIGHT].pos[2];
  6,606 ( 0.00%)          var_t3 = 0;
 26,424 ( 0.00%)          surfaceType = player->tyres[BACK_RIGHT].surfaceType;
      .               }
 55,160 ( 0.00%)      switch (surfaceType) {
      .                   case DIRT:
      .                       if ((arg1 == 0) &&
      .                           ((player->unk_258[10 + arg2].unk_01E > 0) || (player->unk_258[10 + arg2].unk_01C == 0))) {
      .                           if (((player->unk_094 / 18.0f) * 216.0f) >= 10.0f) {
      .                               func_8005D794(player, &player->unk_258[10 + arg1], var_f2, var_f12, var_f14, (s8) surfaceType,
      .                                             (s8) var_t3);
      .                               func_8005D7D8(&player->unk_258[10 + arg1], 2, 0.46f);
      .                               if ((GetCourse() == GetChocoMountain()) || (GetCourse() == GetRoyalRaceway())) {
-- line 2935 ----------------------------------------
-- line 3113 ----------------------------------------
      .                           func_8005D794(player, &player->unk_258[10 + arg1], var_f2, var_f12, var_f14, (s8) surfaceType,
      .                                         (s8) var_t3);
      .                           func_8005D7D8(&player->unk_258[10 + arg1], 2, 0.46f);
      .                           func_8005DAD8(&player->unk_258[10 + arg1], 0, 0, 0x0080);
      .                           player->unk_258[10 + arg1].unk_03A = random_int(0x0010U);
      .                       }
      .                       break;
      .                   default:
 53,120 ( 0.00%)              break;
      .               }
106,240 ( 0.00%)  }
      .           
      .           void func_8005EA94(Player* player, s16 arg1, s32 arg2, s8 arg3, UNUSED s8 arg4) {
      .               s32 temp_v0;
      .               s32 var_t0;
      .               s32 var_t1;
      .               f32 var_f2;
      .               f32 var_f12;
      .               f32 var_f14;
-- line 3131 ----------------------------------------
-- line 3551 ----------------------------------------
      .                   default:
      .                       break;
      .               }
      .           }
      .           #else
      .           GLOBAL_ASM("asm/non_matchings/code_80057C60/func_8005F90C.s")
      .           #endif
      .           
156,876 ( 0.00%)  void func_80060504(Player* player, s16 arg1, s32 arg2, UNUSED s8 arg3, UNUSED s8 arg4) {
      .               UNUSED s32 thing1;
      .               s16 thing2;
      .               UNUSED s32 thing3;
      .               f32 sp50;
      .               f32 sp4C;
      .               f32 sp48;
      .               f32 var_f0;
      .               s32 var_v0;
      .               s32 temp_v0;
      .               UNUSED s32 test;
      .           
 78,438 ( 0.00%)      if ((player->unk_044 & 0x20) == 0x20) {
  1,964 ( 0.00%)          var_v0 = 5;
      .               } else {
 12,091 ( 0.00%)          var_v0 = 0xE;
      .               }
 78,438 ( 0.00%)      temp_v0 = random_int(var_v0);
804,165 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_int (13,073x)
 72,166 ( 0.00%)      if ((temp_v0 == 1) || (temp_v0 == 2) || (temp_v0 == 3)) {
  9,794 ( 0.00%)          if ((arg1 == 0) && ((player->unk_258[arg2].unk_01E > 0) || (player->unk_258[arg2].unk_01C == 0))) {
    815 ( 0.00%)              sp4C = player->pos[1] - 2.5;
    489 ( 0.00%)              sp48 = player->pos[2];
    489 ( 0.00%)              sp50 = player->pos[0];
  3,586 ( 0.00%)              func_8005D794(player, &player->unk_258[arg1], sp50, sp4C, sp48, 0, 0);
  5,705 ( 0.00%)  => src/code_80057C60.c:func_8005D794 (163x)
  2,608 ( 0.00%)              func_8005D7D8(&player->unk_258[arg1], 1, 0.5f);
  3,097 ( 0.00%)  => src/code_80057C60.c:func_8005D7D8 (163x)
 36,288 ( 0.00%)          } else if (player->unk_258[arg2].unk_01E > 0) {
  4,950 ( 0.00%)              sp4C = player->pos[1] - 2.5;
  2,970 ( 0.00%)              sp48 = player->pos[2];
  2,970 ( 0.00%)              sp50 = player->pos[0];
 21,780 ( 0.00%)              func_8005D794(player, &player->unk_258[arg1], sp50, sp4C, sp48, 0, 0);
 34,650 ( 0.00%)  => src/code_80057C60.c:func_8005D794 (990x)
 14,850 ( 0.00%)              func_8005D7D8(&player->unk_258[arg1], 1, 0.5f);
 18,810 ( 0.00%)  => src/code_80057C60.c:func_8005D7D8 (990x)
      .                   }
      .               }
143,803 ( 0.00%)      player->unk_258[arg1].unk_024 = 0.0f;
 78,438 ( 0.00%)      if ((player->unk_044 & 0x20) == 0x20) {
  9,820 ( 0.00%)          player->unk_258[arg1].unk_040 = 0;
  4,910 ( 0.00%)          if ((player->effects & BOOST_EFFECT) == BOOST_EFFECT) {
      .                       func_8005D800(&player->unk_258[arg1], 0x00FFFF00, 0x0080);
      .                       player->unk_258[arg1].unk_038 = 1;
      .                   } else {
 13,748 ( 0.00%)              func_8005D800(&player->unk_258[arg1], 0x00FFFFFF, 0x0070);
 25,532 ( 0.00%)  => src/code_80057C60.c:func_8005D800 (982x)
 10,802 ( 0.00%)              player->unk_258[arg1].unk_038 = 0;
      .                   }
      .               } else {
120,910 ( 0.00%)          player->unk_258[arg1].unk_040 = 1;
 60,455 ( 0.00%)          if ((player->effects & BOOST_EFFECT) == BOOST_EFFECT) {
      .                       func_8005D800(&player->unk_258[arg1], 0x00FFFF00, 0x0080);
      .                       player->unk_258[arg1].unk_038 = 1;
      .                   } else {
169,274 ( 0.00%)              func_8005D800(&player->unk_258[arg1], 0x00FFFFFF, 0x0070);
314,366 ( 0.00%)  => src/code_80057C60.c:func_8005D800 (12,091x)
120,910 ( 0.00%)              player->unk_258[arg1].unk_038 = 0;
      .                   }
      .               }
274,533 ( 0.00%)      thing2 = (player->unk_258[arg1].unk_020 - (player->unk_0C0 / 2));
156,876 ( 0.00%)      if (player->unk_258[arg1].unk_040 == 0) {
 11,784 ( 0.00%)          var_f0 = -((player->unk_098 / 3000.0f) + 0.1);
      .               } else {
133,001 ( 0.00%)          var_f0 = -((player->unk_098 / 5000.0f) + 0.1);
      .               }
379,117 ( 0.00%)      func_80062B18(&sp50, &sp4C, &sp48, 0.0f, 4.5f, (player->unk_258[arg1].unk_01E * var_f0) + -5.5, -thing2,
3,438,199 ( 0.00%)  => src/code_80057C60.c:func_80062B18 (13,073x)
 78,438 ( 0.00%)                    -player->unk_206 * 2);
183,022 ( 0.00%)      player->unk_258[arg1].unk_000[0] = player->pos[0] + sp50;
104,584 ( 0.00%)      sp4C = sp4C + (player->pos[1] - player->boundingBoxSize);
183,022 ( 0.00%)      player->unk_258[arg1].unk_000[2] = player->pos[2] + sp48;
287,606 ( 0.00%)      player->unk_258[arg1].unk_000[1] = player->unk_258[arg1].unk_024 + sp4C;
130,730 ( 0.00%)      player->unk_258[arg1].unk_010 = 0;
 39,219 ( 0.00%)  }
      .           
      .           void func_800608E0(Player* player, s16 arg1, UNUSED s32 arg2, s8 arg3, UNUSED s8 arg4) {
      .               f32 var_f0;
      .               f32 sp50;
      .               f32 sp4C;
      .               f32 sp48;
      .           
      .               var_f0 = 8.0f - (D_801652A0[arg3] - player->pos[1]);
-- line 3633 ----------------------------------------
-- line 4187 ----------------------------------------
      .           void func_80062AA8(Player* player, UNUSED s8 arg1, UNUSED s8 arg2, s8 arg3) {
      .               player->unk_258[20 + arg3].unk_01C = 1;
      .               player->unk_258[20 + arg3].unk_012 = 5;
      .               player->unk_258[20 + arg3].unk_00C = 0.1f;
      .               player->unk_258[20 + arg3].unk_01E = 0;
      .               player->unk_258[20 + arg3].unk_000[1] = (player->pos[1] + player->boundingBoxSize) - 2.5;
      .           }
      .           
396,676 ( 0.00%)  void func_80062B18(f32* arg0, f32* arg1, f32* arg2, f32 arg3, f32 arg4, f32 arg5, u16 arg6, u16 arg7) {
      .               UNUSED f32 pad;
      .               f32 sp30;
      .               f32 sp2C;
      .               f32 sp28;
      .               f32 temp_f20;
      .           
      .               //  Apply the matrix multiplication:
      .               //  Matrix is the Jacobian for cartesian to spherical coordinates?
-- line 4203 ----------------------------------------
-- line 4204 ----------------------------------------
      .               //  Get the change in r, theta, and phi for a change in x, y, z?
      .               //
      .               // | arg0 |     | cos(arg6)*cos(arg7)  cos(arg6)*sin(arg7)   -sin(arg6) |     | arg3 |
      .               // |      |     |                                                       |     |      |
      .               // | arg1 |  =  | -sin(arg7)           cos(arg7)                 0      |  X  | arg4 |
      .               // |      |     |                                                       |     |      |
      .               // | arg2 |     | sin(arg6)*cos(arg7)  sin(arg6)*sin(arg7)    cos(arg6) |     | arg5 |
      .               //
141,670 ( 0.00%)      sp28 = sins(arg7);
340,008 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (28,334x)
141,670 ( 0.00%)      sp2C = coss(arg6);
396,676 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (28,334x)
141,670 ( 0.00%)      sp30 = coss(arg7);
396,676 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (28,334x)
141,670 ( 0.00%)      temp_f20 = coss(arg6);
396,676 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (28,334x)
      .               //    = arg3 * cos(arg6) * cos(arg7) + arg4 * cos(arg6) * sin(arg7) - arg5 * sin(arg6)
510,012 ( 0.00%)      *arg0 = (((arg3 * temp_f20) * sp30) + (arg4 * sp2C) * sp28) - (sins(arg6) * arg5);
340,008 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (28,334x)
      .           
141,670 ( 0.00%)      temp_f20 = sins(arg7);
340,008 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (28,334x)
      .               //    = -arg3 * sin(arg7) + arg4 * cos(arg7)
311,674 ( 0.00%)      *arg1 = (coss(arg7) * arg4) - (arg3 * temp_f20);
396,676 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (28,334x)
      .           
141,670 ( 0.00%)      sp28 = sins(arg7);
340,008 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (28,334x)
141,670 ( 0.00%)      sp2C = sins(arg6);
340,008 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (28,334x)
141,670 ( 0.00%)      sp30 = coss(arg7);
396,676 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (28,334x)
141,670 ( 0.00%)      temp_f20 = sins(arg6);
340,008 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (28,334x)
      .               //    = arg3 * sin(arg6) * cos(arg7) + arg4 * sin(arg6) * sin(arg7) + arg5 * cos(arg6)
453,344 ( 0.00%)      *arg2 = (coss(arg6) * arg5) + (((arg3 * temp_f20) * sp30) + ((arg4 * sp2C) * sp28));
396,676 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (28,334x)
 85,002 ( 0.00%)  }
      .           
107,896 ( 0.00%)  void func_80062C74(Player* player, s16 arg1, UNUSED s32 arg2, UNUSED s32 arg3) {
215,792 ( 0.00%)      f32 sp48[8] = { 4.5f, 4.5f, 4.5f, 4.5f, 4.5f, 5.5f, 4.5f, 6.5f };
      .               f32 var_f6;
      .               f32 sp40;
      .               f32 sp3C;
      .               f32 sp38;
      .               s16 thing;
      .           
296,714 ( 0.00%)      player->unk_258[arg1].unk_01E += 1;
161,844 ( 0.00%)      if (player->unk_258[arg1].unk_01E == 0x000C) {
 10,980 ( 0.00%)          player->unk_258[arg1].unk_01C = 0;
 10,980 ( 0.00%)          player->unk_258[arg1].unk_01E = 0;
 10,980 ( 0.00%)          player->unk_258[arg1].unk_012 = 0;
      .               }
148,357 ( 0.00%)      player->unk_258[arg1].unk_018 = 2.0f;
161,844 ( 0.00%)      if (player->unk_258[arg1].unk_040 == 0) {
 88,992 ( 0.00%)          player->unk_258[arg1].unk_00C = player->unk_258[arg1].unk_00C + 0.07;
 88,992 ( 0.00%)          player->unk_258[arg1].unk_024 = player->unk_258[arg1].unk_024 + 0.3;
 44,496 ( 0.00%)          if (player->unk_258[arg1].unk_01E >= 3) {
 60,918 ( 0.00%)              player->unk_258[arg1].unk_03E -= 3;
      .                   }
 44,496 ( 0.00%)          if (player->unk_258[arg1].unk_03E <= 0) {
      .                       player->unk_258[arg1].unk_03E = 0;
      .                   }
      .               } else {
234,696 ( 0.00%)          player->unk_258[arg1].unk_00C = player->unk_258[arg1].unk_00C + 0.1;
234,696 ( 0.00%)          player->unk_258[arg1].unk_024 = player->unk_258[arg1].unk_024 + 0.3;
117,348 ( 0.00%)          if (player->unk_258[arg1].unk_01E >= 3) {
161,282 ( 0.00%)              player->unk_258[arg1].unk_03E -= 2;
      .                   }
117,348 ( 0.00%)          if (player->unk_258[arg1].unk_03E <= 0) {
      .                       player->unk_258[arg1].unk_03E = 0;
      .                   }
      .               }
283,227 ( 0.00%)      thing = player->unk_258[arg1].unk_020 - (player->unk_0C0 / 2);
161,844 ( 0.00%)      if (player->unk_258[arg1].unk_040 == 0) {
 44,496 ( 0.00%)          var_f6 = -((player->unk_098 / 5000.0f) + 0.1);
      .               } else {
107,569 ( 0.00%)          var_f6 = -((player->unk_098 / 6000.0f) + 0.1);
      .               }
 67,435 ( 0.00%)      if (((player->effects & BOOST_EFFECT) == BOOST_EFFECT) && (player->unk_258[arg1].unk_01E >= 6)) {
      .                   player->unk_258[arg1].unk_00C = player->unk_258[arg1].unk_00C + 0.06;
      .               }
269,740 ( 0.00%)      player->unk_258[arg1].unk_010++;
161,844 ( 0.00%)      if (player->unk_258[arg1].unk_010 >= 3) {
 44,800 ( 0.00%)          player->unk_258[arg1].unk_010 = 0;
      .               }
458,558 ( 0.00%)      func_80062B18(&sp40, &sp38, &sp3C, 0.0f, sp48[player->characterId], (player->unk_258[arg1].unk_01E * var_f6) + -5.5,
3,547,081 ( 0.00%)  => src/code_80057C60.c:func_80062B18 (13,487x)
 80,922 ( 0.00%)                    -thing, -player->unk_206 * 2);
188,818 ( 0.00%)      player->unk_258[arg1].unk_000[0] = player->pos[0] + sp40;
107,896 ( 0.00%)      sp38 = (player->pos[1] - player->boundingBoxSize) + sp38;
188,818 ( 0.00%)      player->unk_258[arg1].unk_000[2] = player->pos[2] + sp3C;
296,714 ( 0.00%)      player->unk_258[arg1].unk_000[1] = player->unk_258[arg1].unk_024 + sp38;
 40,461 ( 0.00%)  }
      .           
      .           void func_80062F98(Player* player, s16 arg1, s8 arg2, UNUSED s8 arg3) {
      .               f32 temp_f0;
      .           
      .               temp_f0 = player->unk_258[10 + arg1].unk_018 / 10.0f;
      .               ++player->unk_258[10 + arg1].unk_01E;
      .               player->unk_258[10 + arg1].unk_000[1] += temp_f0;
      .               if ((player->unk_0CA & 1) == 1) {
-- line 4292 ----------------------------------------
-- line 4966 ----------------------------------------
      .                       player->unk_0B6 &= ~0x0020;
      .                       player->unk_258[20 + arg3].unk_01C = 0;
      .                       player->unk_258[20 + arg3].unk_01E = 0;
      .                       player->unk_258[20 + arg3].unk_012 = 0;
      .                   }
      .               }
      .           }
      .           
 25,458 ( 0.00%)  void func_800652D4(Vec3f arg0, Vec3s arg1, f32 arg2) {
      .               Mat4 sp20;
      .           
 25,458 ( 0.00%)      mtxf_translate_rotate(sp20, arg0, arg1);
958,918 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_player.c:mtxf_translate_rotate (4,243x)
 21,215 ( 0.00%)      mtxf_scale2(sp20, arg2);
271,552 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_player.c:mtxf_scale2 (4,243x)
 55,159 ( 0.00%)      convert_to_fixed_point_matrix(&gGfxPool->mtxEffect[gMatrixEffectCount], sp20);
2,146,958 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_player.c:convert_to_fixed_point_matrix (4,243x)
 84,860 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
 12,729 ( 0.00%)  }
      .           
 38,187 ( 0.00%)  void func_8006538C(Player* player, s8 arg1, s16 arg2, s8 arg3) {
      .               Vec3f spB4;
      .               Vec3s spAC;
  8,486 ( 0.00%)      s32 primColors[] = { MAKE_RGB(0xFB, 0xFF, 0xFB), MAKE_RGB(0xFF, 0xFB, 0x86) };
  8,486 ( 0.00%)      s32 envColors[] = { MAKE_RGB(0x89, 0x62, 0x8F), MAKE_RGB(0xFE, 0x01, 0x09) };
      .               s16 primRed;
      .               s16 primGreen;
      .               s16 primBlue;
      .               s16 primAlpha;
      .               s16 envRed;
      .               s16 envGreen;
      .               s16 envBlue;
      .           
 50,916 ( 0.00%)      if (player->unk_258[arg2].unk_01C == 1) {
 46,673 ( 0.00%)          spB4[0] = player->unk_258[arg2].unk_000[0];
 46,673 ( 0.00%)          spB4[1] = player->unk_258[arg2].unk_000[1];
 46,673 ( 0.00%)          spB4[2] = player->unk_258[arg2].unk_000[2];
  4,243 ( 0.00%)          spAC[0] = 0;
 25,458 ( 0.00%)          spAC[1] = player->unk_048[arg3];
  4,243 ( 0.00%)          spAC[2] = 0;
 21,215 ( 0.00%)          if ((player->effects & STAR_EFFECT) && (((s32) gCourseTimer - D_8018D930[arg1]) < 9)) {
      .                       primRed = (primColors[1] >> 0x10) & 0xFF;
      .                       primGreen = (primColors[1] >> 0x08) & 0xFF;
      .                       primBlue = (primColors[1] >> 0x00) & 0xFF;
      .                       envRed = (envColors[1] >> 0x10) & 0xFF;
      .                       envGreen = (envColors[1] >> 0x08) & 0xFF;
      .                       envBlue = (envColors[1] >> 0x00) & 0xFF;
      .                       primAlpha = player->unk_258[arg2].unk_03E;
      .                       func_800652D4(spB4, spAC, ((player->unk_258[arg2].unk_00C * player->size) * 1.4));
-- line 5012 ----------------------------------------
-- line 5013 ----------------------------------------
      .                       gSPDisplayList(gDisplayListHead++, D_0D008DB8);
      .                       gDPLoadTextureBlock(gDisplayListHead++, common_texture_particle_smoke[player->unk_258[arg2].unk_010],
      .                                           G_IM_FMT_I, G_IM_SIZ_8b, 32, 32, 0, G_TX_NOMIRROR | G_TX_WRAP,
      .                                           G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
      .                       func_8004B72C(primRed, primGreen, primBlue, envRed, envGreen, envBlue, primAlpha);
      .                       gDPSetAlphaCompare(gDisplayListHead++, G_AC_DITHER);
      .                       gSPDisplayList(gDisplayListHead++, D_0D008E48);
      .                   } else {
 67,888 ( 0.00%)              primRed = (primColors[player->unk_258[arg2].unk_038] >> 0x10) & 0xFF;
 67,888 ( 0.00%)              primGreen = (primColors[player->unk_258[arg2].unk_038] >> 0x08) & 0xFF;
 63,645 ( 0.00%)              primBlue = (primColors[player->unk_258[arg2].unk_038] >> 0x00) & 0xFF;
 67,888 ( 0.00%)              envRed = (envColors[player->unk_258[arg2].unk_038] >> 0x10) & 0xFF;
 67,888 ( 0.00%)              envGreen = (envColors[player->unk_258[arg2].unk_038] >> 0x08) & 0xFF;
 63,645 ( 0.00%)              envBlue = (envColors[player->unk_258[arg2].unk_038] >> 0x00) & 0xFF;
 46,673 ( 0.00%)              primAlpha = player->unk_258[arg2].unk_03E;
 84,860 ( 0.00%)              func_800652D4(spB4, spAC, player->unk_258[arg2].unk_00C * player->size);
3,602,307 ( 0.00%)  => src/code_80057C60.c:func_800652D4 (4,243x)
 38,187 ( 0.00%)              gSPDisplayList(gDisplayListHead++, D_0D008DB8);
50,732,940 ( 0.04%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (4,243x)
394,599 ( 0.00%)              gDPLoadTextureBlock(gDisplayListHead++, common_texture_particle_smoke[player->unk_258[arg2].unk_010],
      .                                           G_IM_FMT_I, G_IM_SIZ_8b, 32, 32, 0, G_TX_NOMIRROR | G_TX_WRAP,
      .                                           G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
 50,916 ( 0.00%)              func_8004B72C(primRed, primGreen, primBlue, envRed, envGreen, envBlue, primAlpha);
305,496 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004B72C (4,243x)
 38,187 ( 0.00%)              gSPDisplayList(gDisplayListHead++, D_0D008E48);
50,727,986 ( 0.04%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (4,243x)
      .                   }
 25,458 ( 0.00%)          gMatrixEffectCount += 1;
      .               }
 12,729 ( 0.00%)  }
      .           
      .           void func_800658A0(Player* player, UNUSED s8 arg1, s16 arg2, s8 arg3) {
      .               Vec3f sp54;
      .               Vec3s sp4C;
      .               s16 red;
      .               s16 green;
      .               s16 blue;
      .               s16 alpha;
-- line 5046 ----------------------------------------
-- line 6087 ----------------------------------------
      .           
      .           void func_8006B7E4(Player* player, s8 arg1) {
      .               func_8006A50C(player, 0.0f, 0.0f, arg1, (s8) 0, (s16) 0);
      .               func_8006A50C(player, 1.5f, 2.0f, arg1, (s8) 1, (s16) 0x1C70);
      .               func_8006A50C(player, -1.5f, 2.0f, arg1, (s8) 2, (s16) -0x1C70);
      .               gPlayerBalloonCount[arg1] = 2;
      .           }
      .           
     40 ( 0.00%)  void func_8006B87C(UNUSED Player* player, s8 playerIndex) {
     72 ( 0.00%)      gPlayerBalloonStatus[playerIndex][0] = BALLOON_STATUS_GONE;
     80 ( 0.00%)      gPlayerBalloonStatus[playerIndex][1] = BALLOON_STATUS_GONE;
     80 ( 0.00%)      gPlayerBalloonStatus[playerIndex][2] = BALLOON_STATUS_GONE;
     24 ( 0.00%)  }
      .           
      .           void func_8006B8B4(Player* player, s8 playerIndex) {
      .               if (gPlayerBalloonCount[playerIndex] >= 0) {
      .                   gPlayerBalloonStatus[playerIndex][gPlayerBalloonCount[playerIndex]] &= ~1;
      .                   gPlayerBalloonStatus[playerIndex][gPlayerBalloonCount[playerIndex]] |= 2;
      .                   gPlayerBalloonCount[playerIndex]--;
      .                   func_800C9060(playerIndex, SOUND_ARG_LOAD(0x19, 0x00, 0x90, 0x51));
      .                   if (gPlayerBalloonCount[playerIndex] < 0) {
-- line 6107 ----------------------------------------
-- line 6281 ----------------------------------------
      .               gDPLoadTextureBlock(gDisplayListHead++, common_texture_particle_spark[arg4], G_IM_FMT_I, G_IM_SIZ_8b, 32, 32, 0,
      .                                   G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
      .                                   G_TX_NOLOD);
      .               func_8004B414(red, green, blue, alpha);
      .               gSPDisplayList(gDisplayListHead++, D_0D008E48);
      .               gMatrixEffectCount += 1;
      .           }
      .           
239,040 ( 0.00%)  void func_8006C6AC(Player* player, s16 arg1, s8 arg2, s8 arg3) {
 53,120 ( 0.00%)      s8 arg2_copy = arg2;
      .               s32 sp28;
      .           
 79,680 ( 0.00%)      sp28 = arg1 - 1;
 53,120 ( 0.00%)      if (sp28 < 0) {
  2,656 ( 0.00%)          sp28 = 9;
      .               }
345,280 ( 0.00%)      if (player->unk_258[10 + arg1].unk_01C == 1) {
      .                   switch (player->unk_258[10 + arg1].unk_012) {
      .                       case 1:
      .                           func_80063408(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       case 2:
      .                           func_800635D4(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       case 3:
-- line 6305 ----------------------------------------
-- line 6316 ----------------------------------------
      .                           break;
      .                       case 11:
      .                           func_80062F98(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       default:
      .                           break;
      .                   }
      .               } else {
159,360 ( 0.00%)          if (player->unk_0DE & 1) {
      .                       func_80060BCC(player, arg1, sp28, arg2_copy, arg3);
265,600 ( 0.00%)          } else if (!(player->effects & 8) && !(player->effects & 2)) {
132,800 ( 0.00%)              if (((player->effects & 0x10) == 0x10) && ((player->type & PLAYER_HUMAN) == PLAYER_HUMAN)) {
      .                           func_8005DA30(player, arg1, sp28, arg2_copy, arg3);
292,160 ( 0.00%)              } else if (((f64) (D_801652A0[arg2_copy] - player->tyres[BACK_RIGHT].baseHeight) >= 3.5) ||
185,920 ( 0.00%)                         ((f64) (D_801652A0[arg2_copy] - player->tyres[BACK_LEFT].baseHeight) >= 3.5)) {
      .                           func_8005EA94(player, arg1, sp28, arg2_copy, arg3);
265,600 ( 0.00%)              } else if (((player->effects & 0x80) == 0x80) || ((player->effects & 0x40) == 0x40)) {
      .                           func_8005F90C(player, arg1, sp28, arg2_copy, arg3);
185,920 ( 0.00%)              } else if (((player->effects & 0x4000) && !(player->type & PLAYER_START_SEQUENCE)) ||
371,840 ( 0.00%)                         (player->effects & 0x800) || (player->effects & 0x20) || (player->unk_044 & 0x4000)) {
      .                           func_8005ED48(player, arg1, sp28, arg2_copy, arg3);
      .                       } else {
212,480 ( 0.00%)                  func_8005DAF4(player, arg1, sp28, arg2_copy, arg3);
2,791,454 ( 0.00%)  => src/code_80057C60.c:func_8005DAF4 (26,560x)
      .                       }
      .                   }
      .               }
106,240 ( 0.00%)  }
      .           
 29,880 ( 0.00%)  void func_8006C9B8(Player* player, s16 arg1, s8 arg2, s8 arg3) {
      .               UNUSED s32 stackPadding;
      .               s32 sp28;
  9,960 ( 0.00%)      sp28 = arg1 - 1;
  6,640 ( 0.00%)      if (sp28 < 0) {
    332 ( 0.00%)          sp28 = 9;
      .               }
 43,160 ( 0.00%)      if (player->unk_258[30 + arg1].unk_01C == 1) {
      .                   switch (player->unk_258[30 + arg1].unk_012) {
      .                       case 1:
      .                           func_800644E8(player, arg1, arg2, arg3);
      .                           break;
      .           
      .                       case 2:
      .                           func_800649F4(player, arg1, arg2, arg3);
      .                           break;
-- line 6359 ----------------------------------------
-- line 6385 ----------------------------------------
      .                       case 9:
      .                           func_80064664(player, arg1, arg2, arg3);
      .                           break;
      .           
      .                       default:
      .                           break;
      .                   }
      .               } else {
 19,920 ( 0.00%)          if (player->unk_044 & 0x1000) {
      .                       func_80061430(player, arg1, sp28, arg2, arg3);
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 56,440 ( 0.00%)          if (((((player->unk_0CA & 0x1000) == 0x1000) || ((player->unk_0E0 < 2) && (player->effects & 0x01000000))) ||
 29,880 ( 0.00%)               ((player->unk_0E0 < 2) && (player->effects & HIT_BY_ITEM_EFFECT))) ||
  9,960 ( 0.00%)              (player->effects & 0x400)) {
      .                       func_8006199C(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 19,920 ( 0.00%)          if ((player->unk_0CA & 0x2000) == 0x2000) {
      .                       func_80061A34(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 16,600 ( 0.00%)          if ((player->effects & STAR_EFFECT) && ((((s32) gCourseTimer) - D_8018D930[arg2]) < 9)) {
      .                       func_800615AC(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 19,920 ( 0.00%)          if ((player->unk_046 & 8) == 8) {
      .                       func_800612F8(player, arg1, sp28, arg2, arg3);
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 19,920 ( 0.00%)          if (((player->unk_046 & 0x20) == 0x20) && (((player->unk_094 / 18.0f) * 216.0f) >= 20.0f)) {
      .                       func_80061D4C(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 16,600 ( 0.00%)          if ((player->effects & BOOST_EFFECT) && (player->type & PLAYER_HUMAN)) {
      .                       func_800621BC(player, arg1, sp28, arg2, arg3);
      .                       return;
      .                   }
 33,200 ( 0.00%)          if (((player->effects & 0x200000) || (player->effects & BOOST_RAMP_ASPHALT_EFFECT)) &&
      .                       ((player->type & PLAYER_HUMAN) == PLAYER_HUMAN)) {
      .                       func_80061EF4(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 19,920 ( 0.00%)          if ((player->unk_044 & 0x100) == 0x100) {
      .                       func_800624D8(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                   }
      .               }
  6,640 ( 0.00%)  }
      .           
239,040 ( 0.00%)  void func_8006CEC0(Player* arg0, s16 arg1, s8 arg2, s8 arg3) {
      .               UNUSED u16 temp_v0_3;
 53,120 ( 0.00%)      s32 sp20 = arg1;
 79,680 ( 0.00%)      if (--sp20 < 0) {
  2,656 ( 0.00%)          sp20 = 9;
      .               }
318,720 ( 0.00%)      if (arg0->unk_258[arg1].unk_01C == 1) {
283,227 ( 0.00%)          switch (arg0->unk_258[arg1].unk_012) {
      .                       case 1:
 80,922 ( 0.00%)                  func_80062C74(arg0, arg1, arg2, arg3);
8,368,874 ( 0.01%)  => src/code_80057C60.c:func_80062C74 (13,487x)
 13,487 ( 0.00%)                  break;
      .                       case 3:
      .                           func_80064184(arg0, arg1, arg2, arg3);
      .                           break;
      .                       case 5:
      .                           func_800630C0(arg0, arg1, arg2, arg3);
      .                           break;
      .                       case 6:
      .                           func_800631A8(arg0, arg1, arg2, arg3);
      .                           break;
      .                       case 7:
      .                           func_80063268(arg0, arg1, arg2, arg3);
      .                           break;
      .                   }
      .               } else {
 78,438 ( 0.00%)          if ((arg0->unk_044 & 0x200) && (arg0->type & 0x4000)) {
      .                       func_80061224(arg0, arg1, sp20, arg2, arg3);
      .                       return;
 65,365 ( 0.00%)          } else if (((arg0->effects & 0x40000000) == 0x40000000) && (arg0->unk_0B0 < 0x32)) {
      .                       func_80061094(arg0, arg1, sp20, arg2, arg3);
      .                       return;
 78,438 ( 0.00%)          } else if ((arg0->type & 0x4000) == 0x4000) {
 11,304 ( 0.00%)              if ((arg0->unk_0DE & 8) == 8) {
      .                           func_80060F50(arg0, arg1, sp20, arg2, arg3);
      .                           return;
 22,608 ( 0.00%)              } else if ((arg0->unk_0DE & 2) || (arg0->unk_0DE & 1)) {
      .                           func_80060B14(arg0, arg1, sp20, arg2, arg3);
      .                           return;
      .                       }
      .                   }
 52,292 ( 0.00%)          switch (gActiveScreenMode) {
      .                       case SCREEN_MODE_1P:
156,876 ( 0.00%)                  if (((arg0->effects & 0x04000000) != 0x04000000) && ((arg0->effects & 0x400) != 0x400) &&
 39,219 ( 0.00%)                      ((arg0->effects & 0x01000000) != 0x01000000)) {
235,314 ( 0.00%)                      if (((arg0->unk_0CA & 2) != 2) && ((arg0->unk_0CA & 0x10) != 0x10) && !(arg0->unk_0CA & 0x100)) {
104,584 ( 0.00%)                          func_80060504(arg0, arg1, sp20, arg2, arg3);
7,841,088 ( 0.01%)  => src/code_80057C60.c:func_80060504 (13,073x)
      .                               }
      .                           }
 39,219 ( 0.00%)                  break;
      .                       default:
      .                           break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL:
      .                       case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
      .                       case SCREEN_MODE_3P_4P_SPLITSCREEN:
      .                           if (((arg0->type & 0x4000) != 0) && ((arg0->effects & 0x04000000) != 0x04000000) &&
      .                               ((arg0->effects & 0x400) != 0x400) && ((arg0->effects & 0x01000000) != 0x01000000)) {
      .                               if (((arg0->unk_0CA & 2) != 2) && ((arg0->unk_0CA & 0x10) != 0x10) && !(arg0->unk_0CA & 0x100)) {
      .                                   func_80060504(arg0, arg1, sp20, arg2, arg3);
      .                               }
      .                           }
      .                           break;
      .                   }
      .               }
 53,120 ( 0.00%)  }
      .           
  2,988 ( 0.00%)  void func_8006D194(Player* player, s8 arg1, s8 arg2) {
  1,328 ( 0.00%)      if (player->unk_258[0x14].unk_01C == 1) {
      .                   switch (player->unk_258[0x14].unk_012) {
      .                       case 2:
      .                           func_80064DEC(player, arg1, arg2, 0);
      .                           break;
      .                       case 3:
      .                           func_800650FC(player, arg1, arg2, 0);
      .                           break;
      .                       case 4:
-- line 6521 ----------------------------------------
-- line 6524 ----------------------------------------
      .                       case 5:
      .                           func_80064F88(player, arg1, arg2, 0);
      .                           break;
      .                       case 6:
      .                           func_80065030(player, arg1, arg2, 0);
      .                           break;
      .                   }
      .               } else {
  1,992 ( 0.00%)          if ((player->unk_0B6 & 0x40) == 0x40) {
      .                       func_800628C0(player, arg1, arg2, 0);
      .                   }
  1,992 ( 0.00%)          if ((player->unk_0B6 & 0x800) == 0x800) {
      .                       func_80062968(player, arg1, arg2, 0);
      .                   }
  1,992 ( 0.00%)          if ((player->unk_0B6 & 0x1000) == 0x1000) {
      .                       func_80062914(player, arg1, arg2, 0);
      .                   }
  1,992 ( 0.00%)          if ((player->unk_0B6 & 0x80) == 0x80) {
      .                       func_80062A18(player, arg1, arg2, 0);
      .                   }
  1,992 ( 0.00%)          if ((player->unk_0B6 & 0x100) == 0x100) {
      .                       func_800629BC(player, arg1, arg2, 0);
      .                   }
      .               }
  1,328 ( 0.00%)      if (player->unk_258[0x15].unk_01C == 1) {
      .                   if (player->unk_258[0x15].unk_012 == 5) {
      .                       func_800651F4(player, arg1, arg2, 1);
      .                   }
  1,992 ( 0.00%)      } else if ((player->unk_0B6 & 0x20) == 0x20) {
      .                   func_80062AA8(player, arg1, arg2, 1);
      .               }
    996 ( 0.00%)  }
      .           
 23,904 ( 0.00%)  void func_8006D474(Player* player, s8 playerId, s8 screenId) {
      .               s16 var_s2;
 37,184 ( 0.00%)      if ((player->unk_002 & (8 << (screenId * 4))) == (8 << (screenId * 4))) {
 49,518 ( 0.00%)          for (var_s2 = 0; var_s2 < 10; var_s2++) {
133,991 ( 0.00%)              switch (player->unk_258[var_s2].unk_012) {
      .                           case 1:
 16,972 ( 0.00%)                      if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                                   if (screenId == playerId) {
      .                                       func_8006538C(player, playerId, var_s2, screenId);
      .                                   }
      .                               } else {
 25,458 ( 0.00%)                          func_8006538C(player, playerId, var_s2, screenId);
106,760,433 ( 0.09%)  => src/code_80057C60.c:func_8006538C (4,243x)
      .                               }
 12,729 ( 0.00%)                      break;
      .                           case 6:
      .                               if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                                   if (screenId == playerId) {
      .                                       func_80066BAC(player, playerId, var_s2, screenId);
      .                                   }
      .                               } else if (screenId == playerId) {
      .                                   func_80066BAC(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
      .                       }
201,740 ( 0.00%)              switch (player->unk_258[var_s2 + 30].unk_012) {
      .                           case 1:
      .                           case 9:
      .                               if (gActiveScreenMode == SCREEN_MODE_1P) {
      .                                   func_800691B8(player, playerId, var_s2, screenId);
      .                               } else if (screenId == playerId) {
      .                                   func_800691B8(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
-- line 6589 ----------------------------------------
-- line 6632 ----------------------------------------
      .                           case 8:
      .                               if (gActiveScreenMode == SCREEN_MODE_1P) {
      .                                   func_80067604(player, playerId, var_s2, screenId);
      .                               } else if (screenId == playerId) {
      .                                   func_80067604(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
      .                       }
220,080 ( 0.00%)              switch (player->unk_258[var_s2 + 10].unk_012) {
      .                           case 1:
      .                               if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                                   if (screenId == playerId) {
      .                                       func_80065AB0(player, playerId, var_s2, screenId);
      .                                   }
      .                               } else {
      .                                   func_80065AB0(player, playerId, var_s2, screenId);
      .                               }
-- line 6648 ----------------------------------------
-- line 6675 ----------------------------------------
      .                                   }
      .                               } else if (screenId == playerId) {
      .                                   func_8006A01C(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
      .                       }
      .                   }
      .               }
 10,624 ( 0.00%)      if ((gModeSelection == BATTLE) && (player->unk_002 & (2 << (screenId * 4)))) {
      .                   func_8006BA94(player, playerId, screenId);
      .               }
  7,968 ( 0.00%)  }
      .           
 23,904 ( 0.00%)  void func_8006DC54(Player* player, s8 arg1, s8 arg2) {
      .               s16 i;
      .               s32 bitwiseMask;
      .           
 13,280 ( 0.00%)      bitwiseMask = 8 << (arg2 * 4);
 15,936 ( 0.00%)      if (bitwiseMask == (player->unk_002 & bitwiseMask)) {
 49,518 ( 0.00%)          for (i = 0; i < 10; i++) {
110,040 ( 0.00%)              if (player->unk_258[i].unk_012 == 7) {
      .                           func_800658A0(player, arg1, i, arg2);
      .                       }
      .                   }
      .               }
  7,968 ( 0.00%)  }
      .           
 23,904 ( 0.00%)  void func_8006DD3C(Player* arg0, s8 arg1, s8 arg2) {
      .               s16 temp_s0;
      .               s32 temp_v0;
      .           
 13,280 ( 0.00%)      temp_v0 = 8 << (arg2 * 4);
 15,936 ( 0.00%)      if (temp_v0 == (arg0->unk_002 & temp_v0)) {
 49,518 ( 0.00%)          for (temp_s0 = 0; temp_s0 < 10; ++temp_s0) {
110,040 ( 0.00%)              temp_v0 = arg0->unk_258[temp_s0].unk_012;
 18,340 ( 0.00%)              if (temp_v0 != 3) {
 18,340 ( 0.00%)                  if (temp_v0 == 5) {
      .                               func_8006A280(arg0, arg1, temp_s0, arg2);
      .                           }
      .                       } else if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                           if (arg2 == arg1) {
      .                               func_80066998(arg0, arg1, temp_s0, arg2);
      .                           }
      .                       } else {
      .                           func_80066998(arg0, arg1, temp_s0, arg2);
      .                       }
      .                   }
      .           
  6,162 ( 0.00%)          if (((arg0->type & 0x4000) == 0x4000) && (arg2 == arg1)) {
  2,860 ( 0.00%)              switch (arg0->unk_258[20].unk_012) {
      .                           case 2:
      .                               func_80068310(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                           case 3:
      .                               func_80067964(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                           case 4:
      .                               func_80068724(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
-- line 6732 ----------------------------------------
-- line 6733 ----------------------------------------
      .                               break;
      .                           case 5:
      .                               func_80068AA4(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                           case 6:
      .                               func_80068DA0(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                       }
    880 ( 0.00%)              if (arg0->unk_258[21].unk_012 == 5) {
      .                           func_80067D3C(arg0, arg2, D_8018D480, 1, 1.6f, 0xFFFFFF);
      .                           func_8006801C(arg0, arg2, D_8018D484, 1, 1.6f, 0xFF);
      .                       }
      .                   }
      .               }
  7,968 ( 0.00%)  }
      .           
    664 ( 0.00%)  void func_8006E058(void) {
  2,656 ( 0.00%)      switch (gActiveScreenMode) {
      .                   case SCREEN_MODE_1P:
  2,656 ( 0.00%)              switch (gModeSelection) {
      .                           case GRAND_PRIX:
  1,992 ( 0.00%)                      func_8006E420(gPlayerOne, 0, 0);
3,510,499 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerTwo, 1, 0);
3,090,303 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerThree, 2, 0);
3,089,891 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerFour, 3, 0);
3,090,721 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerFive, 4, 0);
3,090,179 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerSix, 5, 0);
3,089,838 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerSeven, 6, 0);
3,090,018 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
  1,992 ( 0.00%)                      func_8006E420(gPlayerEight, 7, 0);
3,091,328 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (332x)
      .           
    332 ( 0.00%)                      break;
      .                           case TIME_TRIALS:
      .                               func_8006E420(gPlayerOne, 0, 0);
      .           
      .                               if ((gPlayerTwo->type & 0x100) == 0x100) {
      .                                   func_8006E420(gPlayerTwo, 1, 0);
      .                               }
      .           
      .                               if ((gPlayerThree->type & 0x100) == 0x100) {
-- line 6771 ----------------------------------------
-- line 6786 ----------------------------------------
      .                               if (gPlayerCountSelection1 == 4) {
      .                                   func_8006E420(gPlayerFour, 3, 0);
      .                                   break;
      .                               }
      .           
      .                               break;
      .                       }
      .           
    996 ( 0.00%)              break;
      .                   case SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL:
      .                   case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
      .                       switch (gModeSelection) {
      .                           case GRAND_PRIX:
      .                               func_8006E420(gPlayerOne, 0, 0);
      .                               func_8006E420(gPlayerTwo, 1, 0);
      .                               func_8006E420(gPlayerThree, 2, 0);
      .                               func_8006E420(gPlayerFour, 3, 0);
-- line 6802 ----------------------------------------
-- line 6832 ----------------------------------------
      .           
      .                           if (gPlayerCountSelection1 == 4) {
      .                               func_8006E420(gPlayerFour, 3, 0);
      .                           }
      .                       }
      .           
      .                       break;
      .               }
    996 ( 0.00%)  }
      .           
 23,904 ( 0.00%)  void func_8006E420(Player* player, s8 arg1, s8 arg2) {
      .               s16 temp_s0;
      .           
 10,624 ( 0.00%)      if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
 15,936 ( 0.00%)          if ((player->type & PLAYER_HUMAN) == PLAYER_HUMAN) {
  1,992 ( 0.00%)              func_8006D194(player, arg1, arg2);
 18,592 ( 0.00%)  => src/code_80057C60.c:func_8006D194 (332x)
      .                   }
      .           
143,424 ( 0.00%)          for (temp_s0 = 0; temp_s0 < 10; ++temp_s0) {
159,360 ( 0.00%)              func_8006CEC0(player, temp_s0, arg1, arg2);
18,217,591 ( 0.02%)  => src/code_80057C60.c:func_8006CEC0 (26,560x)
252,320 ( 0.00%)              if (((player->type & PLAYER_HUMAN) == PLAYER_HUMAN) || (gGamestate == ENDING)) {
 19,920 ( 0.00%)                  func_8006C9B8(player, temp_s0, arg1, arg2);
358,892 ( 0.00%)  => src/code_80057C60.c:func_8006C9B8 (3,320x)
      .                       }
159,360 ( 0.00%)              func_8006C6AC(player, temp_s0, arg1, arg2);
5,742,270 ( 0.00%)  => src/code_80057C60.c:func_8006C6AC (26,560x)
      .                   }
      .           
 10,624 ( 0.00%)          if (gModeSelection == BATTLE) {
      .                       func_8006B9CC(player, arg1);
      .                   }
      .               }
  7,968 ( 0.00%)  }
      .           
 23,904 ( 0.00%)  void render_kart_particle_on_screen_one(Player* player, s8 playerId, s8 screenId) {
 10,624 ( 0.00%)      if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
 10,624 ( 0.00%)          if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (playerId == screenId) {
      .                           func_8006D474(player, playerId, screenId);
      .                       }
      .                   } else {
 15,936 ( 0.00%)              func_8006D474(player, playerId, screenId);
107,500,601 ( 0.09%)  => src/code_80057C60.c:func_8006D474 (2,656x)
      .                   }
 15,936 ( 0.00%)          func_8006DC54(player, playerId, screenId);
220,646 ( 0.00%)  => src/code_80057C60.c:func_8006DC54 (2,656x)
      .               }
  7,968 ( 0.00%)  }
      .           
      .           void render_kart_particle_on_screen_two(Player* player, s8 arg1, s8 arg2) {
      .               if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
      .                   if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (arg1 == arg2) {
      .                           func_8006D474(player, arg1, arg2);
      .                       }
      .                   } else {
-- line 6883 ----------------------------------------
-- line 6908 ----------------------------------------
      .                       }
      .                   } else {
      .                       func_8006D474(player, arg1, arg2);
      .                   }
      .                   func_8006DC54(player, arg1, arg2);
      .               }
      .           }
      .           
 23,904 ( 0.00%)  void func_8006E7CC(Player* player, s8 arg1, s8 arg2) {
 10,624 ( 0.00%)      if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
 10,624 ( 0.00%)          if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (arg1 == arg2) {
      .                           func_8006DD3C(player, arg1, arg2);
      .                       }
      .                   } else {
 15,936 ( 0.00%)              func_8006DD3C(player, arg1, arg2);
267,228 ( 0.00%)  => src/code_80057C60.c:func_8006DD3C (2,656x)
      .                   }
      .               }
  7,968 ( 0.00%)  }
      .           
      .           void func_8006E848(Player* player, s8 arg1, s8 arg2) {
      .               if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
      .                   if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (arg1 == arg2) {
      .                           func_8006DD3C(player, arg1, arg2);
      .                       }
      .                   } else {
-- line 6934 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                 

-- line 90 ----------------------------------------
        .           
        .                 struct _Vector_impl_data
        .                 {
        .           	pointer _M_start;
        .           	pointer _M_finish;
        .           	pointer _M_end_of_storage;
        .           
        .           	_GLIBCXX20_CONSTEXPR
   11,238 ( 0.00%)  	_Vector_impl_data() _GLIBCXX_NOEXCEPT
   22,505 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
   11,238 ( 0.00%)  	{ }
        .           
        .           #if __cplusplus >= 201103L
        .           	_GLIBCXX20_CONSTEXPR
        .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
        .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
        .           	  _M_end_of_storage(__x._M_end_of_storage)
        .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
        .           #endif
-- line 108 ----------------------------------------
-- line 124 ----------------------------------------
        .           	  // information used by TBAA.
        .           	  _Vector_impl_data __tmp;
        .           	  __tmp._M_copy_data(*this);
        .           	  _M_copy_data(__x);
        .           	  __x._M_copy_data(__tmp);
        .           	}
        .                 };
        .           
   55,168 ( 0.00%)        struct _Vector_impl
        .           	: public _Tp_alloc_type, public _Vector_impl_data
        .                 {
        .           	_GLIBCXX20_CONSTEXPR
   14,088 ( 0.00%)  	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
        .           	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
        .           #if __cpp_lib_concepts
        .           	requires is_default_constructible_v<_Tp_alloc_type>
        .           #endif
    5,283 ( 0.00%)  	: _Tp_alloc_type()
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<Cup*, std::allocator<Cup*> >::_Vector_impl_data::_Vector_impl_data() (1x)
    5,283 ( 0.00%)  	{ }
        .           
        .           	_GLIBCXX20_CONSTEXPR
   25,805 ( 0.00%)  	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
    5,955 ( 0.00%)  	: _Tp_alloc_type(__a)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Vector_impl_data::_Vector_impl_data() (1x)
    5,955 ( 0.00%)  	{ }
        .           
        .           #if __cplusplus >= 201103L
        .           	// Not defaulted, to enforce noexcept(true) even when
        .           	// !is_nothrow_move_constructible<_Tp_alloc_type>.
        .           	_GLIBCXX20_CONSTEXPR
        .           	_Vector_impl(_Vector_impl&& __x) noexcept
        .           	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
        .           	{ }
-- line 155 ----------------------------------------
-- line 292 ----------------------------------------
        .           #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
        .                 };
        .           
        .               public:
        .                 typedef _Alloc allocator_type;
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Tp_alloc_type&
   67,251 ( 0.00%)        _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
   67,251 ( 0.00%)        { return this->_M_impl; }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 const _Tp_alloc_type&
   72,366 ( 0.00%)        _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
   72,366 ( 0.00%)        { return this->_M_impl; }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 allocator_type
        .                 get_allocator() const _GLIBCXX_NOEXCEPT
        .                 { return allocator_type(_M_get_Tp_allocator()); }
        .           
        .           #if __cplusplus >= 201103L
   17,610 ( 0.00%)        _Vector_base() = default;
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<std::unique_ptr<AActor, std::default_delete<AActor> >, std::allocator<std::unique_ptr<AActor, std::default_delete<AActor> > > >::_Vector_impl::_Vector_impl() (1x)
        .           #else
        .                 _Vector_base() { }
        .           #endif
        .           
        .                 _GLIBCXX20_CONSTEXPR
    6,595 ( 0.00%)        _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
   10,552 ( 0.00%)        : _M_impl(__a) { }
   43,098 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_Vector_impl::_Vector_impl(std::allocator<char> const&) (1,306x)
        .           
        .                 // Kept for ABI compatibility.
        .           #if !_GLIBCXX_INLINE_VERSION
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Vector_base(size_t __n)
        .                 : _M_impl()
        .                 { _M_create_storage(__n); }
        .           #endif
        .           
        .                 _GLIBCXX20_CONSTEXPR
    4,662 ( 0.00%)        _Vector_base(size_t __n, const allocator_type& __a)
    3,330 ( 0.00%)        : _M_impl(__a)
   21,681 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_Vector_impl::_Vector_impl(std::allocator<char> const&) (657x)
    5,994 ( 0.00%)        { _M_create_storage(__n); }
  191,636 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_M_create_storage(unsigned long) (657x)
        .           
        .           #if __cplusplus >= 201103L
        .                 _Vector_base(_Vector_base&&) = default;
        .           
        .                 // Kept for ABI compatibility.
        .           # if !_GLIBCXX_INLINE_VERSION
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Vector_base(_Tp_alloc_type&& __a) noexcept
-- line 342 ----------------------------------------
-- line 358 ----------------------------------------
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
        .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
        .                 { }
        .           #endif
        .           
        .                 _GLIBCXX20_CONSTEXPR
   27,584 ( 0.00%)        ~_Vector_base() _GLIBCXX_NOEXCEPT
        .                 {
   45,001 ( 0.00%)  	_M_deallocate(_M_impl._M_start,
      142 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::_M_deallocate(std::shared_ptr<spdlog::sinks::sink>*, unsigned long) (1x)
   41,745 ( 0.00%)  		      _M_impl._M_end_of_storage - _M_impl._M_start);
   41,376 ( 0.00%)        }
        9 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::_Vector_impl::~_Vector_impl() (1x)
        .           
        .               public:
        .                 _Vector_impl _M_impl;
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 pointer
   68,880 ( 0.00%)        _M_allocate(size_t __n)
        .                 {
        .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
  137,699 ( 0.00%)  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   27,552 ( 0.00%)        }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
   42,684 ( 0.00%)        _M_deallocate(pointer __p, size_t __n)
        .                 {
        .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
   14,244 ( 0.00%)  	if (__p)
   57,840 ( 0.00%)  	  _Tr::deallocate(_M_impl, __p, __n);
   21,342 ( 0.00%)        }
        .           
        .               protected:
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
    3,330 ( 0.00%)        _M_create_storage(size_t __n)
        .                 {
    4,663 ( 0.00%)  	this->_M_impl._M_start = this->_M_allocate(__n);
       10 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<int, std::allocator<int> >::_M_allocate(unsigned long) (1x)
    2,664 ( 0.00%)  	this->_M_impl._M_finish = this->_M_impl._M_start;
    4,008 ( 0.00%)  	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
    1,998 ( 0.00%)        }
        .               };
        .           
        .             /**
        .              *  @brief A standard container which offers fixed time access to
        .              *  individual elements in any order.
        .              *
        .              *  @ingroup sequences
        .              *  @headerfile vector
-- line 409 ----------------------------------------
-- line 496 ----------------------------------------
        .                 }
        .           
        .                 static pointer
        .                 _S_do_relocate(pointer, pointer, pointer __result,
        .           		     _Tp_alloc_type&, false_type) noexcept
        .                 { return __result; }
        .           
        .                 static _GLIBCXX20_CONSTEXPR pointer
   82,474 ( 0.00%)        _S_relocate(pointer __first, pointer __last, pointer __result,
        .           		  _Tp_alloc_type& __alloc) noexcept
        .                 {
        .           #if __cpp_if_constexpr
        .           	// All callers have already checked _S_use_relocate() so just do it.
   70,692 ( 0.00%)  	return std::__relocate_a(__first, __last, __result, __alloc);
      300 ( 0.00%)  => /usr/include/c++/14/bits/stl_uninitialized.h:Framebuffer* std::__relocate_a<Framebuffer*, Framebuffer*, std::allocator<Framebuffer> >(Framebuffer*, Framebuffer*, Framebuffer*, std::allocator<Framebuffer>&) (3x)
        .           #else
        .           	using __do_it = __bool_constant<_S_use_relocate()>;
        .           	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
        .           #endif
   23,564 ( 0.00%)        }
        .           #endif // C++11
        .           
        .               protected:
        .                 using _Base::_M_allocate;
        .                 using _Base::_M_deallocate;
        .                 using _Base::_M_impl;
        .                 using _Base::_M_get_Tp_allocator;
        .           
-- line 522 ----------------------------------------
-- line 523 ----------------------------------------
        .               public:
        .                 // [23.2.4.1] construct/copy/destroy
        .                 // (assign() and get_allocator() are also listed in this section)
        .           
        .                 /**
        .                  *  @brief  Creates a %vector with no elements.
        .                  */
        .           #if __cplusplus >= 201103L
   17,610 ( 0.00%)        vector() = default;
       38 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<GfxExecStack::CodeDisp, std::allocator<GfxExecStack::CodeDisp> >::_Vector_base() (1x)
        .           #else
        .                 vector() { }
        .           #endif
        .           
        .                 /**
        .                  *  @brief  Creates a %vector with no elements.
        .                  *  @param  __a  An allocator object.
        .                  */
-- line 539 ----------------------------------------
-- line 548 ----------------------------------------
        .                  *  @param  __n  The number of elements to initially create.
        .                  *  @param  __a  An allocator.
        .                  *
        .                  *  This constructor fills the %vector with @a __n default
        .                  *  constructed elements.
        .                  */
        .                 explicit
        .                 _GLIBCXX20_CONSTEXPR
    4,599 ( 0.00%)        vector(size_type __n, const allocator_type& __a = allocator_type())
    7,884 ( 0.00%)        : _Base(_S_check_init_len(__n, __a), __a)
  227,114 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_Vector_base(unsigned long, std::allocator<char> const&) (657x)
   34,164 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::_S_check_init_len(unsigned long, std::allocator<char> const&) (657x)
    5,913 ( 0.00%)        { _M_default_initialize(__n); }
1,676,240 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::_M_default_initialize(unsigned long) (657x)
        .           
        .                 /**
        .                  *  @brief  Creates a %vector with copies of an exemplar element.
        .                  *  @param  __n  The number of elements to initially create.
        .                  *  @param  __value  An element to copy.
        .                  *  @param  __a  An allocator.
        .                  *
        .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 566 ----------------------------------------
-- line 593 ----------------------------------------
        .                  *  All the elements of @a __x are copied, but any unused capacity in
        .                  *  @a __x  will not be copied
        .                  *  (i.e. capacity() == size() in the new %vector).
        .                  *
        .                  *  The newly-created %vector uses a copy of the allocator object used
        .                  *  by @a __x (unless the allocator traits dictate a different object).
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
       72 ( 0.00%)        vector(const vector& __x)
        .                 : _Base(__x.size(),
      216 ( 0.00%)  	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
       90 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<int, std::allocator<int> >::_Vector_base(unsigned long, std::allocator<int> const&) (1x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<int, std::allocator<int> >::size() const (1x)
        6 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<int, std::allocator<int> >::_M_get_Tp_allocator() const (1x)
        .                 {
       18 ( 0.00%)  	this->_M_impl._M_finish =
      126 ( 0.00%)  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
      227 ( 0.00%)  => /usr/include/c++/14/bits/stl_uninitialized.h:int* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<int const*, std::vector<int, std::allocator<int> > >, int*, int>(__gnu_cxx::__normal_iterator<int const*, std::vector<int, std::allocator<int> > >, __gnu_cxx::__normal_iterator<int const*, std::vector<int, std::allocator<int> > >, int*, std::allocator<int>&) (1x)
       24 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<int, std::allocator<int> >::end() const (1x)
       23 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<int, std::allocator<int> >::begin() const (1x)
        .           				      this->_M_impl._M_start,
       36 ( 0.00%)  				      _M_get_Tp_allocator());
        6 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<int, std::allocator<int> >::_M_get_Tp_allocator() (1x)
       63 ( 0.00%)        }
        .           
        .           #if __cplusplus >= 201103L
        .                 /**
        .                  *  @brief  %Vector move constructor.
        .                  *
        .                  *  The newly-created %vector contains the exact contents of the
        .                  *  moved instance.
        .                  *  The contents of the moved instance are a valid, but unspecified
-- line 617 ----------------------------------------
-- line 670 ----------------------------------------
        .                  *
        .                  *  Create a %vector consisting of copies of the elements in the
        .                  *  initializer_list @a __l.
        .                  *
        .                  *  This will call the element type's copy constructor N times
        .                  *  (where N is @a __l.size()) and do no memory reallocation.
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
      143 ( 0.00%)        vector(initializer_list<value_type> __l,
        .           	     const allocator_type& __a = allocator_type())
       55 ( 0.00%)        : _Base(__a)
       46 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<spdlog::level::level_enum, std::allocator<spdlog::level::level_enum> >::_Vector_base(std::allocator<spdlog::level::level_enum> const&) (1x)
        .                 {
      143 ( 0.00%)  	_M_range_initialize(__l.begin(), __l.end(),
      460 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:void std::vector<spdlog::level::level_enum, std::allocator<spdlog::level::level_enum> >::_M_range_initialize<spdlog::level::level_enum const*>(spdlog::level::level_enum const*, spdlog::level::level_enum const*, std::forward_iterator_tag) (1x)
       31 ( 0.00%)  => /usr/include/c++/14/initializer_list:std::initializer_list<spdlog::level::level_enum>::end() const (1x)
        7 ( 0.00%)  => /usr/include/c++/14/initializer_list:std::initializer_list<spdlog::level::level_enum>::begin() const (1x)
        .           			    random_access_iterator_tag());
       44 ( 0.00%)        }
        .           #endif
        .           
        .                 /**
        .                  *  @brief  Builds a %vector from a range.
        .                  *  @param  __first  An input iterator.
        .                  *  @param  __last  An input iterator.
        .                  *  @param  __a  An allocator.
        .                  *
-- line 692 ----------------------------------------
-- line 699 ----------------------------------------
        .                  *  no memory reallocation.  But if only input iterators are
        .                  *  used, then this will do at most 2N calls to the copy
        .                  *  constructor, and logN memory reallocations.
        .                  */
        .           #if __cplusplus >= 201103L
        .                 template<typename _InputIterator,
        .           	       typename = std::_RequireInputIter<_InputIterator>>
        .           	_GLIBCXX20_CONSTEXPR
   10,464 ( 0.00%)  	vector(_InputIterator __first, _InputIterator __last,
        .           	       const allocator_type& __a = allocator_type())
    6,540 ( 0.00%)  	: _Base(__a)
       92 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_Vector_base(std::allocator<char> const&) (2x)
        .           	{
    7,848 ( 0.00%)  	  _M_range_initialize(__first, __last,
      908 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:void std::vector<char, std::allocator<char> >::_M_range_initialize<char*>(char*, char*, std::forward_iterator_tag) (2x)
        .           			      std::__iterator_category(__first));
    5,232 ( 0.00%)  	}
        .           #else
        .                 template<typename _InputIterator>
        .           	vector(_InputIterator __first, _InputIterator __last,
        .           	       const allocator_type& __a = allocator_type())
        .           	: _Base(__a)
        .           	{
        .           	  // Check whether it's an integral type.  If so, it's not an iterator.
        .           	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
-- line 721 ----------------------------------------
-- line 725 ----------------------------------------
        .           
        .                 /**
        .                  *  The dtor only erases the elements, and note that if the
        .                  *  elements themselves are pointers, the pointed-to memory is
        .                  *  not touched in any way.  Managing the pointer is the user's
        .                  *  responsibility.
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
   27,584 ( 0.00%)        ~vector() _GLIBCXX_NOEXCEPT
        .                 {
   48,286 ( 0.00%)  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   20,688 ( 0.00%)  		      _M_get_Tp_allocator());
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::_M_get_Tp_allocator() (2x)
        .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
   41,376 ( 0.00%)        }
      348 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::~_Vector_base() (2x)
        .           
        .                 /**
        .                  *  @brief  %Vector assignment operator.
        .                  *  @param  __x  A %vector of identical element and allocator types.
        .                  *
        .                  *  All the elements of @a __x are copied, but any unused capacity in
        .                  *  @a __x will not be copied.
        .                  *
-- line 746 ----------------------------------------
-- line 865 ----------------------------------------
        .                 // iterators
        .                 /**
        .                  *  Returns a read/write iterator that points to the first
        .                  *  element in the %vector.  Iteration is done in ordinary
        .                  *  element order.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 iterator
   83,964 ( 0.00%)        begin() _GLIBCXX_NOEXCEPT
  167,928 ( 0.00%)        { return iterator(this->_M_impl._M_start); }
    7,106 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<Gfx*, std::vector<Gfx, std::allocator<Gfx> > >::__normal_iterator(Gfx* const&) (646x)
        .           
        .                 /**
        .                  *  Returns a read-only (constant) iterator that points to the
        .                  *  first element in the %vector.  Iteration is done in ordinary
        .                  *  element order.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 const_iterator
  783,748 ( 0.00%)        begin() const _GLIBCXX_NOEXCEPT
1,567,496 ( 0.00%)        { return const_iterator(this->_M_impl._M_start); }
   45,628 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> const*, std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::__normal_iterator(nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> const* const&) (4,148x)
        .           
        .                 /**
        .                  *  Returns a read/write iterator that points one past the last
        .                  *  element in the %vector.  Iteration is done in ordinary
        .                  *  element order.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 iterator
  166,268 ( 0.00%)        end() _GLIBCXX_NOEXCEPT
  374,103 ( 0.00%)        { return iterator(this->_M_impl._M_finish); }
  133,562 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::__normal_iterator(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >* const&) (12,142x)
        .           
        .                 /**
        .                  *  Returns a read-only (constant) iterator that points one past
        .                  *  the last element in the %vector.  Iteration is done in
        .                  *  ordinary element order.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 const_iterator
  781,616 ( 0.00%)        end() const _GLIBCXX_NOEXCEPT
1,758,636 ( 0.00%)        { return const_iterator(this->_M_impl._M_finish); }
       22 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::shared_ptr<Ship::Archive> const*, std::vector<std::shared_ptr<Ship::Archive>, std::allocator<std::shared_ptr<Ship::Archive> > > >::__normal_iterator(std::shared_ptr<Ship::Archive> const* const&) (2x)
        .           
        .                 /**
        .                  *  Returns a read/write reverse iterator that points to the
        .                  *  last element in the %vector.  Iteration is done in reverse
        .                  *  element order.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 reverse_iterator
-- line 912 ----------------------------------------
-- line 984 ----------------------------------------
        .                 crend() const noexcept
        .                 { return const_reverse_iterator(begin()); }
        .           #endif
        .           
        .                 // [23.2.4.2] capacity
        .                 /**  Returns the number of elements in the %vector.  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 size_type
  538,134 ( 0.00%)        size() const _GLIBCXX_NOEXCEPT
1,556,317 ( 0.00%)        { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
        .           
        .                 /**  Returns the size() of the largest possible %vector.  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 size_type
   96,452 ( 0.00%)        max_size() const _GLIBCXX_NOEXCEPT
  168,791 ( 0.00%)        { return _S_max_size(_M_get_Tp_allocator()); }
   30,131 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_S_max_size(std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&) (1,039x)
    6,234 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_get_Tp_allocator() const (1,039x)
        .           
        .           #if __cplusplus >= 201103L
        .                 /**
        .                  *  @brief  Resizes the %vector to the specified number of elements.
        .                  *  @param  __new_size  Number of elements the %vector should contain.
        .                  *
        .                  *  This function will %resize the %vector to the specified
        .                  *  number of elements.  If the number is smaller than the
        .                  *  %vector's current size the %vector is truncated, otherwise
        .                  *  default constructed elements are appended.
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
       15 ( 0.00%)        resize(size_type __new_size)
        .                 {
       21 ( 0.00%)  	if (__new_size > size())
       39 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::size() const (3x)
       27 ( 0.00%)  	  _M_default_append(__new_size - size());
    2,816 ( 0.00%)  => /usr/include/c++/14/bits/vector.tcc:std::vector<Framebuffer, std::allocator<Framebuffer> >::_M_default_append(unsigned long) (3x)
       39 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<Framebuffer, std::allocator<Framebuffer> >::size() const (3x)
        .           	else if (__new_size < size())
        .           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
       12 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief  Resizes the %vector to the specified number of elements.
        .                  *  @param  __new_size  Number of elements the %vector should contain.
        .                  *  @param  __x  Data with which new elements should be populated.
        .                  *
        .                  *  This function will %resize the %vector to the specified
        .                  *  number of elements.  If the number is smaller than the
-- line 1027 ----------------------------------------
-- line 1070 ----------------------------------------
        .           #endif
        .           
        .                 /**
        .                  *  Returns the total number of elements that the %vector can
        .                  *  hold before needing to allocate more memory.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 size_type
    2,916 ( 0.00%)        capacity() const _GLIBCXX_NOEXCEPT
        .                 {
    1,944 ( 0.00%)  	return size_type(this->_M_impl._M_end_of_storage
    4,866 ( 0.00%)  			   - this->_M_impl._M_start);
    1,944 ( 0.00%)        }
        .           
        .                 /**
        .                  *  Returns true if the %vector is empty.  (Thus begin() would
        .                  *  equal end().)
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 bool
  773,344 ( 0.00%)        empty() const _GLIBCXX_NOEXCEPT
2,900,040 ( 0.00%)        { return begin() == end(); }
   16,368 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:bool __gnu_cxx::operator==<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>* const*, std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> > >(__gnu_cxx::__normal_iterator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>* const*, std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> > > const&, __gnu_cxx::__normal_iterator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>* const*, std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> > > const&) (528x)
   12,672 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::end() const (528x)
   12,144 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::begin() const (528x)
        .           
        .                 /**
        .                  *  @brief  Attempt to preallocate enough memory for specified number of
        .                  *          elements.
        .                  *  @param  __n  Number of elements required.
        .                  *  @throw  std::length_error  If @a n exceeds @c max_size().
        .                  *
        .                  *  This function attempts to reserve enough memory for the
-- line 1099 ----------------------------------------
-- line 1120 ----------------------------------------
        .                  *
        .                  *  This operator allows for easy, array-style, data access.
        .                  *  Note that data access with this operator is unchecked and
        .                  *  out_of_range lookups are not defined. (For checked lookups
        .                  *  see at().)
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 reference
3,150,988 ( 0.00%)        operator[](size_type __n) _GLIBCXX_NOEXCEPT
        .                 {
    7,884 ( 0.00%)  	__glibcxx_requires_subscript(__n);
5,673,952 ( 0.00%)  	return *(this->_M_impl._M_start + __n);
1,575,494 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief  Subscript access to the data contained in the %vector.
        .                  *  @param __n The index of the element for which data should be
        .                  *  accessed.
        .                  *  @return  Read-only (constant) reference to data.
        .                  *
        .                  *  This operator allows for easy, array-style, data access.
-- line 1140 ----------------------------------------
-- line 1149 ----------------------------------------
        .           	__glibcxx_requires_subscript(__n);
        .           	return *(this->_M_impl._M_start + __n);
        .                 }
        .           
        .               protected:
        .                 /// Safety check used only from at().
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
  468,770 ( 0.00%)        _M_range_check(size_type __n) const
        .                 {
  656,278 ( 0.00%)  	if (__n >= this->size())
1,031,294 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::size() const (93,754x)
        .           	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
        .           				       "(which is %zu) >= this->size() "
        .           				       "(which is %zu)"),
        .           				   __n, this->size());
  281,262 ( 0.00%)        }
        .           
        .               public:
        .                 /**
        .                  *  @brief  Provides access to the data contained in the %vector.
        .                  *  @param __n The index of the element for which data should be
        .                  *  accessed.
        .                  *  @return  Read/write reference to data.
        .                  *  @throw  std::out_of_range  If @a __n is an invalid index.
        .                  *
        .                  *  This function provides for safer data access.  The parameter
        .                  *  is first checked that it is in the range of the vector.  The
        .                  *  function throws out_of_range if the check fails.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 reference
  468,770 ( 0.00%)        at(size_type __n)
        .                 {
  468,770 ( 0.00%)  	_M_range_check(__n);
2,437,604 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::_M_range_check(unsigned long) const (93,754x)
  468,770 ( 0.00%)  	return (*this)[__n];
  937,540 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::operator[](unsigned long) (93,754x)
  187,508 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief  Provides access to the data contained in the %vector.
        .                  *  @param __n The index of the element for which data should be
        .                  *  accessed.
        .                  *  @return  Read-only (constant) reference to data.
        .                  *  @throw  std::out_of_range  If @a __n is an invalid index.
        .                  *
-- line 1192 ----------------------------------------
-- line 1215 ----------------------------------------
        .                 }
        .           
        .                 /**
        .                  *  Returns a read-only (constant) reference to the data at the first
        .                  *  element of the %vector.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 const_reference
    2,132 ( 0.00%)        front() const _GLIBCXX_NOEXCEPT
        .                 {
        .           	__glibcxx_requires_nonempty();
    3,731 ( 0.00%)  	return *begin();
   12,259 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<BS::thread_pool::pr_task, std::allocator<BS::thread_pool::pr_task> >::begin() const (533x)
    3,731 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<BS::thread_pool::pr_task const*, std::vector<BS::thread_pool::pr_task, std::allocator<BS::thread_pool::pr_task> > >::operator*() const (533x)
    1,066 ( 0.00%)        }
        .           
        .                 /**
        .                  *  Returns a read/write reference to the data at the last
        .                  *  element of the %vector.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 reference
   87,516 ( 0.00%)        back() _GLIBCXX_NOEXCEPT
        .                 {
        .           	__glibcxx_requires_nonempty();
  262,548 ( 0.00%)  	return *(end() - 1);
       62 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >::operator-(long) const (2x)
       48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::end() (2x)
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >::operator*() const (2x)
   43,758 ( 0.00%)        }
        .           
        .                 /**
        .                  *  Returns a read-only (constant) reference to the data at the
        .                  *  last element of the %vector.
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 const_reference
        .                 back() const _GLIBCXX_NOEXCEPT
-- line 1247 ----------------------------------------
-- line 1254 ----------------------------------------
        .                 // DR 464. Suggestion for new member functions in standard containers.
        .                 // data access
        .                 /**
        .                  *   Returns a pointer such that [data(), data() + size()) is a valid
        .                  *   range.  For a non-empty %vector, data() == &front().
        .                  */
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 _Tp*
  161,852 ( 0.00%)        data() _GLIBCXX_NOEXCEPT
  323,704 ( 0.00%)        { return _M_data_ptr(this->_M_impl._M_start); }
   49,336 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:Vtx* std::vector<Vtx, std::allocator<Vtx> >::_M_data_ptr<Vtx>(Vtx*) const (7,048x)
        .           
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 const _Tp*
        .                 data() const _GLIBCXX_NOEXCEPT
        .                 { return _M_data_ptr(this->_M_impl._M_start); }
        .           
        .                 // [23.2.4.3] modifiers
        .                 /**
-- line 1271 ----------------------------------------
-- line 1275 ----------------------------------------
        .                  *  This is a typical stack operation.  The function creates an
        .                  *  element at the end of the %vector and assigns the given data
        .                  *  to it.  Due to the nature of a %vector this operation can be
        .                  *  done in constant time if the %vector has preallocated space
        .                  *  available.
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
1,180,730 ( 0.00%)        push_back(const value_type& __x)
        .                 {
1,416,876 ( 0.00%)  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
        .           	  {
        .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
1,578,262 ( 0.00%)  	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
        .           				     __x);
1,127,330 ( 0.00%)  	    ++this->_M_impl._M_finish;
        .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
        .           	  }
        .           	else
   53,400 ( 0.00%)  	  _M_realloc_append(__x);
      752 ( 0.00%)  => /usr/include/c++/14/bits/vector.tcc:void std::vector<std::shared_ptr<TrainCrossing>, std::allocator<std::shared_ptr<TrainCrossing> > >::_M_realloc_append<std::shared_ptr<TrainCrossing> const&>(std::shared_ptr<TrainCrossing> const&) (1x)
  933,904 ( 0.00%)        }
        .           
        .           #if __cplusplus >= 201103L
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
   82,445 ( 0.00%)        push_back(value_type&& __x)
  181,623 ( 0.00%)        { emplace_back(std::move(__x)); }
    2,280 ( 0.00%)  => /usr/include/c++/14/bits/vector.tcc:std::unique_ptr<AVehicle, std::default_delete<AVehicle> >& std::vector<std::unique_ptr<AVehicle, std::default_delete<AVehicle> >, std::allocator<std::unique_ptr<AVehicle, std::default_delete<AVehicle> > > >::emplace_back<std::unique_ptr<AVehicle, std::default_delete<AVehicle> > >(std::unique_ptr<AVehicle, std::default_delete<AVehicle> >&&) (2x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::unique_ptr<AVehicle, std::default_delete<AVehicle> >&>::type&& std::move<std::unique_ptr<AVehicle, std::default_delete<AVehicle> >&>(std::unique_ptr<AVehicle, std::default_delete<AVehicle> >&) (2x)
        .           
        .                 template<typename... _Args>
        .           #if __cplusplus > 201402L
        .           	_GLIBCXX20_CONSTEXPR
        .           	reference
        .           #else
        .           	void
        .           #endif
-- line 1309 ----------------------------------------
-- line 1316 ----------------------------------------
        .                  *  This is a typical stack operation. It shrinks the %vector by one.
        .                  *
        .                  *  Note that no data is returned, and if the last element's
        .                  *  data is needed, it should be retrieved before pop_back() is
        .                  *  called.
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
  762,784 ( 0.00%)        pop_back() _GLIBCXX_NOEXCEPT
        .                 {
        .           	__glibcxx_requires_nonempty();
  953,480 ( 0.00%)  	--this->_M_impl._M_finish;
  953,480 ( 0.00%)  	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
        .           	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
  572,088 ( 0.00%)        }
        .           
        .           #if __cplusplus >= 201103L
        .                 /**
        .                  *  @brief  Inserts an object in %vector before specified iterator.
        .                  *  @param  __position  A const_iterator into the %vector.
        .                  *  @param  __args  Arguments.
        .                  *  @return  An iterator that points to the inserted data.
        .                  *
-- line 1338 ----------------------------------------
-- line 1599 ----------------------------------------
        .                 /**
        .                  *  Erases all the elements.  Note that this function only erases the
        .                  *  elements, and that if the elements themselves are pointers, the
        .                  *  pointed-to memory is not touched in any way.  Managing the pointer is
        .                  *  the user's responsibility.
        .                  */
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
    4,880 ( 0.00%)        clear() _GLIBCXX_NOEXCEPT
   10,984 ( 0.00%)        { _M_erase_at_end(this->_M_impl._M_start); }
   24,720 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::_M_erase_at_end(char*) (412x)
        .           
        .               protected:
        .                 /**
        .                  *  Memory expansion handler.  Uses the member allocation function to
        .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
        .                  */
        .                 template<typename _ForwardIterator>
        .           	_GLIBCXX20_CONSTEXPR
        .           	pointer
       72 ( 0.00%)  	_M_allocate_and_copy(size_type __n,
        .           			     _ForwardIterator __first, _ForwardIterator __last)
        .           	{
       54 ( 0.00%)  	  pointer __result = this->_M_allocate(__n);
    1,108 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<Ship::CommandArgument, std::allocator<Ship::CommandArgument> >::_M_allocate(unsigned long) (4x)
        .           	  __try
        .           	    {
       45 ( 0.00%)  	      std::__uninitialized_copy_a(__first, __last, __result,
    3,963 ( 0.00%)  => /usr/include/c++/14/bits/stl_uninitialized.h:Ship::CommandArgument* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<Ship::CommandArgument const*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >, Ship::CommandArgument*, Ship::CommandArgument>(__gnu_cxx::__normal_iterator<Ship::CommandArgument const*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >, __gnu_cxx::__normal_iterator<Ship::CommandArgument const*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >, Ship::CommandArgument*, std::allocator<Ship::CommandArgument>&) (4x)
       36 ( 0.00%)  					  _M_get_Tp_allocator());
       24 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<Ship::CommandArgument, std::allocator<Ship::CommandArgument> >::_M_get_Tp_allocator() (4x)
       18 ( 0.00%)  	      return __result;
        .           	    }
        .           	  __catch(...)
        .           	    {
        .           	      _M_deallocate(__result, __n);
        .           	      __throw_exception_again;
        .           	    }
       27 ( 0.00%)  	}
        .           
        .           
        .                 // Internal constructor functions follow.
        .           
        .                 // Called by the range constructor to implement [23.1.1]/9
        .           
        .           #if __cplusplus < 201103L
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1641 ----------------------------------------
-- line 1681 ----------------------------------------
        .           	    __throw_exception_again;
        .           	  }
        .           	}
        .           
        .                 // Called by the second initialize_dispatch above
        .                 template<typename _ForwardIterator>
        .           	_GLIBCXX20_CONSTEXPR
        .           	void
   14,509 ( 0.00%)  	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
        .           			    std::forward_iterator_tag)
        .           	{
    1,319 ( 0.00%)  	  const size_type __n = std::distance(__first, __last);
        .           	  this->_M_impl._M_start
   18,467 ( 0.00%)  	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
  336,997 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_M_allocate(unsigned long) (1,304x)
   67,808 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<char, std::allocator<char> >::_S_check_init_len(unsigned long, std::allocator<char> const&) (1,304x)
    7,824 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_M_get_Tp_allocator() (1,304x)
    7,941 ( 0.00%)  	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
    2,639 ( 0.00%)  	  this->_M_impl._M_finish =
    7,914 ( 0.00%)  	    std::__uninitialized_copy_a(__first, __last,
  702,483 ( 0.00%)  => /usr/include/c++/14/bits/stl_uninitialized.h:char* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<char*, std::vector<char, std::allocator<char> > >, char*, char>(__gnu_cxx::__normal_iterator<char*, std::vector<char, std::allocator<char> > >, __gnu_cxx::__normal_iterator<char*, std::vector<char, std::allocator<char> > >, char*, std::allocator<char>&) (1,304x)
        .           					this->_M_impl._M_start,
    5,276 ( 0.00%)  					_M_get_Tp_allocator());
    7,824 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_M_get_Tp_allocator() (1,304x)
    5,276 ( 0.00%)  	}
        .           
        .                 // Called by the first initialize_dispatch above and by the
        .                 // vector(n,value,a) constructor.
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
        .                 _M_fill_initialize(size_type __n, const value_type& __value)
        .                 {
        .           	this->_M_impl._M_finish =
-- line 1708 ----------------------------------------
-- line 1709 ----------------------------------------
        .           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
        .           					_M_get_Tp_allocator());
        .                 }
        .           
        .           #if __cplusplus >= 201103L
        .                 // Called by the vector(n) constructor.
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
    3,285 ( 0.00%)        _M_default_initialize(size_type __n)
        .                 {
    1,315 ( 0.00%)  	this->_M_impl._M_finish =
    3,942 ( 0.00%)  	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
1,659,158 ( 0.00%)  => /usr/include/c++/14/bits/stl_uninitialized.h:char* std::__uninitialized_default_n_a<char*, unsigned long, char>(char*, unsigned long, std::allocator<char>&) (657x)
    2,628 ( 0.00%)  					   _M_get_Tp_allocator());
    3,942 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_M_get_Tp_allocator() (657x)
    1,971 ( 0.00%)        }
        .           #endif
        .           
        .                 // Internal assign functions follow.  The *_aux functions do the actual
        .                 // assignment work for the range versions.
        .           
        .                 // Called by the range assign to implement [23.1.1]/9
        .           
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1730 ----------------------------------------
-- line 1898 ----------------------------------------
        .                 iterator
        .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
        .                 { return _M_insert_rval(__position, std::move(__v)); }
        .           #endif
        .           
        .                 // Called by _M_fill_insert, _M_insert_aux etc.
        .                 _GLIBCXX20_CONSTEXPR
        .                 size_type
   81,011 ( 0.00%)        _M_check_len(size_type __n, const char* __s) const
        .                 {
  162,089 ( 0.00%)  	if (max_size() - size() < __n)
      368 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::max_size() const (8x)
       96 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::size() const (8x)
        .           	  __throw_length_error(__N(__s));
        .           
  185,168 ( 0.00%)  	const size_type __len = size() + (std::max)(size(), __n);
      192 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::size() const (16x)
      106 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&) (8x)
  127,354 ( 0.00%)  	return (__len < size() || __len > max_size()) ? max_size() : __len;
      368 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::max_size() const (8x)
       96 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*, std::allocator<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>*> >::size() const (8x)
   34,719 ( 0.00%)        }
        .           
        .                 // Called by constructors to check initial size.
        .                 static _GLIBCXX20_CONSTEXPR size_type
   21,736 ( 0.00%)        _S_check_init_len(size_type __n, const allocator_type& __a)
        .                 {
   13,835 ( 0.00%)  	if (__n > _S_max_size(_Tp_alloc_type(__a)))
       29 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<ImVec4, std::allocator<ImVec4> >::_S_max_size(std::allocator<ImVec4> const&) (1x)
        .           	  __throw_length_error(
        .           	      __N("cannot create std::vector larger than max_size()"));
    1,976 ( 0.00%)  	return __n;
    3,952 ( 0.00%)        }
        .           
        .                 static _GLIBCXX20_CONSTEXPR size_type
  104,356 ( 0.00%)        _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
        .                 {
        .           	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
        .           	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
        .           	// (even if std::allocator_traits::max_size says we can).
   52,178 ( 0.00%)  	const size_t __diffmax
        .           	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
   50,187 ( 0.00%)  	const size_t __allocmax = _Alloc_traits::max_size(__a);
  156,534 ( 0.00%)  	return (std::min)(__diffmax, __allocmax);
       52 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (4x)
   52,178 ( 0.00%)        }
        .           
        .                 // Internal erase functions follow.
        .           
        .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
        .                 // _M_assign_aux.
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
    6,100 ( 0.00%)        _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
        .                 {
    8,134 ( 0.00%)  	if (size_type __n = this->_M_impl._M_finish - __pos)
        .           	  {
    2,472 ( 0.00%)  	    std::_Destroy(__pos, this->_M_impl._M_finish,
    1,236 ( 0.00%)  			  _M_get_Tp_allocator());
    2,472 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::_Vector_base<char, std::allocator<char> >::_M_get_Tp_allocator() (412x)
    1,236 ( 0.00%)  	    this->_M_impl._M_finish = __pos;
        .           	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
        .           	  }
    3,660 ( 0.00%)        }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 iterator
        .                 _M_erase(iterator __position);
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 iterator
        .                 _M_erase(iterator __first, iterator __last);
-- line 1960 ----------------------------------------
-- line 1992 ----------------------------------------
        .           	    __x.clear();
        .           	  }
        .                 }
        .           #endif
        .           
        .                 template<typename _Up>
        .           	_GLIBCXX20_CONSTEXPR
        .           	_Up*
  161,852 ( 0.00%)  	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
  121,389 ( 0.00%)  	{ return __ptr; }
        .           
        .           #if __cplusplus >= 201103L
        .                 template<typename _Ptr>
        .           	_GLIBCXX20_CONSTEXPR
        .           	typename std::pointer_traits<_Ptr>::element_type*
        .           	_M_data_ptr(_Ptr __ptr) const
        .           	{ return empty() ? nullptr : std::__to_address(__ptr); }
        .           #else
-- line 2009 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/unordered_map.h
--------------------------------------------------------------------------------
Ir                   

-- line 101 ----------------------------------------
          .              *
          .              *  Base is _Hashtable, dispatched at compile time via template
          .              *  alias __umap_hashtable.
          .              */
          .             template<typename _Key, typename _Tp,
          .           	   typename _Hash = hash<_Key>,
          .           	   typename _Pred = equal_to<_Key>,
          .           	   typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    297,527 ( 0.00%)      class unordered_map
        556 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::~_Hashtable() (4x)
          .               {
          .                 typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;
          .                 _Hashtable _M_h;
          .           
          .               public:
          .                 // typedefs:
          .                 ///@{
          .                 /// Public typedefs.
-- line 117 ----------------------------------------
-- line 140 ----------------------------------------
          .           #if __cplusplus > 201402L
          .                 using node_type = typename _Hashtable::node_type;
          .                 using insert_return_type = typename _Hashtable::insert_return_type;
          .           #endif
          .           
          .                 //construct/destroy/copy
          .           
          .                 /// Default constructor.
      5,300 ( 0.00%)        unordered_map() = default;
        110 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<int, std::pair<int const, bool>, std::allocator<std::pair<int const, bool> >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable() (1x)
          .           
          .                 /**
          .                  *  @brief  Default constructor creates no elements.
          .                  *  @param __n  Minimal initial number of buckets.
          .                  *  @param __hf  A hash functor.
          .                  *  @param __eql  A key equality functor.
          .                  *  @param __a  An allocator object.
          .                  */
-- line 156 ----------------------------------------
-- line 180 ----------------------------------------
          .           		      size_type __n = 0,
          .           		      const hasher& __hf = hasher(),
          .           		      const key_equal& __eql = key_equal(),
          .           		      const allocator_type& __a = allocator_type())
          .           	: _M_h(__first, __last, __n, __hf, __eql, __a)
          .           	{ }
          .           
          .                 /// Copy constructor.
    381,433 ( 0.00%)        unordered_map(const unordered_map&) = default;
  8,432,704 ( 0.01%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_Hashtable(std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> > const&) (17,864x)
          .           
          .                 /// Move constructor.
          .                 unordered_map(unordered_map&&) = default;
          .           
          .                 /**
          .                  *  @brief Creates an %unordered_map with no elements.
          .                  *  @param __a An allocator object.
          .                  */
-- line 196 ----------------------------------------
-- line 226 ----------------------------------------
          .                  *  @param __n  Minimal initial number of buckets.
          .                  *  @param __hf  A hash functor.
          .                  *  @param __eql  A key equality functor.
          .                  *  @param  __a  An allocator object.
          .                  *
          .                  *  Create an %unordered_map consisting of copies of the elements in the
          .                  *  list. This is linear in N (where N is @a __l.size()).
          .                  */
         70 ( 0.00%)        unordered_map(initializer_list<value_type> __l,
          .           		    size_type __n = 0,
          .           		    const hasher& __hf = hasher(),
          .           		    const key_equal& __eql = key_equal(),
          .           		    const allocator_type& __a = allocator_type())
         65 ( 0.00%)        : _M_h(__l, __n, __hf, __eql, __a)
      7,529 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable(std::initializer_list<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, unsigned long, std::hash<Ship::Direction> const&, std::equal_to<Ship::Direction> const&, std::allocator<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&) (1x)
         15 ( 0.00%)        { }
          .           
          .                 unordered_map(size_type __n, const allocator_type& __a)
          .                 : unordered_map(__n, hasher(), key_equal(), __a)
          .                 { }
          .           
          .                 unordered_map(size_type __n, const hasher& __hf,
          .           		    const allocator_type& __a)
          .                 : unordered_map(__n, __hf, key_equal(), __a)
-- line 248 ----------------------------------------
-- line 304 ----------------------------------------
          .                 allocator_type
          .                 get_allocator() const noexcept
          .                 { return _M_h.get_allocator(); }
          .           
          .                 // size and capacity:
          .           
          .                 ///  Returns true if the %unordered_map is empty.
          .                 _GLIBCXX_NODISCARD bool
     30,632 ( 0.00%)        empty() const noexcept
     38,290 ( 0.00%)        { return _M_h.empty(); }
         18 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::empty() const (1x)
          .           
          .                 ///  Returns the size of the %unordered_map.
          .                 size_type
     59,632 ( 0.00%)        size() const noexcept
     74,540 ( 0.00%)        { return _M_h.size(); }
      2,800 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::size() const (400x)
          .           
          .                 ///  Returns the maximum size of the %unordered_map.
          .                 size_type
          .                 max_size() const noexcept
          .                 { return _M_h.max_size(); }
          .           
          .                 // iterators.
          .           
          .                 /**
          .                  *  Returns a read/write iterator that points to the first element in the
          .                  *  %unordered_map.
          .                  */
          .                 iterator
    232,352 ( 0.00%)        begin() noexcept
    290,440 ( 0.00%)        { return _M_h.begin(); }
  1,819,440 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::begin() (40,432x)
          .           
          .                 ///@{
          .                 /**
          .                  *  Returns a read-only (constant) iterator that points to the first
          .                  *  element in the %unordered_map.
          .                  */
          .                 const_iterator
          .                 begin() const noexcept
-- line 341 ----------------------------------------
-- line 346 ----------------------------------------
          .                 { return _M_h.begin(); }
          .                 ///@}
          .           
          .                 /**
          .                  *  Returns a read/write iterator that points one past the last element in
          .                  *  the %unordered_map.
          .                  */
          .                 iterator
  1,091,884 ( 0.00%)        end() noexcept
  1,364,855 ( 0.00%)        { return _M_h.end(); }
        102 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::end() (3x)
          .           
          .                 ///@{
          .                 /**
          .                  *  Returns a read-only (constant) iterator that points one past the last
          .                  *  element in the %unordered_map.
          .                  */
          .                 const_iterator
    747,860 ( 0.00%)        end() const noexcept
    934,825 ( 0.00%)        { return _M_h.end(); }
  4,553,994 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::end() const (133,941x)
          .           
          .                 const_iterator
          .                 cend() const noexcept
          .                 { return _M_h.end(); }
          .                 ///@}
          .           
          .                 // modifiers.
          .           
-- line 372 ----------------------------------------
-- line 563 ----------------------------------------
          .                 // 2354. Unnecessary copying when inserting into maps with braced-init
          .                 std::pair<iterator, bool>
          .                 insert(value_type&& __x)
          .                 { return _M_h.insert(std::move(__x)); }
          .           
          .                 template<typename _Pair>
          .           	__enable_if_t<is_constructible<value_type, _Pair&&>::value,
          .           		      pair<iterator, bool>>
      2,400 ( 0.00%)  	insert(_Pair&& __x)
      4,000 ( 0.00%)          { return _M_h.emplace(std::forward<_Pair>(__x)); }
    580,118 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::pair<std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>, bool> std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::emplace<std::pair<TextureCacheKey, TextureCacheValue> >(std::pair<TextureCacheKey, TextureCacheValue>&&) (400x)
      2,400 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<TextureCacheKey, TextureCacheValue>&& std::forward<std::pair<TextureCacheKey, TextureCacheValue> >(std::remove_reference<std::pair<TextureCacheKey, TextureCacheValue> >::type&) (400x)
          .                 ///@}
          .           
          .                 ///@{
          .                 /**
          .                  *  @brief Attempts to insert a std::pair into the %unordered_map.
          .                  *  @param  __hint  An iterator that serves as a hint as to where the
          .                  *                 pair should be inserted.
          .                  *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
-- line 580 ----------------------------------------
-- line 762 ----------------------------------------
          .                  *  This function erases all the elements located by the given key from
          .                  *  an %unordered_map. For an %unordered_map the result of this function
          .                  *  can only be 0 (not present) or 1 (present).
          .                  *  Note that this function only erases the element, and that if the
          .                  *  element is itself a pointer, the pointed-to memory is not touched in
          .                  *  any way.  Managing the pointer is the user's responsibility.
          .                  */
          .                 size_type
         70 ( 0.00%)        erase(const key_type& __x)
         99 ( 0.00%)        { return _M_h.erase(__x); }
      6,699 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (14x)
          .           
          .                 /**
          .                  *  @brief Erases a [__first,__last) range of elements from an
          .                  *  %unordered_map.
          .                  *  @param  __first  Iterator pointing to the start of the range to be
          .                  *                  erased.
          .                  *  @param __last  Iterator pointing to the end of the range to
          .                  *                be erased.
-- line 779 ----------------------------------------
-- line 790 ----------------------------------------
          .           
          .                 /**
          .                  *  Erases all elements in an %unordered_map.
          .                  *  Note that this function only erases the elements, and that if the
          .                  *  elements themselves are pointers, the pointed-to memory is not touched
          .                  *  in any way.  Managing the pointer is the user's responsibility.
          .                  */
          .                 void
      1,692 ( 0.00%)        clear() noexcept
      2,538 ( 0.00%)        { _M_h.clear(); }
         60 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerLEDMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::clear() (1x)
          .           
          .                 /**
          .                  *  @brief  Swaps data with another %unordered_map.
          .                  *  @param  __x  An %unordered_map of the same element and allocator
          .                  *  types.
          .                  *
          .                  *  This exchanges the elements between two %unordered_map in constant
          .                  *  time.
-- line 807 ----------------------------------------
-- line 868 ----------------------------------------
          .                  *           found.
          .                  *
          .                  *  This function takes a key and tries to locate the element with which
          .                  *  the key matches.  If successful the function returns an iterator
          .                  *  pointing to the sought after element.  If unsuccessful it returns the
          .                  *  past-the-end ( @c end() ) iterator.
          .                  */
          .                 iterator
  1,082,495 ( 0.00%)        find(const key_type& __x)
  1,515,507 ( 0.00%)        { return _M_h.find(__x); }
 15,745,033 ( 0.01%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(TextureCacheKey const&) (33,429x)
          .           
          .           #if __cplusplus > 201703L
          .                 template<typename _Kt>
          .           	auto
          .           	find(const _Kt& __x) -> decltype(_M_h._M_find_tr(__x))
          .           	{ return _M_h._M_find_tr(__x); }
          .           #endif
          .           
          .                 const_iterator
    934,825 ( 0.00%)        find(const key_type& __x) const
  1,308,755 ( 0.00%)        { return _M_h.find(__x); }
  4,613,088 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<MtxS*, std::pair<MtxS* const, MtxF>, std::allocator<std::pair<MtxS* const, MtxF> >, std::__detail::_Select1st, std::equal_to<MtxS*>, std::hash<MtxS*>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(MtxS* const&) const (53,024x)
          .           
          .           #if __cplusplus > 201703L
          .                 template<typename _Kt>
          .           	auto
          .           	find(const _Kt& __x) const -> decltype(_M_h._M_find_tr(__x))
          .           	{ return _M_h._M_find_tr(__x); }
          .           #endif
          .                 ///@}
-- line 896 ----------------------------------------
-- line 920 ----------------------------------------
          .           #if __cplusplus > 201703L
          .                 ///@{
          .                 /**
          .                  *  @brief  Finds whether an element with the given key exists.
          .                  *  @param  __x  Key of elements to be located.
          .                  *  @return  True if there is any element with the specified key.
          .                  */
          .                 bool
 28,697,505 ( 0.02%)        contains(const key_type& __x) const
103,311,018 ( 0.09%)        { return _M_h.find(__x) != _M_h.end(); }
2,002,703,694 ( 1.66%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const (5,738,406x)
195,105,804 ( 0.16%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::end() const (5,738,406x)
 68,860,872 ( 0.06%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<Attribute const, std::any>, false> const&, std::__detail::_Node_iterator_base<std::pair<Attribute const, std::any>, false> const&) (5,738,406x)
          .           
          .                 template<typename _Kt>
          .           	auto
          .           	contains(const _Kt& __x) const
          .           	-> decltype(_M_h._M_find_tr(__x), void(), true)
          .           	{ return _M_h._M_find_tr(__x) != _M_h.end(); }
          .                 ///@}
          .           #endif
-- line 937 ----------------------------------------
-- line 979 ----------------------------------------
          .                  *  Allows for easy lookup with the subscript ( @c [] )operator.  Returns
          .                  *  data associated with the key specified in subscript.  If the key does
          .                  *  not exist, a pair with that key is created using default values, which
          .                  *  is then returned.
          .                  *
          .                  *  Lookup requires constant time.
          .                  */
          .                 mapped_type&
    256,280 ( 0.00%)        operator[](const key_type& __k)
    358,798 ( 0.00%)        { return _M_h[__k]; }
      6,560 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Map_base<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Stick>, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::operator[](Ship::Stick const&) (20x)
          .           
          .                 mapped_type&
    102,756 ( 0.00%)        operator[](key_type&& __k)
    171,262 ( 0.00%)        { return _M_h[std::move(__k)]; }
    403,705 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (498x)
      2,988 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&& std::move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (498x)
          .                 ///@}
          .           
          .                 ///@{
          .                 /**
          .                  *  @brief  Access to %unordered_map data.
          .                  *  @param  __k  The key for which data should be retrieved.
          .                  *  @return  A reference to the data whose key is equal to @a __k, if
          .                  *           such a data is present in the %unordered_map.
          .                  *  @throw  std::out_of_range  If no such data is present.
          .                  */
          .                 mapped_type&
          .                 at(const key_type& __k)
          .                 { return _M_h.at(__k); }
          .           
          .                 const mapped_type&
 28,692,030 ( 0.02%)        at(const key_type& __k) const
 40,168,842 ( 0.03%)        { return _M_h.at(__k); }
2,283,885,588 ( 1.89%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Map_base<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::at(Attribute const&) const (5,738,406x)
          .                 ///@}
          .           
          .                 // bucket interface.
          .           
          .                 /// Returns the number of buckets of the %unordered_map.
          .                 size_type
          .                 bucket_count() const noexcept
          .                 { return _M_h.bucket_count(); }
-- line 1017 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/debug/GfxDebugger.cpp
--------------------------------------------------------------------------------
Ir                   

-- line 19 ----------------------------------------
          .           
          .           void GfxDebugger::SetBreakPoint(const std::vector<const F3DGfx*>& bp) {
          .               mBreakPoint = bp;
          .           }
          .           
          .           void GfxDebugger::RequestDebugging() {
          .               mIsDebuggingRequested = true;
          .           }
173,248,251 ( 0.14%)  bool GfxDebugger::IsDebugging() const {
115,498,834 ( 0.10%)      return mIsDebugging;
115,498,834 ( 0.10%)  }
      1,209 ( 0.00%)  bool GfxDebugger::IsDebuggingRequested() const {
        806 ( 0.00%)      return mIsDebuggingRequested;
        806 ( 0.00%)  }
          .           
          .           void GfxDebugger::DebugDisplayList(F3DGfx* cmds) {
          .               mDlist = cmds;
          .               mIsDebuggingRequested = false;
          .               mIsDebugging = true;
          .               mBreakPoint = { cmds };
          .           }
          .           
-- line 40 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/basic_string.tcc
--------------------------------------------------------------------------------
Ir                 

-- line 130 ----------------------------------------
        .                 const size_type __tmp_length = length();
        .                 _M_length(__s.length());
        .                 __s._M_length(__tmp_length);
        .               }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::pointer
3,147,802 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               _M_create(size_type& __capacity, size_type __old_capacity)
        .               {
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 83.  String::npos vs. string::max_size()
4,047,183 ( 0.00%)        if (__capacity > max_size())
8,544,034 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::max_size() const (449,686x)
        .           	std::__throw_length_error(__N("basic_string::_M_create"));
        .           
        .                 // The below implements an exponential growth policy, necessary to
        .                 // meet amortized linear time requirements of the library: see
        .                 // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
4,496,864 ( 0.00%)        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
        .           	{
   87,840 ( 0.00%)  	  __capacity = 2 * __old_capacity;
        .           	  // Never allocate a string bigger than max_size.
  197,640 ( 0.00%)  	  if (__capacity > max_size())
  417,240 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::max_size() const (21,960x)
        .           	    __capacity = max_size();
        .           	}
        .           
        .                 // NB: Need an array of char_type[__capacity], plus a terminating
        .                 // null char_type() element.
4,047,178 ( 0.00%)        return _S_allocate(_M_get_allocator(), __capacity + 1);
55,360,343 ( 0.05%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_allocate(std::allocator<char>&, unsigned long) (449,686x)
2,698,116 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_get_allocator() (449,686x)
1,349,058 ( 0.00%)      }
        .           
        .             // NB: This is the special case for Input Iterators, used in
        .             // istreambuf_iterators, etc.
        .             // Input Iterators have a cost structure very different from
        .             // pointers, calling for a different coding style.
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               template<typename _InIterator>
        .                 _GLIBCXX20_CONSTEXPR
-- line 168 ----------------------------------------
-- line 213 ----------------------------------------
        .           
        .           	_M_set_length(__len);
        .                 }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               template<typename _InIterator>
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
6,144,722 ( 0.01%)        basic_string<_CharT, _Traits, _Alloc>::
        .                 _M_construct(_InIterator __beg, _InIterator __end,
        .           		   std::forward_iterator_tag)
        .                 {
  566,391 ( 0.00%)  	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
        .           
1,699,237 ( 0.00%)  	if (__dnew > size_type(_S_local_capacity))
        .           	  {
4,525,312 ( 0.00%)  	    _M_data(_M_create(__dnew, size_type(0)));
61,936,286 ( 0.05%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_create(unsigned long&, unsigned long) (357,288x)
3,572,880 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (357,288x)
2,778,350 ( 0.00%)  	    _M_capacity(__dnew);
3,572,880 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (357,288x)
        .           	  }
        .           	else
        .           	  _M_init_local_buf();
        .           
        .           	// Check for out_of_range and length_error exceptions.
        .           	struct _Guard
        .           	{
        .           	  _GLIBCXX20_CONSTEXPR
5,663,910 ( 0.00%)  	  explicit _Guard(basic_string* __s) : _M_guarded(__s) { }
        .           
        .           	  _GLIBCXX20_CONSTEXPR
6,230,301 ( 0.01%)  	  ~_Guard() { if (_M_guarded) _M_guarded->_M_dispose(); }
        .           
        .           	  basic_string* _M_guarded;
2,831,955 ( 0.00%)  	} __guard(this);
4,805,240 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)::_Guard::_Guard(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) (480,524x)
        .           
5,097,519 ( 0.00%)  	this->_S_copy_chars(_M_data(), __beg, __end);
32,377,607 ( 0.03%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy_chars(char*, char const*, char const*) (480,524x)
3,363,668 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (480,524x)
        .           
  566,391 ( 0.00%)  	__guard._M_guarded = 0;
        .           
2,831,955 ( 0.00%)  	_M_set_length(__dnew);
26,428,820 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (480,524x)
3,793,195 ( 0.00%)        }
5,285,764 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)::_Guard::~_Guard() (480,524x)
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               void
      108 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               _M_construct(size_type __n, _CharT __c)
        .               {
       36 ( 0.00%)        if (__n > size_type(_S_local_capacity))
        .           	{
      132 ( 0.00%)  	  _M_data(_M_create(__n, size_type(0)));
  102,694 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_create(unsigned long&, unsigned long) (12x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (12x)
       72 ( 0.00%)  	  _M_capacity(__n);
      120 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (12x)
        .           	}
        .                 else
        .           	_M_init_local_buf();
        .           
       36 ( 0.00%)        if (__n)
      108 ( 0.00%)  	this->_S_assign(_M_data(), __n, __c);
    9,162 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_assign(char*, unsigned long, char) (12x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (12x)
        .           
       60 ( 0.00%)        _M_set_length(__n);
      660 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (12x)
       72 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               void
  202,852 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               _M_assign(const basic_string& __str)
        .               {
  236,651 ( 0.00%)        if (this != std::__addressof(__str))
  202,842 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const* std::__addressof<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (33,807x)
        .           	{
  135,228 ( 0.00%)  	  const size_type __rsize = __str.length();
  236,649 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (33,807x)
  135,228 ( 0.00%)  	  const size_type __capacity = capacity();
2,636,942 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::capacity() const (33,807x)
        .           
  101,423 ( 0.00%)  	  if (__rsize > __capacity)
        .           	    {
   67,548 ( 0.00%)  	      size_type __new_capacity = __rsize;
  236,418 ( 0.00%)  	      pointer __tmp = _M_create(__new_capacity, __capacity);
11,699,044 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_create(unsigned long&, unsigned long) (33,774x)
  101,322 ( 0.00%)  	      _M_dispose();
2,634,372 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_dispose() (33,774x)
  168,870 ( 0.00%)  	      _M_data(__tmp);
  337,740 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (33,774x)
  168,870 ( 0.00%)  	      _M_capacity(__new_capacity);
  337,740 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (33,774x)
        .           	    }
        .           
   67,614 ( 0.00%)  	  if (__rsize)
  439,413 ( 0.00%)  	    this->_S_copy(_M_data(), __str._M_data(), __rsize);
1,740,514 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (33,801x)
  473,214 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (67,602x)
        .           
  169,035 ( 0.00%)  	  _M_set_length(__rsize);
1,859,385 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (33,807x)
        .           	}
  135,236 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               void
   26,502 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               reserve(size_type __res)
        .               {
   17,668 ( 0.00%)        const size_type __capacity = capacity();
  344,518 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::capacity() const (4,417x)
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 2968. Inconsistencies between basic_string reserve and
        .                 // vector/unordered_map/unordered_set reserve functions
        .                 // P0966 reserve should not shrink
   13,251 ( 0.00%)        if (__res <= __capacity)
    2,786 ( 0.00%)  	return;
        .           
   11,417 ( 0.00%)        pointer __tmp = _M_create(__res, __capacity);
  366,683 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_create(unsigned long&, unsigned long) (1,631x)
   21,203 ( 0.00%)        this->_S_copy(__tmp, _M_data(), length() + 1);
   52,232 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (1,631x)
   11,417 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (1,631x)
   11,417 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (1,631x)
    4,893 ( 0.00%)        _M_dispose();
  127,544 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_dispose() (1,631x)
    8,155 ( 0.00%)        _M_data(__tmp);
   16,310 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (1,631x)
    9,786 ( 0.00%)        _M_capacity(__res);
   16,310 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (1,631x)
   13,251 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               void
   23,016 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
        .           	      size_type __len2)
        .               {
   17,262 ( 0.00%)        const size_type __how_much = length() - __pos - __len1;
   20,139 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (2,877x)
        .           
   20,139 ( 0.00%)        size_type __new_capacity = length() + __len2 - __len1;
   20,139 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::length() const (2,877x)
   28,770 ( 0.00%)        pointer __r = _M_create(__new_capacity, capacity());
  592,312 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_create(unsigned long&, unsigned long) (2,877x)
  219,226 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::capacity() const (2,877x)
        .           
    5,754 ( 0.00%)        if (__pos)
   18,666 ( 0.00%)  	this->_S_copy(__r, _M_data(), __pos);
  117,078 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (2,074x)
   14,518 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (2,074x)
   11,500 ( 0.00%)        if (__s && __len2)
   22,984 ( 0.00%)  	this->_S_copy(__r + __pos, __s, __len2);
  151,272 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (2,873x)
    5,754 ( 0.00%)        if (__how_much)
       81 ( 0.00%)  	this->_S_copy(__r + __pos + __len2,
      467 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (9x)
       63 ( 0.00%)  		      _M_data() + __pos + __len1, __how_much);
       63 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (9x)
        .           
    8,631 ( 0.00%)        _M_dispose();
  437,627 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_dispose() (2,877x)
   14,385 ( 0.00%)        _M_data(__r);
   28,770 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data(char*) (2,877x)
   14,385 ( 0.00%)        _M_capacity(__new_capacity);
   28,770 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_capacity(unsigned long) (2,877x)
    8,631 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               void
        .               basic_string<_CharT, _Traits, _Alloc>::
        .               _M_erase(size_type __pos, size_type __n)
        .               {
        .                 const size_type __how_much = length() - __pos - __n;
-- line 353 ----------------------------------------
-- line 392 ----------------------------------------
        .           	catch (...)
        .           	  { /* swallow the exception */ }
        .           #endif
        .               }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               void
       14 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               resize(size_type __n, _CharT __c)
        .               {
        8 ( 0.00%)        const size_type __size = this->size();
       14 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (2x)
        6 ( 0.00%)        if (__size < __n)
        .           	this->append(__n - __size, __c);
        6 ( 0.00%)        else if (__n < __size)
       10 ( 0.00%)  	this->_M_set_length(__n);
      110 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (2x)
        6 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               basic_string<_CharT, _Traits, _Alloc>&
  126,343 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               _M_append(const _CharT* __s, size_type __n)
        .               {
  108,294 ( 0.00%)        const size_type __len = __n + this->size();
  126,343 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (18,049x)
        .           
  126,343 ( 0.00%)        if (__len <= this->capacity())
1,363,818 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::capacity() const (18,049x)
        .           	{
   32,358 ( 0.00%)  	  if (__n)
  226,254 ( 0.00%)  	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
  795,898 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (16,161x)
  113,127 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (16,161x)
  113,127 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (16,161x)
        .           	}
        .                 else
   22,440 ( 0.00%)  	this->_M_mutate(this->size(), size_type(0), __s, __n);
1,299,668 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long) (1,870x)
   13,090 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (1,870x)
        .           
   90,245 ( 0.00%)        this->_M_set_length(__len);
  992,695 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (18,049x)
   18,049 ( 0.00%)        return *this;
   54,147 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               template<typename _InputIterator>
        .                 _GLIBCXX20_CONSTEXPR
        .                 basic_string<_CharT, _Traits, _Alloc>&
        .                 basic_string<_CharT, _Traits, _Alloc>::
        .                 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
        .           			  _InputIterator __k1, _InputIterator __k2,
-- line 436 ----------------------------------------
-- line 503 ----------------------------------------
        .           	      this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
        .           	    }
        .           	}
        .               }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               basic_string<_CharT, _Traits, _Alloc>&
    8,288 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        .           	       const size_type __len2)
        .               {
    6,216 ( 0.00%)        _M_check_length(__len1, __len2, "basic_string::_M_replace");
   53,872 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_check_length(unsigned long, unsigned long, char const*) const (1,036x)
        .           
    4,144 ( 0.00%)        const size_type __old_size = this->size();
    7,252 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (1,036x)
    5,180 ( 0.00%)        const size_type __new_size = __old_size + __len2 - __len1;
        .           
    7,252 ( 0.00%)        if (__new_size <= this->capacity())
   80,032 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::capacity() const (1,036x)
        .           	{
    1,374 ( 0.00%)  	  pointer __p = this->_M_data() + __pos;
    1,603 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (229x)
        .           
      916 ( 0.00%)  	  const size_type __how_much = __old_size - __pos - __len1;
        .           #if __cpp_lib_is_constant_evaluated
      687 ( 0.00%)  	  if (std::is_constant_evaluated())
    1,145 ( 0.00%)  => /usr/include/c++/14/type_traits:std::is_constant_evaluated() (229x)
        .           	    {
        .           	      auto __newp = _S_allocate(_M_get_allocator(), __new_size);
        .           	      _S_copy(__newp, this->_M_data(), __pos);
        .           	      _S_copy(__newp + __pos, __s, __len2);
        .           	      _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
        .           	      _S_copy(this->_M_data(), __newp, __new_size);
        .           	      this->_M_get_allocator().deallocate(__newp, __new_size);
        .           	    }
        .           	  else
        .           #endif
    2,290 ( 0.00%)  	  if (__builtin_expect(_M_disjunct(__s), true))
   17,931 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_disjunct(char const*) const (229x)
        .           	    {
    1,091 ( 0.00%)  	      if (__how_much && __len1 != __len2)
    2,110 ( 0.00%)  		this->_S_move(__p + __len2, __p + __len1, __how_much);
   11,918 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_move(char*, char const*, unsigned long) (211x)
      458 ( 0.00%)  	      if (__len2)
    1,603 ( 0.00%)  		this->_S_copy(__p, __s, __len2);
    7,706 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) (229x)
        .           	    }
        .           	  else
        .           	    _M_replace_cold(__p, __len1, __s, __len2, __how_much);
        .           	}
        .                 else
    6,456 ( 0.00%)  	this->_M_mutate(__pos, __len1, __s, __len2);
  392,889 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long) (807x)
        .           
    5,180 ( 0.00%)        this->_M_set_length(__new_size);
   56,980 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_set_length(unsigned long) (1,036x)
    1,036 ( 0.00%)        return *this;
    2,072 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX20_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
        .               basic_string<_CharT, _Traits, _Alloc>::
        .               copy(_CharT* __s, size_type __n, size_type __pos) const
        .               {
        .                 _M_check(__pos, "basic_string::copy");
-- line 560 ----------------------------------------
-- line 618 ----------------------------------------
        .           #if __glibcxx_constexpr_string >= 201907L
        .           # define _GLIBCXX_STRING_CONSTEXPR constexpr
        .           #else
        .           # define _GLIBCXX_STRING_CONSTEXPR
        .           #endif
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX_STRING_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
  165,228 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               find(const _CharT* __s, size_type __pos, size_type __n) const
        .               _GLIBCXX_NOEXCEPT
        .               {
        .                 __glibcxx_requires_string_len(__s, __n);
   94,416 ( 0.00%)        const size_type __size = this->size();
  165,228 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (23,604x)
        .           
   47,208 ( 0.00%)        if (__n == 0)
        .           	return __pos <= __size ? __pos : npos;
   70,812 ( 0.00%)        if (__pos >= __size)
        .           	return npos;
        .           
   70,812 ( 0.00%)        const _CharT __elem0 = __s[0];
   94,416 ( 0.00%)        const _CharT* const __data = data();
  377,664 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (23,604x)
   94,416 ( 0.00%)        const _CharT* __first = __data + __pos;
   94,416 ( 0.00%)        const _CharT* const __last = __data + __size;
   94,416 ( 0.00%)        size_type __len = __size - __pos;
        .           
   94,434 ( 0.00%)        while (__len >= __n)
        .           	{
        .           	  // Find the first occurrence of __elem0:
  212,463 ( 0.00%)  	  __first = traits_type::find(__first, __len - __n + 1, __elem0);
  991,718 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::find(char const*, unsigned long, char const&) (23,607x)
   47,214 ( 0.00%)  	  if (!__first)
   41,788 ( 0.00%)  	    return npos;
        .           	  // Compare the full strings from the first occurrence of __elem0.
        .           	  // We already know that __first[0] == __s[0] but compare them again
        .           	  // anyway because __s is probably aligned, which helps memcmp.
   27,130 ( 0.00%)  	  if (traits_type::compare(__first, __s, __n) == 0)
   84,181 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) (2,713x)
    8,121 ( 0.00%)  	    return __first - __data;
       24 ( 0.00%)  	  __len = __last - ++__first;
        .           	}
        3 ( 0.00%)        return npos;
   47,208 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX_STRING_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
  152,145 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
        .               {
   21,735 ( 0.00%)        size_type __ret = npos;
   86,940 ( 0.00%)        const size_type __size = this->size();
  152,145 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (21,735x)
   65,205 ( 0.00%)        if (__pos < __size)
        .           	{
   86,940 ( 0.00%)  	  const _CharT* __data = _M_data();
  152,145 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (21,735x)
   65,205 ( 0.00%)  	  const size_type __n = __size - __pos;
  195,615 ( 0.00%)  	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
  913,588 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::find(char const*, unsigned long, char const&) (21,735x)
   43,470 ( 0.00%)  	  if (__p)
   29,532 ( 0.00%)  	    __ret = __p - __data;
        .           	}
   21,735 ( 0.00%)        return __ret;
   43,470 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX_STRING_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
        .               basic_string<_CharT, _Traits, _Alloc>::
        .               rfind(const _CharT* __s, size_type __pos, size_type __n) const
        .               _GLIBCXX_NOEXCEPT
        .               {
-- line 685 ----------------------------------------
-- line 732 ----------------------------------------
        .           	    return __pos;
        .           	}
        .                 return npos;
        .               }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX_STRING_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
       14 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
        .               find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
        .               _GLIBCXX_NOEXCEPT
        .               {
        .                 __glibcxx_requires_string_len(__s, __n);
        8 ( 0.00%)        size_type __size = this->size();
       14 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (2x)
       11 ( 0.00%)        if (__size && __n)
        .           	{
       15 ( 0.00%)  	  if (--__size > __pos)
        .           	    __size = __pos;
        .           	  do
        .           	    {
      368 ( 0.00%)  	      if (traits_type::find(__s, __n, _M_data()[__size]))
    2,236 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::find(char const*, unsigned long, char const&) (24x)
      168 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_data() const (24x)
        4 ( 0.00%)  		return __size;
        .           	    }
      184 ( 0.00%)  	  while (__size-- != 0);
        .           	}
        .                 return npos;
        4 ( 0.00%)      }
        .           
        .             template<typename _CharT, typename _Traits, typename _Alloc>
        .               _GLIBCXX_STRING_CONSTEXPR
        .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
        .               basic_string<_CharT, _Traits, _Alloc>::
        .               find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
        .               _GLIBCXX_NOEXCEPT
        .               {
-- line 766 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/racing/math_util.c
--------------------------------------------------------------------------------
Ir                 

-- line 38 ----------------------------------------
        .           UNUSED void func_802B4FF0() {
        .           }
        .           
        .           /**
        .            * Inserts matrix into the rsp. Position, rotation and mode of where to render the next object and check number of
        .            * object already render Note that gMatrixObjectCount gets reset at the beginning of the game loop. So no cleanup needs
        .            * to be performed.
        .            */
  170,765 ( 0.00%)  s32 render_set_position(Mat4 arg0, s32 arg1) {
  136,612 ( 0.00%)      if (gMatrixObjectCount >= MTX_OBJECT_POOL_SIZE) {
        .                   return 0;
        .               }
  443,989 ( 0.00%)      mtxf_to_mtx(&gGfxPool->mtxObject[gMatrixObjectCount], arg0);
17,281,418 ( 0.01%)  => src/racing/math_util.c:mtxf_to_mtx (34,153x)
  295,610 ( 0.00%)      switch (arg1) { /* irregular */
        .                   case 0:
  653,499 ( 0.00%)              gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
   28,413 ( 0.00%)              break;
        .                   case 1:
        .                       gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_PUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
        .                       break;
        .                   case 3:
  132,020 ( 0.00%)              gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_PUSH | G_MTX_MUL | G_MTX_MODELVIEW);
    5,740 ( 0.00%)              break;
        .                   case 2:
        .                       gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
        .                       break;
        .               }
   34,153 ( 0.00%)      return 1;
   68,306 ( 0.00%)  }
        .           
        .           f32 func_802B51E8(Vec3f arg0, Vec3f arg1) {
        .               f32 sub_y;
        .               f32 sub_z;
        .               f32 sub_x;
        .           
        .               sub_x = arg1[0] - arg0[0];
        .               sub_y = arg1[1] - arg0[1];
        .               sub_z = arg1[2] - arg0[2];
        .               return (sub_x * sub_x) + (sub_y * sub_y) + sub_z + sub_z;
        .           }
        .           
   80,470 ( 0.00%)  s32 get_angle_between_two_vectors(Vec3f arg0, Vec3f arg1) {
        .               f32 temp_v1;
        .               f32 temp_v2;
   96,564 ( 0.00%)      temp_v1 = arg1[0] - arg0[0];
  128,752 ( 0.00%)      temp_v2 = arg1[2] - arg0[2];
        .           
   96,564 ( 0.00%)      return atan2s(temp_v1, temp_v2);
  937,335 ( 0.00%)  => src/racing/math_util.c:atan2s (16,094x)
   32,188 ( 0.00%)  }
        .           
        .           // get_angle_between_two_vectors
        .           u32 func_802B5258(Vec3f arg0, Vec3s arg1) {
        .               f32 temp_v1;
        .               f32 temp_v2;
        .               temp_v1 = arg1[0] - arg0[0];
        .               temp_v2 = arg1[2] - arg0[2];
        .           
        .               return atan2s(temp_v1, temp_v2);
        .           }
        .           
   35,190 ( 0.00%)  void vec3f_set(Vec3f arg0, f32 arg1, f32 arg2, f32 arg3) {
   17,595 ( 0.00%)      arg0[0] = arg1;
   23,460 ( 0.00%)      arg0[1] = arg2;
   23,460 ( 0.00%)      arg0[2] = arg3;
   17,595 ( 0.00%)  }
        .           
      136 ( 0.00%)  void vec3s_set(Vec3s arg0, s16 arg1, s16 arg2, s16 arg3) {
       51 ( 0.00%)      arg0[0] = arg1;
       68 ( 0.00%)      arg0[1] = arg2;
       68 ( 0.00%)      arg0[2] = arg3;
       51 ( 0.00%)  }
        .           
        .           // These functions have bogus return values.
        .           // Disable the compiler warning.
        .           #pragma GCC diagnostic push
        .           
        .           #ifdef __GNUC__
        .           #if defined(__clang__)
        .           #pragma GCC diagnostic ignored "-Wreturn-stack-address"
        .           #else
        .           #pragma GCC diagnostic ignored "-Wreturn-local-addr"
        .           #endif
        .           #endif
        .           
      232 ( 0.00%)  void* vec3f_copy_return(Vec3f dest, Vec3f src) {
      232 ( 0.00%)      dest[0] = src[0];
      290 ( 0.00%)      dest[1] = src[1];
      290 ( 0.00%)      dest[2] = src[2];
        .               //! @warning function returns address of local variable
       58 ( 0.00%)      return &dest;
      116 ( 0.00%)  }
        .           
      116 ( 0.00%)  void vec3s_copy(Vec3s dest, Vec3s src) {
      116 ( 0.00%)      dest[0] = src[0];
      145 ( 0.00%)      dest[1] = src[1];
      145 ( 0.00%)      dest[2] = src[2];
       87 ( 0.00%)  }
        .           
        .           UNUSED void* vec3f_set_return(Vec3f dest, f32 x, f32 y, f32 z) {
        .               dest[0] = x;
        .               dest[1] = y;
        .               dest[2] = z;
        .               return &dest;
        .           }
        .           
-- line 146 ----------------------------------------
-- line 152 ----------------------------------------
        .               for (row = 0; row < 4; row++) {
        .                   for (column = 0; column < 4; column++) {
        .                       mat2[row][column] = mat1[row][column];
        .                   }
        .               }
        .           }
        .           
        .           // mtxf_copy
   30,360 ( 0.00%)  void mtxf_copy_n_element(s32* dest, s32* src, s32 n) {
  522,192 ( 0.00%)      while (n-- > 0) {
  777,216 ( 0.00%)          *dest++ = *src++;
        .               }
   24,288 ( 0.00%)  }
        .           
        .           // Transform a matrix to a matrix identity
   64,040 ( 0.00%)  void mtxf_identity(Mat4 mtx) {
        .               register s32 i;
        .               register s32 k;
        .           
  204,928 ( 0.00%)      for (i = 0; i < 4; i++) {
  819,712 ( 0.00%)          for (k = 0; k < 4; k++) {
2,100,512 ( 0.00%)              mtx[i][k] = (i == k) ? 1.0f : 0.0f;
        .                   }
        .               }
   76,848 ( 0.00%)  }
        .           
        .           // Add a translation vector to a matrix, mat is the matrix to add, dest is the destination matrix, pos is the
        .           // translation vector
        .           void add_translate_mat4_vec3f(Mat4 mat, Mat4 dest, Vec3f pos) {
        .               dest[3][0] = mat[3][0] + pos[0];
        .               dest[3][1] = mat[3][1] + pos[1];
        .               dest[3][2] = mat[3][2] + pos[2];
        .               dest[3][3] = mat[3][3];
-- line 184 ----------------------------------------
-- line 206 ----------------------------------------
        .           // Light version of add_translate_mat4_vec3f
        .           UNUSED void add_translate_mat4_vec3f_lite(Mat4 mat, Mat4 dest, Vec3f pos) {
        .               dest[3][0] = mat[3][0] + pos[0];
        .               dest[3][1] = mat[3][1] + pos[1];
        .               dest[3][2] = mat[3][2] + pos[2];
        .           }
        .           
        .           // create a translation matrix
   30,360 ( 0.00%)  void mtxf_translate(Mat4 dest, Vec3f b) {
   18,216 ( 0.00%)      mtxf_identity(dest);
1,548,360 ( 0.00%)  => src/racing/math_util.c:mtxf_identity (6,072x)
   30,360 ( 0.00%)      dest[3][0] = b[0];
   30,360 ( 0.00%)      dest[3][1] = b[1];
   30,360 ( 0.00%)      dest[3][2] = b[2];
   18,216 ( 0.00%)  }
        .           
        .           // Note the use of `2` which generates diff asm than just using floats (2.0f).
    3,652 ( 0.00%)  void func_802B5564(Mat4 arg0, u16* arg1, f32 arg2, f32 arg3, f32 arg4, f32 arg5, f32 arg6) {
        .               f32 temp;
        .               s32 i, j;
      996 ( 0.00%)      mtxf_identity(arg0);
   84,660 ( 0.00%)  => src/racing/math_util.c:mtxf_identity (332x)
    1,660 ( 0.00%)      arg2 *= 0.017453292222222222;
    5,976 ( 0.00%)      temp = cosf(arg2 / 2) / sinf(arg2 / 2);
    6,972 ( 0.00%)  => ???:0x00000000000771e0 (332x)
    6,308 ( 0.00%)  => ???:0x000000000007cec0 (332x)
    1,328 ( 0.00%)      arg0[0][0] = temp / arg3;
    1,328 ( 0.00%)      arg0[1][1] = temp;
    2,656 ( 0.00%)      arg0[2][2] = (arg4 + arg5) / (arg4 - arg5);
    1,328 ( 0.00%)      arg0[2][3] = -1.0f;
    2,988 ( 0.00%)      arg0[3][2] = (2 * arg4 * arg5) / (arg4 - arg5);
    1,328 ( 0.00%)      arg0[3][3] = 0.0f;
        .           
    5,312 ( 0.00%)      for (i = 0; i < 4; i++) {
   21,248 ( 0.00%)          for (j = 0; j < 4; j++) {
  100,928 ( 0.00%)              arg0[i][j] *= arg6;
        .                   }
        .               }
        .           
      664 ( 0.00%)      if (arg1 != 0) {
    1,660 ( 0.00%)          if ((arg4 + arg5) <= 2.0) {
        .                       *arg1 = 0xFFFF;
        .                   } else {
    2,988 ( 0.00%)              *arg1 = 131072.0 / (arg4 + arg5);
    1,328 ( 0.00%)              if (*arg1 <= 0) {
        .                           *arg1 = 1;
        .                       }
        .                   }
        .               }
    1,328 ( 0.00%)  }
        .           
        .           // Appears to only be for the skybox. mtxf_lookat from sm64 with some modifications.
    1,992 ( 0.00%)  void func_802B5794(Mat4 mtx, Vec3f from, Vec3f to) {
        .               // register from sm64 but not required for matching.
        .               register f32 invLength;
        .               f32 xColY;
        .               f32 yColY;
        .               f32 zColY;
        .               f32 xColZ;
        .               f32 yColZ;
        .               f32 zColZ;
        .               f32 xColX;
        .               f32 yColX;
        .               f32 zColX;
        .           
      664 ( 0.00%)      xColY = 0.0f;
      664 ( 0.00%)      yColY = 1.0f;
      664 ( 0.00%)      zColY = 0.0f;
        .           
    1,992 ( 0.00%)      xColZ = to[0] - from[0];
    2,656 ( 0.00%)      yColZ = to[1] - from[1];
    2,656 ( 0.00%)      zColZ = to[2] - from[2];
        .           
    5,312 ( 0.00%)      invLength = -1.0 / sqrtf(xColZ * xColZ + yColZ * yColZ + zColZ * zColZ);
    2,656 ( 0.00%)  => ???:sqrtf (332x)
      996 ( 0.00%)      xColZ *= invLength;
      996 ( 0.00%)      yColZ *= invLength;
      996 ( 0.00%)      zColZ *= invLength;
        .           
    1,992 ( 0.00%)      xColX = yColY * zColZ - zColY * yColZ;
    1,992 ( 0.00%)      yColX = zColY * xColZ - xColY * zColZ;
    1,992 ( 0.00%)      zColX = xColY * yColZ - yColY * xColZ;
        .           
    5,312 ( 0.00%)      invLength = 1.0 / sqrtf(xColX * xColX + yColX * yColX + zColX * zColX);
    2,656 ( 0.00%)  => ???:sqrtf (332x)
        .           
      996 ( 0.00%)      xColX *= invLength;
      996 ( 0.00%)      yColX *= invLength;
      996 ( 0.00%)      zColX *= invLength;
        .           
    1,992 ( 0.00%)      xColY = yColZ * zColX - zColZ * yColX;
    1,992 ( 0.00%)      yColY = zColZ * xColX - xColZ * zColX;
    1,992 ( 0.00%)      zColY = xColZ * yColX - yColZ * xColX;
        .           
    5,312 ( 0.00%)      invLength = 1.0 / sqrtf(xColY * xColY + yColY * yColY + zColY * zColY);
    2,656 ( 0.00%)  => ???:sqrtf (332x)
      996 ( 0.00%)      xColY *= invLength;
      996 ( 0.00%)      yColY *= invLength;
      996 ( 0.00%)      zColY *= invLength;
        .           
      996 ( 0.00%)      mtx[0][0] = xColX;
    1,328 ( 0.00%)      mtx[1][0] = yColX;
    1,328 ( 0.00%)      mtx[2][0] = zColX;
    5,976 ( 0.00%)      mtx[3][0] = -(from[0] * xColX + from[1] * yColX + from[2] * zColX);
        .           
      996 ( 0.00%)      mtx[0][1] = xColY;
    1,328 ( 0.00%)      mtx[1][1] = yColY;
    1,328 ( 0.00%)      mtx[2][1] = zColY;
    5,976 ( 0.00%)      mtx[3][1] = -(from[0] * xColY + from[1] * yColY + from[2] * zColY);
        .           
      996 ( 0.00%)      mtx[0][2] = xColZ;
    1,328 ( 0.00%)      mtx[1][2] = yColZ;
    1,328 ( 0.00%)      mtx[2][2] = zColZ;
    5,976 ( 0.00%)      mtx[3][2] = -(from[0] * xColZ + from[1] * yColZ + from[2] * zColZ);
        .           
      996 ( 0.00%)      mtx[0][3] = 0.0f;
    1,328 ( 0.00%)      mtx[1][3] = 0.0f;
    1,328 ( 0.00%)      mtx[2][3] = 0.0f;
    1,328 ( 0.00%)      mtx[3][3] = 1.0f;
      996 ( 0.00%)  }
        .           
        .           // create a rotation matrix around the x axis
   34,440 ( 0.00%)  void mtxf_rotate_x(Mat4 mat, s16 angle) {
   34,440 ( 0.00%)      f32 sin_theta = sins(angle);
   68,880 ( 0.00%)  => src/racing/math_util.c:sins (5,740x)
   34,440 ( 0.00%)      f32 cos_theta = coss(angle);
   80,360 ( 0.00%)  => src/racing/math_util.c:coss (5,740x)
        .           
   17,220 ( 0.00%)      mtxf_identity(mat);
1,463,700 ( 0.00%)  => src/racing/math_util.c:mtxf_identity (5,740x)
   22,960 ( 0.00%)      mat[1][1] = cos_theta;
   22,960 ( 0.00%)      mat[1][2] = sin_theta;
   34,440 ( 0.00%)      mat[2][1] = -sin_theta;
   22,960 ( 0.00%)      mat[2][2] = cos_theta;
        .           
        .               /*
        .                * 1, 0, 0, 0,
        .                * 0, cos_theta, sin_theta, 0,
        .                * 0, -sin_theta, cos_theta, 0,
        .                * 0, 0, 0, 1
        .                */
   17,220 ( 0.00%)  }
        .           
        .           // create a rotation matrix around the y axis
        .           void mtxf_rotate_y(Mat4 mat, s16 angle) {
        .               f32 sin_theta = sins(angle);
        .               f32 cos_theta = coss(angle);
        .           
        .               mtxf_identity(mat);
        .               mat[0][0] = cos_theta;
-- line 345 ----------------------------------------
-- line 417 ----------------------------------------
        .               arg2[1] = sp2C;
        .               arg2[2] = -(sp28 * temp_f10);
        .           }
        .           
        .           void func_802B5D30(s16 arg0, s16 arg1, s32 arg2) {
        .               func_802B5D64((Lights1*) 0x9000000, arg0, arg1, arg2);
        .           }
        .           
    5,976 ( 0.00%)  void func_802B5D64(Lights1* addr, s16 arg1, s16 arg2, s32 arg3) {
        .               UNUSED s32 pad;
        .               f32 sp48;
        .               f32 sp44;
        .               f32 sp40;
        .               UNUSED s32 pad2[2];
        .               f32 temp_f10;
        .               s32 var_v0;
        .               s8 sp2C[3];
        .               Lights1* var_s0;
        .           
    1,328 ( 0.00%)      var_s0 = (Lights1*) addr;
    3,984 ( 0.00%)      sp48 = sins(arg2);
    7,968 ( 0.00%)  => src/racing/math_util.c:sins (664x)
    3,984 ( 0.00%)      sp44 = coss(arg2);
    9,296 ( 0.00%)  => src/racing/math_util.c:coss (664x)
    3,984 ( 0.00%)      sp40 = sins(arg1);
    7,968 ( 0.00%)  => src/racing/math_util.c:sins (664x)
    3,984 ( 0.00%)      temp_f10 = coss(arg1);
    9,296 ( 0.00%)  => src/racing/math_util.c:coss (664x)
    3,984 ( 0.00%)      sp2C[0] = sp44 * sp40 * 120.0f;
    3,320 ( 0.00%)      sp2C[1] = 120.0f * sp48;
    3,984 ( 0.00%)      sp2C[2] = sp44 * temp_f10 * -120.0f;
    6,640 ( 0.00%)      for (var_v0 = 0; var_v0 < arg3; var_v0++, var_s0++) {
    1,992 ( 0.00%)          var_s0->l[0].l.dir[0] = sp2C[0];
    1,992 ( 0.00%)          var_s0->l[0].l.dir[1] = sp2C[1];
    1,992 ( 0.00%)          var_s0->l[0].l.dir[2] = sp2C[2];
        .               }
    2,656 ( 0.00%)  }
        .           
        .           // multiply a matrix with a number
        .           void mtxf_scale(Mat4 mat, f32 coef) {
        .               mat[0][0] *= coef;
        .               mat[1][0] *= coef;
        .               mat[2][0] *= coef;
        .               mat[0][1] *= coef;
        .               mat[1][1] *= coef;
        .               mat[2][1] *= coef;
        .               mat[0][2] *= coef;
        .               mat[1][2] *= coef;
        .               mat[2][2] *= coef;
        .           }
        .           
        .           // look like create a translation and rotation matrix with arg1 position and arg2 rotation
  164,502 ( 0.00%)  void mtxf_pos_rotation_xyz(Mat4 out, Vec3f pos, Vec3s orientation) {
        .               f32 sine1;
        .               f32 cosine1;
        .               f32 sine2;
        .               f32 cosine2;
        .               f32 sine3;
        .               f32 cosine3;
        .           
  191,919 ( 0.00%)      sine1 = sins(orientation[0]);
  329,004 ( 0.00%)  => src/racing/math_util.c:sins (27,417x)
  191,919 ( 0.00%)      cosine1 = coss(orientation[0]);
  383,838 ( 0.00%)  => src/racing/math_util.c:coss (27,417x)
  219,336 ( 0.00%)      sine2 = sins(orientation[1]);
  329,004 ( 0.00%)  => src/racing/math_util.c:sins (27,417x)
  219,336 ( 0.00%)      cosine2 = coss(orientation[1]);
  383,838 ( 0.00%)  => src/racing/math_util.c:coss (27,417x)
  219,336 ( 0.00%)      sine3 = sins(orientation[2]);
  329,004 ( 0.00%)  => src/racing/math_util.c:sins (27,417x)
  219,336 ( 0.00%)      cosine3 = coss(orientation[2]);
  383,838 ( 0.00%)  => src/racing/math_util.c:coss (27,417x)
  219,336 ( 0.00%)      out[0][0] = (cosine2 * cosine3) + ((sine1 * sine2) * sine3);
  301,587 ( 0.00%)      out[1][0] = (-cosine2 * sine3) + ((sine1 * sine2) * cosine3);
  137,085 ( 0.00%)      out[2][0] = cosine1 * sine2;
  137,085 ( 0.00%)      out[3][0] = pos[0];
  109,668 ( 0.00%)      out[0][1] = cosine1 * sine3;
  137,085 ( 0.00%)      out[1][1] = cosine1 * cosine3;
  164,502 ( 0.00%)      out[2][1] = -sine1;
  137,085 ( 0.00%)      out[3][1] = pos[1];
  274,170 ( 0.00%)      out[0][2] = (-sine2 * cosine3) + ((sine1 * cosine2) * sine3);
  246,753 ( 0.00%)      out[1][2] = (sine2 * sine3) + ((sine1 * cosine2) * cosine3);
  137,085 ( 0.00%)      out[2][2] = cosine1 * cosine2;
  137,085 ( 0.00%)      out[3][2] = pos[2];
   82,251 ( 0.00%)      out[0][3] = 0.0f;
  109,668 ( 0.00%)      out[1][3] = 0.0f;
  109,668 ( 0.00%)      out[2][3] = 0.0f;
  109,668 ( 0.00%)      out[3][3] = 1.0f;
   82,251 ( 0.00%)  }
        .           
        .           UNUSED void func_802B60B4(Mat4 arg0, Vec3s arg1, Vec3s arg2) {
        .               f32 sine1;
        .               f32 cosine1;
        .               f32 sine2;
        .               f32 cosine2;
        .               f32 sine3;
        .               f32 cosine3;
-- line 503 ----------------------------------------
-- line 563 ----------------------------------------
        .               f32 temp_f0;
        .               temp_f0 = sqrtf((arg0[0] * arg0[0]) + (arg0[1] * arg0[1]) + (arg0[2] * arg0[2]));
        .               arg0[0] /= temp_f0;
        .               arg0[1] /= temp_f0;
        .               arg0[2] /= temp_f0;
        .           }
        .           
        .           // translate the vector with a matrix
   37,692 ( 0.00%)  void mtxf_translate_vec3f_mat3(Vec3f pos, Mat3 mat) {
        .               f32 new_x;
        .               f32 new_y;
        .               f32 new_z;
        .           
  188,460 ( 0.00%)      new_x = (mat[0][0] * pos[0]) + (mat[0][1] * pos[1]) + (mat[0][2] * pos[2]);
  216,729 ( 0.00%)      new_y = (mat[1][0] * pos[0]) + (mat[1][1] * pos[1]) + (mat[1][2] * pos[2]);
  216,729 ( 0.00%)      new_z = (mat[2][0] * pos[0]) + (mat[2][1] * pos[1]) + (mat[2][2] * pos[2]);
        .           
   28,269 ( 0.00%)      pos[0] = new_x;
   37,692 ( 0.00%)      pos[1] = new_y;
   37,692 ( 0.00%)      pos[2] = new_z;
   28,269 ( 0.00%)  }
        .           
        .           // translate the vector with a matrix (with a matrix 4x4)
    1,328 ( 0.00%)  void mtxf_translate_vec3f_mat4(Vec3f pos, Mat4 mat) {
        .               f32 new_x;
        .               f32 new_y;
        .               f32 new_z;
        .           
    6,640 ( 0.00%)      new_x = (mat[0][0] * pos[0]) + (mat[0][1] * pos[1]) + (mat[0][2] * pos[2]);
    7,636 ( 0.00%)      new_y = (mat[1][0] * pos[0]) + (mat[1][1] * pos[1]) + (mat[1][2] * pos[2]);
    7,636 ( 0.00%)      new_z = (mat[2][0] * pos[0]) + (mat[2][1] * pos[1]) + (mat[2][2] * pos[2]);
        .           
      996 ( 0.00%)      pos[0] = new_x;
    1,328 ( 0.00%)      pos[1] = new_y;
    1,328 ( 0.00%)      pos[2] = new_z;
      996 ( 0.00%)  }
        .           
        .           UNUSED void func_802B64B0(UNUSED s32 arg0, UNUSED s32 arg1, UNUSED s32 arg2, UNUSED s32 arg3) {
        .           }
        .           
        .           void func_802B64C4(Vec3f arg0, s16 arg1) {
        .               f32 sp2C = sins(arg1);
        .               f32 temp_f0 = coss(arg1);
        .           
-- line 606 ----------------------------------------
-- line 608 ----------------------------------------
        .               f32 temp2 = arg0[1];
        .               f32 temp3 = arg0[2];
        .           
        .               arg0[0] = temp_f0 * temp1 - (sp2C * temp3);
        .               arg0[1] = temp2;
        .               arg0[2] = sp2C * temp1 + (temp_f0 * temp3);
        .           }
        .           
   30,654 ( 0.00%)  void calculate_orientation_matrix(Mat3 dest, f32 arg1, f32 arg2, f32 arg3, s16 rotationAngle) {
        .               Mat3 mtx_rot_y;
        .               Mat3 matrix;
        .               s32 i, j;
        .               f32 a;
        .               f32 b;
        .               f32 c;
        .               f32 d;
        .               UNUSED s32 pad[3];
        .               f32 sinValue;
        .               f32 cossValue;
        .           
   20,436 ( 0.00%)      sinValue = sins(rotationAngle);
   40,872 ( 0.00%)  => src/racing/math_util.c:sins (3,406x)
   20,436 ( 0.00%)      cossValue = coss(rotationAngle);
   47,684 ( 0.00%)  => src/racing/math_util.c:coss (3,406x)
    6,812 ( 0.00%)      mtx_rot_y[0][0] = cossValue;
    6,812 ( 0.00%)      mtx_rot_y[2][1] = 0;
    6,812 ( 0.00%)      mtx_rot_y[1][2] = 0;
        .           
    6,812 ( 0.00%)      mtx_rot_y[1][1] = 1;
    6,812 ( 0.00%)      mtx_rot_y[2][0] = sinValue;
   13,624 ( 0.00%)      mtx_rot_y[0][2] = -sinValue;
        .           
    6,812 ( 0.00%)      mtx_rot_y[2][2] = cossValue;
    6,812 ( 0.00%)      mtx_rot_y[1][0] = 0;
    6,812 ( 0.00%)      mtx_rot_y[0][1] = 0;
        .           
   20,436 ( 0.00%)      if (arg2 == 1) { // set matrix to identity
        .           
   47,684 ( 0.00%)          for (i = 0; i < 3; i++) {
  132,834 ( 0.00%)              for (j = 0; j < 3; j++) {
  408,720 ( 0.00%)                  matrix[i][j] = (i == j) ? 1.0f : 0.0f;
        .                       }
        .                   }
        .           
        .               } else if (arg2 == -1) { // set matrix to identity with the second column negative
        .           
        .                   for (i = 0; i < 3; i++) {
        .                       for (j = 0; j < 3; j++) {
        .                           matrix[i][j] = (i == j) ? 1.0f : 0.0f;
-- line 654 ----------------------------------------
-- line 659 ----------------------------------------
        .           
        .               } else {
        .                   a = (f32) - (360.0 - ((f64) (calculate_vector_angle_xy(arg2) * 180.0f) / M_PI));
        .                   b = -arg3 / sqrtf((arg1 * arg1) + (arg3 * arg3));
        .                   c = 0;
        .                   d = arg1 / sqrtf((arg1 * arg1) + (arg3 * arg3));
        .                   calculate_rotation_matrix(matrix, a, b, c, d);
        .               }
   44,278 ( 0.00%)      dest[0][0] = (mtx_rot_y[0][0] * matrix[0][0]) + (mtx_rot_y[0][1] * matrix[1][0]) + (mtx_rot_y[0][2] * matrix[2][0]);
   47,684 ( 0.00%)      dest[1][0] = (mtx_rot_y[1][0] * matrix[0][0]) + (mtx_rot_y[1][1] * matrix[1][0]) + (mtx_rot_y[1][2] * matrix[2][0]);
   47,684 ( 0.00%)      dest[2][0] = (mtx_rot_y[2][0] * matrix[0][0]) + (mtx_rot_y[2][1] * matrix[1][0]) + (mtx_rot_y[2][2] * matrix[2][0]);
        .           
   44,278 ( 0.00%)      dest[0][1] = (mtx_rot_y[0][0] * matrix[0][1]) + (mtx_rot_y[0][1] * matrix[1][1]) + (mtx_rot_y[0][2] * matrix[2][1]);
   47,684 ( 0.00%)      dest[1][1] = (mtx_rot_y[1][0] * matrix[0][1]) + (mtx_rot_y[1][1] * matrix[1][1]) + (mtx_rot_y[1][2] * matrix[2][1]);
   47,684 ( 0.00%)      dest[2][1] = (mtx_rot_y[2][0] * matrix[0][1]) + (mtx_rot_y[2][1] * matrix[1][1]) + (mtx_rot_y[2][2] * matrix[2][1]);
        .           
   44,278 ( 0.00%)      dest[0][2] = (mtx_rot_y[0][0] * matrix[0][2]) + (mtx_rot_y[0][1] * matrix[1][2]) + (mtx_rot_y[0][2] * matrix[2][2]);
   47,684 ( 0.00%)      dest[1][2] = (mtx_rot_y[1][0] * matrix[0][2]) + (mtx_rot_y[1][1] * matrix[1][2]) + (mtx_rot_y[1][2] * matrix[2][2]);
   47,684 ( 0.00%)      dest[2][2] = (mtx_rot_y[2][0] * matrix[0][2]) + (mtx_rot_y[2][1] * matrix[1][2]) + (mtx_rot_y[2][2] * matrix[2][2]);
   10,218 ( 0.00%)  }
        .           
        .           // include in calculate_orientation_matrix
        .           UNUSED void func_802B68F8(Mat3 matrix, f32 arg1, f32 arg2, f32 arg3) {
        .               s32 i, j;
        .               f32 a;
        .               f32 b;
        .               f32 c;
        .               f32 d;
-- line 686 ----------------------------------------
-- line 807 ----------------------------------------
        .               arg0[2][2] = cosine1 * cosine2;
        .               arg0[3][2] = arg1[2];
        .               arg0[0][3] = 0.0f;
        .               arg0[1][3] = 0.0f;
        .               arg0[2][3] = 0.0f;
        .               arg0[3][3] = 1.0f;
        .           }
        .           
   36,432 ( 0.00%)  void mtxf_multiplication(Mat4 dest, Mat4 mat1, Mat4 mat2) {
        .               Mat4 product;
    6,072 ( 0.00%)      product[0][0] =
  157,872 ( 0.00%)          (mat1[0][0] * mat2[0][0]) + (mat1[0][1] * mat2[1][0]) + (mat1[0][2] * mat2[2][0]) + (mat1[0][3] * mat2[3][0]);
    6,072 ( 0.00%)      product[0][1] =
  157,872 ( 0.00%)          (mat1[0][0] * mat2[0][1]) + (mat1[0][1] * mat2[1][1]) + (mat1[0][2] * mat2[2][1]) + (mat1[0][3] * mat2[3][1]);
    6,072 ( 0.00%)      product[0][2] =
  157,872 ( 0.00%)          (mat1[0][0] * mat2[0][2]) + (mat1[0][1] * mat2[1][2]) + (mat1[0][2] * mat2[2][2]) + (mat1[0][3] * mat2[3][2]);
    6,072 ( 0.00%)      product[0][3] =
  157,872 ( 0.00%)          (mat1[0][0] * mat2[0][3]) + (mat1[0][1] * mat2[1][3]) + (mat1[0][2] * mat2[2][3]) + (mat1[0][3] * mat2[3][3]);
    6,072 ( 0.00%)      product[1][0] =
  182,160 ( 0.00%)          (mat1[1][0] * mat2[0][0]) + (mat1[1][1] * mat2[1][0]) + (mat1[1][2] * mat2[2][0]) + (mat1[1][3] * mat2[3][0]);
    6,072 ( 0.00%)      product[1][1] =
  182,160 ( 0.00%)          (mat1[1][0] * mat2[0][1]) + (mat1[1][1] * mat2[1][1]) + (mat1[1][2] * mat2[2][1]) + (mat1[1][3] * mat2[3][1]);
    6,072 ( 0.00%)      product[1][2] =
  182,160 ( 0.00%)          (mat1[1][0] * mat2[0][2]) + (mat1[1][1] * mat2[1][2]) + (mat1[1][2] * mat2[2][2]) + (mat1[1][3] * mat2[3][2]);
    6,072 ( 0.00%)      product[1][3] =
  182,160 ( 0.00%)          (mat1[1][0] * mat2[0][3]) + (mat1[1][1] * mat2[1][3]) + (mat1[1][2] * mat2[2][3]) + (mat1[1][3] * mat2[3][3]);
    6,072 ( 0.00%)      product[2][0] =
  182,160 ( 0.00%)          (mat1[2][0] * mat2[0][0]) + (mat1[2][1] * mat2[1][0]) + (mat1[2][2] * mat2[2][0]) + (mat1[2][3] * mat2[3][0]);
    6,072 ( 0.00%)      product[2][1] =
  182,160 ( 0.00%)          (mat1[2][0] * mat2[0][1]) + (mat1[2][1] * mat2[1][1]) + (mat1[2][2] * mat2[2][1]) + (mat1[2][3] * mat2[3][1]);
    6,072 ( 0.00%)      product[2][2] =
  182,160 ( 0.00%)          (mat1[2][0] * mat2[0][2]) + (mat1[2][1] * mat2[1][2]) + (mat1[2][2] * mat2[2][2]) + (mat1[2][3] * mat2[3][2]);
    6,072 ( 0.00%)      product[2][3] =
  182,160 ( 0.00%)          (mat1[2][0] * mat2[0][3]) + (mat1[2][1] * mat2[1][3]) + (mat1[2][2] * mat2[2][3]) + (mat1[2][3] * mat2[3][3]);
    6,072 ( 0.00%)      product[3][0] =
  182,160 ( 0.00%)          (mat1[3][0] * mat2[0][0]) + (mat1[3][1] * mat2[1][0]) + (mat1[3][2] * mat2[2][0]) + (mat1[3][3] * mat2[3][0]);
    6,072 ( 0.00%)      product[3][1] =
  182,160 ( 0.00%)          (mat1[3][0] * mat2[0][1]) + (mat1[3][1] * mat2[1][1]) + (mat1[3][2] * mat2[2][1]) + (mat1[3][3] * mat2[3][1]);
    6,072 ( 0.00%)      product[3][2] =
  182,160 ( 0.00%)          (mat1[3][0] * mat2[0][2]) + (mat1[3][1] * mat2[1][2]) + (mat1[3][2] * mat2[2][2]) + (mat1[3][3] * mat2[3][2]);
    6,072 ( 0.00%)      product[3][3] =
  182,160 ( 0.00%)          (mat1[3][0] * mat2[0][3]) + (mat1[3][1] * mat2[1][3]) + (mat1[3][2] * mat2[2][3]) + (mat1[3][3] * mat2[3][3]);
   36,432 ( 0.00%)      mtxf_copy_n_element((s32*) dest, (s32*) product, 16);
1,354,056 ( 0.00%)  => src/racing/math_util.c:mtxf_copy_n_element (6,072x)
   18,216 ( 0.00%)  }
        .           
        .           /**
        .            * Convert float matrix 'src' to fixed point matrix 'dest'.
        .            * The float matrix may not contain entries larger than 65536 or the console
        .            * crashes. The fixed point matrix has entries with a 16-bit integer part, so
        .            * the floating point numbers are multiplied by 2^16 before being cast to a s32
        .            * integer. If this doesn't fit, the N64 and iQue consoles will throw an
        .            * exception. On Wii and Wii U Virtual Console the value will simply be clamped
        .            * and no crashes occur.
        .            */
  170,765 ( 0.00%)  void mtxf_to_mtx(Mtx* dest, Mat4 src) {
        .           #ifdef AVOID_UB
        .               // Avoid type-casting which is technically UB by calling the equivalent
        .               // guMtxF2L function. This helps little-endian systems, as well.
  170,765 ( 0.00%)      guMtxF2L(src, dest);
16,837,429 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guMtxF2L.c:guMtxF2L (34,153x)
        .           #else
        .               s32 asFixedPoint;
        .               register s32 i;
        .               register s16* a3 = (s16*) dest;      // all integer parts stored in first 16 bytes
        .               register s16* t0 = (s16*) dest + 16; // all fraction parts stored in last 16 bytes
        .               register f32* t1 = (f32*) src;
        .           
        .               for (i = 0; i < 16; i++) {
        .                   asFixedPoint = *t1++ * (1 << 16);         //! float-to-integer conversion responsible for PU crashes
        .                   *a3++ = GET_HIGH_S16_OF_32(asFixedPoint); // integer part
        .                   *t0++ = GET_LOW_S16_OF_32(asFixedPoint);  // fraction part
        .               }
        .           #endif
  102,459 ( 0.00%)  }
        .           
        .           /**
        .            * Comment from sm64 unverified. mk64 verison is modified
        .            *
        .            * Helper function for atan2s. Does a look up of the arctangent of y/x assuming
        .            * the resulting angle is in range [0, 0x2000] (1/8 of a circle).
        .            */
        .           
  134,832 ( 0.00%)  u16 atan2_lookup(f32 y, f32 x) {
        .               u16 ret;
        .           
  202,248 ( 0.00%)      if (x == 0) {
        .                   ret = gArctanTable[0];
        .               } else {
  134,832 ( 0.00%)          if (1000000.0f < y / x) {
        .                       if (y > 0.0f) {
        .                           ret = 0x4000;
        .                       } else {
        .                           ret = 0xC000;
        .                       }
        .                   } else {
  370,788 ( 0.00%)              ret = gArctanTable[(s32) (y / x * 1024 + 0.5f)];
        .                   }
        .               }
   33,708 ( 0.00%)      return ret;
   67,416 ( 0.00%)  }
        .           
        .           /**
        .            * Compute the angle from (0, 0) to (x, y) as a u16. Given that terrain is in
        .            * the xz-plane, this is commonly called with (z, x) to get a yaw angle.
        .            * sm64 but x, y swapped and returns u16.
        .            */
  168,540 ( 0.00%)  u16 atan2s(f32 x, f32 y) {
        .               u16 ret;
  134,832 ( 0.00%)      if (x >= 0) {
  114,228 ( 0.00%)          if (y >= 0) {
   60,177 ( 0.00%)              if (y >= x) {
  118,132 ( 0.00%)                  ret = atan2_lookup(x, y);
  472,528 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (16,876x)
        .                       } else {
   31,830 ( 0.00%)                  ret = 0x4000 - atan2_lookup(y, x);
   89,124 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (3,183x)
        .                       }
        .                   } else {
   33,992 ( 0.00%)              y = -y;
   25,494 ( 0.00%)              if (y < x) {
   22,240 ( 0.00%)                  ret = 0x4000 + atan2_lookup(y, x);
   77,840 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (2,780x)
        .                       } else {
   57,180 ( 0.00%)                  ret = 0x8000 - atan2_lookup(x, y);
  160,104 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (5,718x)
        .                       }
        .                   }
        .               } else {
   20,604 ( 0.00%)          x = -x;
   15,453 ( 0.00%)          if (y < 0) {
   13,248 ( 0.00%)              y = -y;
    9,936 ( 0.00%)              if (y >= x) {
   22,296 ( 0.00%)                  ret = 0x8000 + atan2_lookup(x, y);
   78,036 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (2,787x)
        .                       } else {
    5,250 ( 0.00%)                  ret = 0xC000 - atan2_lookup(y, x);
   14,700 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (525x)
        .                       }
        .                   } else {
    5,517 ( 0.00%)              if (y < x) {
    7,048 ( 0.00%)                  ret = 0xC000 + atan2_lookup(y, x);
   24,668 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (881x)
        .                       } else {
    6,706 ( 0.00%)                  ret = -atan2_lookup(x, y);
   26,824 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (958x)
        .                       }
        .                   }
        .               }
   33,708 ( 0.00%)      return ret;
   67,416 ( 0.00%)  }
        .           
        .           f32 atan2f(f32 arg0, f32 arg1) {
        .               return atan2s(arg0, arg1);
        .           }
        .           
        .           #ifndef NON_MATCHING // The decomp does not support fabs
        .           UNUSED f32 func_802B79F0(f32 arg0, f32 arg1) {
        .               f64 halfpi;
-- line 955 ----------------------------------------
-- line 996 ----------------------------------------
        .           UNUSED u16 func_802B7B50(f32 arg0, f32 arg1) {
        .               return ((atan2f(arg0, arg1) * 32768.0f) / M_PI);
        .           }
        .           
        .           UNUSED void func_802B7C18(f32 arg0) {
        .               atan2f(arg0, 1.0f);
        .           }
        .           
   33,600 ( 0.00%)  s16 func_802B7C40(f32 arg0) {
   33,600 ( 0.00%)      return atan2s(arg0, 1.0f);
  453,600 ( 0.00%)  => src/racing/math_util.c:atan2s (8,400x)
   16,800 ( 0.00%)  }
        .           
        .           UNUSED void func_802B7C6C(f32 arg0) {
        .               atan2f(arg0, sqrtf(1.0 - (arg0 * arg0)));
        .           }
        .           
   14,876 ( 0.00%)  s16 func_802B7CA8(f32 arg0) {
   48,347 ( 0.00%)      return atan2s(arg0, sqrtf(1.0 - (arg0 * arg0)));
  200,829 ( 0.00%)  => src/racing/math_util.c:atan2s (3,719x)
   29,752 ( 0.00%)  => ???:sqrtf (3,719x)
    7,438 ( 0.00%)  }
        .           
        .           f32 calculate_vector_angle_xy(f32 vectorX) {
        .               return atan2f(sqrtf(1.0 - (vectorX * vectorX)), vectorX);
        .           }
        .           
        .           UNUSED s16 func_802B7D28(f32 arg0) {
        .               return atan2f(sqrtf(1.0 - (f64) (arg0 * arg0)), arg0) * 32768.0f / M_PI;
        .           }
        .           
   84,250 ( 0.00%)  u16 random_u16(void) {
        .               u16 temp1, temp2;
        .           
  168,500 ( 0.00%)      if (gRandomSeed16 == 22026) {
        .                   gRandomSeed16 = 0;
        .               }
        .           
  168,500 ( 0.00%)      temp1 = (gRandomSeed16 & 0x00FF) << 8;
  126,375 ( 0.00%)      temp1 = temp1 ^ gRandomSeed16;
        .           
  168,500 ( 0.00%)      gRandomSeed16 = ((temp1 & 0x00FF) << 8) + ((temp1 & 0xFF00) >> 8);
        .           
  337,000 ( 0.00%)      temp1 = ((temp1 & 0x00FF) << 1) ^ gRandomSeed16;
  168,500 ( 0.00%)      temp2 = (temp1 >> 1) ^ 0xFF80;
        .           
  168,500 ( 0.00%)      if ((temp1 & 1) == 0) {
   42,186 ( 0.00%)          if (temp2 == 43605) {
        .                       gRandomSeed16 = 0;
        .                   } else {
  126,558 ( 0.00%)              gRandomSeed16 = temp2 ^ 0x1FF4;
        .                   }
        .               } else {
  105,160 ( 0.00%)          gRandomSeed16 = temp2 ^ 0x8180;
        .               }
        .           
   84,250 ( 0.00%)      return gRandomSeed16;
   84,250 ( 0.00%)  }
        .           
  210,460 ( 0.00%)  u16 random_int(u16 arg0) {
  463,012 ( 0.00%)      return arg0 * (((f32) random_u16()) / 65535.0);
1,831,089 ( 0.00%)  => src/racing/math_util.c:random_u16 (42,092x)
   84,184 ( 0.00%)  }
        .           
       21 ( 0.00%)  s16 func_802B7F34(f32 arg0, f32 arg1, f32 arg2, f32 arg3) {
       21 ( 0.00%)      return atan2s(arg2 - arg0, arg3 - arg1);
      181 ( 0.00%)  => src/racing/math_util.c:atan2s (3x)
        6 ( 0.00%)  }
        .           
        7 ( 0.00%)  void func_802B7F7C(Vec3f arg0, Vec3f arg1, Vec3s dest) {
        3 ( 0.00%)      f32 x1 = arg0[0];
        3 ( 0.00%)      f32 y1 = arg0[1];
        3 ( 0.00%)      f32 z1 = arg0[2];
        .           
        3 ( 0.00%)      f32 x2 = arg1[0];
        3 ( 0.00%)      f32 y2 = arg1[1];
        3 ( 0.00%)      f32 z2 = arg1[2];
        .           
       12 ( 0.00%)      dest[1] = func_802B7F34(z1, x1, z2, x2);
       74 ( 0.00%)  => src/racing/math_util.c:func_802B7F34 (1x)
       11 ( 0.00%)      dest[0] = func_802B7F34(y1, z1, y2, z2);
       78 ( 0.00%)  => src/racing/math_util.c:func_802B7F34 (1x)
       12 ( 0.00%)      dest[2] = func_802B7F34(x1, y1, x2, y2);
       77 ( 0.00%)  => src/racing/math_util.c:func_802B7F34 (1x)
        4 ( 0.00%)  }
        .           
1,376,876 ( 0.00%)  f32 sins(u16 arg0) {
2,065,314 ( 0.00%)      return gSineTable[arg0 >> 4];
  688,438 ( 0.00%)  }
        .           
1,303,540 ( 0.00%)  f32 coss(u16 arg0) {
2,607,080 ( 0.00%)      return gCosineTable[arg0 >> 4];
  651,770 ( 0.00%)  }
        .           
  153,369 ( 0.00%)  s32 is_visible_between_angle(u16 arg0, u16 arg1, u16 arg2) {
   51,123 ( 0.00%)      if (arg1 < arg0) {
   51,123 ( 0.00%)          if (arg1 >= arg2) {
   23,728 ( 0.00%)              return 0;
        .                   }
   15,531 ( 0.00%)          if (arg2 >= arg0) {
    3,668 ( 0.00%)              return 0;
        .                   }
        .               } else {
        .                   if ((arg1 >= arg2) && (arg2 >= arg0)) {
        .                       return 0;
        .                   }
        .               }
    3,343 ( 0.00%)      return 1;
   34,082 ( 0.00%)  }
        .           
        .           /**
        .            * Determines whether an object is within the render distance of a camera.
        .            *
        .            * @param cameraPos       The position of the camera in 3D space.
        .            * @param objectPos       The position of the object in 3D space.
        .            * @param orientationY    The orientation angle of the object around the Y-axis.
        .            * @param minDistance     The minimum distance at which the object is considered within render distance.
        .            * @param fov             The field of view (FOV) of the camera.
        .            * @param maxDistance     The maximum render distance.
        .            * @return                The distance between the camera and the object if it's within render distance,
        .            *                        or -1.0f if it exceeds the render distance.
        .            */
        .           
        .           f32 is_within_render_distance(Vec3f cameraPos, Vec3f objectPos, u16 orientationY, f32 minDistance, f32 fov,
   96,280 ( 0.00%)                                f32 maxDistance) {
        .               u16 angleObject;
        .               UNUSED u16 pad;
        .               u16 temp_v0;
        .               f32 distanceX;
        .               f32 distance;
        .               f32 distanceY;
        .               s32 plus_fov_angle;
        .               s32 minus_fov_angle;
        .               u16 temp;
        .               UNUSED s32 pad2[3];
   28,884 ( 0.00%)      u16 extended_fov = ((u16) fov * 0xB6);
        .           
   57,768 ( 0.00%)      distanceX = objectPos[0] - cameraPos[0];
   28,884 ( 0.00%)      distanceX = distanceX * distanceX;
   28,884 ( 0.00%)      if (maxDistance < distanceX) {
        .                   return -1.0f;
        .               }
        .           
   77,024 ( 0.00%)      distanceY = objectPos[2] - cameraPos[2];
   28,884 ( 0.00%)      distanceY = distanceY * distanceY;
   28,884 ( 0.00%)      if (maxDistance < distanceY) {
        .                   return -1.0f;
        .               }
        .           
   28,884 ( 0.00%)      distance = distanceX + distanceY;
   28,884 ( 0.00%)      if (distance < minDistance) {
       50 ( 0.00%)          return distance;
        .               }
        .           
   28,809 ( 0.00%)      if (distance > maxDistance) {
        .                   return -1.0f;
        .               }
        .           
   57,618 ( 0.00%)      angleObject = get_angle_between_two_vectors(cameraPos, objectPos);
  825,067 ( 0.00%)  => src/racing/math_util.c:get_angle_between_two_vectors (9,603x)
   38,412 ( 0.00%)      minus_fov_angle = (orientationY - extended_fov);
   38,412 ( 0.00%)      plus_fov_angle = (orientationY + extended_fov);
        .           
   57,618 ( 0.00%)      if (minDistance == 0.0f) {
   51,792 ( 0.00%)          if (is_visible_between_angle((orientationY + extended_fov), (orientationY - extended_fov), angleObject) == 1) {
   80,241 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (3,984x)
    2,886 ( 0.00%)              return distance;
        .                   }
    5,082 ( 0.00%)          return -1.0f;
        .               }
        .           
   56,190 ( 0.00%)      if (is_visible_between_angle((u16) plus_fov_angle, (u16) minus_fov_angle, angleObject) == 1) {
  111,734 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (5,619x)
    3,800 ( 0.00%)          return distance;
        .               }
   22,314 ( 0.00%)      temp_v0 = func_802B7CA8(minDistance / distance);
  301,242 ( 0.00%)  => src/racing/math_util.c:func_802B7CA8 (3,719x)
   14,876 ( 0.00%)      temp = angleObject + temp_v0;
        .           
   37,190 ( 0.00%)      if (is_visible_between_angle(plus_fov_angle, minus_fov_angle, temp) == 1) {
   71,816 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (3,719x)
        .                   return distance;
        .               }
        .           
   11,157 ( 0.00%)      temp = angleObject - temp_v0;
   37,190 ( 0.00%)      if (is_visible_between_angle(plus_fov_angle, minus_fov_angle, temp) == 1) {
   72,176 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (3,719x)
        .                   return distance;
        .               }
    3,719 ( 0.00%)      return -1.0f;
   19,256 ( 0.00%)  }
        .           
        .           // No idea if arg1 is actually a Mat4 or not, but since this function is unused
        .           // its impossible to know with certainty either way, very close of func_802B5D64
        .           UNUSED void func_802B8414(uintptr_t addr, Mat4 arg1, s16 arg2, s16 arg3, s32 arg4) {
        .               UNUSED s32 pad;
        .               Vec3f sp40;
        .               s8 sp3C[3];
        .               s32 var_v0;
-- line 1180 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/os/guMtxF2L.c
--------------------------------------------------------------------------------
Ir                 

        .           #include "libultra_internal.h"
        .           #ifdef GBI_FLOATS
        .           #include <string.h>
        .           #endif
        .           
        .           #ifndef GBI_FLOATS
  198,848 ( 0.00%)  void guMtxF2L(float mf[4][4], Mtx* m) {
        .               int r, c;
        .               s32 tmp1;
        .               s32 tmp2;
   99,424 ( 0.00%)      s32* m1 = &m->m[0][0];
  149,136 ( 0.00%)      s32* m2 = &m->m[2][0];
  795,392 ( 0.00%)      for (r = 0; r < 4; r++) {
1,988,480 ( 0.00%)          for (c = 0; c < 2; c++) {
5,567,744 ( 0.00%)              tmp1 = mf[r][2 * c] * 65536.0f;
5,965,440 ( 0.00%)              tmp2 = mf[r][2 * c + 1] * 65536.0f;
4,772,352 ( 0.00%)              *m1++ = (tmp1 & 0xffff0000) | ((tmp2 >> 0x10) & 0xffff);
4,772,352 ( 0.00%)              *m2++ = ((tmp1 << 0x10) & 0xffff0000) | (tmp2 & 0xffff);
        .                   }
        .               }
  198,848 ( 0.00%)  }
        .           
        .           void guMtxL2F(float mf[4][4], Mtx* m) {
        .               int r, c;
        .               u32 tmp1;
        .               u32 tmp2;
        .               u32* m1;
        .               u32* m2;
        .               s32 stmp1, stmp2;
-- line 29 ----------------------------------------
-- line 41 ----------------------------------------
        .               }
        .           }
        .           #else
        .           void guMtxF2L(float mf[4][4], Mtx* m) {
        .               memcpy(m, mf, sizeof(Mtx));
        .           }
        .           #endif
        .           
    9,831 ( 0.00%)  void guMtxIdentF(float mf[4][4]) {
        .               int r, c;
   52,432 ( 0.00%)      for (r = 0; r < 4; r++) {
  209,728 ( 0.00%)          for (c = 0; c < 4; c++) {
  157,296 ( 0.00%)              if (r == c) {
  144,188 ( 0.00%)                  mf[r][c] = 1.0f;
        .                       } else {
  393,240 ( 0.00%)                  mf[r][c] = 0.0f;
        .                       }
        .                   }
        .               }
   13,108 ( 0.00%)  }
        .           
        .           void guMtxIdent(Mtx* m) {
        .           #ifndef GBI_FLOATS
        .               float mf[4][4];
        .               guMtxIdentF(mf);
        .               guMtxF2L(mf, m);
        .           #else
        .               guMtxIdentF(m->m);
-- line 68 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/utils/StrHash64.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 168 ----------------------------------------
        .               }
        .               return ~crc;
        .           }
        .           
        .           u64 crc64(const void* buf, unint len) {
        .               return update_crc64(buf, len, INITIAL_CRC64);
        .           }
        .           
   51,618 ( 0.00%)  u64 CRC64(const char* t) {
   17,206 ( 0.00%)      u64 crc = INITIAL_CRC64;
   34,412 ( 0.00%)      const u8* s = (const u8*)t;
2,392,030 ( 0.00%)      while (*s) {
8,647,500 ( 0.01%)          crc = CRC64_Table[(u8)(crc >> 56) ^ *s++] ^ (crc << 8);
        .               }
   17,206 ( 0.00%)      return crc;
   34,412 ( 0.00%)  }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_iterator.h
--------------------------------------------------------------------------------
Ir                 

-- line 696 ----------------------------------------
        .                 /// A nested typedef for the type of whatever container you used.
        .                 typedef _Container          container_type;
        .           #if __cplusplus > 201703L
        .                 using difference_type = ptrdiff_t;
        .           #endif
        .           
        .                 /// The only way to create this %iterator is with a container.
        .                 explicit _GLIBCXX20_CONSTEXPR
    9,835 ( 0.00%)        back_insert_iterator(_Container& __x)
   15,736 ( 0.00%)        : container(std::__addressof(__x)) { }
   11,802 ( 0.00%)  => /usr/include/c++/14/bits/move.h:fmt::v10::detail::buffer<char>* std::__addressof<fmt::v10::detail::buffer<char> >(fmt::v10::detail::buffer<char>&) (1,967x)
        .           
        .                 /**
        .                  *  @param  __value  An instance of whatever type
        .                  *                 container_type::const_reference is; presumably a
        .                  *                 reference-to-const T for container<T>.
        .                  *  @return  This %iterator, for chained operations.
        .                  *
        .                  *  This kind of %iterator doesn't really have a @a position in the
-- line 713 ----------------------------------------
-- line 728 ----------------------------------------
        .                 operator=(const typename _Container::value_type& __value)
        .                 {
        .           	container->push_back(__value);
        .           	return *this;
        .                 }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 back_insert_iterator&
1,181,526 ( 0.00%)        operator=(typename _Container::value_type&& __value)
        .                 {
1,575,368 ( 0.00%)  	container->push_back(std::move(__value));
4,135,341 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::push_back(char const&) (196,921x)
1,181,526 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<char&>::type&& std::move<char&>(char&) (196,921x)
  196,921 ( 0.00%)  	return *this;
  590,763 ( 0.00%)        }
        .           #endif
        .           
        .                 /// Simply returns *this.
        .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .                 back_insert_iterator&
  590,763 ( 0.00%)        operator*()
  590,763 ( 0.00%)        { return *this; }
        .           
        .                 /// Simply returns *this.  (This %iterator does not @a move.)
        .                 _GLIBCXX20_CONSTEXPR
        .                 back_insert_iterator&
        .                 operator++()
        .                 { return *this; }
        .           
        .                 /// Simply returns *this.  (This %iterator does not @a move.)
-- line 755 ----------------------------------------
-- line 1055 ----------------------------------------
        .                 typedef typename __traits_type::difference_type 	difference_type;
        .                 typedef typename __traits_type::reference 	reference;
        .                 typedef typename __traits_type::pointer   	pointer;
        .           
        .           #if __cplusplus > 201703L && __glibcxx_concepts
        .                 using iterator_concept = std::__detail::__iter_concept<_Iterator>;
        .           #endif
        .           
      156 ( 0.00%)        _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      260 ( 0.00%)        : _M_current(_Iterator()) { }
        .           
        .                 explicit _GLIBCXX20_CONSTEXPR
1,919,352 ( 0.00%)        __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
3,370,691 ( 0.00%)        : _M_current(__i) { }
        .           
        .                 // Allow iterator to const_iterator conversion
        .           #if __cplusplus >= 201103L
        .                 template<typename _Iter, typename = __convertible_from<_Iter>>
        .           	_GLIBCXX20_CONSTEXPR
        .           	__normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
        .           	noexcept
        .           #else
-- line 1076 ----------------------------------------
-- line 1082 ----------------------------------------
        .           	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
        .           		      _Container>::__type>& __i)
        .           #endif
        .                   : _M_current(__i.base()) { }
        .           
        .                 // Forward iterator requirements
        .                 _GLIBCXX20_CONSTEXPR
        .                 reference
  360,600 ( 0.00%)        operator*() const _GLIBCXX_NOEXCEPT
  480,800 ( 0.00%)        { return *_M_current; }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 pointer
        .                 operator->() const _GLIBCXX_NOEXCEPT
        .                 { return _M_current; }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 __normal_iterator&
  289,935 ( 0.00%)        operator++() _GLIBCXX_NOEXCEPT
        .                 {
  483,397 ( 0.00%)  	++_M_current;
   96,725 ( 0.00%)  	return *this;
  193,290 ( 0.00%)        }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 __normal_iterator
        .                 operator++(int) _GLIBCXX_NOEXCEPT
        .                 { return __normal_iterator(_M_current++); }
        .           
        .                 // Bidirectional iterator requirements
        .                 _GLIBCXX20_CONSTEXPR
-- line 1112 ----------------------------------------
-- line 1130 ----------------------------------------
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 __normal_iterator&
        .                 operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
        .                 { _M_current += __n; return *this; }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 __normal_iterator
    9,195 ( 0.00%)        operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
   26,047 ( 0.00%)        { return __normal_iterator(_M_current + __n); }
       22 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >::__normal_iterator(Ship::CommandArgument* const&) (2x)
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 __normal_iterator&
        .                 operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
        .                 { _M_current -= __n; return *this; }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 __normal_iterator
  112,060 ( 0.00%)        operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
  327,164 ( 0.00%)        { return __normal_iterator(_M_current - __n); }
       22 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<unsigned int*, std::vector<unsigned int, std::allocator<unsigned int> > >::__normal_iterator(unsigned int* const&) (2x)
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 const _Iterator&
1,887,156 ( 0.00%)        base() const _GLIBCXX_NOEXCEPT
1,887,156 ( 0.00%)        { return _M_current; }
        .               };
        .           
        .             // Note: In what follows, the left- and right-hand-side iterators are
        .             // allowed to vary in types (conceptually in cv-qualification) so that
        .             // comparison between cv-qualified and non-cv-qualified iterators be
        .             // valid.  However, the greedy and unfriendly operators in std::rel_ops
        .             // will make overload resolution ambiguous (when in scope) if we don't
        .             // provide overloads whose operands are of the same type.  Can someone
-- line 1162 ----------------------------------------
-- line 1180 ----------------------------------------
        .               operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
        .           		const __normal_iterator<_IteratorR, _Container>& __rhs)
        .               noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
        .               { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
        .           
        .             template<typename _Iterator, typename _Container>
        .               [[nodiscard]]
        .               constexpr bool
1,790,520 ( 0.00%)      operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
        .               noexcept(noexcept(__lhs.base() == __rhs.base()))
        .               requires requires {
        .                 { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
        .               }
3,879,460 ( 0.00%)      { return __lhs.base() == __rhs.base(); }
       36 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >::base() const (6x)
        .           
        .             template<typename _Iterator, typename _Container>
        .               [[nodiscard]]
        .               constexpr std::__detail::__synth3way_t<_Iterator>
        .               operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
        .           		const __normal_iterator<_Iterator, _Container>& __rhs)
        .               noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
        .               { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
-- line 1202 ----------------------------------------
-- line 1211 ----------------------------------------
        .               { return __lhs.base() == __rhs.base(); }
        .           
        .             template<typename _Iterator, typename _Container>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline bool
        .               operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
        .               _GLIBCXX_NOEXCEPT
       20 ( 0.00%)      { return __lhs.base() == __rhs.base(); }
        .           
        .             template<typename _IteratorL, typename _IteratorR, typename _Container>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline bool
        .               operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        .           	       const __normal_iterator<_IteratorR, _Container>& __rhs)
        .               _GLIBCXX_NOEXCEPT
        .               { return __lhs.base() != __rhs.base(); }
        .           
        .             template<typename _Iterator, typename _Container>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline bool
        .               operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
        .               _GLIBCXX_NOEXCEPT
       20 ( 0.00%)      { return __lhs.base() != __rhs.base(); }
        .           
        .             // Random access iterator requirements
        .             template<typename _IteratorL, typename _IteratorR, typename _Container>
        .               _GLIBCXX_NODISCARD
        .               inline bool
        .               operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
        .           	      const __normal_iterator<_IteratorR, _Container>& __rhs)
        .               _GLIBCXX_NOEXCEPT
-- line 1243 ----------------------------------------
-- line 1317 ----------------------------------------
        .               operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
        .           	      const __normal_iterator<_IteratorR, _Container>& __rhs)
        .           #endif
        .               { return __lhs.base() - __rhs.base(); }
        .           
        .             template<typename _Iterator, typename _Container>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline typename __normal_iterator<_Iterator, _Container>::difference_type
   88,722 ( 0.00%)      operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
        .           	      const __normal_iterator<_Iterator, _Container>& __rhs)
        .               _GLIBCXX_NOEXCEPT
  220,718 ( 0.00%)      { return __lhs.base() - __rhs.base(); }
       36 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<F3DGfx const**, std::vector<F3DGfx const*, std::allocator<F3DGfx const*> > >::base() const (6x)
        .           
        .             template<typename _Iterator, typename _Container>
        .               _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
        .               inline __normal_iterator<_Iterator, _Container>
        .               operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
        .           	      __n, const __normal_iterator<_Iterator, _Container>& __i)
        .               _GLIBCXX_NOEXCEPT
        .               { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
-- line 1336 ----------------------------------------
-- line 1340 ----------------------------------------
        .           
        .           namespace std _GLIBCXX_VISIBILITY(default)
        .           {
        .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
        .           
        .             template<typename _Iterator, typename _Container>
        .               _GLIBCXX20_CONSTEXPR
        .               _Iterator
   10,552 ( 0.00%)      __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
        .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
   15,828 ( 0.00%)      { return __it.base(); }
       60 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<unsigned short const*, std::vector<unsigned short, std::allocator<unsigned short> > >::base() const (10x)
        .           
        .           #if __cplusplus >= 201103L
        .           
        .           #if __cplusplus <= 201703L
        .             // Need to overload __to_address because the pointer_traits primary template
        .             // will deduce element_type of __normal_iterator<T*, C> as T* rather than T.
        .             template<typename _Iterator, typename _Container>
        .               constexpr auto
-- line 1358 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/code_80091750.c
--------------------------------------------------------------------------------
Ir                 

-- line 1150 ----------------------------------------
        .           
        .               temp = *arg0;
        .               *arg0 = *arg1;
        .               *arg1 = temp;
        .           }
        .           
        .           extern s8 D_800E852C;
        .           
        3 ( 0.00%)  void func_80091B78(void) {
        1 ( 0.00%)      s32 why = 0;
        .               s32 i;
        .           
        4 ( 0.00%)      if (D_800E852C) {
        4 ( 0.00%)          D_800E852C = why;
        2 ( 0.00%)          D_8018EDF4 = 10;
        2 ( 0.00%)          D_8018EDF5 = 5;
        2 ( 0.00%)          D_8018EDF6 = 10;
        3 ( 0.00%)          if (osEepromProbe(&gSIEventMesgQueue) != 0) {
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/libultra/os_eeprom.cpp:osEepromProbe (1x)
        .                       // save data disabled for now due to array overflow
        .                       // load_save_data();
        .                   }
        3 ( 0.00%)          if (func_80091D74() != 0) {
       22 ( 0.00%)  => src/code_80091750.c:func_80091D74 (1x)
        .                       gMenuSelection = CONTROLLER_PAK_MENU;
        .                   }
        .               }
        4 ( 0.00%)      if (gMenuSelection == LOGO_INTRO_MENU) {
        .                   gNextFreeMemoryAddress = gFreeMemoryResetAnchor;
        .           #ifdef TARGET_N64
        .                   set_segment_base_addr(6, decompress_segments((u8*) STARTUP_LOGO_ROM_START, (u8*) STARTUP_LOGO_ROM_END));
        .           #endif
        .               }
        4 ( 0.00%)      gNextFreeMemoryAddress = gFreeMemoryResetAnchor;
        .               // Hypothetically, this should be a ptr... But only hypothetically.
        4 ( 0.00%)      D_8018D9B0 = get_next_available_memory_addr(0x000900B0);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B4 = (u8*) get_next_available_memory_addr(0x0000CE00);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B8 = (u8*) get_next_available_memory_addr(0x00012C00);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9C0 = (struct_8018EE10_entry*) get_next_available_memory_addr(0x00001000);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        1 ( 0.00%)      func_800AF9B0();
   17,413 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_800AF9B0.c:func_800AF9B0 (1x)
        2 ( 0.00%)      D_8018EE0C = 0;
        .           
       19 ( 0.00%)      for (i = 0; i < 5; i++) {
       20 ( 0.00%)          D_8018E7AC[i] = 0;
        .               }
        .           
       16 ( 0.00%)      for (i = 0; i < 4; i++) {
       16 ( 0.00%)          D_8018E838[i] = 0;
        .               }
        .           
        3 ( 0.00%)      D_800DC5EC->screenStartX = 160;
        3 ( 0.00%)      D_800DC5EC->screenStartY = 120;
        3 ( 0.00%)      D_800DC5EC->screenWidth = SCREEN_WIDTH;
        3 ( 0.00%)      D_800DC5EC->screenHeight = SCREEN_HEIGHT;
        2 ( 0.00%)      D_800E86A4 = 1;
        1 ( 0.00%)      render_menus();
  186,264 ( 0.00%)  => src/code_80091750.c:render_menus (1x)
        .           
       16 ( 0.00%)      for (i = 0; i < 4; i++) {
       16 ( 0.00%)          func_800C97C4((u8) i);
    1,512 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/audio/external.c:func_800C97C4 (4x)
        .               }
        .           
       25 ( 0.00%)      for (i = 1; i < 8; i++) {
       28 ( 0.00%)          func_800C9D0C((u8) i);
    2,107 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/audio/external.c:func_800C9D0C (7x)
        .               }
        .           
        1 ( 0.00%)      func_800B44BC();
       41 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/menus.c:func_800B44BC (1x)
        2 ( 0.00%)      osViSetSpecialFeatures(OS_VI_DITHER_FILTER_ON);
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/libultra/os_vi.cpp:osViSetSpecialFeatures (1x)
        3 ( 0.00%)  }
        .           
        3 ( 0.00%)  s32 func_80091D74(void) {
        .               u8 sp67;
        .               UNUSED s32 pad[10];
        .               s32 i;
        .           
        4 ( 0.00%)      if (!gControllerBits) {
        .                   return 0;
        .               }
        4 ( 0.00%)      if ((!gControllerStatuses[0].status) & CONT_CARD_ON) {
        .                   return 0;
        .               }
        7 ( 0.00%)      if (!(gControllerOne->button & START_BUTTON)) {
        2 ( 0.00%)          return 0;
        .               }
        .               osPfsIsPlug(&gSIEventMesgQueue, &sp67);
        .               if (sp67 & 1) {
        .                   if (osPfsInit(&gSIEventMesgQueue, &gControllerPak1FileHandle, 0)) {
        .                       return 0;
        .                   }
        .               } else {
        .                   return 0;
-- line 1237 ----------------------------------------
-- line 1245 ----------------------------------------
        .                   pfsError[i] = osPfsFileState(&gControllerPak1FileHandle, i, pfsState + i);
        .               }
        .           
        .               if (osPfsFreeBlocks(&gControllerPak1FileHandle, &gControllerPak1NumPagesFree)) {
        .                   return 0;
        .               }
        .               gControllerPak1NumPagesFree >>= 8;
        .               return 1;
        2 ( 0.00%)  }
        .           
        .           void func_80091EE4(void) {
        .               s32 temp_s0;
        .               s32 temp_s2;
        .               s32 tmp;
        .           
        .               gControllerPak1State = BAD;
        .               tmp = func_800B5F30();
-- line 1261 ----------------------------------------
-- line 1269 ----------------------------------------
        .                           func_800B64EC(temp_s0);
        .                           temp_s0 = 2;
        .                           D_8018EDFB = 0;
        .                       }
        .                   }
        .               }
        .           }
        .           
        3 ( 0.00%)  void func_80091FA4(void) {
        .               s32 i;
        .           
        .               //! @todo These sizes need to be sizeof() for shiftability if possible
        4 ( 0.00%)      D_8018D9B4 = (u8*) get_next_available_memory_addr(0x00002800);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B0 = (u16*) get_next_available_memory_addr(0x000124F8);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B8 = (u8*) get_next_available_memory_addr(0x00001000);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9BC = get_next_available_memory_addr(4);
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        .           
       19 ( 0.00%)      for (i = 0; i < 5; i++) {
       20 ( 0.00%)          D_8018E7AC[i] = 0;
        .               }
        .           
       16 ( 0.00%)      for (i = 0; i < 4; i++) {
       16 ( 0.00%)          D_8018E838[i] = 0;
        .               }
        .           
        1 ( 0.00%)      func_80099110();
        9 ( 0.00%)  => src/code_80091750.c:func_80099110 (1x)
        1 ( 0.00%)      func_8009A344();
      170 ( 0.00%)  => src/code_80091750.c:func_8009A344 (1x)
        1 ( 0.00%)      func_8009E620();
      394 ( 0.00%)  => src/code_80091750.c:func_8009E620 (1x)
        1 ( 0.00%)      func_80092258();
       34 ( 0.00%)  => src/code_80091750.c:func_80092258 (1x)
        5 ( 0.00%)      add_ui_element(0x00000096, 0x00000064, 0x00000024, 1);
       59 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)      add_ui_element(0x00000097, 0x00000064, 0x000000DD, 1);
       68 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)      add_ui_element(0x00000098, 0, 0, 0);
       77 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)      add_ui_element(0x000000C7, 0, 0, 0);
       86 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        4 ( 0.00%)      if (gModeSelection == TIME_TRIALS) {
        .                   add_ui_element(0x000000BE, 0, 0, 0);
        .                   add_ui_element(0x0000010E, 0, 0, 0);
        .               }
        4 ( 0.00%)      if ((D_8015F890 != 0) && (gModeSelection == TIME_TRIALS)) {
        .                   add_ui_element(0x000000BD, 0, 0, 0);
        .               }
        6 ( 0.00%)      if (!(gControllerBits & 1) && (D_8018EE08 != 0)) {
        .                   add_ui_element(4, 0, 0, 2);
        .               }
        1 ( 0.00%)      func_800B5F30();
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:func_800B5F30 (1x)
        3 ( 0.00%)  }
        .           
      664 ( 0.00%)  void func_80092148(void) {
      996 ( 0.00%)      struct Controller* controller = gControllerFive;
        .               s32 isHeld;
        .           
    1,992 ( 0.00%)      isHeld = controller->button ? 1 : 0;
        .           
    1,328 ( 0.00%)      if (controller->buttonPressed) {
        2 ( 0.00%)          D_8018D9D9 = 1;
        .               }
      740 ( 0.00%)      if ((isHeld) && (D_8018D9D9)) {
       38 ( 0.00%)          D_8018D9D8 = 1;
       19 ( 0.00%)          return;
        .               }
      626 ( 0.00%)      D_8018D9D8 = 0;
      664 ( 0.00%)  }
        .           
        .           void func_800921B4(void) {
        .               D_8018D9D9 = 0;
        .           }
        .           
        .           // if selected and detect kind menu
        .           void text_rainbow_effect(s32 test, s32 target, s32 alternative_color) {
        .               if (test == target) {
-- line 1337 ----------------------------------------
-- line 1348 ----------------------------------------
        .           void set_text_color_rainbow_if_selected(s32 test, s32 target, s32 alternative_color) {
        .               if (test == target) {
        .                   set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        .               } else {
        .                   set_text_color(alternative_color);
        .               }
        .           }
        .           
        4 ( 0.00%)  void func_80092258(void) {
        .               s32 i;
        .           
       20 ( 0.00%)      for (i = 0; i < 2; i++) {
       20 ( 0.00%)          D_8018E850[i] = i;
       16 ( 0.00%)          D_8018E858[i] = 0;
        .               }
        8 ( 0.00%)  }
        .           
    4,812 ( 0.00%)  void func_80092290(s32 arg0, s32* arg1, s32* arg2) {
        .               s32 temp_v1;
        .               s32 i;
        .               s32 idx;
        .               s32 temp_t6;
        .               s32 temp_t7;
        .               s32 temp_t8_2;
        .               s32 temp_t9;
        .               s32 temp_t0;
        .               s32 a, b, c, d;
        .               Vtx* vtx;
        .           
    3,208 ( 0.00%)      if ((arg0 < 4) || (arg0 >= 6)) {
        .                   return;
        .               }
        .           
   12,030 ( 0.00%)      idx = (((arg0 * 4) + ((gGlobalTimer % 2) * 2)) - 6);
        .           
    4,010 ( 0.00%)      *arg2 += 16;
    3,208 ( 0.00%)      if (*arg2 >= 256) {
       96 ( 0.00%)          *arg2 = 0;
      816 ( 0.00%)          *arg1 = (s32) (*arg1 + 1) % 3;
        .               }
        .           
   11,228 ( 0.00%)      for (i = 0; i < 3; i++) {
   52,932 ( 0.00%)          vtx = (Vtx*) LOAD_ASSET(D_800E84C0[i]);
28,358,172 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (2,406x)
  153,984 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (2,406x)
        .           
   12,030 ( 0.00%)          temp_v1 = (*arg1 * 2) + 2;
        .           
   33,684 ( 0.00%)          temp_t6 = (vtx + temp_v1)->v.cn[0] * (256 - *arg2);
   33,684 ( 0.00%)          temp_t9 = (vtx + temp_v1)->v.cn[1] * (256 - *arg2);
   33,684 ( 0.00%)          temp_t7 = (vtx + temp_v1)->v.cn[2] * (256 - *arg2);
   33,684 ( 0.00%)          temp_t8_2 = (vtx + temp_v1)->v.cn[3] * (256 - *arg2);
        .           
   45,714 ( 0.00%)          temp_v1 = (((*arg1 * 2) + 2) % 6) + 2;
   28,872 ( 0.00%)          a = ((vtx + temp_v1)->v.cn[0] * *arg2);
   28,872 ( 0.00%)          b = ((vtx + temp_v1)->v.cn[1] * *arg2);
   28,872 ( 0.00%)          c = ((vtx + temp_v1)->v.cn[2] * *arg2);
   28,872 ( 0.00%)          d = ((vtx + temp_v1)->v.cn[3] * *arg2);
        .           
   38,496 ( 0.00%)          (vtx + idx)->v.cn[0] = (temp_t6 + a) / 256;
   38,496 ( 0.00%)          (vtx + idx)->v.cn[1] = (temp_t9 + b) / 256;
   38,496 ( 0.00%)          (vtx + idx)->v.cn[2] = (temp_t7 + c) / 256;
   38,496 ( 0.00%)          (vtx + idx)->v.cn[3] = (temp_t8_2 + d) / 256;
        .           
   40,902 ( 0.00%)          (vtx + idx + 1)->v.cn[0] = (temp_t6 + a) / 256;
   40,902 ( 0.00%)          (vtx + idx + 1)->v.cn[1] = (temp_t9 + b) / 256;
   40,902 ( 0.00%)          (vtx + idx + 1)->v.cn[2] = (temp_t7 + c) / 256;
   40,902 ( 0.00%)          (vtx + idx + 1)->v.cn[3] = (temp_t8_2 + d) / 256;
        .               }
    1,604 ( 0.00%)  }
        .           
        .           void func_80092500(void) {
        .           
        .               switch (gModeSelection) {
        .                   case GRAND_PRIX:
        .                       add_ui_element(0xAA, 0, 0, 0);
        .                       break;
        .                   case TIME_TRIALS:
-- line 1423 ----------------------------------------
-- line 1566 ----------------------------------------
        .           
        .           void func_80092C80(void) {
        .               D_8018ED91 = 1;
        .           }
        .           
        .           // Originally func_80092C90
        .           // Some kind of lookup function, seems to return an index to be used
        .           // to get a character's width in pixels
   16,720 ( 0.00%)  s32 char_to_glyph_index(char* character) {
        .               s32 var_v1;
        .               s8 temp_v0;
        .           
   12,540 ( 0.00%)      temp_v0 = *character;
    4,180 ( 0.00%)      var_v1 = 1;
   15,390 ( 0.00%)      if ((temp_v0 >= 'a') && (temp_v0 <= 'z')) {
   14,060 ( 0.00%)          var_v1 = temp_v0 - 0x61;
    1,850 ( 0.00%)      } else if ((temp_v0 >= 'A') && (temp_v0 <= 'Z')) {
    1,040 ( 0.00%)          var_v1 = temp_v0 - 0x41;
      810 ( 0.00%)      } else if ((temp_v0 >= '0') && (temp_v0 <= '9')) {
        .                   var_v1 = temp_v0 - 0x10;
      810 ( 0.00%)      } else if (temp_v0 == ' ') {
      810 ( 0.00%)          var_v1 = -1;
        .               } else if (temp_v0 < 0) {
        .                   // Handling EUC-JUP characters
        .                   switch (temp_v0) { /* irregular */
        .                       case -92:      // 0xA4
        .                           var_v1 = func_80092E1C(character + 1);
        .                           break;
        .                       case -91: // 0xA5
        .                           var_v1 = func_80092DF8(character + 1);
-- line 1595 ----------------------------------------
-- line 1636 ----------------------------------------
        .                       case ',':
        .                           var_v1 = 0x0000002E;
        .                           break;
        .                       default:
        .                           var_v1 = -2;
        .                           break;
        .                   }
        .               }
    4,180 ( 0.00%)      return var_v1;
    8,360 ( 0.00%)  }
        .           
        .           s32 func_80092DF8(char* arg) {
        .               return func_80092E1C(arg) + 0x50;
        .           }
        .           
        .           s32 func_80092E1C(char* character) {
        .               s32 ret;
        .               UNUSED s32 test;
-- line 1653 ----------------------------------------
-- line 1776 ----------------------------------------
        .                       break;
        .                   default: /* switch 3 */
        .                       var_v1 = 2;
        .               }
        .               return var_v1;
        .           }
        .           
        .           // Originally func_80093034
        8 ( 0.00%)  s32 get_string_width(char* buffer) {
        .               s32 glyphIndex;
        2 ( 0.00%)      s32 stringWidth = 0;
        .           
        8 ( 0.00%)      if (*buffer != 0) {
        .                   do {
       84 ( 0.00%)              glyphIndex = char_to_glyph_index(buffer);
      407 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (21x)
       42 ( 0.00%)              if (glyphIndex >= 0) {
      133 ( 0.00%)                  stringWidth += gGlyphDisplayWidth[glyphIndex];
        4 ( 0.00%)              } else if (glyphIndex == -1) {
        2 ( 0.00%)                  stringWidth += 7;
        .                       }
       42 ( 0.00%)              if (glyphIndex >= 0x30) {
        .                           buffer += 2;
        .                       } else {
       21 ( 0.00%)                  buffer += 1;
        .                       }
       84 ( 0.00%)          } while (*buffer != 0);
        .               }
        2 ( 0.00%)      return stringWidth;
        4 ( 0.00%)  }
        .           
      798 ( 0.00%)  void set_text_color(s32 arg0) {
    1,064 ( 0.00%)      gTextColor = arg0;
      798 ( 0.00%)  }
        .           
        .           UNUSED void func_800930E4(s32 arg0, s32 arg1, char* arg2) {
        .               set_text_color(TEXT_BLUE);
        .               func_80093324(arg0, arg1, arg2, 0, 1.0, 1.0);
        .           }
        .           
        .           // "tracking" is a uniform spacing between all characters in a given word
    1,419 ( 0.00%)  void print_text0(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY, s32 mode) {
      129 ( 0.00%)      s32 stringWidth = 0;
        .               s32 glyphIndex;
        .           
    1,161 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077A8);
1,538,432 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (129x)
      516 ( 0.00%)      if (*text != 0) {
        .                   do {
    5,676 ( 0.00%)              glyphIndex = char_to_glyph_index(text);
   27,735 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (1,419x)
    2,838 ( 0.00%)              if (glyphIndex >= 0) {
   10,320 ( 0.00%)                  load_menu_img((MkTexture*) segmented_to_virtual_dupe((const void*) gGlyphTextureLUT[glyphIndex]));
  203,448 ( 0.00%)  => src/code_80091750.c:load_menu_img (1,290x)
    7,740 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,290x)
    2,580 ( 0.00%)                  gDisplayListHead =
   21,930 ( 0.00%)                      print_letter(gDisplayListHead,
43,771,011 ( 0.04%)  => src/code_80091750.c:print_letter (1,290x)
    9,030 ( 0.00%)                                   (MkTexture*) segmented_to_virtual_dupe((const void*) gGlyphTextureLUT[glyphIndex]),
    7,740 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,290x)
    2,580 ( 0.00%)                                   column + (stringWidth * scaleX), row, mode, scaleX, scaleY);
   11,610 ( 0.00%)                  stringWidth += gGlyphDisplayWidth[glyphIndex] + tracking;
      516 ( 0.00%)              } else if ((glyphIndex != -2) && (glyphIndex == -1)) {
      516 ( 0.00%)                  stringWidth += tracking + 7;
        .                       } else {
        .                           gSPDisplayList(gDisplayListHead++, D_020077D8);
        .                           return;
        .                       }
    2,838 ( 0.00%)              if (glyphIndex >= 0x30) {
        .                           text += 2;
        .                       } else {
    1,419 ( 0.00%)                  text += 1;
        .                       }
    5,676 ( 0.00%)          } while (*text != 0);
        .               }
    1,161 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077D8);
1,553,048 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (129x)
      387 ( 0.00%)  }
        .           
    1,161 ( 0.00%)  void func_80093324(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
    1,419 ( 0.00%)      print_text0(column, row, text, tracking, scaleX, scaleY, 1);
47,191,456 ( 0.04%)  => src/code_80091750.c:print_text0 (129x)
      387 ( 0.00%)  }
        .           
        .           void func_80093358(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text0(column, row, text, tracking, scaleX, scaleY, 2);
        .           }
        .           
        .           // "tracking" is a uniform spacing between all characters in a given word
    1,507 ( 0.00%)  void print_text1(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY, s32 arg6) {
      274 ( 0.00%)      char* temp_string = text;
      137 ( 0.00%)      s32 stringWidth = 0;
        .               s32 glyphIndex;
        .               s32 sp60;
        .           
    6,165 ( 0.00%)      while (*temp_string != 0) {
    5,480 ( 0.00%)          glyphIndex = char_to_glyph_index(temp_string);
   26,304 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (1,370x)
    2,740 ( 0.00%)          if (glyphIndex >= 0) {
   17,262 ( 0.00%)              stringWidth += ((gGlyphDisplayWidth[glyphIndex] + tracking) * scaleX);
      548 ( 0.00%)          } else if ((glyphIndex != -2) && (glyphIndex == -1)) {
    1,096 ( 0.00%)              stringWidth += ((tracking + 7) * scaleX);
        .                   } else {
        .                       return;
        .                   }
    2,740 ( 0.00%)          if (glyphIndex >= 0x30) {
        .                       temp_string += 2;
        .                   } else {
    1,370 ( 0.00%)              temp_string += 1;
        .                   }
        .               }
        .           
    1,370 ( 0.00%)      switch (arg6) {
        .                   case 1:
        .                       // ???
        .                       do {
        .                       } while (0);
        .                   case 3:
      274 ( 0.00%)              column -= stringWidth;
      137 ( 0.00%)              break;
        .                   case 2:
        .                   case 4:
        .                       column -= stringWidth / 2;
        .                       break;
        .                   default:
        .                       break;
        .               }
        .           
      274 ( 0.00%)      if (arg6 < 3) {
      274 ( 0.00%)          sp60 = 1;
        .               } else {
        .                   sp60 = 2;
        .               }
        .           
    1,233 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077A8);
1,635,510 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (137x)
    6,165 ( 0.00%)      while (*text != 0) {
    5,480 ( 0.00%)          glyphIndex = char_to_glyph_index(text);
   26,304 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (1,370x)
    2,740 ( 0.00%)          if (glyphIndex >= 0) {
    9,864 ( 0.00%)              load_menu_img(segmented_to_virtual_dupe(gGlyphTextureLUT[glyphIndex]));
  143,702 ( 0.00%)  => src/code_80091750.c:load_menu_img (1,233x)
    7,398 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,233x)
   30,825 ( 0.00%)              gDisplayListHead = print_letter(gDisplayListHead, segmented_to_virtual_dupe(gGlyphTextureLUT[glyphIndex]),
40,049,430 ( 0.03%)  => src/code_80091750.c:print_letter (1,233x)
    7,398 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,233x)
        .                                                       column, row, sp60, scaleX, scaleY);
   14,796 ( 0.00%)              column = column + (s32) ((gGlyphDisplayWidth[glyphIndex] + tracking) * scaleX);
      548 ( 0.00%)          } else if ((glyphIndex != -2) && (glyphIndex == -1)) {
      959 ( 0.00%)              column = column + (s32) ((tracking + 7) * scaleX);
        .                   } else {
        .                       gSPDisplayList(gDisplayListHead++, D_020077D8);
        .                       return;
        .                   }
    2,740 ( 0.00%)          if (glyphIndex >= 0x30) {
        .                       text += 2;
        .                   } else {
    1,370 ( 0.00%)              text += 1;
        .                   }
        .               }
    1,370 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077D8);
1,651,252 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (137x)
      411 ( 0.00%)  }
        .           
    1,233 ( 0.00%)  void func_800936B8(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
    1,507 ( 0.00%)      print_text1(column, row, text, tracking, scaleX, scaleY, 1);
43,667,447 ( 0.04%)  => src/code_80091750.c:print_text1 (137x)
      411 ( 0.00%)  }
        .           
        .           void draw_text(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text1(column, row, text, tracking, scaleX, scaleY, 2);
        .           }
        .           
        .           void func_80093720(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text1(column, row, text, tracking, scaleX, scaleY, 3);
        .           }
-- line 1933 ----------------------------------------
-- line 1977 ----------------------------------------
        .           void func_800939C8(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text2(column, row, text, tracking, scaleX, scaleY, 1);
        .           }
        .           
        .           void text_draw(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text2(column, row, text, tracking, scaleX, scaleY, 2);
        .           }
        .           
    1,328 ( 0.00%)  void func_80093A30(s32 arg0) {
    2,324 ( 0.00%)      func_8009E2A8(D_800F0B1C[arg0]);
    4,980 ( 0.00%)  => src/code_80091750.c:func_8009E2A8 (332x)
      996 ( 0.00%)  }
        .           
    1,328 ( 0.00%)  void func_80093A5C(u32 arg0) {
    1,328 ( 0.00%)      if (D_8015F788 == 0) {
      332 ( 0.00%)          func_8009C918();
   83,996 ( 0.00%)  => src/code_80091750.c:func_8009C918 (332x)
        .               }
    1,992 ( 0.00%)      switch (arg0) {
        .                   case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    1,992 ( 0.00%)              func_800940EC((s32) D_800F0B1C[arg0]);
140,757,669 ( 0.12%)  => src/code_80091750.c:func_800940EC (332x)
      332 ( 0.00%)              break;
        .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
        .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
        .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_ONE:
        .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_TWO:
        .                       if (D_8015F788 == 0) {
        .                           func_80093C1C((s32) D_800F0B1C[arg0]);
        .                       } else {
        .                           func_800940EC((s32) D_800F0B1C[arg0]);
-- line 2004 ----------------------------------------
-- line 2010 ----------------------------------------
        .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
        .                       if (D_8015F788 == 3) {
        .                           func_800940EC((s32) D_800F0B1C[arg0]);
        .                       } else {
        .                           func_80093C1C((s32) D_800F0B1C[arg0]);
        .                       }
        .                       break;
        .               }
    3,652 ( 0.00%)      gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
      996 ( 0.00%)  }
        .           
        .           UNUSED void func_80093B70(u32 arg0) {
        .               if ((arg0 == 0) || (arg0 == 2) || (arg0 == 3) || (arg0 == 8)) {
        .                   func_8009C918();
        .               }
        .               switch (arg0) {
        .                   case 0:
        .                       func_800940EC(0);
-- line 2027 ----------------------------------------
-- line 2056 ----------------------------------------
        .           UNUSED void func_80093C88(void) {
        .               return;
        .           }
        .           
        .           UNUSED void func_80093C90(void) {
        .               return;
        .           }
        .           
    1,604 ( 0.00%)  void func_80093C98(s32 arg0) {
    4,812 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    7,619 ( 0.00%)      guOrtho(&gGfxPool->mtxEffect[gMatrixEffectCount], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
  514,884 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guOrthoF.c:guOrtho (401x)
   10,025 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount++]),
        .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    3,609 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007F18);
4,801,258 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (401x)
    4,411 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
      401 ( 0.00%)      func_800A8250();
5,827,439 ( 0.00%)  => src/code_80091750.c:func_800A8250 (401x)
      802 ( 0.00%)      if (arg0 == 0) {
      332 ( 0.00%)          func_800A54EC();
    3,320 ( 0.00%)  => src/code_80091750.c:func_800A54EC (332x)
      664 ( 0.00%)          func_8009CA6C(4);
3,981,231 ( 0.00%)  => src/code_80091750.c:func_8009CA6C (332x)
    1,660 ( 0.00%)          D_80165754 = gMatrixEffectCount;
      664 ( 0.00%)          gMatrixEffectCount = 0;
        .               }
    1,203 ( 0.00%)  }
        .           
      664 ( 0.00%)  void func_80093E20(void) {
      664 ( 0.00%)      func_80093C98(0);
13,248,188 ( 0.01%)  => src/code_80091750.c:func_80093C98 (332x)
      996 ( 0.00%)  }
        .           
      138 ( 0.00%)  void func_80093E40(void) {
      138 ( 0.00%)      func_80093C98(1);
1,917,750 ( 0.00%)  => src/code_80091750.c:func_80093C98 (69x)
      207 ( 0.00%)  }
        .           
        .           void func_80093E60(void) {
        .               s32 i;
        .           
        .               D_8018D9B4 = get_next_available_memory_addr(0x00002800);
        .               D_8018D9B0 = (u16*) get_next_available_memory_addr(0x000124F8);
        .               D_8018D9B8 = get_next_available_memory_addr(0x00001000);
        .               D_8018D9BC = get_next_available_memory_addr(4U);
-- line 2094 ----------------------------------------
-- line 2123 ----------------------------------------
        .               func_800A8230();
        .               func_80099AEC();
        .               func_80099EC4();
        .               func_8009CA2C();
        .               gSPDisplayList(gDisplayListHead++, D_02007F48);
        .               gMatrixEffectCount = 0;
        .           }
        .           
    1,328 ( 0.00%)  void func_800940EC(s32 arg0) {
    3,984 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    3,652 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    6,308 ( 0.00%)      guOrtho(&gGfxPool->mtxEffect[gMatrixEffectCount], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
  426,288 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guOrthoF.c:guOrtho (332x)
    8,300 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount++]),
        .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007F18);
3,977,046 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
    1,992 ( 0.00%)      func_80092290(4, D_8018E850, D_8018E858);
12,111,097 ( 0.01%)  => src/code_80091750.c:func_80092290 (332x)
    2,656 ( 0.00%)      func_80092290(5, (s32*) &D_8018E850[1], (s32*) &D_8018E858[1]);
12,111,097 ( 0.01%)  => src/code_80091750.c:func_80092290 (332x)
      332 ( 0.00%)      func_80092148();
    7,069 ( 0.00%)  => src/code_80091750.c:func_80092148 (332x)
      332 ( 0.00%)      func_80099A70();
   19,920 ( 0.00%)  => src/code_80091750.c:func_80099A70 (332x)
      332 ( 0.00%)      func_80099E54();
    2,324 ( 0.00%)  => src/code_80091750.c:func_80099E54 (332x)
      332 ( 0.00%)      func_800A8230();
103,198,149 ( 0.09%)  => src/code_80091750.c:func_800A8230 (332x)
      332 ( 0.00%)      func_80099AEC();
    6,972 ( 0.00%)  => src/code_80091750.c:func_80099AEC (332x)
      332 ( 0.00%)      func_80099EC4();
    4,980 ( 0.00%)  => src/code_80091750.c:func_80099EC4 (332x)
      996 ( 0.00%)      func_8009CA6C(arg0);
4,839,146 ( 0.00%)  => src/code_80091750.c:func_8009CA6C (332x)
    2,988 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007F48);
3,961,285 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
      332 ( 0.00%)      func_80057CE4();
   53,784 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80057C60.c:func_80057CE4 (332x)
      996 ( 0.00%)  }
        .           
        .           void func_800942D0(void) {
        .               Mtx* test;
        .               f32 var_f26;
        .               s32 var_s2;
        .               s32 thing;
        .               test = &gGfxPool->mtxObject[0];
        .               gSPMatrix(gDisplayListHead++, &gGfxPool->mtxScreen, G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
-- line 2157 ----------------------------------------
-- line 2194 ----------------------------------------
        .               gSPPerspNormalize(gDisplayListHead++, perspNorm);
        .               guLookAt(&arg0->mtxLookAt[0], 0.0f, 0.0f, (f32) D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
        .               func_800942D0();
        .               gDPPipeSync(gDisplayListHead++);
        .               gDPSetTexturePersp(gDisplayListHead++, G_TP_NONE);
        .               gDPSetTextureFilter(gDisplayListHead++, G_TF_BILERP);
        .           }
        .           
      345 ( 0.00%)  void render_checkered_flag(struct GfxPool* arg0, UNUSED s32 arg1) {
        .               u16 perspNorm;
       69 ( 0.00%)      move_segment_table_to_dmem();
   26,082 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:move_segment_table_to_dmem (69x)
      828 ( 0.00%)      guPerspective(&arg0->mtxPersp[0], &perspNorm, 45.0f, 1.3333334f, 100.0f, 12800.0f, 1.0f);
  201,963 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guPerspectiveF.c:guPerspective (69x)
      897 ( 0.00%)      gSPPerspNormalize(gDisplayListHead++, perspNorm);
    1,449 ( 0.00%)      guLookAt(&arg0->mtxLookAt[1], 0.0f, 0.0f, (f32) D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
   74,589 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guLookAtF.c:guLookAt (69x)
      690 ( 0.00%)      guRotate(&arg0->mtxObject[0], D_8018EDC8, 1.0f, 0, 0);
   73,830 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guRotateF.c:guRotate (69x)
      690 ( 0.00%)      guRotate(&arg0->mtxObject[1], D_8018EDCC, 0, 1.0f, 0);
   71,829 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guRotateF.c:guRotate (69x)
      690 ( 0.00%)      guRotate(&arg0->mtxObject[2], D_8018EDD0, 0, 0, 1.0f);
   71,829 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guRotateF.c:guRotate (69x)
      897 ( 0.00%)      guScale(&arg0->mtxObject[3], D_8018EDC4, D_8018EDC4, D_8018EDC4);
   58,236 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guScaleF.c:guScale (69x)
      897 ( 0.00%)      guTranslate(&arg0->mtxObject[4], D_8018EDD4, D_8018EDD8, D_8018EDDC);
   58,029 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guTranslateF.c:guTranslate (69x)
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxPersp[0], G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxLookAt[1], G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[0], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[1], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[2], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[3], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      897 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[4], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      621 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007FC8);
  824,587 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (69x)
       69 ( 0.00%)      func_800B0004();
9,434,838 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_800AF9B0.c:func_800B0004 (69x)
      621 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007650);
  822,854 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (69x)
      207 ( 0.00%)  }
        .           
      276 ( 0.00%)  void func_80094A64(struct GfxPool* pool) {
      138 ( 0.00%)      gMatrixHudCount = 0;
      138 ( 0.00%)      gMatrixEffectCount = 0;
      828 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
      759 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
      759 ( 0.00%)      guOrtho(&pool->mtxScreen, 0.0f, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1, 0.0f, -100.0f, 100.0f, 1.0f);
   88,596 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guOrthoF.c:guOrtho (69x)
      828 ( 0.00%)      gSPMatrix(gDisplayListHead++, &pool->mtxScreen, G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      621 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007650);
  823,869 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (69x)
       69 ( 0.00%)      render_menus();
      621 ( 0.00%)  => src/code_80091750.c:render_menus (69x)
      414 ( 0.00%)      func_80092290(4, D_8018E850, D_8018E858);
2,506,913 ( 0.00%)  => src/code_80091750.c:func_80092290 (69x)
      552 ( 0.00%)      func_80092290(5, (s32*) &D_8018E850[1], (s32*) &D_8018E858[1]);
2,502,553 ( 0.00%)  => src/code_80091750.c:func_80092290 (69x)
       69 ( 0.00%)      func_80099A70();
    4,140 ( 0.00%)  => src/code_80091750.c:func_80099A70 (69x)
       69 ( 0.00%)      func_8009C918();
   17,457 ( 0.00%)  => src/code_80091750.c:func_8009C918 (69x)
      690 ( 0.00%)      switch (gMenuSelection) {
        .                   case START_MENU:
       69 ( 0.00%)              func_80095574();
24,190,867 ( 0.02%)  => src/code_80091750.c:func_80095574 (69x)
       69 ( 0.00%)              func_80093E40();
1,918,233 ( 0.00%)  => src/code_80091750.c:func_80093E40 (69x)
       69 ( 0.00%)              break;
        .                   case OPTIONS_MENU:
        .                   case DATA_MENU:
        .                   case COURSE_DATA_MENU:
        .                   case LOGO_INTRO_MENU:
        .                   case CONTROLLER_PAK_MENU:
        .                   case MAIN_MENU:
        .                   case CHARACTER_SELECT_MENU:
        .                   case COURSE_SELECT_MENU:
        .                       func_800A8230();
        .                       func_80099AEC();
        .                       break;
        .               }
       69 ( 0.00%)      func_8009CA2C();
5,286,434 ( 0.00%)  => src/code_80091750.c:func_8009CA2C (69x)
      345 ( 0.00%)      gCycleFlashMenu += 1;
      759 ( 0.00%)      gDPPipeSync(gDisplayListHead++);
      621 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020076B0);
  824,515 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (69x)
      207 ( 0.00%)  }
        .           
      140 ( 0.00%)  void render_menus(void) {
      280 ( 0.00%)      if (D_800E86A4 != 0) {
        1 ( 0.00%)          func_80099110();
        9 ( 0.00%)  => src/code_80091750.c:func_80099110 (1x)
        1 ( 0.00%)          func_8009A344();
      170 ( 0.00%)  => src/code_80091750.c:func_8009A344 (1x)
        1 ( 0.00%)          func_8009E620();
      394 ( 0.00%)  => src/code_80091750.c:func_8009E620 (1x)
        1 ( 0.00%)          func_8009B938();
       11 ( 0.00%)  => src/code_80091750.c:func_8009B938 (1x)
        1 ( 0.00%)          func_80092258();
       34 ( 0.00%)  => src/code_80091750.c:func_80092258 (1x)
        1 ( 0.00%)          func_800B5F30();
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:func_800B5F30 (1x)
        1 ( 0.00%)          func_800B6014();
       44 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:func_800B6014 (1x)
        4 ( 0.00%)          func_800B3F74(gMenuSelection);
    4,858 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/menus.c:func_800B3F74 (1x)
       13 ( 0.00%)          switch (gMenuSelection) {
        .                       case OPTIONS_MENU:
        .                           add_ui_element(0x00000023, 0, 0, 2);
        .                           add_ui_element(0x000000F1, 0, 0, 4);
        .                           add_ui_element(0x000000F0, 0, 0, 2);
        .                           break;
        .                       case DATA_MENU:
        .                           add_ui_element(0x00000023, 0, 0, 2);
        .                           add_ui_element(0x0000008C, 0, 0, 6);
-- line 2279 ----------------------------------------
-- line 2312 ----------------------------------------
        .                           add_ui_element(0x000000D3, 0, 0, 8);
        .                           add_ui_element(0x000000D5, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D6, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D7, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D8, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D9, 0, 0, 0x0A);
        .                           break;
        .                       case START_MENU:
        5 ( 0.00%)                  add_ui_element(2, 0, 0, 4);
   13,520 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)                  add_ui_element(1, 0, 0, 0);
  166,606 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)                  add_ui_element(0x000000FB, 0, 0, 0);
      104 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        6 ( 0.00%)                  if (gControllerBits & 1) {
        6 ( 0.00%)                      add_ui_element(3, 0, 0, 2);
      255 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        .                           } else {
        .                               add_ui_element(4, 0, 0, 2);
        .                           }
        5 ( 0.00%)                  add_ui_element(5, 0, 0, 6);
       95 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        2 ( 0.00%)                  gDemoMode = 0;
        2 ( 0.00%)                  D_8018EE08 = 0;
        1 ( 0.00%)                  break;
        .                       case MAIN_MENU:
        .                           add_ui_element(0x00000023, 0, 0, 2);
        .                           add_ui_element(0x0000000A, 0x0000015E, 0x00000011, 6);
        .                           add_ui_element(0x0000000E, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000D, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000C, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000B, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000F, 0x0000015E, 0x000000C8, 6);
-- line 2339 ----------------------------------------
-- line 2402 ----------------------------------------
        .                       case 0:
        .                       case 1:
        .                       case 2:
        .                       case 3:
        .                       case 4:
        .                       default:
        .                           break;
        .                   }
        4 ( 0.00%)          if (D_800E86A4 != 2) {
        3 ( 0.00%)              func_8009DF4C(0x00000014);
       41 ( 0.00%)  => src/code_80091750.c:func_8009DF4C (1x)
        .                   } else {
        .                       func_8009DF6C(0x00000014);
        .                   }
        2 ( 0.00%)          D_800E86A4 = 0;
        .               }
      210 ( 0.00%)  }
        .           
        .           CProperties* GetCoursePropsA(void);
        .           
      207 ( 0.00%)  void func_80095574(void) {
        .               s32 var_v0;
        .           
      276 ( 0.00%)      if ((D_8018EE0C < 3) || (D_8018E7AC[4] != 0)) {
       69 ( 0.00%)          func_800A8230();
19,900,272 ( 0.02%)  => src/code_80091750.c:func_800A8230 (69x)
        .               }
      276 ( 0.00%)      if (gDebugMenuSelection >= 2) {
       69 ( 0.00%)          load_debug_font();
1,655,759 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:load_debug_font (69x)
      345 ( 0.00%)          debug_print_str2(0x00000050, 0x00000064, "debug_mode");
  131,790 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      801 ( 0.00%)          switch (gDebugMenuSelection) {
        .                       case DEBUG_MENU_DEBUG_MODE:
      120 ( 0.00%)                  debug_print_str2(0x00000046, 0x00000064, "*");
    5,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (24x)
       24 ( 0.00%)                  break;
        .                       case DEBUG_MENU_COURSE:
      165 ( 0.00%)                  debug_print_str2(0x00000046, 0x0000006E, "*");
    7,491 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (33x)
       33 ( 0.00%)                  break;
        .                       case DEBUG_MENU_SCREEN_MODE:
        .                           debug_print_str2(0x00000046, 0x00000078, "*");
        .                           break;
        .                       case DEBUG_MENU_PLAYER:
        .                           debug_print_str2(0x00000046, 0x00000082, "*");
        .                           break;
        .                       case DEBUG_MENU_SOUND_MODE:
        .                           debug_print_str2(0x00000046, 0x0000008C, "*");
        .                           break;
        .                       case DEBUG_MENU_GIVE_ALL_GOLD_CUP:
        .                           debug_print_str2(0x00000046, 0x00000096, "*");
        .                           break;
        .                   }
      276 ( 0.00%)          if (gEnableDebugMode) {
      414 ( 0.00%)              debug_print_str2(0x000000AA, 0x00000064, "on");
   28,566 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
        .                   } else {
        .                       debug_print_str2(0x000000AA, 0x00000064, "off");
        .                   }
      548 ( 0.00%)          if ((gCurrentCourseId >= (NUM_COURSES - 1)) || (gCurrentCourseId < 0)) {
        2 ( 0.00%)              gCurrentCourseId = 0;
        .                   }
      552 ( 0.00%)          print_str_num(0x00000050, 0x0000006E, "map_number", GetCourseIndex());
  153,318 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:print_str_num (69x)
      414 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourseIndex (69x)
        .                   // This isn't functionally equivallent, but who cares.
      276 ( 0.00%)          if (gCurrentCourseId < COURSE_TOADS_TURNPIKE) {
      138 ( 0.00%)              var_v0 = 0;
        .                   } else {
        .                       var_v0 = 8;
        .                   }
      552 ( 0.00%)          debug_print_str2(var_v0 + 0xB9, 0x0000006E, GetCoursePropsA()->DebugName);
  113,566 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
    3,933 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCoursePropsA (69x)
      345 ( 0.00%)          debug_print_str2(0x00000050, 0x00000078, "screen_mode");
  144,693 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      690 ( 0.00%)          debug_print_str2(0x000000AA, 0x00000078, gDebugScreenModeNames[D_8018EDF1]);
   28,566 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      345 ( 0.00%)          debug_print_str2(0x00000050, 0x00000082, "player");
   80,178 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      690 ( 0.00%)          debug_print_str2(0x000000AA, 0x00000082, gDebugCharacterNames[gCharacterSelections[0]]);
   67,275 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      345 ( 0.00%)          debug_print_str2(0x00000050, 0x0000008C, "sound mode");
  121,233 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      690 ( 0.00%)          debug_print_str2(0x000000AA, 0x0000008C, gDebugSoundModeNames[gSoundMode]);
   80,178 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (69x)
      276 ( 0.00%)          if (gDebugMenuSelection == DEBUG_MENU_GIVE_ALL_GOLD_CUP) {
        .                       debug_print_str2(0x00000050, 0x00000096, "push b to get all goldcup");
        .                   }
       69 ( 0.00%)          func_80057778();
  826,067 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_80057778 (69x)
        .               }
      276 ( 0.00%)      if (gDebugMenuSelection == DEBUG_MENU_DISABLED) {
        .                   gMenuTimingCounter += 1;
        .               } else {
      138 ( 0.00%)          gMenuTimingCounter = 3;
        .               }
      276 ( 0.00%)      if (gMenuTimingCounter == DEBUG_MENU_DEBUG_MODE) {
        .                   play_sound2(SOUND_INTRO_WELCOME);
        .               }
      276 ( 0.00%)      if (gMenuTimingCounter >= 0x12D) {
        .                   func_8009E230();
        .                   func_800CA0A0();
        .               }
      621 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020076E0);
  831,733 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (69x)
      207 ( 0.00%)  }
        .           
        .           // While this matches, its a little screwy
        .           // This function seemingly needs to return a Gfx*, but doing that explicity doesn't match
        .           // Instead we depend on the fact that the result of draw_box_fill is left
        .           // in v0 which means it is returned, sort of.
        .           // Its also weird that the displayListHead argument goes entirely unused. What's up with that?
        .           Gfx* draw_flash_select_case(UNUSED Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 speed) {
        .               s32 greyscale;
-- line 2498 ----------------------------------------
-- line 2517 ----------------------------------------
        .           Gfx* draw_flash_select_case_slow(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
        .               return draw_flash_select_case(displayListHead, ulx, uly, lrx, lry, 64);
        .           }
        .           
        .           Gfx* draw_flash_select_case_fast(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
        .               return draw_flash_select_case(displayListHead, ulx, uly, lrx, lry, 4);
        .           }
        .           
   11,350 ( 0.00%)  Gfx* func_800959F8(Gfx* displayListHead, Vtx* arg1) {
        .               s32 index;
        .           
    9,080 ( 0.00%)      if ((s32) gTextColor < TEXT_BLUE_GREEN_RED_CYCLE_1) {
        .                   index = gTextColor;
        .               } else {
   36,320 ( 0.00%)          index = ((gTextColor * 2) + ((s32) gGlobalTimer % 2)) - 4;
        .               }
        .           #ifdef AVOID_UB
   27,240 ( 0.00%)      arg1 = LOAD_ASSET(arg1);
26,622,666 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (2,270x)
  145,280 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (2,270x)
   18,160 ( 0.00%)      gSPVertex(displayListHead++, arg1, 2, 0);
  222,460 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPVertex (2,270x)
   36,320 ( 0.00%)      gSPVertex(displayListHead++, &arg1[(index + 1) * 2], 2, 2);
  222,460 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPVertex (2,270x)
   15,890 ( 0.00%)      gSPDisplayList(displayListHead++, common_rectangle_display);
27,177,089 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (2,270x)
        .           #else
        .               if (arg1 == D_02007BB8) {
        .                   gSPDisplayList(displayListHead++, D_800E84CC[index]);
        .               } else if (arg1 == D_02007CD8) {
        .                   gSPDisplayList(displayListHead++, D_800E84EC[index]);
        .               } else if (arg1 == D_02007DF8) {
        .                   gSPDisplayList(displayListHead++, D_800E850C[index]);
        .               }
        .           #endif
        .           
    2,270 ( 0.00%)      return displayListHead;
    4,540 ( 0.00%)  }
        .           
        .           #ifdef AVOID_UB
        .           #define MTX_TYPE Mtx
        .           #else
        .           typedef struct {
        .               u16 i[4][4];
        .               u16 f[4][4];
        .           } Mtx_u;
-- line 2557 ----------------------------------------
-- line 2566 ----------------------------------------
        .               s16 s[2];
        .               s32 w;
        .           } TheWhyUnion;
        .           
        .           #define MTX_TYPE Mtx2
        .           #endif
        .           
        .           // Why... Why... Why... This function is so bad it's not going in the header.
   18,160 ( 0.00%)  void func_80095AE0(MTX_TYPE* arg0, f32 arg1, f32 arg2, f32 arg3, f32 arg4) {
        .           #ifdef AVOID_UB
        .               // Use Mat4 array to set matrix values using guMtxF2L. This helps little-endian systems.
        .               Mat4 src;
    4,540 ( 0.00%)      src[0][0] = arg3;
    4,540 ( 0.00%)      src[0][1] = 0.0f;
    4,540 ( 0.00%)      src[0][2] = 0.0f;
    4,540 ( 0.00%)      src[0][3] = 0.0f;
    4,540 ( 0.00%)      src[1][0] = 0.0f;
    4,540 ( 0.00%)      src[1][1] = arg4;
    4,540 ( 0.00%)      src[1][2] = 0.0f;
    4,540 ( 0.00%)      src[1][3] = 0.0f;
    4,540 ( 0.00%)      src[2][0] = 0.0f;
    4,540 ( 0.00%)      src[2][1] = 0.0f;
    4,540 ( 0.00%)      src[2][2] = 1.0f;
    4,540 ( 0.00%)      src[2][3] = 0.0f;
    4,540 ( 0.00%)      src[3][0] = arg1;
    4,540 ( 0.00%)      src[3][1] = arg2;
    4,540 ( 0.00%)      src[3][2] = 0.0f;
    4,540 ( 0.00%)      src[3][3] = 1.0f;
   11,350 ( 0.00%)      guMtxF2L(src, arg0);
1,119,110 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guMtxF2L.c:guMtxF2L (2,270x)
        .           #else
        .               TheWhyUnion sp14;
        .               TheWhyUnion sp10;
        .               TheWhyUnion spC;
        .               TheWhyUnion sp8;
        .               s32 i;
        .           
        .               // clang-format off
-- line 2602 ----------------------------------------
-- line 2614 ----------------------------------------
        .               arg0->u.i[3][0] = spC.s[0];
        .               arg0->u.i[3][1] = sp8.s[0];
        .               arg0->u.i[3][3] = 1;
        .               arg0->u.f[0][0] = sp14.s[1];
        .               arg0->u.f[1][1] = sp10.s[1];
        .               arg0->u.f[3][0] = spC.s[1];
        .               arg0->u.f[3][1] = sp8.s[1];
        .           #endif
    6,810 ( 0.00%)  }
        .           
        .           #undef MTX_TYPE
        .           
   24,970 ( 0.00%)  Gfx* func_80095BD0(Gfx* displayListHead, u8* arg1, f32 arg2, f32 arg3, u32 arg4, u32 arg5, f32 arg6, f32 arg7) {
        .               Vtx* var_a1;
        .               Mtx* sp28;
        .           
        .               // A match is a match, but why are goto's required here?
    9,080 ( 0.00%)      if (gMatrixEffectCount >= 0x2F7) {
        .                   goto func_80095BD0_label1;
        .               }
   22,700 ( 0.00%)      sp28 = &gGfxPool->mtxEffect[gMatrixEffectCount];
    9,080 ( 0.00%)      if (gMatrixEffectCount < 0) {
        .                   rmonPrintf("effectcount < 0 !!!!!!(kawano)\n");
        .               }
    2,270 ( 0.00%)      goto func_80095BD0_label2;
        .           func_80095BD0_label1:
        .               rmonPrintf("MAX effectcount(760) over!!!!(kawano)\n");
        .               return displayListHead;
        .           func_80095BD0_label2:
   24,970 ( 0.00%)      func_80095AE0(sp28, arg2, arg3, arg6, arg7);
1,228,070 ( 0.00%)  => src/code_80091750.c:func_80095AE0 (2,270x)
   40,860 ( 0.00%)      gSPMatrix(displayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount]),
        .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
   13,620 ( 0.00%)      gMatrixEffectCount += 1;
  236,080 ( 0.00%)      gDPLoadTextureTile_4b(displayListHead++, arg1, G_IM_FMT_I, arg4, 0, 0, 0, arg4, arg5, 0, G_TX_NOMIRROR | G_TX_WRAP,
        .                                     G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
   18,160 ( 0.00%)      switch (arg4) {
        .                   default:
        .                       var_a1 = D_02007CD8;
        .                       break;
        .                   case 16:
        .                       var_a1 = D_02007CD8;
        .                       break;
        .                   case 26:
    4,540 ( 0.00%)              var_a1 = D_02007BB8;
    2,270 ( 0.00%)              break;
        .                   case 30:
        .                       var_a1 = D_02007DF8;
        .                       break;
        .               }
        .           
   11,350 ( 0.00%)      return func_800959F8(displayListHead, var_a1);
54,551,125 ( 0.05%)  => src/code_80091750.c:func_800959F8 (2,270x)
    4,540 ( 0.00%)  }
        .           
        .           // Player select menu character border
        .           Gfx* func_80095E10(Gfx* displayListHead, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8,
    1,850 ( 0.00%)                     s32 arg9, u8* argA, u32 argB, u32 argC) {
      370 ( 0.00%)      u32 var_a1_2 = arg4;
      370 ( 0.00%)      u32 var_s3 = arg5;
        .               s32 sp7C;
        .               u32 var_s2;
        .               u32 var_s4;
      185 ( 0.00%)      s32 var_t0 = 1;
        .               s32 temp_lo;
      185 ( 0.00%)      s32 sp68 = 0;
      185 ( 0.00%)      s32 sp64 = 0;
        .               s32 var_v0_2;
        .           
    5,180 ( 0.00%)      while (var_t0 < argB) {
    1,480 ( 0.00%)          var_t0 *= 2;
        .               }
        .           
      740 ( 0.00%)      temp_lo = 0x400 / var_t0;
        .           
    1,480 ( 0.00%)      while ((temp_lo / 2) > argC) {
        .                   temp_lo /= 2;
        .               }
        .           
      370 ( 0.00%)      var_v0_2 = var_t0;
    3,515 ( 0.00%)      while (var_v0_2 > 1) {
    8,880 ( 0.00%)          var_v0_2 /= 2;
    1,480 ( 0.00%)          sp68 += 1;
        .               }
      370 ( 0.00%)      var_v0_2 = temp_lo;
        .           
    1,295 ( 0.00%)      while (var_v0_2 > 1) {
    2,220 ( 0.00%)          var_v0_2 /= 2;
      370 ( 0.00%)          sp64 += 1;
        .               }
        .           
      370 ( 0.00%)      if (arg8 < 0) {
        .                   arg4 -= arg8;
        .                   arg8 = 0;
    1,295 ( 0.00%)      } else if (((arg6 - arg4) + arg8) > SCREEN_WIDTH) {
        .                   arg6 = (arg4 - arg8) + SCREEN_WIDTH;
        .               }
        .           
      370 ( 0.00%)      if (arg9 < 0) {
        .                   arg5 -= arg9;
        .                   arg9 = 0;
    1,295 ( 0.00%)      } else if (((arg7 - arg5) + arg9) > SCREEN_HEIGHT) {
        .                   arg7 = (arg5 - arg9) + SCREEN_HEIGHT;
        .               }
        .           
      555 ( 0.00%)      if (arg6 < arg4) {
        .                   return displayListHead;
        .               }
      555 ( 0.00%)      if (arg7 < arg5) {
        .                   return displayListHead;
        .               }
      370 ( 0.00%)      sp7C = arg8;
   44,485 ( 0.00%)      for (var_s3 = arg5; var_s3 < arg7; var_s3 += temp_lo) {
        .           
   52,050 ( 0.00%)          if (arg7 < temp_lo + var_s3) {
      207 ( 0.00%)              var_s4 = arg7 - var_s3;
      138 ( 0.00%)              if (!var_s4) {
        .                           break;
        .                       }
        .                   } else {
   17,212 ( 0.00%)              var_s4 = temp_lo;
        .                   }
        .           
   95,425 ( 0.00%)          for (var_a1_2 = arg4; var_a1_2 < arg6; var_a1_2 += var_t0) {
        .           
   52,050 ( 0.00%)              if (arg6 < var_t0 + var_a1_2) {
   26,025 ( 0.00%)                  var_s2 = arg6 - var_a1_2;
   17,350 ( 0.00%)                  if (!var_s2) {
        .                               break;
        .                           }
        .                       } else {
        .                           var_s2 = var_t0;
        .                       }
1,396,675 ( 0.00%)              gDPLoadTextureTile(displayListHead++, argA, arg1, G_IM_SIZ_16b, argB, 0, var_a1_2, var_s3,
        .                                          var_a1_2 + var_s2, var_s3 + var_s4, 0, G_TX_NOMIRROR | G_TX_WRAP,
        .                                          G_TX_NOMIRROR | G_TX_WRAP, sp68, sp64, G_TX_NOLOD, G_TX_NOLOD);
  581,225 ( 0.00%)              gSPTextureRectangle(displayListHead++, arg8 * 4, arg9 * 4, (arg8 + var_s2) * 4, (arg9 + var_s4) * 4, 0,
        .                                           (var_a1_2 * 32) & 0xFFFF, (var_s3 * 32) & 0xFFFF, arg2, arg3);
        .           
   17,350 ( 0.00%)              arg8 += var_t0;
        .                   }
        .           
   17,350 ( 0.00%)          arg8 = sp7C;
   17,350 ( 0.00%)          arg9 += temp_lo;
        .               }
      185 ( 0.00%)      return displayListHead;
      370 ( 0.00%)  }
        .           
        .           Gfx* func_800963F0(Gfx* displayListHead, s8 arg1, s32 arg2, s32 arg3, f32 arg4, f32 arg5, s32 arg6, s32 arg7, s32 arg8,
        .                              s32 arg9, s32 argA, s32 argB, u8* argC, u32 argD, u32 argE) {
        .               u32 var_a1_2 = arg6;
        .               u32 var_s3 = arg7;
        .               s32 sp7C;
        .               u32 var_s2;
        .               u32 var_s4;
-- line 2766 ----------------------------------------
-- line 3226 ----------------------------------------
        .                   }
        .                   column = columnCopy;
        .                   row += 0x20;
        .               }
        .               return displayListHead;
        .           }
        .           
        .           // draw a box filled with a solid color
    2,304 ( 0.00%)  Gfx* draw_box_fill(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 red, s32 green, s32 blue, s32 alpha) {
      256 ( 0.00%)      red &= 0xFF;
      256 ( 0.00%)      green &= 0xFF;
      256 ( 0.00%)      blue &= 0xFF;
      256 ( 0.00%)      alpha &= 0xFF;
    1,024 ( 0.00%)      if (lrx < ulx) {
        .                   swap_values(&ulx, &lrx);
        .               }
    1,024 ( 0.00%)      if (lry < uly) {
        .                   swap_values(&uly, &lry);
        .               }
    1,536 ( 0.00%)      if ((ulx >= 0x140) || (uly >= 0xF0)) {
        .                   return displayListHead;
        .               }
      768 ( 0.00%)      if (ulx < 0) {
        .                   ulx = 0;
        .               }
      768 ( 0.00%)      if (uly < 0) {
        .                   uly = 0;
        .               }
    1,536 ( 0.00%)      if ((lrx < 0) || (lry < 0)) {
        .                   return displayListHead;
        .               }
      768 ( 0.00%)      if (lrx >= SCREEN_WIDTH) {
        .                   lrx = SCREEN_WIDTH - 1;
        .               }
      768 ( 0.00%)      if (lry >= SCREEN_HEIGHT) {
        .                   lry = SCREEN_HEIGHT - 1;
        .               }
    1,792 ( 0.00%)      gSPDisplayList(displayListHead++, D_02008030);
3,054,828 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (256x)
    7,424 ( 0.00%)      gDPSetFillColor(displayListHead++, (GPACK_RGBA5551(red, green, (u32) blue, alpha) << 0x10 |
        .                                                   GPACK_RGBA5551(red, green, (u32) blue, alpha)));
    6,912 ( 0.00%)      gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
    1,792 ( 0.00%)      gSPDisplayList(displayListHead++, D_02008058);
3,083,303 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (256x)
      256 ( 0.00%)      return displayListHead;
      512 ( 0.00%)  }
        .           
        .           // draw a box filled with a solid color
        .           Gfx* draw_box_fill_wide(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 red, s32 green, s32 blue,
        .                                   s32 alpha) {
        .               red &= 0xFF;
        .               green &= 0xFF;
        .               blue &= 0xFF;
        .               alpha &= 0xFF;
-- line 3277 ----------------------------------------
-- line 3305 ----------------------------------------
        .               gDPFillWideRectangle(displayListHead++, OTRGetDimensionFromLeftEdge(ulx), uly, OTRGetDimensionFromRightEdge(lrx),
        .                                    lry);
        .               // gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
        .               gSPDisplayList(displayListHead++, D_02008058);
        .               return displayListHead;
        .           }
        .           
        .           // draw a box with a solid outline
      288 ( 0.00%)  Gfx* draw_box(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, u32 red, u32 green, u32 blue, u32 alpha) {
       32 ( 0.00%)      red &= 0xFF;
       32 ( 0.00%)      green &= 0xFF;
       32 ( 0.00%)      blue &= 0xFF;
       32 ( 0.00%)      alpha &= 0xFF;
      128 ( 0.00%)      if (lrx < ulx) {
        .                   swap_values(&ulx, &lrx);
        .               }
      128 ( 0.00%)      if (lry < uly) {
        .                   swap_values(&uly, &lry);
        .               }
      192 ( 0.00%)      if ((ulx >= 0x140) || (uly >= 0xF0)) {
        .                   return displayListHead;
        .               }
       96 ( 0.00%)      if (ulx < 0) {
        .                   ulx = 0;
        .               }
       96 ( 0.00%)      if (uly < 0) {
        .                   uly = 0;
        .               }
      192 ( 0.00%)      if ((lrx < 0) || (lry < 0)) {
        .                   return displayListHead;
        .               }
       96 ( 0.00%)      if (lrx >= 0x141) {
        .                   lrx = 0x140;
        .               }
       96 ( 0.00%)      if (lry >= 0xF1) {
        .                   lry = 0xF0;
        .               }
      224 ( 0.00%)      gSPDisplayList(displayListHead++, D_02008008);
  383,729 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (32x)
      768 ( 0.00%)      gDPSetPrimColor(displayListHead++, 0, 0, red, green, blue, alpha);
        .               // gDPFillWideRectangle(displayListHead++, OTRGetRectDimensionFromLeftEdge(0), uly,
        .               // OTRGetRectDimensionFromRightEdge(SCREEN_WIDTH), lry);
      864 ( 0.00%)      gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
      288 ( 0.00%)      gDPPipeSync(displayListHead++);
       32 ( 0.00%)      return displayListHead;
       64 ( 0.00%)  }
        .           
    2,048 ( 0.00%)  Gfx* func_80098FC8(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
    3,584 ( 0.00%)      return draw_box_fill(displayListHead, ulx, uly, lrx, lry, 0, 0, 0, 0xFF);
6,168,339 ( 0.01%)  => src/code_80091750.c:draw_box_fill (256x)
      512 ( 0.00%)  }
        .           
        .           void dma_copy_base_729a30(u64* arg0, size_t nbytes, void* vaddr) {
        .           #ifdef TARGET_N64
        .               OSIoMesg sp30;
        .               OSMesg sp2C;
        .           
        .               osInvalDCache(vaddr, nbytes);
        .               osPiStartDma(&sp30, OS_MESG_PRI_NORMAL, OS_READ, (uintptr_t) &_textures_0aSegmentRomStart[SEGMENT_OFFSET(arg0)],
-- line 3361 ----------------------------------------
-- line 3371 ----------------------------------------
        .           
        .               osInvalDCache(vaddr, nbytes);
        .               osPiStartDma(&sp30, OS_MESG_PRI_NORMAL, OS_READ, (uintptr_t) &_textures_0bSegmentRomStart[SEGMENT_OFFSET(arg0)],
        .                            vaddr, nbytes, &gDmaMesgQueue);
        .               osRecvMesg(&gDmaMesgQueue, &sp2C, OS_MESG_BLOCK);
        .           #endif
        .           }
        .           
        4 ( 0.00%)  void func_80099110(void) {
        4 ( 0.00%)      gMenuTextureBufferIndex = 0;
        4 ( 0.00%)      gNumD_8018E118Entries = 0;
        6 ( 0.00%)  }
        .           
        .           /**
        .            * Differs from memory.c with `+ 0x8` instead of `| 0x8`
        .            *
        .            * @param addr
        .            * @return void*
        .            */
   30,840 ( 0.00%)  void* segmented_to_virtual_dupe(const void* addr) {
        .           #ifdef TARGET_N64
        .               size_t segment = (uintptr_t) addr >> 24;
        .               size_t offset = (uintptr_t) addr & 0x00FFFFFF;
        .           
        .               return (void*) ((gSegmentTable[segment] + offset) + 0x80000000);
        .           #else
   10,280 ( 0.00%)      return addr;
        .           #endif
   20,560 ( 0.00%)  }
        .           
        .           void* segmented_to_virtual_dupe_2(const void* addr) {
        .           #ifdef TARGET_N64
        .               size_t segment = (uintptr_t) addr >> 24;
        .               size_t offset = (uintptr_t) addr & 0x00FFFFFF;
        .           
        .               return (void*) ((gSegmentTable[segment] + offset) + 0x80000000);
        .           #else
-- line 3407 ----------------------------------------
-- line 3409 ----------------------------------------
        .           #endif
        .           }
        .           
        .           #include <assets/player_selection.h>
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/NAZ12
        .           // Register allocation nonsense
   10,100 ( 0.00%)  void load_menu_img(MkTexture* arg0) {
        .               u16 var_a1_2;
        .               s32 var_v0;
        .               s32 var_a1;
        .               MkTexture* var_s1;
    5,050 ( 0.00%)      struct_8018E118_entry* thing = &D_8018E118[0];
   10,100 ( 0.00%)      var_s1 = segmented_to_virtual_dupe(arg0);
   15,150 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (2,525x)
   22,725 ( 0.00%)      while (var_s1->textureData != NULL) {
    2,525 ( 0.00%)          var_a1 = 0;
   82,390 ( 0.00%)          for (var_v0 = 0; var_v0 < gNumD_8018E118Entries; var_v0++) {
  175,560 ( 0.00%)              if (var_s1->textureData == (thing + var_v0)->textureData) {
    2,512 ( 0.00%)                  var_a1 = 1;
    2,512 ( 0.00%)                  break;
        .                       }
        .                   }
        .           
    5,050 ( 0.00%)          if (var_a1 == 0) {
       52 ( 0.00%)              if (var_s1->type == 3) {
        .                           if (var_s1->size != 0) {
        .                               var_a1_2 = var_s1->size;
        .                           } else {
        .                               var_a1_2 = 0x1000;
        .                           }
        .                           if (var_a1_2 % 8) {
        .                               var_a1_2 = ((var_a1_2 / 8) * 8) + 8;
        .                           }
-- line 3442 ----------------------------------------
-- line 3449 ----------------------------------------
        .           #else
        .                           strcpy(&D_8018D9B0[gMenuTextureBufferIndex], var_s1->textureData);
        .           #endif
        .                       } else {
        .           #ifdef TARGET_N64
        .                           dma_copy_base_729a30(var_s1->textureData, var_s1->height * var_s1->width * 2,
        .                                                &D_8018D9B0[gMenuTextureBufferIndex]);
        .           #else
      169 ( 0.00%)                  strcpy(&D_8018D9B0[gMenuTextureBufferIndex], var_s1->textureData);
      315 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcpy-avx2.S:__strcpy_avx2 (13x)
        .           #endif
        .                       }
      130 ( 0.00%)              thing[gNumD_8018E118Entries].textureData = var_s1->textureData;
      130 ( 0.00%)              thing[gNumD_8018E118Entries].offset = gMenuTextureBufferIndex;
      156 ( 0.00%)              gMenuTextureBufferIndex += var_s1->height * var_s1->width;
      130 ( 0.00%)              gMenuTextureBufferIndex = ((gMenuTextureBufferIndex / 8) * 8) + 8;
       65 ( 0.00%)              gNumD_8018E118Entries += 1;
        .                   }
    2,525 ( 0.00%)          var_s1++;
        .               }
   10,100 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/load_menu_img.s")
        .           #endif
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/O2tkD
        .           // Register allocation nonsense
        .           void func_80099394(MkTexture* arg0) {
-- line 3476 ----------------------------------------
-- line 3566 ----------------------------------------
        .           
        .           void load_img_wrap(MkTexture* arg0) {
        .               load_menu_img2(arg0, 1);
        .           }
        .           
        .           #ifdef NON_MATCHING
        .           // Register allocation nonsense
        .           // https://decomp.me/scratch/hwAAp
        5 ( 0.00%)  void load_menu_img2(MkTexture* arg0, s32 arg1) {
        .               u16 var_a1_2;
        .               s32 var_v0;
        .               s32 var_a1;
        .               u8 var_v0_2;
        .               MkTexture* texture;
        2 ( 0.00%)      struct_8018E118_entry* thing = &D_8018E118[0];
        .           
        4 ( 0.00%)      texture = segmented_to_virtual_dupe(arg0);
        6 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1x)
        .           
        9 ( 0.00%)      size_t siz = texture->width * texture->height;
        .               // for (size_t i = 0; i < siz; i++) {
        .               //     printf(" 0x%llX", texture->textureData[i]);
        .               // }
        .           
        .               // Because it's loading an mkTexture. The second element in the array is usually all zeros.
        .               // Despite this loop, it's usually only ran once.
        9 ( 0.00%)      while (texture->textureData != NULL) {
        1 ( 0.00%)          var_a1 = 0;
       11 ( 0.00%)          for (var_v0 = 0; var_v0 < gNumD_8018E118Entries; var_v0++) {
       11 ( 0.00%)              if (texture->textureData == (thing + var_v0)->textureData) {
        .                           var_a1 = 1;
        .                           break;
        .                       }
        .                   }
        2 ( 0.00%)          if ((var_a1 == 0) || (arg1 > 0)) {
        4 ( 0.00%)              if (texture->size != 0) {
        4 ( 0.00%)                  var_a1_2 = texture->size;
        .                       } else {
        .                           var_a1_2 = 0x1000;
        .                       }
        4 ( 0.00%)              if ((var_a1_2 % 8)) {
        .                           var_a1_2 = (((var_a1_2 / 8) * 8) + 8);
        .                       }
       11 ( 0.00%)              switch (arg1) { /* irregular */
        .                           case -1:
        .                           case 1:
        .                               // dma_copy_base_729a30(texture->textureData, var_a1_2, D_8018D9B4);
        .                               break;
        .                           case 0:
        .                           case 2:
        .                               // dma_copy_base_7fa3c0(texture->textureData, var_a1_2, D_8018D9B4);
        2 ( 0.00%)                      break;
        .                       }
       12 ( 0.00%)              switch (arg1) { /* switch 1; irregular */
        .                           case -1:    /* switch 1 */
        .                           case 1: {
        .                               // mio0decode(D_8018D9B4, (u8*)&D_8018D9B0[gMenuTextureBufferIndex]);
        .                               // printf("w: %d, h: %d", texture->width, texture->height);
        .                               u8* tex = (u8*) LOAD_ASSET(texture->textureData);
        .                               memcpy(&D_8018D9B0[gMenuTextureBufferIndex], tex, texture->width * texture->height * 2);
        .                               break;
        .                           }
        .                           case 0: /* switch 1 */
        .                           case 2: /* switch 1 */
        4 ( 0.00%)                      if (texture->type == 1) {
        .                                   var_v0_2 = 0x000000BE;
        .                               } else {
        1 ( 0.00%)                          var_v0_2 = 1;
        .                               }
        .                               if (1) {}
        .                               // D_8018D9B0[gMenuTextureBufferIndex] = &gTextureBackgroundBlueSky;
        .                               // tkmk00decode(D_8018D9B4, texture->textureData, (u8*)&D_8018D9B0[gMenuTextureBufferIndex],
        .                               // var_v0_2);
       16 ( 0.00%)                      u8* tex2 = (u8*) LOAD_ASSET(texture->textureData);
   12,634 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (1x)
       55 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (1x)
       21 ( 0.00%)                      memcpy(&D_8018D9B0[gMenuTextureBufferIndex], tex2, texture->width * texture->height * 2);
  153,632 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        1 ( 0.00%)                      break;
        .                       }
        .           
       10 ( 0.00%)              thing[gNumD_8018E118Entries].textureData = texture->textureData;
       10 ( 0.00%)              thing[gNumD_8018E118Entries].offset = gMenuTextureBufferIndex;
       12 ( 0.00%)              gMenuTextureBufferIndex += texture->height * texture->width;
       10 ( 0.00%)              gMenuTextureBufferIndex = ((gMenuTextureBufferIndex / 8) * 8) + 8;
        5 ( 0.00%)              gNumD_8018E118Entries += 1;
        .                   }
        1 ( 0.00%)          texture++;
        .               }
        4 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/load_menu_img2.s")
        .           #endif
        .           
        .           void func_80099958(MkTexture* arg0, s32 arg1, s32 arg2) {
        .               u16 var_a1;
        .               UNUSED u8* thing;
        .               MkTexture* temp_v0;
-- line 3659 ----------------------------------------
-- line 3674 ----------------------------------------
        .                   u8* tex = LOAD_ASSET(temp_v0->textureData);
        .                   memcpy(D_802BFB80.arraySize4[arg2][arg1 / 2][(arg1 % 2) + 2].pixel_index_array, temp_v0->textureData,
        .                          temp_v0->width * temp_v0->height * 2);
        .                   temp_v0++;
        .               }
        .           }
        .           
        .           // Possibly a debug print function?
      802 ( 0.00%)  void func_80099A70(void) {
        .               s32 i;
      802 ( 0.00%)      D_8018E060[0].texture = NULL;
   20,852 ( 0.00%)      for (i = 0; i < D_8018E060_SIZE; i++) {}
    1,604 ( 0.00%)  }
        .           
        .           void func_80099A94(MkTexture* arg0, s32 arg1) {
        .               struct_8018E060_entry* var_v1;
        .           
        .               var_v1 = &D_8018E060[0];
        .               while (var_v1->texture != NULL) {
        .                   var_v1++;
        .               }
        .               var_v1->texture = segmented_to_virtual_dupe(arg0);
        .               var_v1->unk_4 = arg1;
        .           }
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/rxEoi
        .           // Something's up with the handling of `_textures_0aSegmentRomStart`, I don't know how to fix it
      996 ( 0.00%)  void func_80099AEC(void) {
        .               s8 var_s4;
        .               s32 size;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               s32 huh;
        .               OSIoMesg sp68;
        .               OSMesg sp64;
        .               UNUSED u8* test;
        .               s32 sp60;
        .               MkTexture* temp_s2;
        .               struct_8018E060_entry* var_s1;
        .           
    1,328 ( 0.00%)      if (gGamestate == RACING) {
      664 ( 0.00%)          sp60 = 0x00000500;
        .               } else {
        .                   sp60 = 0x00001000;
        .               }
        .           
      332 ( 0.00%)      var_s4 = 0;
      664 ( 0.00%)      var_s1 = &D_8018E060[0];
      996 ( 0.00%)      temp_s2 = var_s1->texture;
        .           
      664 ( 0.00%)      if (temp_s2 == NULL)
      664 ( 0.00%)          return;
        .           
        .               huh = temp_s2->size;
        .               if (huh != 0) {
        .                   size = huh;
        .               } else {
        .                   size = 0x1400;
        .               }
        .               if (size % 8) {
-- line 3734 ----------------------------------------
-- line 3797 ----------------------------------------
        .                          var_s1->texture->width * var_s1->texture->height * 2);
        .           #endif
        .                   var_s1->texture = NULL;
        .                   var_s1++;
        .                   if (var_s4 != 0)
        .                       break;
        .                   osRecvMesg(&gDmaMesgQueue, &sp64, 1);
        .               }
      664 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099AEC.s")
        .           #endif
        .           
      664 ( 0.00%)  void func_80099E54(void) {
      664 ( 0.00%)      D_8018E0E8[0].mk64Texture = NULL;
      996 ( 0.00%)  }
        .           
        .           void func_80099E60(MkTexture* arg0, s32 arg1, s32 arg2) {
        .               struct_8018E0E8_entry* var_v1;
        .           
        .               var_v1 = D_8018E0E8;
        .               while (var_v1->mk64Texture != NULL) {
        .                   var_v1++;
        .               }
-- line 3820 ----------------------------------------
-- line 3822 ----------------------------------------
        .               var_v1->unk4 = arg1;
        .               var_v1->unk6 = arg2;
        .           }
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/rUXbD
        .           // Some fakematch nonsense, may or may not be necessary
        .           // Issue is with instruction ordering near the first `osPiStartDma` call
      996 ( 0.00%)  void func_80099EC4(void) {
        .               s8 var_s4;
        .               s32 var_s0;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               OSIoMesg sp68;
        .               OSMesg sp64;
        .               s32 huh;
        .               u8* test;
        .               MkTexture* temp_s2;
        .               struct_8018E0E8_entry* var_s1;
        .           
      332 ( 0.00%)      var_s4 = 0;
      664 ( 0.00%)      var_s1 = D_8018E0E8;
      996 ( 0.00%)      temp_s2 = var_s1->mk64Texture;
        .           
      664 ( 0.00%)      if (temp_s2 == NULL)
      664 ( 0.00%)          return;
        .           
        .               huh = temp_s2->size;
        .               if (huh != 0) {
        .                   var_s0 = huh;
        .               } else {
        .                   var_s0 = 0x1400;
        .               }
        .               if (var_s0 % 8) {
-- line 3855 ----------------------------------------
-- line 3923 ----------------------------------------
        .                          temp_s2->textureData, temp_s2->width * temp_s2->height * 2);
        .           #endif
        .                   var_s1->mk64Texture = NULL;
        .                   var_s1++;
        .                   if (var_s4 != 0)
        .                       break;
        .                   osRecvMesg(&gDmaMesgQueue, &sp64, 1);
        .               }
      664 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099EC4.s")
        .           #endif
        .           
        .           void func_8009A238(MkTexture* arg0, s32 arg1) {
        .               s32 var_a3;
        .               s32 temp_v1;
        .               u64* sp24;
-- line 3939 ----------------------------------------
-- line 3965 ----------------------------------------
        .                   }
        .                   load_menu_img2(var_a0, 0);
        .                   if (1) {}
        .                   temp_v0++;
        .                   var_a0 = temp_v0->mk64Texture;
        .               }
        .           }
        .           
        4 ( 0.00%)  void func_8009A344(void) {
        .               s32 index;
      104 ( 0.00%)      for (index = 0; index < D_8018DEE0_SIZE; index++) {
      224 ( 0.00%)          D_8018DEE0[index].visible = 0;
        .               }
        8 ( 0.00%)  }
        .           
        .           s32 animate_character_select_menu(MkAnimation* anim) {
        .               s32 i;
        .               struct_8018DEE0_entry* entry;
        .           
        .               anim = segmented_to_virtual_dupe_2(anim);
        .               i = 0;
        .               while (D_8018DEE0[i].visible) {
-- line 3986 ----------------------------------------
-- line 4321 ----------------------------------------
        .                   newgreen = ((temp_t9 * arg3) >> 8) << 6;
        .                   newblue = ((temp_t9 * arg4) >> 8) << 1;
        .                   *color++ = BSWAP16(newred + newgreen + newblue + alpha);
        .               }
        .               // Invalidate texture to properly apply color manipulation
        .               gSPInvalidateTexCache(gDisplayListHead++, D_8018E118[arg0].offset);
        .           }
        .           
    7,365 ( 0.00%)  u16* func_8009B8C4(u64* arg0) {
        .               UNUSED s32 pad[2];
        .               s32 offset;
        .               s32 found;
        .               s32 someIndex;
        .           
    2,455 ( 0.00%)      found = 0;
   77,005 ( 0.00%)      for (someIndex = 0; someIndex < gNumD_8018E118Entries; someIndex++) {
  119,280 ( 0.00%)          if (arg0 == D_8018E118[someIndex].textureData) {
    2,455 ( 0.00%)              found = 1;
   19,640 ( 0.00%)              offset = D_8018E118[someIndex].offset;
    2,455 ( 0.00%)              break;
        .                   }
        .               }
        .           
    4,910 ( 0.00%)      if (found != 0) {
   17,185 ( 0.00%)          return &D_8018D9B0[offset];
        .               }
        .               return NULL;
    4,910 ( 0.00%)  }
        .           
        .           // D_8018D9C0 is a little weird. In code_800AF9B0 its treated as a
        .           // struct_8018EE10_entry pointer. But here its being treated as a
        .           // Gfx pointer. It seems to be multi use.
        2 ( 0.00%)  void func_8009B938(void) {
        4 ( 0.00%)      D_8018E75C = (Gfx*) D_8018D9C0;
        2 ( 0.00%)      gNumD_8018E768Entries = 0;
        3 ( 0.00%)  }
        .           
        .           void func_8009B954(MkTexture* arg0) {
        .               D_8018E768[gNumD_8018E768Entries].textures = segmented_to_virtual_dupe(arg0);
        .               D_8018E768[gNumD_8018E768Entries].displayList = D_8018E75C;
        .           }
        .           
        .           void func_8009B998(void) {
        .               gSPEndDisplayList(D_8018E75C++);
-- line 4364 ----------------------------------------
-- line 4385 ----------------------------------------
        .                   }
        .               }
        .               if (found) {
        .                   gSPDisplayList(displayListHead++, displayList);
        .                   return displayListHead;
        .               }
        .           }
        .           
    1,295 ( 0.00%)  Gfx* func_8009BA74(Gfx* arg0, MkTexture* arg1, s32 column, s32 row) {
        .               MkTexture* temp_v0;
        .               u8* temp_v0_3;
        .               s8 var_s4;
        .           
      740 ( 0.00%)      temp_v0 = segmented_to_virtual_dupe(arg1);
    1,110 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (185x)
    1,665 ( 0.00%)      while (temp_v0->textureData != NULL) {
      185 ( 0.00%)          var_s4 = 0;
    2,405 ( 0.00%)          switch (temp_v0->type) {
        .                       case 0:
      483 ( 0.00%)                  gSPDisplayList(arg0++, D_02007708);
  825,536 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (69x)
       69 ( 0.00%)                  break;
        .                       case 1:
      812 ( 0.00%)                  gSPDisplayList(arg0++, D_02007728);
1,385,223 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (116x)
      116 ( 0.00%)                  break;
        .                       case 2:
        .                           gSPDisplayList(arg0++, D_02007748);
        .                           break;
        .                       case 3:
        .                           gSPDisplayList(arg0++, D_02007768);
        .                           var_s4 = 3;
        .                           break;
        .                       case 4:
        .                           gSPDisplayList(arg0++, D_02007788);
        .                           break;
        .                       default:
        .                           gSPDisplayList(arg0++, D_02007728);
        .                           break;
        .                   }
      925 ( 0.00%)          temp_v0_3 = (u8*) func_8009B8C4(temp_v0->textureData);
    9,334 ( 0.00%)  => src/code_80091750.c:func_8009B8C4 (185x)
      370 ( 0.00%)          if (temp_v0_3 != 0) {
      740 ( 0.00%)              if (D_8018E7AC[4] != 4) {
        .                           arg0 =
    5,735 ( 0.00%)                      func_80095E10(arg0, var_s4, 0x00000400, 0x00000400, 0, 0, temp_v0->width, temp_v0->height,
2,370,782 ( 0.00%)  => src/code_80091750.c:func_80095E10 (185x)
    1,850 ( 0.00%)                                    temp_v0->dX + column, temp_v0->dY + row, temp_v0_3, temp_v0->width, temp_v0->height);
        .                       } else {
        .                           arg0 = func_800987D0(arg0, 0U, 0U, temp_v0->width, temp_v0->height, temp_v0->dX + column,
        .                                                temp_v0->dY + row, temp_v0_3, temp_v0->width, temp_v0->height);
        .                       }
        .                   }
      185 ( 0.00%)          temp_v0++;
        .               }
      185 ( 0.00%)      return arg0;
      370 ( 0.00%)  }
        .           
        .           Gfx* func_8009BC9C(Gfx* arg0, MkTexture* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
        .               MkTexture* var_s0;
        .               u8* temp_v0_3;
        .           
        .               var_s0 = segmented_to_virtual_dupe(arg1);
        .               while (var_s0->textureData != NULL) {
        .                   switch (var_s0->type) { /* irregular */
-- line 4444 ----------------------------------------
-- line 4470 ----------------------------------------
        .                               break;
        .                       }
        .                   }
        .                   var_s0++;
        .               }
        .               return arg0;
        .           }
        .           
   25,230 ( 0.00%)  Gfx* print_letter(Gfx* arg0, MkTexture* glyphTexture, f32 arg2, f32 arg3, s32 mode, f32 scaleX, f32 scaleY) {
        .               s32 var_v0;
        .               u8* temp_v0_2;
        .               f32 thing0;
        .               f32 thing1;
        .               MkTexture* var_s0;
        .           
   10,092 ( 0.00%)      var_s0 = segmented_to_virtual_dupe(glyphTexture);
   15,138 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (2,523x)
   22,707 ( 0.00%)      while (var_s0->textureData != NULL) {
    2,523 ( 0.00%)          var_v0 = 0;
        .           
   17,661 ( 0.00%)          thing0 = var_s0->dX + arg2;
    7,569 ( 0.00%)          if (thing0 > 320.0f) {
       75 ( 0.00%)              var_v0 = 1;
        .                   }
   20,184 ( 0.00%)          thing0 += var_s0->width * scaleX;
    7,569 ( 0.00%)          if (thing0 < 0.0f) {
       58 ( 0.00%)              var_v0 += 1;
        .                   }
   17,661 ( 0.00%)          thing1 = var_s0->dY + arg3;
    7,569 ( 0.00%)          if (thing1 < 0.0f) {
       90 ( 0.00%)              var_v0 += 1;
        .                   }
   20,184 ( 0.00%)          thing1 -= var_s0->height * scaleY;
    7,569 ( 0.00%)          if (thing1 > 240.0f) {
       30 ( 0.00%)              var_v0 += 1;
        .                   }
        .           
    5,046 ( 0.00%)          if (var_v0 != 0) {
      506 ( 0.00%)              var_s0++;
        .                   } else {
   11,350 ( 0.00%)              temp_v0_2 = (u8*) func_8009B8C4(var_s0->textureData);
  248,326 ( 0.00%)  => src/code_80091750.c:func_8009B8C4 (2,270x)
    4,540 ( 0.00%)              if (temp_v0_2 != 0) {
    4,540 ( 0.00%)                  switch (mode) { /* irregular */
        .                               case 1:
   15,890 ( 0.00%)                          gSPDisplayList(arg0++, D_020077F8);
27,071,250 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (2,270x)
   56,750 ( 0.00%)                          arg0 = func_80095BD0(arg0, temp_v0_2, var_s0->dX + arg2, var_s0->dY + arg3, var_s0->width,
56,203,685 ( 0.05%)  => src/code_80091750.c:func_80095BD0 (2,270x)
    4,540 ( 0.00%)                                               var_s0->height, scaleX, scaleY);
    2,270 ( 0.00%)                          break;
        .                               case 2:
        .                                   gSPDisplayList(arg0++, D_02007818);
        .                                   arg0 = func_80095BD0(arg0, temp_v0_2, var_s0->dX + arg2, var_s0->dY + arg3, var_s0->width,
        .                                                        var_s0->height, scaleX, scaleY);
        .                                   break;
        .                           }
        .                       }
    2,270 ( 0.00%)              var_s0++;
        .                   }
        .               }
    2,523 ( 0.00%)      return arg0;
    5,046 ( 0.00%)  }
        .           
        .           Gfx* func_8009C204(Gfx* arg0, MkTexture* arg1, s32 arg2, s32 arg3, s32 arg4) {
        .               s32 var_s2;
        .               u8* temp_t0;
        .               MkTexture* var_s1;
        .           
        .               var_s1 = segmented_to_virtual_dupe(arg1);
        .               while (var_s1->textureData != NULL) {
-- line 4536 ----------------------------------------
-- line 4658 ----------------------------------------
        .                                         D_802BFB80.arraySize4[arg1->unk14][arg4 / 2][(arg4 % 2) + 2].pixel_index_array,
        .                                         var_s1->width, var_s1->height, (u32) arg5);
        .                   }
        .                   var_s1++;
        .               }
        .               return arg0;
        .           }
        .           
      802 ( 0.00%)  void func_8009C918(void) {
        .               s32 someIndex;
        .           
    6,416 ( 0.00%)      for (someIndex = 0; someIndex < 4; someIndex++) {
   22,456 ( 0.00%)          D_8018E7E8[someIndex].x = D_8015F480[someIndex].screenStartX;
   22,456 ( 0.00%)          D_8018E7E8[someIndex].y = D_8015F480[someIndex].screenStartY;
   22,456 ( 0.00%)          D_8018E810[someIndex].x = D_8015F480[someIndex].screenWidth;
   22,456 ( 0.00%)          D_8018E810[someIndex].y = D_8015F480[someIndex].screenHeight;
        .               }
        .           
      802 ( 0.00%)      D_8018E7E8[4].x = 0x00A0;
      802 ( 0.00%)      D_8018E7E8[4].y = 0x0078;
      802 ( 0.00%)      D_8018E810[4].x = 0x0140;
      802 ( 0.00%)      D_8018E810[4].y = 0x00F0;
    1,203 ( 0.00%)  }
        .           
      207 ( 0.00%)  void func_8009CA2C(void) {
        .               s32 var_s0;
        .           
    1,311 ( 0.00%)      for (var_s0 = 0; var_s0 < 5; var_s0++) {
    1,035 ( 0.00%)          func_8009CA6C(var_s0);
5,283,605 ( 0.00%)  => src/code_80091750.c:func_8009CA6C (345x)
        .               }
      276 ( 0.00%)  }
        .           
    4,036 ( 0.00%)  void func_8009CA6C(s32 arg0) {
        .               s32 var_a1;
        .           
    8,098 ( 0.00%)      if ((arg0 == 4) || ((find_8018D9E0_entry(0x000000AA) == NULL) && (find_8018D9E0_entry(0x000000AB) == NULL) &&
  518,016 ( 0.00%)  => src/code_80091750.c:find_8018D9E0_entry (1,216x)
    4,864 ( 0.00%)                          (find_8018D9E0_entry(0x000000B9) == NULL) && (find_8018D9E0_entry(0x000000BA) == NULL) &&
  518,016 ( 0.00%)  => src/code_80091750.c:find_8018D9E0_entry (1,216x)
    3,648 ( 0.00%)                          (find_8018D9E0_entry(0x000000AC) == NULL) && (find_8018D9E0_entry(0x000000B0) == NULL))) {
  518,016 ( 0.00%)  => src/code_80091750.c:find_8018D9E0_entry (1,216x)
    1,009 ( 0.00%)          var_a1 = 0;
    9,081 ( 0.00%)          gSPDisplayList(gDisplayListHead++, D_0D0076F8);
12,102,741 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (1,009x)
    4,450 ( 0.00%)          if ((arg0 != 4) && (gIsGamePaused != 0)) {
        .                       var_a1 = 1;
        .                   }
   15,135 ( 0.00%)          switch (D_8018E7AC[arg0]) {
        .                       case 1:
      100 ( 0.00%)                  func_8009CDDC(arg0, var_a1);
  245,973 ( 0.00%)  => src/code_80091750.c:func_8009CDDC (20x)
       20 ( 0.00%)                  return;
        .                       case 2:
       60 ( 0.00%)                  func_8009D958(arg0, var_a1);
  147,712 ( 0.00%)  => src/code_80091750.c:func_8009D958 (12x)
       12 ( 0.00%)                  return;
        .                       case 3:
        .                           func_8009DB8C();
        .                           return;
        .                       case 4:
        .                           func_8009DAA8();
        .                           return;
        .                       case 5:
        .                           func_8009D998(arg0);
-- line 4715 ----------------------------------------
-- line 4717 ----------------------------------------
        .                       case 7:
        .                           func_8009D978(arg0, var_a1);
        .                           return;
        .                       case 8:
        .                           func_8009CDFC(arg0, var_a1);
        .                           break;
        .                       case 0:
        .                       default:
      977 ( 0.00%)                  break;
        .                   }
        .               }
    2,018 ( 0.00%)  }
        .           
      140 ( 0.00%)  void func_8009CBE4(s32 arg0, s32 arg1, s32 arg2) {
        .               RGBA16* color;
        .               s16 x, y, w, h;
        .               UNUSED s32 pad[3];
        .               struct UnkStruct_800DC5EC* unk;
        .               struct UnkStruct_8018E7E8 *size, *start;
        .           
       80 ( 0.00%)      if ((gModeSelection == GRAND_PRIX) || (gModeSelection == TIME_TRIALS)) {
      120 ( 0.00%)          start = &(D_8018E7E8[arg0]);
      120 ( 0.00%)          size = &(D_8018E810[arg0]);
       60 ( 0.00%)          x = start->x;
       60 ( 0.00%)          y = start->y;
       60 ( 0.00%)          w = size->x;
       80 ( 0.00%)          h = size->y;
        .               } else if (arg0 >= 4) {
        .                   start = &(D_8018E7E8[arg0]);
        .                   size = &(D_8018E810[arg0]);
        .                   x = start->x;
        .                   y = start->y;
        .                   w = size->x;
        .                   h = size->y;
        .               } else {
        .                   unk = &D_8015F480[arg0];
        .                   x = unk->screenStartX;
        .                   y = unk->screenStartY;
        .                   w = unk->screenWidth;
        .                   h = unk->screenHeight;
        .               }
      120 ( 0.00%)      color = &D_800E7AE8[arg2];
    1,060 ( 0.00%)      gDisplayListHead = draw_box(gDisplayListHead, x - (w / 2), y - (h / 2), (w / 2) + x, (h / 2) + y, color->red,
  242,923 ( 0.00%)  => src/code_80091750.c:draw_box (20x)
      380 ( 0.00%)                                  color->green, color->blue, 0xFF - (D_8018E7D0[arg0] * 0xFF / D_8018E7B8[arg0]));
        .           
      420 ( 0.00%)      if ((arg1 == 0) && (D_8018E7D0[arg0] += 1, (D_8018E7D0[arg0] >= D_8018E7B8[arg0]))) {
        4 ( 0.00%)          if (gGamestate == 4) {
        .                       D_8018E7AC[arg0] = 6;
        .                       return;
        .                   }
        4 ( 0.00%)          D_8018E7AC[arg0] = 0;
        2 ( 0.00%)          D_8018EE0C = 0;
        .               }
       60 ( 0.00%)  }
        .           
      100 ( 0.00%)  void func_8009CDDC(s32 arg0, s32 arg1) {
      120 ( 0.00%)      func_8009CBE4(arg0, arg1, 0);
  245,693 ( 0.00%)  => src/code_80091750.c:func_8009CBE4 (20x)
       60 ( 0.00%)  }
        .           
        .           void func_8009CDFC(s32 arg0, s32 arg1) {
        .               func_8009CBE4(arg0, arg1, 1);
        .           }
        .           
        .           void func_8009CE1C(void) {
        .               if ((gSoundMode != 3) && (gPlayerCountSelection1 >= 2)) {
        .                   func_800C3448(0xE0000002);
        .               }
        .           }
        .           
        5 ( 0.00%)  void func_8009CE64(s32 arg0) {
        .               s32 thing;
        .               s32 var_a1;
        .               UNUSED s32 stackPadding0;
        .               struct_8018D9E0_entry* temp_v0;
        .           
        1 ( 0.00%)      var_a1 = 0;
        4 ( 0.00%)      if (gGamestate == 5) {
        .                   if (2 != gCCSelection) {
        .                       thing = gCCSelection;
        .                       if (thing != 3) {
        .                           goto func_8009CE64_label1;
        .                       }
        .                       goto func_8009CE64_label2;
        .                   }
        .               func_8009CE64_label2:
-- line 4801 ----------------------------------------
-- line 4805 ----------------------------------------
        .               func_8009CE64_label1:
        .                   if (var_a1) {
        .                       gGotoMenu = 9;
        .                       gCreditsCourseId = 8;
        .                   } else {
        .                       gGotoMenu = 1;
        .                       gMenuSelection = 0x0000000B;
        .                   }
        4 ( 0.00%)      } else if (gGamestate == 4) {
        .                   if (D_8018E7AC[arg0] == 2) {
        .                       if (arg0 != 4) {
        .                           D_8018E7AC[arg0] = 5;
        .                       } else {
        .                           var_a1 = 0;
        .                           temp_v0 = find_8018D9E0_entry(0x000000B0);
        .                           if (temp_v0 != NULL) {
        .                               switch (temp_v0->cursor) { /* switch 8; irregular */
-- line 4821 ----------------------------------------
-- line 4917 ----------------------------------------
        .                                   } else {
        .                                       D_8018E7AC[arg0] = 5;
        .                                   }
        .                               }
        .                           }
        .                       }
        .                   }
        .               } else {
        4 ( 0.00%)          D_8018E7AC[arg0] = 0;
        4 ( 0.00%)          if (gDebugMenuSelection != 0x40) {
        .                       switch (D_8018EDE0) { /* switch 3 */
        .                           case 0:           /* switch 3 */
        .                               if (gMenuSelection == 8) {
        .                                   gMenuSelection = 0x0000000A;
        .                                   D_800E86A4 = 2;
        .                               } else {
        .                                   gMenuSelection++;
        .                               }
-- line 4934 ----------------------------------------
-- line 5051 ----------------------------------------
        .                           gGamestateNext = 4;
        .                           if (gModeSelection == 1) {
        .                               D_8018EDFB = (s8) 1;
        .                           }
        .                           func_8009CE1C();
        .                       }
        .                       D_8018EE0C = 0;
        .                   } else {
        7 ( 0.00%)              switch (gDebugGotoScene) { /* switch 5; irregular */
        .                           case 1:                /* switch 5 */
        .                               gGamestateNext = (s32) 5;
        .                               break;
        .                           case 2: /* switch 5 */
        .                           case 3: /* switch 5 */
        .                               gGamestateNext = 9;
        .                               gCreditsCourseId = 8;
        .                               break;
        .                           default: /* switch 5 */
        2 ( 0.00%)                      gGamestateNext = 4;
        4 ( 0.00%)                      if (gModeSelection == (s32) 1) {
        .                                   D_8018EDFB = 1;
        .                               }
        1 ( 0.00%)                      break;
        .                       }
        1 ( 0.00%)              func_8000F124();
      278 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80005FD0.c:func_8000F124 (1x)
        4 ( 0.00%)              if (gScreenModeSelection == 3) {
        .                           switch (gModeSelection) {
        .                               case 0:
        .                               case 1:
        .                                   gModeSelection = 2;
        .                                   break;
        .                           }
        .                       }
        .           
       17 ( 0.00%)              if (GetCourse() == GetBlockFort() || GetCourse() == GetSkyscraper() || GetCourse() == GetDoubleDeck() ||
       18 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (3x)
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetSkyscraper (1x)
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBlockFort (1x)
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetDoubleDeck (1x)
        3 ( 0.00%)                  GetCourse() == GetBigDonut()) {
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1x)
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBigDonut (1x)
        .           
        .                           gModeSelection = BATTLE;
        .                           if (gPlayerCountSelection1 == 1) {
        .                               gPlayerCount = 2;
        .                               gScreenModeSelection = SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL;
        .                               gPlayerCountSelection1 = gPlayerCount;
        .                           }
        .                       } else {
        4 ( 0.00%)                  if (gModeSelection == 3) {
        .                               gModeSelection = 0;
        .                           }
        4 ( 0.00%)                  if ((gModeSelection == 2) && (gPlayerCountSelection1 == 1)) {
        .                               gModeSelection = 0;
        .                           }
        .                       }
        .           
        8 ( 0.00%)              gCupSelection = gCupSelectionByCourseId[gCurrentCourseId];
        4 ( 0.00%)              D_800DC540 = GetCupIndex();
    1,021 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCupIndex (1x)
        8 ( 0.00%)              gCourseIndexInCup = gPerCupIndexByCourseId[gCurrentCourseId];
        .           
       11 ( 0.00%)              switch (gDebugGotoScene) { /* switch 6; irregular */
        .                           case 1:                /* switch 6 */
        .                               break;
        .                           case 2: /* switch 6 */
        .                               gCCSelection = 0;
        .                               break;
        .                           case 3: /* switch 6 */
        .                               gCCSelection = 3;
        .                               break;
        .                           default: /* switch 6 */
        4 ( 0.00%)                      if (gCCSelection == 3) {
        .                                   gIsMirrorMode = 1;
        .                               } else {
        2 ( 0.00%)                          gIsMirrorMode = 0;
        .                               }
        1 ( 0.00%)                      break;
        .                       }
        .                   }
        .               }
        4 ( 0.00%)  }
        .           
       72 ( 0.00%)  void func_8009D77C(s32 arg0, s32 arg1, s32 arg2) {
        .               s16 var_ra;
        .               s16 var_t3;
        .               s16 var_t4;
        .               s32 temp_t8;
        .               s32 temp_v1;
        .               s32 var_t2;
        .               s32 someMath0;
        .               s32 someMath1;
        .               RGBA16* temp_v0_2;
        .               s32 sp44;
        .               UNUSED s32 stackPadding0;
        .           
       48 ( 0.00%)      if ((gModeSelection == 0) || (gModeSelection == 1)) {
       60 ( 0.00%)          var_t3 = D_8018E7E8[arg0].x;
       60 ( 0.00%)          var_t4 = D_8018E7E8[arg0].y;
       60 ( 0.00%)          var_ra = D_8018E810[arg0].x;
       84 ( 0.00%)          sp44 = D_8018E810[arg0].y;
        .               } else if (arg0 >= 4) {
        .                   var_t3 = D_8018E7E8[arg0].x;
        .                   var_t4 = D_8018E7E8[arg0].y;
        .                   var_ra = D_8018E810[arg0].x;
        .                   sp44 = D_8018E810[arg0].y;
        .               } else {
        .                   var_t3 = D_8015F480[arg0].screenStartX;
        .                   var_t4 = D_8015F480[arg0].screenStartY;
        .                   var_ra = D_8015F480[arg0].screenWidth;
        .                   sp44 = D_8015F480[arg0].screenHeight;
        .               }
      192 ( 0.00%)      var_t2 = (D_8018E7D0[arg0] * 0xFF) / D_8018E7B8[arg0];
       24 ( 0.00%)      if (var_t2 >= 0x100) {
        1 ( 0.00%)          var_t2 = 0x000000FF;
        .               }
       84 ( 0.00%)      temp_v1 = var_ra / 2;
       72 ( 0.00%)      temp_t8 = sp44 / 2;
       72 ( 0.00%)      temp_v0_2 = &D_800E7AE8[arg2];
        .               // Why does it have to written like this to match?
       24 ( 0.00%)      someMath0 = temp_v1;
       24 ( 0.00%)      someMath0 += var_t3;
       24 ( 0.00%)      someMath1 = temp_t8;
       24 ( 0.00%)      someMath1 += var_t4;
      300 ( 0.00%)      gDisplayListHead = draw_box(gDisplayListHead, var_t3 - temp_v1, var_t4 - temp_t8, someMath0, someMath1,
  144,486 ( 0.00%)  => src/code_80091750.c:draw_box (12x)
       72 ( 0.00%)                                  temp_v0_2->red, temp_v0_2->green, temp_v0_2->blue, var_t2);
       24 ( 0.00%)      if (arg1 == 0) {
      108 ( 0.00%)          D_8018E7D0[arg0]++;
      132 ( 0.00%)          if ((D_8018E7B8[arg0] + 1) < D_8018E7D0[arg0]) {
        3 ( 0.00%)              func_8009CE64(arg0);
    1,458 ( 0.00%)  => src/code_80091750.c:func_8009CE64 (1x)
        .                   }
        .               }
       36 ( 0.00%)  }
        .           
       60 ( 0.00%)  void func_8009D958(s32 arg0, s32 arg1) {
       72 ( 0.00%)      func_8009D77C(arg0, arg1, 0);
  147,544 ( 0.00%)  => src/code_80091750.c:func_8009D77C (12x)
       36 ( 0.00%)  }
        .           
        .           void func_8009D978(s32 arg0, s32 arg1) {
        .               func_8009D77C(arg0, arg1, 1);
        .           }
        .           
        .           void func_8009D998(s32 arg0) {
        .               s16 var_t0;
        .               s16 var_t1;
-- line 5189 ----------------------------------------
-- line 5282 ----------------------------------------
        .               gDPPipeSync(gDisplayListHead++);
        .               var_v1 = (D_8018E7D0[4] * 255) / D_8018E7B8[4];
        .               if (var_v1 >= 0x100) {
        .                   var_v1 = 0x000000FF;
        .               }
        .               gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x00000140, 0x000000F0, 0, 0, 0, var_v1);
        .           }
        .           
        4 ( 0.00%)  void func_8009DEF8(u32 arg0, u32 arg1) {
        2 ( 0.00%)      if (arg0 == 0) {
        .                   arg0 = 1;
        .               }
        8 ( 0.00%)      if ((D_8018E7AC[4] != 1) && (D_8018E7AC[4] != 6)) {
        4 ( 0.00%)          D_8018E7AC[4] = arg1;
        3 ( 0.00%)          D_8018E7B8[4] = arg0;
        4 ( 0.00%)          if (D_8018E7B8[4] >= 0x100U) {
        .                       D_8018E7B8[4] = 0xFFU;
        .                   }
        2 ( 0.00%)          D_8018E7D0[4] = 0;
        .               }
        3 ( 0.00%)  }
        .           
        4 ( 0.00%)  void func_8009DF4C(s32 arg0) {
        4 ( 0.00%)      func_8009DEF8(arg0, 1);
       30 ( 0.00%)  => src/code_80091750.c:func_8009DEF8 (1x)
        3 ( 0.00%)  }
        .           
        .           void func_8009DF6C(s32 arg0) {
        .               func_8009DEF8(arg0, 8);
        .           }
        .           
        4 ( 0.00%)  void func_8009DF8C(u32 arg0, u32 arg1) {
        2 ( 0.00%)      if (arg0 == 0) {
        .                   arg0 = 1;
        .               }
        8 ( 0.00%)      if ((D_8018E7AC[4] != 2) && (D_8018E7AC[4] != 5)) {
        4 ( 0.00%)          D_8018E7AC[4] = arg1;
        3 ( 0.00%)          D_8018E7B8[4] = arg0;
        4 ( 0.00%)          if (D_8018E7B8[4] >= 0x100U) {
        .                       D_8018E7B8[4] = 0xFFU;
        .                   }
        2 ( 0.00%)          D_8018E7D0[4] = 0;
        .               }
        3 ( 0.00%)  }
        .           
        4 ( 0.00%)  void func_8009DFE0(s32 arg0) {
        4 ( 0.00%)      func_8009DF8C(arg0, 2);
       30 ( 0.00%)  => src/code_80091750.c:func_8009DF8C (1x)
        3 ( 0.00%)  }
        .           
        .           void func_8009E000(s32 arg0) {
        .               func_8009DF8C(arg0, 7);
        .           }
        .           
        .           void func_8009E020(s32 arg0, s32 arg1) {
        .               s32 temp;
        .           
-- line 5336 ----------------------------------------
-- line 5389 ----------------------------------------
        .                   D_8018E7B8[4] = arg0;
        .                   if (D_8018E7B8[4] >= 0x100U) {
        .                       D_8018E7B8[4] = 0x000000FFU;
        .                   }
        .                   D_8018E7D0[4] = 0;
        .               }
        .           }
        .           
        2 ( 0.00%)  void func_8009E1C0(void) {
        2 ( 0.00%)      func_8009DFE0(10);
       41 ( 0.00%)  => src/code_80091750.c:func_8009DFE0 (1x)
        2 ( 0.00%)      D_8018EDE0 = 0;
        3 ( 0.00%)  }
        .           
        .           void func_8009E1E4(void) {
        .               func_8009E000(10);
        .               D_8018EDE0 = 0;
        .           }
        .           
        .           void func_8009E208(void) {
        .               func_8009DFE0(10);
-- line 5408 ----------------------------------------
-- line 5419 ----------------------------------------
        .               D_8018EDE0 = 3;
        .           }
        .           
        .           void func_8009E280(void) {
        .               func_8009DFE0(10);
        .               D_8018EDE0 = 4;
        .           }
        .           
    1,328 ( 0.00%)  void func_8009E2A8(s32 arg0) {
    2,324 ( 0.00%)      switch (D_8018E838[arg0]) {
        .                   case 0:
      332 ( 0.00%)              break;
        .                   case 1:
        .                       func_8009E2F0(arg0);
        .                       break;
        .                   default:
        .                       D_8018E838[arg0] = 0;
        .                       break;
        .               }
      996 ( 0.00%)  }
        .           
        .           void func_8009E2F0(s32 arg0) {
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               s32 someIndex;
        .               s32 temp_t7;
        .               f32 temp_t7_2;
        .               RGBA16* temp_v0;
-- line 5446 ----------------------------------------
-- line 5478 ----------------------------------------
        .               }
        .           }
        .           
        .           void func_8009E5FC(s32 arg0) {
        .               D_8018E838[arg0] = 1;
        .               D_8018E840[arg0] = 0;
        .           }
        .           
        4 ( 0.00%)  void func_8009E620(void) {
        .               s32 index;
      200 ( 0.00%)      for (index = 0; index < D_8018D9E0_SIZE; index++) {
      576 ( 0.00%)          D_8018D9E0[index].type = 0;
        .               }
        8 ( 0.00%)  }
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/1BHpa
        .           // Stack differences, can't figure out how to fix them
       81 ( 0.00%)  void add_ui_element(s32 type, s32 column, s32 row, s8 priority) {
        .               struct_8018D9E0_entry* var_ra;
        .               s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               UNUSED s32 stackPadding2;
        .               s32 temp_v0_6;
        .               s32 var_v0;
        .               s32 var_v1_3;
        .               s32 temp_a1;
        .               UNUSED MkTexture* mk64Texture;
        .               MkAnimation* var_a0;
        9 ( 0.00%)      s32 one = 1;
        .           
        9 ( 0.00%)      var_v0 = 0;
       18 ( 0.00%)      var_ra = D_8018D9E0;
        .               // ????????
        .               // Credit to Vetri for the idea to mess around with this loop
        .               // to fix the issue near the 0xD4 case
        .               while (true) {
       41 ( 0.00%)          var_v0++;
      100 ( 0.00%)          if (var_ra->type == 0)
        9 ( 0.00%)              break;
        .           
       32 ( 0.00%)          if (var_v0 > D_8018D9E0_SIZE) {
        .                       printf("Ran out of buffer space for UI elements");
        .                       while (true) {}
        .                   }
       16 ( 0.00%)          var_ra++;
        .               }
       27 ( 0.00%)      var_ra->type = type;
       18 ( 0.00%)      var_ra->cursor = 0;
       18 ( 0.00%)      var_ra->unk8 = 0;
       27 ( 0.00%)      var_ra->column = column;
       27 ( 0.00%)      var_ra->row = row;
       27 ( 0.00%)      var_ra->priority = (u8) priority;
       36 ( 0.00%)      var_ra->visible = one;
       18 ( 0.00%)      var_ra->unk1C = 0;
       18 ( 0.00%)      var_ra->unk20 = 0;
       90 ( 0.00%)      switch (type) {
        .                   case 0xFA:
        .                       s8018ED94 = 0;
        .                       D_800E8530 = 0.0f;
        .                       D_800E8534 = 3.0f;
        .                       D_8018EDC0 = 0x000009C4;
        .                       D_8018EDC8 = 0;
        .                       D_8018EDCC = -270.0f;
        .                       D_8018EDD0 = 0;
-- line 5542 ----------------------------------------
-- line 5543 ----------------------------------------
        .                       D_8018EDD4 = 0;
        .                       D_8018EDD8 = 0;
        .                       D_8018EDDC = 0;
        .                       D_8018EDC4 = 3;
        .                       var_ra->unk1C = -1;
        .                       var_ra->unk20 = one;
        .                       break;
        .                   case 0xFB:
        2 ( 0.00%)              D_8018EDC0 = 0x00000708;
        3 ( 0.00%)              D_8018EDC8 = -51.0f;
        3 ( 0.00%)              D_8018EDCC = -12.0f;
        3 ( 0.00%)              D_8018EDD0 = -18.0f;
        3 ( 0.00%)              D_8018EDD4 = -270.0f;
        3 ( 0.00%)              D_8018EDD8 = 750.0f;
        3 ( 0.00%)              D_8018EDDC = 0;
        3 ( 0.00%)              D_8018EDC4 = 1.0f;
        2 ( 0.00%)              var_ra->unk1C = -1;
        3 ( 0.00%)              var_ra->unk20 = one;
        1 ( 0.00%)              break;
        .                   case 0xD2:
        .                       load_menu_img2(D_020014C8, 0);
        .                       func_8009B954(D_020014C8);
        .                       D_8018E75C = func_8009BA74(D_8018E75C, D_020014C8, var_ra->column, var_ra->row);
        .                       func_8009B998();
        .                       break;
        .                   case 0xD3:
        .                       load_menu_img2(D_02001540, 0);
-- line 5569 ----------------------------------------
-- line 5609 ----------------------------------------
        .                           load_menu_img(segmented_to_virtual_dupe(D_800E7D0C[var_v0]));
        .                       }
        .                       break;
        .                   case 0xD8:
        .                   case 0xD9:
        .                       load_menu_img(D_0200184C);
        .                       break;
        .                   case 0x1:
        8 ( 0.00%)              load_menu_img2(D_800E7D4C[has_unlocked_extra_mode()], 0);
  166,513 ( 0.00%)  => src/code_80091750.c:load_menu_img2 (1x)
       18 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:has_unlocked_extra_mode (1x)
        1 ( 0.00%)              break;
        .                   case 0x2:
        1 ( 0.00%)              load_mario_kart_64_logo();
   13,324 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_8006E9C0.c:load_mario_kart_64_logo (1x)
        5 ( 0.00%)              gMenuTextureBufferIndex += 0x10000;
        3 ( 0.00%)              load_menu_img(D_020045E8);
      129 ( 0.00%)  => src/code_80091750.c:load_menu_img (1x)
        1 ( 0.00%)              break;
        .                   case 0x3:
        3 ( 0.00%)              load_menu_img(D_02004610);
      167 ( 0.00%)  => src/code_80091750.c:load_menu_img (1x)
        1 ( 0.00%)              break;
        .                   case 0x23:
        .                   case 0x24:
        .                   case 0x25:
        .                       load_menu_img2(D_800E7D4C[has_unlocked_extra_mode()], 0);
        .                       load_menu_img2(D_02004B74, 0);
        .                       convert_img_to_greyscale(0, 0x00000019);
        .                       adjust_img_colour(0, SCREEN_WIDTH * SCREEN_HEIGHT, D_800E74E8[type - 0x23].red,
        .                                         D_800E74E8[type - 0x23].green, D_800E74E8[type - 0x23].blue);
-- line 5634 ----------------------------------------
-- line 5916 ----------------------------------------
        .                   case 0x1C8:
        .                   case 0x1C9:
        .                   case 0x1CA:
        .                   case 0x1CB:
        .                   case 0x1CC:
        .                   case 0x1CD:
        .                   case 0x1CE:
        .                   default:
       10 ( 0.00%)              break;
        .               }
       36 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/add_ui_element.s")
        .           #endif
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/MatRp
        .           // Biggest diff left is in the case 0x12 though 0x19 handling. Not really sure what's going on there
        .           // There's also a diff in the handling of D_800E77A0 in case 0x4. Not sure what's going on there either
   76,992 ( 0.00%)  void func_8009F5E0(struct_8018D9E0_entry* arg0) {
        .               s32 var_a1;
        .               s32 var_v1;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               MkTexture* sp9C;
        .               UNUSED s32 stackPadding2;
        .               s32 temp_a0;
        .               s32 temp_t2;
        .               s32 temp_t5;
        .               s32 temp_t9;
        .               s32 temp_v1;
        .               char sp80[3];
        .               s32 var_t0;
        .               UNUSED s32 var_a2;
   25,664 ( 0.00%)      f32 why = 0.75f;
   12,832 ( 0.00%)      s32 one = 1;
   25,664 ( 0.00%)      f32 floatone = 1;
        .               UNUSED s32 stackPadding3;
        .               UNUSED s32 stackPadding4;
        .               f32 var_f0;
        .           
   51,328 ( 0.00%)      if ((s8) arg0->visible != 0) {
   17,644 ( 0.00%)          gDPPipeSync(gDisplayListHead++);
   19,248 ( 0.00%)          switch (arg0->type) { /* switch 6; irregular */
        .                       case 0xFA:        /* switch 6 */
        .                           func_80094660(gGfxPool, arg0->unk1C);
        .                           break;
        .                       case 0xFB: /* switch 6 */
      483 ( 0.00%)                  render_checkered_flag(gGfxPool, arg0->unk1C);
11,733,915 ( 0.01%)  => src/code_80091750.c:render_checkered_flag (69x)
       69 ( 0.00%)                  break;
        .                       case 0xD2: /* switch 6 */
        .                           gDisplayListHead = func_8009B9D0(gDisplayListHead, D_020014C8);
        .                           break;
        .                       case 0xD3: /* switch 6 */
        .                           gDisplayListHead = func_8009B9D0(gDisplayListHead, D_02001540);
        .                           break;
        .                       case 0xD4: /* switch 6 */
        .                           func_800A09E0(arg0);
-- line 5973 ----------------------------------------
-- line 5993 ----------------------------------------
        .                       case 0xD7: /* switch 6 */
        .                           func_800A0DFC();
        .                           break;
        .                       case 0xD8: /* switch 6 */
        .                       case 0xD9: /* switch 6 */
        .                           func_800A0EB8(arg0, arg0->type - 0xD8);
        .                           break;
        .                       case 0x1: /* switch 6 */
      138 ( 0.00%)                  gDisplayListHead =
    1,035 ( 0.00%)                      func_8009BA74(gDisplayListHead, D_800E7D4C[has_unlocked_extra_mode()], arg0->column, arg0->row);
3,077,696 ( 0.00%)  => src/code_80091750.c:func_8009BA74 (69x)
    1,242 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:has_unlocked_extra_mode (69x)
       69 ( 0.00%)                  break;
        .                       case 0x2: /* switch 6 */
      759 ( 0.00%)                  func_8004C8D4((arg0->column + 0xA0), (arg0->row + 0x47));
2,279,799 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004C8D4 (69x)
      759 ( 0.00%)                  gDisplayListHead = func_8009BA74(gDisplayListHead, D_020045E8, arg0->column, arg0->row);
  904,166 ( 0.00%)  => src/code_80091750.c:func_8009BA74 (69x)
       69 ( 0.00%)                  break;
        .                       case 0x3: /* switch 6 */
    1,449 ( 0.00%)                  if (((gGlobalTimer / 8) % 3) != 0) {
      517 ( 0.00%)                      gDisplayListHead = func_8009BA74(gDisplayListHead, D_02004610, arg0->column, arg0->row);
  628,253 ( 0.00%)  => src/code_80091750.c:func_8009BA74 (47x)
        .                           }
      185 ( 0.00%)                  break;
        .                       case 0x5: /* switch 6 */
        .                           var_t0 = (s32) ((f32) (get_string_width(gCourseNamesDup[0]) + 5) * 0.9f) / 2;
        .                           gDisplayListHead = draw_box(gDisplayListHead, 0xA0 - var_t0, 0x0000007B, var_t0 + 0xA0, 0x000000A4, 0,
        .                                                       0, 0, 0x00000096);
        .                           set_text_color(1);
        .                           draw_text(0x0000009B, 0x0000008C, gCourseNamesDup[0], 0, 0.9f, 0.9f);
        .                           temp_v1 = func_800B4EB4(0, 7) & 0xFFFFF;
        .                           if (temp_v1 < 0x1EAA) {
-- line 6020 ----------------------------------------
-- line 6295 ----------------------------------------
        .                       case 0x87: /* switch 6 */
        .                       case 0x88: /* switch 6 */
        .                       case 0x89: /* switch 6 */
        .                       case 0x8A: /* switch 6 */
        .                       case 0x8B: /* switch 6 */
        .                           func_800A15EC(arg0);
        .                           break;
        .                       case 0x96: /* switch 6 */
      274 ( 0.00%)                  set_text_color(4);
    1,370 ( 0.00%)  => src/code_80091750.c:set_text_color (137x)
    2,329 ( 0.00%)                  func_800936B8(arg0->column, arg0->row, gCupNames[D_800DC540], arg0->unk1C, arg0->unk24, 1.0f);
43,670,598 ( 0.04%)  => src/code_80091750.c:func_800936B8 (137x)
      137 ( 0.00%)                  break;
        .                       case 0x97: /* switch 6 */
      258 ( 0.00%)                  set_text_color(5);
    1,290 ( 0.00%)  => src/code_80091750.c:set_text_color (129x)
    2,064 ( 0.00%)                  func_80093324(arg0->column, arg0->row, CourseManager_GetProps()->Name, arg0->unk1C, arg0->unk24, 1.0f);
47,194,423 ( 0.04%)  => src/code_80091750.c:func_80093324 (129x)
    1,548 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_GetProps (129x)
      129 ( 0.00%)                  break;
        .                       case 0x98: /* switch 6 */
      387 ( 0.00%)                  func_800A2D1C(arg0);
6,179,391 ( 0.01%)  => src/code_80091750.c:func_800A2D1C (129x)
      129 ( 0.00%)                  break;
        .                       case 0x5E: /* switch 6 */
        .                           gDisplayListHead = func_80096CD8(gDisplayListHead, 0x00000019, 0x00000072, 0x0000007CU, 0x0000004AU);
        .                           break;
        .                       case 0xAA: /* switch 6 */
        .                           func_800A2EB8(arg0);
        .                           break;
        .                       case 0xAB: /* switch 6 */
        .                           func_800A34A8(arg0);
-- line 6320 ----------------------------------------
-- line 6347 ----------------------------------------
        .                           break;
        .                       case 0xBA: /* switch 6 */
        .                           func_800A3E60(arg0);
        .                           break;
        .                       case 0xBC: /* switch 6 */
        .                           func_800A4A24(arg0);
        .                           break;
        .                       case 0xC7: /* switch 6 */
      996 ( 0.00%)                  render_pause_menu(arg0);
    3,652 ( 0.00%)  => src/code_80091750.c:render_pause_menu (332x)
      332 ( 0.00%)                  break;
        .                       case 0xBD: /* switch 6 */
        .                           func_800A5738(arg0);
        .                           break;
        .                       case 0xE6: /* switch 6 */
        .                           func_800A1924(arg0);
        .                           break;
        .                       case 0xE7: /* switch 6 */
        .                           func_800A1A20(arg0);
-- line 6364 ----------------------------------------
-- line 6466 ----------------------------------------
        .                       case 0x1CB: /* switch 6 */
        .                       case 0x1CC: /* switch 6 */
        .                       case 0x1CD: /* switch 6 */
        .                       case 0x1CE: /* switch 6 */
        .                           func_800A7790(arg0);
        .                           break;
        .                   }
        .               }
   76,992 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009F5E0.s")
        .           #endif
        .           
        .           void func_800A08D8(u8 arg0, s32 column, s32 row) {
        .               if (arg0 >= 0x10) {
        .                   arg0 -= 0x10;
        .                   if (arg0 < 0x85) {
-- line 6482 ----------------------------------------
-- line 7186 ----------------------------------------
        .                       break;
        .               }
        .               func_800A66A8(arg0, (Unk_D_800E70A0*) &spE0);
        .           }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1FB0.s")
        .           #endif
        .           
      516 ( 0.00%)  void func_800A2D1C(struct_8018D9E0_entry* arg0) {
      575 ( 0.00%)      switch (D_80164A28) {
        .                   case 1:
    1,090 ( 0.00%)              gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, 0x28);
2,630,957 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (109x)
    1,090 ( 0.00%)              gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0xC7, 0x13F, 0xEF);
2,627,407 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (109x)
      218 ( 0.00%)              arg0->unk1C = 0x28;
      109 ( 0.00%)              break;
        .                   case 2:
        5 ( 0.00%)              arg0->unk1C -= 2;
        4 ( 0.00%)              if (arg0->unk1C > 0) {
       12 ( 0.00%)                  gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, arg0->unk1C);
   24,096 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (1x)
       13 ( 0.00%)                  gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
   24,096 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (1x)
        .                       } else {
        .                           arg0->type = 0;
        .                       }
        1 ( 0.00%)              break;
        .                   default:
      228 ( 0.00%)              if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
        .                           arg0->type = 0;
        .                       } else {
       95 ( 0.00%)                  arg0->unk1C -= 2;
       76 ( 0.00%)                  if (arg0->unk1C > 0) {
      216 ( 0.00%)                      gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, arg0->unk1C);
  433,956 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (18x)
      234 ( 0.00%)                      gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
  433,971 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (18x)
        .                           } else {
        2 ( 0.00%)                      arg0->type = 0;
        .                           }
        .                       }
       37 ( 0.00%)              break;
        .               }
      387 ( 0.00%)  }
        .           
        .           void func_800A2EB8(struct_8018D9E0_entry* arg0) {
        .               s8 sp70[8];
        .               UNUSED s32 stackPadding0;
        .               char sp68[3];
        .               s32 temp_s0;
        .               s32 var_a0;
        .               s32 var_s2;
-- line 7232 ----------------------------------------
-- line 7753 ----------------------------------------
        .               temp_t1 = arg0->row;
        .               temp_t2 = (s32) ((get_string_width(D_800E7780) + 8) * someMultiplier) / 2;
        .               gDisplayListHead = draw_box(gDisplayListHead, temp_t0 - temp_t2, (temp_t1 - thing) + 4, temp_t2 + temp_t0,
        .                                           temp_t1 + 4, 0, 0, 0, 0x00000064);
        .               set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
        .               draw_text(arg0->column - 3, arg0->row, D_800E7780, 0, 0.85f, 0.85f);
        .           }
        .           
    1,328 ( 0.00%)  void render_pause_menu(struct_8018D9E0_entry* arg0) {
    1,328 ( 0.00%)      if (gIsGamePaused != 0) {
        .                   switch (gModeSelection) {
        .                       case TIME_TRIALS:
        .                           render_pause_menu_time_trials(arg0);
        .                           break;
        .                       case VERSUS:
        .                           render_pause_menu_versus(arg0);
        .                           break;
        .                       case GRAND_PRIX:
        .                           render_pause_grand_prix(arg0);
        .                           break;
        .                       case BATTLE:
        .                           render_pause_battle(arg0);
        .                           break;
        .                   }
        .               }
      996 ( 0.00%)  }
        .           
        .           void render_pause_menu_time_trials(struct_8018D9E0_entry* arg0) {
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               UNUSED s32 stackPadding2;
        .               char sp68[3];
        .               s32 temp_a0;
        .               s32 var_s0;
-- line 7786 ----------------------------------------
-- line 7908 ----------------------------------------
        .                   } else {
        .                       var_s1 = var_a1;
        .                   }
        .                   text_rainbow_effect(arg0->cursor - 0x29, var_a1, TEXT_YELLOW);
        .                   func_80093324(temp_s3->column - 2, temp_s3->row + 13 * var_a1, gTextPauseButton[var_s1], 0, 0.75f, 0.75f);
        .               }
        .           }
        .           
      996 ( 0.00%)  void func_800A54EC(void) {
        .               Unk_D_800E70A0 sp50;
        .               Unk_D_800E70A0* var_v1;
        .               struct_8018D9E0_entry* sp48;
        .               s32 whyTheSequel;
        .               s32 why;
        .               UNUSED Unk_D_800E70A0* huh;
        .           
    1,328 ( 0.00%)      if (gIsGamePaused == 0) {
      332 ( 0.00%)          return;
        .               }
        .           
        .               why = gModeSelection;
        .               sp48 = find_8018D9E0_entry(0x000000C7);
        .               if (why) {} // ?????
        .               gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
        .               guOrtho(&gGfxPool->mtxEffect[gMatrixEffectCount], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
        .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount++]),
-- line 7933 ----------------------------------------
-- line 7947 ----------------------------------------
        .                   case 3:
        .                       var_v1 = &D_800E8600[(gScreenModeSelection * 4) + (gIsGamePaused - 1)];
        .                       break;
        .               }
        .               whyTheSequel = D_800F0B50[why];
        .               sp50.column = var_v1->column - 8;
        .               sp50.row = (var_v1->row + ((sp48->cursor - whyTheSequel) * 0xD)) - 8;
        .               func_800A66A8(sp48, &sp50);
      664 ( 0.00%)  }
        .           
        .           void func_800A5738(struct_8018D9E0_entry* arg0) {
        .               Unk_D_800E70A0 sp98;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               UNUSED s32 stackPadding2;
        .               f32 why;
        .               char sp84[3];
-- line 7963 ----------------------------------------
-- line 8579 ----------------------------------------
        .           void func_800A79F4(s32 arg0, char* arg1) {
        .               arg1[0] = 0xA3;
        .               arg1[1] = (arg0 / 0xA) - 0x50;
        .               arg1[2] = 0xA3;
        .               arg1[3] = (arg0 % 0xA) - 0x50;
        .               arg1[4] = '\0';
        .           }
        .           
    3,208 ( 0.00%)  void func_800A7A4C(s32 arg0) {
        .               s32 var_s0;
        .               s32 var_v1;
        .               s32 var_v1_2;
        .               s32 type;
        .               struct_8018D9E0_entry* var_s1;
      802 ( 0.00%)      s32 one = 1;
        .           
   80,200 ( 0.00%)      for (var_v1_2 = 0; var_v1_2 < D_8018D9E0_SIZE; var_v1_2++) {
   25,664 ( 0.00%)          var_v1 = 0;
  230,976 ( 0.00%)          var_s1 = &D_8018D9E0[var_v1_2];
   76,992 ( 0.00%)          type = var_s1->type;
  153,708 ( 0.00%)          if ((type == 4) || (type == 5) || (type == 0x000000C7)) {
    2,005 ( 0.00%)              if (arg0 != 0) {
      401 ( 0.00%)                  var_v1 = 1;
        .                       }
   49,724 ( 0.00%)          } else if (arg0 == 0) {
   12,431 ( 0.00%)              var_v1 = 1;
        .                   }
        .           
   51,328 ( 0.00%)          if (var_v1 == 0) {
   25,664 ( 0.00%)              continue;
        .                   }
        .           
  128,320 ( 0.00%)          switch (type) { /* switch 8; irregular */
        .                       case 0xFA:  /* switch 8 */
        .                           if (s8018ED94 < 0x50) {
        .                               D_800E8534 = 3.0f;
        .                           } else if (s8018ED94 < 0x5A) {
        .                               if (D_800E8530 < 1.0) {
        .                                   D_800E8530 += 0.1;
        .                               }
        .                               D_800E8534 += 0.1;
-- line 8619 ----------------------------------------
-- line 8643 ----------------------------------------
        .                           break;
        .                       case 0xD6: /* switch 8 */
        .                           func_800A9710(var_s1);
        .                           break;
        .                       case 0xD4: /* switch 8 */
        .                           func_800A97BC(var_s1);
        .                           break;
        .                       case 0x5:                     /* switch 8 */
      276 ( 0.00%)                  switch (var_s1->cursor) { /* switch 9; irregular */
        .                               case 0:               /* switch 9 */
      483 ( 0.00%)                          if (gControllerFive->button & R_TRIG) {
        .                                       var_s1->cursor = (s32) 1U;
        .                                       play_sound2(SOUND_ACTION_PING);
        .                                   } else {
      138 ( 0.00%)                              var_s1->visible = 0;
        .                                   }
       69 ( 0.00%)                          break;
        .                               case 1:  /* switch 9 */
        .                               default: /* switch 9 */
        .                                   var_s1->visible = one;
        .                                   break;
        .                           }
       69 ( 0.00%)                  break;
        .                       case 0xA: /* switch 8 */
        .                           func_800AA280(var_s1);
        .                           break;
        .                       case 0x10:                             /* switch 8 */
        .                       case 0x11:                             /* switch 8 */
        .                           switch (gMainMenuSelectionDepth) { /* switch 5 */
        .                               case OPTIONS_SELECTION:        /* switch 5 */
        .                               case DATA_SELECTION:           /* switch 5 */
-- line 8673 ----------------------------------------
-- line 8823 ----------------------------------------
        .                       case 0x87: /* switch 8 */
        .                       case 0x88: /* switch 8 */
        .                       case 0x89: /* switch 8 */
        .                       case 0x8A: /* switch 8 */
        .                       case 0x8B: /* switch 8 */
        .                           func_800ABBCC(var_s1);
        .                           break;
        .                       case 0x96: /* switch 8 */
      414 ( 0.00%)                  func_800ABC38(var_s1);
   15,341 ( 0.00%)  => src/code_80091750.c:func_800ABC38 (138x)
      138 ( 0.00%)                  break;
        .                       case 0x97: /* switch 8 */
      390 ( 0.00%)                  func_800ABEAC(var_s1);
   14,625 ( 0.00%)  => src/code_80091750.c:func_800ABEAC (130x)
      130 ( 0.00%)                  break;
        .                       case 0x5E: /* switch 8 */
        .                           func_800AC300(var_s1);
        .                           break;
        .                       case 0xAA: /* switch 8 */
        .                           func_800AC324(var_s1);
        .                           break;
        .                       case 0xAB: /* switch 8 */
        .                           func_800AC458(var_s1);
-- line 8843 ----------------------------------------
-- line 8862 ----------------------------------------
        .                           break;
        .                       case 0xBA: /* switch 8 */
        .                           func_800AD2E8(var_s1);
        .                           break;
        .                       case 0xBC: /* switch 8 */
        .                           func_800AEC54(var_s1);
        .                           break;
        .                       case 0xC7: /* switch 8 */
      996 ( 0.00%)                  func_800ADF48(var_s1);
    4,316 ( 0.00%)  => src/code_80091750.c:func_800ADF48 (332x)
      332 ( 0.00%)                  break;
        .                       case 0xBD: /* switch 8 */
        .                           func_800AE218(var_s1);
        .                           break;
        .                       case 0xE6: /* switch 8 */
        .                           func_800AEDBC(var_s1);
        .                           break;
        .                       case 0xE8: /* switch 8 */
        .                           func_800AEE90(var_s1);
-- line 8879 ----------------------------------------
-- line 8971 ----------------------------------------
        .                       case 1:
        .                       case 2:
        .                       case 3:
        .                       case 4:
        .                           break;
        .                   }
        .               }
        .           
   41,704 ( 0.00%)      for (var_s0 = 0; var_s0 < 0x10; var_s0++) {
1,283,200 ( 0.00%)          for (var_v1_2 = 0; var_v1_2 < D_8018D9E0_SIZE; var_v1_2++) {
  410,624 ( 0.00%)              var_v1 = 0;
3,695,616 ( 0.00%)              var_s1 = &D_8018D9E0[var_v1_2];
        .                       if (var_s1 && var_s1) {} // ?
1,231,872 ( 0.00%)              type = var_s1->type;
2,459,328 ( 0.00%)              if ((type == 4) || (type == 5) || (type == 0x000000C7)) {
   32,080 ( 0.00%)                  if (arg0 != 0) {
    6,416 ( 0.00%)                      var_v1 = 1;
        .                           }
  795,584 ( 0.00%)              } else if (arg0 == 0) {
  198,896 ( 0.00%)                  var_v1 = 1;
        .                       }
1,847,808 ( 0.00%)              if ((var_v1 != 0) && (var_s0 == (s8) var_s1->priority)) {
   38,496 ( 0.00%)                  func_8009F5E0(var_s1);
115,996,274 ( 0.10%)  => src/code_80091750.c:func_8009F5E0 (12,832x)
        .                       }
        .                   }
        .               }
    3,208 ( 0.00%)  }
        .           
      802 ( 0.00%)  void func_800A8230(void) {
      802 ( 0.00%)      func_800A7A4C(0);
123,095,614 ( 0.10%)  => src/code_80091750.c:func_800A7A4C (401x)
    1,203 ( 0.00%)  }
        .           
      802 ( 0.00%)  void func_800A8250(void) {
      802 ( 0.00%)      func_800A7A4C(1);
5,824,632 ( 0.00%)  => src/code_80091750.c:func_800A7A4C (401x)
    1,203 ( 0.00%)  }
        .           
        .           void func_800A8270(s32 arg0, struct_8018D9E0_entry* arg1) {
        .               s32 temp_t1;
        .               s32 temp_t6;
        .               s32 var_s0;
        .               s32 var_s2;
        .               s32 var_s3;
        .               s32 var_s4;
-- line 9013 ----------------------------------------
-- line 9275 ----------------------------------------
        .               }
        .           }
        .           
        .           void func_800A91D8(struct_8018D9E0_entry* arg0, s32 columnTarget, s32 rowTarget) {
        .               func_800A9208(arg0, columnTarget);
        .               func_800A9278(arg0, rowTarget);
        .           }
        .           
    1,072 ( 0.00%)  void func_800A9208(struct_8018D9E0_entry* arg0, s32 columnTarget) {
    1,340 ( 0.00%)      s32 step = columnTarget - arg0->column;
        .           
      536 ( 0.00%)      if (step != 0) {
       84 ( 0.00%)          if (step > 0) {
      147 ( 0.00%)              step = (step / 4) + 1;
       42 ( 0.00%)              if (step >= 0x11) {
       20 ( 0.00%)                  step = 0x10;
        .                       }
        .                   } else {
      147 ( 0.00%)              step = (step / 4) - 1;
       42 ( 0.00%)              if (step < -0x10) {
       10 ( 0.00%)                  step = -0x10;
        .                       }
        .                   }
        .               }
    1,608 ( 0.00%)      arg0->column += step;
      804 ( 0.00%)  }
        .           
        .           void func_800A9278(struct_8018D9E0_entry* arg0, s32 rowTarget) {
        .               s32 step = rowTarget - arg0->row;
        .           
        .               if (step != 0) {
        .                   if (step > 0) {
        .                       step = (step / 4) + 1;
        .                       if (step >= 0x11) {
-- line 9308 ----------------------------------------
-- line 10248 ----------------------------------------
        .               //    }
        .           
        .               // Something VERY wrong has occurred
        .               //    while(true);
        .               // escape:
        .               //    return entry;
        .           }
        .           
   10,944 ( 0.00%)  struct_8018D9E0_entry* find_8018D9E0_entry(s32 arg0) {
  364,800 ( 0.00%)      for (size_t i = 0; i < ARRAY_COUNT(D_8018D9E0); i++) {
1,167,360 ( 0.00%)          if (D_8018D9E0[i].type == arg0) {
        .                       return &D_8018D9E0[i];
        .                   }
        .               }
        .               // No printf here as returning null seems to be normal game logic
        .               // printf("Error: find_8018D9E0_entry returned a null value when searching id 0x%X",
        .               //             arg0);
    3,648 ( 0.00%)      return NULL;
        .           
        .               //    struct_8018D9E0_entry *entry = D_8018D9E0;
        .               //    for (; !(entry > (&D_8018D9E0[D_8018D9E0_SIZE])); entry++) {
        .               //        if (entry->type == arg0) {
        .               //            goto escape;
        .               //        }
        .               //    }
        .           
        .               //    return NULL;
        .               // escape:
        .               //    return entry;
    7,296 ( 0.00%)  }
        .           
        .           s32 func_800AAF70(s32 arg0) {
        .               struct_8018D9E0_entry* temp;
        .               temp = func_800AAEB4(arg0);
        .               return temp->cursor;
        .           }
        .           
        .           void func_800AAF94(struct_8018D9E0_entry* arg0, s32 arg1) {
-- line 10285 ----------------------------------------
-- line 10633 ----------------------------------------
        .               Unk_D_800E70A0* temp_v1;
        .           
        .               temp_v0 = arg0->type - 0x7C;
        .               temp_v1 = &D_800E7430[temp_v0 / 4];
        .               arg0->column = (s32) temp_v1->column;
        .               arg0->row = temp_v1->row + ((temp_v0 % 4) * 0x32) + 0x14;
        .           }
        .           
      552 ( 0.00%)  void func_800ABC38(struct_8018D9E0_entry* arg0) {
        .               // Huh?
      138 ( 0.00%)      s32 one = 1;
      414 ( 0.00%)      func_800ABCF4(arg0);
   11,990 ( 0.00%)  => src/code_80091750.c:func_800ABCF4 (138x)
      638 ( 0.00%)      switch (D_80164A28) { /* irregular */
        .                   case 1:
      436 ( 0.00%)              arg0->visible = one;
      109 ( 0.00%)              break;
        .                   case 2:
        4 ( 0.00%)              if (arg0->row >= -0x13) {
        5 ( 0.00%)                  arg0->row -= 2;
        .                       } else {
        .                           arg0->type = 0;
        .                       }
        1 ( 0.00%)              break;
        .                   default:
      336 ( 0.00%)              if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != (s32) 1U) || (D_8018EE08 != 0)) {
        .                           arg0->type = 0;
        .                       } else {
      112 ( 0.00%)                  if (arg0->row >= -0x13) {
      135 ( 0.00%)                      arg0->row -= 2;
        .                           } else {
        2 ( 0.00%)                      arg0->type = 0;
        .                           }
        .                       }
       55 ( 0.00%)              break;
        .               }
      414 ( 0.00%)  }
        .           
      552 ( 0.00%)  void func_800ABCF4(struct_8018D9E0_entry* arg0) {
        .               f64 temp_f0;
        .           
      634 ( 0.00%)      switch (arg0->cursor) { /* irregular */
        .                   case 0:
        2 ( 0.00%)              arg0->column = 0;
        2 ( 0.00%)              arg0->cursor = 1;
       14 ( 0.00%)              arg0->unk20 = (get_string_width(gCupNames[D_800DC540]) / 2) + 0xA0;
      400 ( 0.00%)  => src/code_80091750.c:get_string_width (1x)
        .                       /* fallthrough */
        .                   case 1:
       84 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
      454 ( 0.00%)  => src/code_80091750.c:func_800A9208 (14x)
      182 ( 0.00%)              arg0->unk1C = (s32) (arg0->unk20 - arg0->column) / 4;
       56 ( 0.00%)              if (arg0->unk1C >= 9) {
       22 ( 0.00%)                  arg0->unk1C = 8;
        .                       }
      140 ( 0.00%)              arg0->unk24 = (f32) (((f64) arg0->unk1C * 0.05) + 1.0);
       98 ( 0.00%)              if (arg0->column >= (arg0->unk20 - 0x14)) {
        2 ( 0.00%)                  arg0->cursor = 2;
        2 ( 0.00%)                  arg0->D_8018DEE0_index = 0;
        .                       }
       29 ( 0.00%)              break;
        .                   case 2:
      744 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
    2,557 ( 0.00%)  => src/code_80091750.c:func_800A9208 (124x)
    1,612 ( 0.00%)              arg0->unk1C = (s32) (arg0->unk20 - arg0->column) / 4;
      620 ( 0.00%)              arg0->D_8018DEE0_index++;
      620 ( 0.00%)              temp_f0 = (f64) (arg0->D_8018DEE0_index - 0xA);
    1,116 ( 0.00%)              arg0->unk24 = (f32) ((temp_f0 * 0.0085 * temp_f0) + 0.4);
    1,076 ( 0.00%)              if ((arg0->D_8018DEE0_index >= 9) && ((f64) arg0->unk24 > 1.0)) {
      318 ( 0.00%)                  arg0->unk24 = 1.0f;
        .                       }
      240 ( 0.00%)              break;
        .               }
      414 ( 0.00%)  }
        .           
      520 ( 0.00%)  void func_800ABEAC(struct_8018D9E0_entry* arg0) {
      130 ( 0.00%)      s32 why = 1;
      390 ( 0.00%)      func_800ABF68(arg0);
   11,602 ( 0.00%)  => src/code_80091750.c:func_800ABF68 (130x)
      582 ( 0.00%)      switch (D_80164A28) {
        .                   case 1:
      436 ( 0.00%)              arg0->visible = why;
      109 ( 0.00%)              break;
        .                   case 2:
        4 ( 0.00%)              if (arg0->row < 0x104) {
        5 ( 0.00%)                  arg0->row += 2;
        .                       } else {
        .                           arg0->type = 0;
        .                       }
        1 ( 0.00%)              break;
        .                   default:
      240 ( 0.00%)              if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != why) || (D_8018EE08 != 0)) {
        .                           arg0->type = 0;
        .                       } else {
       80 ( 0.00%)                  if (arg0->row < 0x104) {
       95 ( 0.00%)                      arg0->row += 2;
        .                           } else {
        2 ( 0.00%)                      arg0->type = 0;
        .                           }
        .                       }
       39 ( 0.00%)              break;
        .               }
      390 ( 0.00%)  }
        .           
      520 ( 0.00%)  void func_800ABF68(struct_8018D9E0_entry* arg0) {
      602 ( 0.00%)      switch (arg0->cursor) {
        .                   case 0:
        2 ( 0.00%)              arg0->column = 0x140;
        2 ( 0.00%)              arg0->cursor = 1;
       13 ( 0.00%)              arg0->unk20 = 0xA0 - (get_string_width(CourseManager_GetProps()->Name) / 2);
      443 ( 0.00%)  => src/code_80091750.c:get_string_width (1x)
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_GetProps (1x)
        .                       /* fallthrough */
        .                   case 1:
       84 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
      444 ( 0.00%)  => src/code_80091750.c:func_800A9208 (14x)
      182 ( 0.00%)              arg0->unk1C = (arg0->column - arg0->unk20) / 4;
       56 ( 0.00%)              if (arg0->unk1C >= 9) {
       22 ( 0.00%)                  arg0->unk1C = 8;
        .                       }
      140 ( 0.00%)              arg0->unk24 = (arg0->unk1C * 0.05) + 1.0;
       98 ( 0.00%)              if ((arg0->unk20 + 0x14) >= arg0->column) {
        2 ( 0.00%)                  arg0->cursor = 2;
        2 ( 0.00%)                  arg0->D_8018DEE0_index = 0;
        .                       }
       29 ( 0.00%)              break;
        .                   case 2:
      696 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
    2,397 ( 0.00%)  => src/code_80091750.c:func_800A9208 (116x)
    1,508 ( 0.00%)              arg0->unk1C = (arg0->column - arg0->unk20) / 4;
      580 ( 0.00%)              arg0->D_8018DEE0_index++;
    1,856 ( 0.00%)              arg0->unk24 = ((arg0->D_8018DEE0_index - 0xA) * 0.0085 * (arg0->D_8018DEE0_index - 0xA)) + 0.4;
    1,004 ( 0.00%)              if ((arg0->D_8018DEE0_index >= 9) && ((f64) arg0->unk24 > 1.0)) {
      294 ( 0.00%)                  arg0->unk24 = 1.0f;
        .                       }
      224 ( 0.00%)              break;
        .               }
      390 ( 0.00%)  }
        .           
        .           void func_800AC128(struct_8018D9E0_entry* arg0) {
        .               switch (arg0->cursor) {
        .                   case 0:
        .                       arg0->column = 0x00000140;
        .                       arg0->cursor = 1;
        .                       /* fallthrough */
        .                   case 1:
-- line 10769 ----------------------------------------
-- line 11593 ----------------------------------------
        .                       break;
        .               }
        .           }
        .           #ifdef VERSION_EU
        .           #define FUNC_800ADF48DEF 70
        .           #else
        .           #define FUNC_800ADF48DEF 60
        .           #endif
    1,328 ( 0.00%)  void func_800ADF48(struct_8018D9E0_entry* arg0) {
        .               UNUSED s32 stackPadding;
        .               struct Controller* controller;
        .           
    1,328 ( 0.00%)      if (gIsGamePaused != 0) {
        .                   switch (arg0->cursor) {
        .                       case 0:
        .                           arg0->cursor = D_800F0B50[gModeSelection];
        .                           break;
        .                       case 11:
        .                       case 12:
        .                       case 13:
        .                       case 14:
-- line 11613 ----------------------------------------
-- line 11667 ----------------------------------------
        .                                   }
        .                               }
        .                           }
        .                           break;
        .                       default:
        .                           break;
        .                   }
        .               } else {
      996 ( 0.00%)          arg0->cursor = 0;
        .               }
      664 ( 0.00%)  }
        .           
        .           void func_800AE218(struct_8018D9E0_entry* arg0) {
        .               struct_8018EE10_entry* thing;
        .               s32 var_v1;
        .           
        .               if (arg0->cursor != 0) {
        .                   D_800DC5B8 = 0;
        .               }
-- line 11685 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/std_function.h
--------------------------------------------------------------------------------
Ir                 

-- line 77 ----------------------------------------
        .               void*       _M_object;
        .               const void* _M_const_object;
        .               void (*_M_function_pointer)();
        .               void (_Undefined_class::*_M_member_pointer)();
        .             };
        .           
        .             union [[gnu::may_alias]] _Any_data
        .             {
1,184,676 ( 0.00%)      void*       _M_access()       noexcept { return &_M_pod_data[0]; }
  592,494 ( 0.00%)      const void* _M_access() const noexcept { return &_M_pod_data[0]; }
        .           
        .               template<typename _Tp>
        .                 _Tp&
  396,972 ( 0.00%)        _M_access() noexcept
  496,215 ( 0.00%)        { return *static_cast<_Tp*>(_M_access()); }
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Any_data::_M_access() (533x)
        .           
        .               template<typename _Tp>
        .                 const _Tp&
  394,996 ( 0.00%)        _M_access() const noexcept
  493,745 ( 0.00%)        { return *static_cast<const _Tp*>(_M_access()); }
       18 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Any_data::_M_access() const (3x)
        .           
        .               _Nocopy_types _M_unused;
        .               char _M_pod_data[sizeof(_Nocopy_types)];
        .             };
        .           
        .             enum _Manager_operation
        .             {
        .               __get_type_info,
-- line 104 ----------------------------------------
-- line 126 ----------------------------------------
        .           	 && sizeof(_Functor) <= _M_max_size
        .           	 && __alignof__(_Functor) <= _M_max_align
        .           	 && (_M_max_align % __alignof__(_Functor) == 0));
        .           
        .           	using _Local_storage = integral_constant<bool, __stored_locally>;
        .           
        .           	// Retrieve a pointer to the function object
        .           	static _Functor*
  394,996 ( 0.00%)  	_M_get_pointer(const _Any_data& __source) noexcept
        .           	{
        .           	  if _GLIBCXX17_CONSTEXPR (__stored_locally)
        .           	    {
  392,864 ( 0.00%)  	      const _Functor& __f = __source._M_access<_Functor>();
      600 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:BS::thread_pool::thread_pool(unsigned int)::{lambda()#1} const& std::_Any_data::_M_access<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>() const (40x)
  294,648 ( 0.00%)  	      return const_cast<_Functor*>(std::__addressof(__f));
      240 ( 0.00%)  => /usr/include/c++/14/bits/move.h:BS::thread_pool::thread_pool(unsigned int)::{lambda()#1} const* std::__addressof<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1} const>(BS::thread_pool::thread_pool(unsigned int)::{lambda()#1} const&) (40x)
        .           	    }
        .           	  else // have stored a pointer
    2,132 ( 0.00%)  	    return __source._M_access<_Functor*>();
    7,995 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}* const& std::_Any_data::_M_access<BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}*>() const (533x)
  197,498 ( 0.00%)  	}
        .           
        .                 private:
        .           	// Construct a location-invariant function object that fits within
        .           	// an _Any_data structure.
        .           	template<typename _Fn>
        .           	  static void
  589,191 ( 0.00%)  	  _M_create(_Any_data& __dest, _Fn&& __f, true_type)
        .           	  {
1,374,677 ( 0.00%)  	    ::new (__dest._M_access()) _Functor(std::forward<_Fn>(__f));
    3,731 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&& std::forward<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&> >(std::remove_reference<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&> >::type&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Any_data::_M_access() (533x)
  392,785 ( 0.00%)  	  }
        .           
        .           	// Construct a function object on the heap and store a pointer.
        .           	template<typename _Fn>
        .           	  static void
    3,198 ( 0.00%)  	  _M_create(_Any_data& __dest, _Fn&& __f, false_type)
        .           	  {
    1,599 ( 0.00%)  	    __dest._M_access<_Functor*>()
    7,995 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}*& std::_Any_data::_M_access<BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}*&&, short)::{lambda()#1}*>() (533x)
    5,863 ( 0.00%)  	      = new _Functor(std::forward<_Fn>(__f));
  350,181 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/threadpool-src/include/BS_thread_pool.hpp:BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}::future({lambda()#1}&&) (533x)
   93,695 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}&& std::forward<BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}&&, short)::{lambda()#1}>(std::remove_reference<BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}>::type&) (533x)
    2,132 ( 0.00%)  	  }
        .           
        .           	// Destroy an object stored in the internal buffer.
        .           	static void
  392,708 ( 0.00%)  	_M_destroy(_Any_data& __victim, true_type)
        .           	{
  294,531 ( 0.00%)  	  __victim._M_access<_Functor>().~_Functor();
       45 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}& std::_Any_data::_M_access<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}>() (3x)
  294,531 ( 0.00%)  	}
        .           
        .           	// Destroy an object located on the heap.
        .           	static void
    2,665 ( 0.00%)  	_M_destroy(_Any_data& __victim, false_type)
        .           	{
    6,396 ( 0.00%)  	  delete __victim._M_access<_Functor*>();
  815,557 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/threadpool-src/include/BS_thread_pool.hpp:BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}::~future() (533x)
   57,333 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/del_ops.cc:operator delete(void*, unsigned long) (533x)
    7,995 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}*& std::_Any_data::_M_access<BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}*&&, short)::{lambda()#1}*>() (533x)
    2,132 ( 0.00%)  	}
        .           
        .                 public:
        .           	static bool
  691,180 ( 0.00%)  	_M_manager(_Any_data& __dest, const _Any_data& __source,
        .           		   _Manager_operation __op)
        .           	{
  296,340 ( 0.00%)  	  switch (__op)
        .           	    {
        .           	    case __get_type_info:
        .           #if __cpp_rtti
        .           	      __dest._M_access<const type_info*>() = &typeid(_Functor);
        .           #else
        .           	      __dest._M_access<const type_info*>() = nullptr;
        .           #endif
        .           	      break;
        .           
        .           	    case __get_functor_ptr:
        .           	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
        .           	      break;
        .           
        .           	    case __clone_functor:
      120 ( 0.00%)  	      _M_init_functor(__dest,
      116 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:void std::_Function_base::_Base_manager<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}>::_M_init_functor<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1} const&>(std::_Any_data&, spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1} const&) (2x)
      120 ( 0.00%)  		  *const_cast<const _Functor*>(_M_get_pointer(__source)));
       68 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Base_manager<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}>::_M_get_pointer(std::_Any_data const&) (2x)
       30 ( 0.00%)  	      break;
        .           
        .           	    case __destroy_functor:
  296,130 ( 0.00%)  	      _M_destroy(__dest, _Local_storage());
   13,325 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&> >::_M_destroy(std::_Any_data&, std::integral_constant<bool, true>) (533x)
   98,710 ( 0.00%)  	      break;
        .           	    }
   98,740 ( 0.00%)  	  return false;
  296,220 ( 0.00%)  	}
        .           
        .           	template<typename _Fn>
        .           	  static void
  493,680 ( 0.00%)  	  _M_init_functor(_Any_data& __functor, _Fn&& __f)
        .           	  noexcept(__and_<_Local_storage,
        .           			  is_nothrow_constructible<_Functor, _Fn>>::value)
        .           	  {
  789,888 ( 0.00%)  	    _M_create(__functor, std::forward<_Fn>(__f), _Local_storage());
      246 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:void std::_Function_base::_Base_manager<int (*)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::_M_create<int (* const&)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>(std::_Any_data&, int (* const&)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*), std::integral_constant<bool, true>) (6x)
       36 ( 0.00%)  => /usr/include/c++/14/bits/move.h:int (* const&std::forward<int (* const&)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>(std::remove_reference<int (* const&)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::type&))(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) (6x)
  296,208 ( 0.00%)  	  }
        .           
        .           	template<typename _Signature>
        .           	  static bool
        .           	  _M_not_empty_function(const function<_Signature>& __f) noexcept
        .           	  { return static_cast<bool>(__f); }
        .           
        .           	template<typename _Tp>
        .           	  static bool
       18 ( 0.00%)  	  _M_not_empty_function(_Tp* __fp) noexcept
       24 ( 0.00%)  	  { return __fp != nullptr; }
        .           
        .           	template<typename _Class, typename _Tp>
        .           	  static bool
        .           	  _M_not_empty_function(_Tp _Class::* __mp) noexcept
        .           	  { return __mp != nullptr; }
        .           
        .           	template<typename _Tp>
        .           	  static bool
  296,100 ( 0.00%)  	  _M_not_empty_function(const _Tp&) noexcept
  296,100 ( 0.00%)  	  { return true; }
        .                 };
        .           
1,115,598 ( 0.00%)      _Function_base() = default;
        .           
  405,564 ( 0.00%)      ~_Function_base()
        .               {
  405,582 ( 0.00%)        if (_M_manager)
  789,672 ( 0.00%)  	_M_manager(_M_functor, _M_functor, __destroy_functor);
6,443,646 ( 0.01%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (), std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&> >::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (97,631x)
  913,931 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<void (), BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (533x)
   35,178 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (), std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&> >::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (533x)
      396 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*), int (*)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (6x)
      132 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<void (), spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#2}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (2x)
      132 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<void (), spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (2x)
       66 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<void (), BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (1x)
  304,173 ( 0.00%)      }
        .           
  912,770 ( 0.00%)      bool _M_empty() const { return !_M_manager; }
        .           
        .               using _Manager_type
        .                 = bool (*)(_Any_data&, const _Any_data&, _Manager_operation);
        .           
        .               _Any_data     _M_functor{};
        .               _Manager_type _M_manager{};
        .             };
        .           
-- line 255 ----------------------------------------
-- line 259 ----------------------------------------
        .             template<typename _Res, typename _Functor, typename... _ArgTypes>
        .               class _Function_handler<_Res(_ArgTypes...), _Functor>
        .               : public _Function_base::_Base_manager<_Functor>
        .               {
        .                 using _Base = _Function_base::_Base_manager<_Functor>;
        .           
        .               public:
        .                 static bool
  691,180 ( 0.00%)        _M_manager(_Any_data& __dest, const _Any_data& __source,
        .           		 _Manager_operation __op)
        .                 {
  592,440 ( 0.00%)  	switch (__op)
        .           	  {
        .           #if __cpp_rtti
        .           	  case __get_type_info:
        .           	    __dest._M_access<const type_info*>() = &typeid(_Functor);
        .           	    break;
        .           #endif
        .           	  case __get_functor_ptr:
        .           	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
        .           	    break;
        .           
        .           	  default:
  592,440 ( 0.00%)  	    _Base::_M_manager(__dest, __source, __op);
      367 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Base_manager<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (5x)
        .           	  }
   98,740 ( 0.00%)  	return false;
  296,220 ( 0.00%)        }
        .           
        .                 static _Res
  493,040 ( 0.00%)        _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
        .                 {
  395,431 ( 0.00%)  	return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
       42 ( 0.00%)  => /usr/include/c++/14/bits/invoke.h:std::enable_if<is_invocable_r_v<void, spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}&>, void>::type std::__invoke_r<void, spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}&>(spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}&) (1x)
       34 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Base_manager<spdlog::init_thread_pool(unsigned long, unsigned long)::{lambda()#1}>::_M_get_pointer(std::_Any_data const&) (1x)
  393,211 ( 0.00%)  				     std::forward<_ArgTypes>(__args)...);
  447,187 ( 0.00%)  => /usr/include/c++/14/bits/invoke.h:std::enable_if<is_invocable_r_v<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&>, std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::type std::__invoke_r<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>, std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&>(std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&) (533x)
  295,602 ( 0.00%)        }
        .           
        .                 template<typename _Fn>
        .           	static constexpr bool
        .           	_S_nothrow_init() noexcept
        .           	{
        .           	  return __and_<typename _Base::_Local_storage,
        .           			is_nothrow_constructible<_Functor, _Fn>>::value;
        .           	}
-- line 300 ----------------------------------------
-- line 326 ----------------------------------------
        .               { };
        .           
        .             /**
        .              *  @brief Polymorphic function wrapper.
        .              *  @ingroup functors
        .              *  @since C++11
        .              */
        .             template<typename _Res, typename... _ArgTypes>
1,013,910 ( 0.00%)      class function<_Res(_ArgTypes...)>
       22 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::~_Function_base() (2x)
        .               : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
        .                 private _Function_base
        .               {
        .                 // Equivalent to std::decay_t except that it produces an invalid type
        .                 // if the decayed type is the current specialization of std::function.
        .                 template<typename _Func,
        .           	       bool _Self = is_same<__remove_cvref_t<_Func>, function>::value>
        .           	using _Decay_t
-- line 342 ----------------------------------------
-- line 360 ----------------------------------------
        .                 typedef _Res result_type;
        .           
        .                 // [3.7.2.1] construct/copy/destroy
        .           
        .                 /**
        .                  *  @brief Default construct creates an empty function call wrapper.
        .                  *  @post `!(bool)*this`
        .                  */
       24 ( 0.00%)        function() noexcept
       76 ( 0.00%)        : _Function_base() { }
       66 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Function_base() (6x)
        .           
        .                 /**
        .                  *  @brief Creates an empty function call wrapper.
        .                  *  @post @c !(bool)*this
        .                  */
       35 ( 0.00%)        function(nullptr_t) noexcept
       88 ( 0.00%)        : _Function_base() { }
       22 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Function_base() (2x)
        .           
        .                 /**
        .                  *  @brief %Function copy constructor.
        .                  *  @param __x A %function object with identical call signature.
        .                  *  @post `bool(*this) == bool(__x)`
        .                  *
        .                  *  The newly-created %function contains a copy of the target of
        .                  *  `__x` (if it has one).
        .                  */
      192 ( 0.00%)        function(const function& __x)
      312 ( 0.00%)        : _Function_base()
       66 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Function_base() (6x)
        .                 {
      172 ( 0.00%)  	if (static_cast<bool>(__x))
      114 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::operator bool() const (6x)
        .           	  {
      236 ( 0.00%)  	    __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
      882 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*), int (*)(std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) (6x)
      112 ( 0.00%)  	    _M_invoker = __x._M_invoker;
      116 ( 0.00%)  	    _M_manager = __x._M_manager;
        .           	  }
      156 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief %Function move constructor.
        .                  *  @param __x A %function object rvalue with identical call signature.
        .                  *
        .                  *  The newly-created %function contains the target of `__x`
        .                  *  (if it has one).
        .                  */
   13,335 ( 0.00%)        function(function&& __x) noexcept
   29,347 ( 0.00%)        : _Function_base(), _M_invoker(__x._M_invoker)
   29,315 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Function_base() (2,665x)
        .                 {
   13,340 ( 0.00%)  	if (static_cast<bool>(__x))
   50,635 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<void ()>::operator bool() const (2,665x)
        .           	  {
   15,994 ( 0.00%)  	    _M_functor = __x._M_functor;
   10,662 ( 0.00%)  	    _M_manager = __x._M_manager;
    5,334 ( 0.00%)  	    __x._M_manager = nullptr;
    5,330 ( 0.00%)  	    __x._M_invoker = nullptr;
        .           	  }
    8,001 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief Builds a %function that targets a copy of the incoming
        .                  *  function object.
        .                  *  @param __f A %function object that is callable with parameters of
        .                  *  type `ArgTypes...` and returns a value convertible to `Res`.
        .                  *
        .                  *  The newly-created %function object will target a copy of
-- line 422 ----------------------------------------
-- line 427 ----------------------------------------
        .                  *
        .                  *  If `__f` is a non-null function pointer or an object of type
        .                  *  `reference_wrapper<F>`, this function will not throw.
        .                  */
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 2774. std::function construction vs assignment
        .                 template<typename _Functor,
        .           	       typename _Constraints = _Requires<_Callable<_Functor>>>
  494,063 ( 0.00%)  	function(_Functor&& __f)
        .           	noexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())
  888,354 ( 0.00%)  	: _Function_base()
       11 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_Function_base() (1x)
        .           	{
        .           	  static_assert(is_copy_constructible<__decay_t<_Functor>>::value,
        .           	      "std::function target must be copy-constructible");
        .           	  static_assert(is_constructible<__decay_t<_Functor>, _Functor>::value,
        .           	      "std::function target must be constructible from the "
        .           	      "constructor argument");
        .           
        .           	  using _My_handler = _Handler<_Functor>;
        .           
  493,530 ( 0.00%)  	  if (_My_handler::_M_not_empty_function(__f))
        6 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:bool std::_Function_base::_Base_manager<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>::_M_not_empty_function<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>(BS::thread_pool::thread_pool(unsigned int)::{lambda()#1} const&) (1x)
        .           	    {
  789,648 ( 0.00%)  	      _My_handler::_M_init_functor(_M_functor,
       58 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:void std::_Function_base::_Base_manager<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>::_M_init_functor<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>(std::_Any_data&, BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}&&) (1x)
        6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}&& std::forward<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>(std::remove_reference<BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>::type&) (1x)
        .           					   std::forward<_Functor>(__f));
  197,412 ( 0.00%)  	      _M_invoker = &_My_handler::_M_invoke;
  197,412 ( 0.00%)  	      _M_manager = &_My_handler::_M_manager;
        .           	    }
  297,184 ( 0.00%)  	}
        .           
        .                 /**
        .                  *  @brief Function assignment operator.
        .                  *  @param __x A %function with identical call signature.
        .                  *  @post `(bool)*this == (bool)x`
        .                  *  @returns `*this`
        .                  *
        .                  *  The target of `__x` is copied to `*this`. If `__x` has no
        .                  *  target, then `*this` will be empty.
        .                  *
        .                  *  If `__x` targets a function pointer or a reference to a function
        .                  *  object, then this operation will not throw an exception.
        .                  */
        .                 function&
       30 ( 0.00%)        operator=(const function& __x)
        .                 {
       78 ( 0.00%)  	function(__x).swap(*this);
    1,308 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::function(std::function<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)> const&) (6x)
      972 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::swap(std::function<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>&) (6x)
      126 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<int (std::shared_ptr<Ship::Console>, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)>::~function() (6x)
        6 ( 0.00%)  	return *this;
       12 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief Function move-assignment operator.
        .                  *  @param __x A %function rvalue with identical call signature.
        .                  *  @returns `*this`
        .                  *
        .                  *  The target of `__x` is moved to `*this`. If `__x` has no
        .                  *  target, then `*this` will be empty.
        .                  *
        .                  *  If `__x` targets a function pointer or a reference to a function
        .                  *  object, then this operation will not throw an exception.
        .                  */
        .                 function&
    2,665 ( 0.00%)        operator=(function&& __x) noexcept
        .                 {
    8,528 ( 0.00%)  	function(std::move(__x)).swap(*this);
   86,346 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<void ()>::swap(std::function<void ()>&) (533x)
   36,244 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<void ()>::function(std::function<void ()>&&) (533x)
   11,193 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<void ()>::~function() (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::function<void ()>&>::type&& std::move<std::function<void ()>&>(std::function<void ()>&) (533x)
      533 ( 0.00%)  	return *this;
    1,066 ( 0.00%)        }
        .           
        .                 /**
        .                  *  @brief Function assignment to empty.
        .                  *  @post `!(bool)*this`
        .                  *  @returns `*this`
        .                  *
        .                  *  The target of `*this` is deallocated, leaving it empty.
        .                  */
-- line 499 ----------------------------------------
-- line 548 ----------------------------------------
        .           
        .                 /**
        .                  *  @brief Swap the targets of two %function objects.
        .                  *  @param __x A %function with identical call signature.
        .                  *
        .                  *  Swap the targets of `this` function object and `__f`.
        .                  *  This function will not throw exceptions.
        .                  */
    2,695 ( 0.00%)        void swap(function& __x) noexcept
        .                 {
    2,695 ( 0.00%)  	std::swap(_M_functor, __x._M_functor);
      294 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<std::_Any_data> >, std::is_move_constructible<std::_Any_data>, std::is_move_assignable<std::_Any_data> >::value, void>::type std::swap<std::_Any_data>(std::_Any_data&, std::_Any_data&) (6x)
    3,773 ( 0.00%)  	std::swap(_M_manager, __x._M_manager);
      258 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)> >, std::is_move_constructible<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)>, std::is_move_assignable<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)> >::value, void>::type std::swap<bool (*)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)>(bool (*&)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation), bool (*&)(std::_Any_data&, std::_Any_data const&, std::_Manager_operation)) (6x)
    3,773 ( 0.00%)  	std::swap(_M_invoker, __x._M_invoker);
      258 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<int (*)(std::_Any_data const&, std::shared_ptr<Ship::Console>&&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&&)> >, std::is_move_constructible<int (*)(std::_Any_data const&, std::shared_ptr<Ship::Console>&&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&&)>, std::is_move_assignable<int (*)(std::_Any_data const&, std::shared_ptr<Ship::Console>&&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&&)> >::value, void>::type std::swap<int (*)(std::_Any_data const&, std::shared_ptr<Ship::Console>&&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&&)>(int (*&)(std::_Any_data const&, std::shared_ptr<Ship::Console>&&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&&), int (*&)(std::_Any_data const&, std::shared_ptr<Ship::Console>&&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&&)) (6x)
    1,617 ( 0.00%)        }
        .           
        .                 // [3.7.2.3] function capacity
        .           
        .                 /**
        .                  *  @brief Determine if the %function wrapper has a target.
        .                  *
        .                  *  @return `true` when this function object contains a target,
        .                  *  or `false` when it is empty.
        .                  *
        .                  *  This function will not throw exceptions.
        .                  */
   10,804 ( 0.00%)        explicit operator bool() const noexcept
   16,206 ( 0.00%)        { return !_M_empty(); }
       54 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_M_empty() const (6x)
        .           
        .                 // [3.7.2.4] function invocation
        .           
        .                 /**
        .                  *  @brief Invokes the function targeted by `*this`.
        .                  *  @returns the result of the target.
        .                  *  @throws `bad_function_call` when `!(bool)*this`
        .                  *
        .                  *  The function call operator invokes the target function object
        .                  *  stored by `this`.
        .                  */
        .                 _Res
  493,032 ( 0.00%)        operator()(_ArgTypes... __args) const
        .                 {
  493,590 ( 0.00%)  	if (_M_empty())
    4,977 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_base::_M_empty() const (553x)
        .           	  __throw_bad_function_call();
  690,471 ( 0.00%)  	return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
85,620,115 ( 0.07%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<void (), BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (533x)
    1,760 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::_Function_handler<void (), BS::thread_pool::thread_pool(unsigned int)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (20x)
  295,598 ( 0.00%)        }
        .           
        .           #if __cpp_rtti
        .                 // [3.7.2.5] function target access
        .                 /**
        .                  *  @brief Determine the type of the target of this function object
        .                  *  wrapper.
        .                  *
        .                  *  @returns the type identifier of the target function object, or
-- line 600 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/code_800AF9B0.c
--------------------------------------------------------------------------------
Ir               

-- line 35 ----------------------------------------
      .           s16 D_8018EDB2;
      .           s16 D_8018EDB4;
      .           Vtx* D_8018EDB8;
      .           Vtx* D_8018EDBC;
      .           
      .           /*** utils **/
      .           #define SQ(x) ((x) * (x))
      .           
      2 ( 0.00%)  void func_800AF9B0(void) {
     11 ( 0.00%)      D_8018EDB8 = (void*) calloc(480, sizeof(Vtx));
  8,012 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:calloc (1x)
  1,291 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      7 ( 0.00%)      D_8018EDBC = (void*) calloc(480, sizeof(Vtx));
  8,087 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:calloc (1x)
      3 ( 0.00%)  }
      .           
      .           // could be a normal vertex, not a color...
 99,360 ( 0.00%)  void func_800AF9E4(Vtx* arg0, s32 arg1, s32 arg2, s32 arg3, s16 arg4, s16 arg5, s32 arg6, s32 arg7) {
      .               s32 r, g, b;
      .               s32 i;
      .           
132,480 ( 0.00%)      for (i = 0; i < 4; i++) {
728,640 ( 0.00%)          (arg0 + i)->v.ob[0] = ((i % 2) * arg7) + arg6 - 504;
132,480 ( 0.00%)          if (i / 2 == 0) {
231,840 ( 0.00%)              (arg0 + i)->v.ob[1] = (arg2 * arg3) - 420;
      .                   } else {
215,280 ( 0.00%)              (arg0 + i)->v.ob[1] = (arg2 * arg3) + arg3 - 420;
      .                   }
132,480 ( 0.00%)          if (i % 2 == 0) {
397,440 ( 0.00%)              (arg0 + i)->v.ob[1] += (f32) SQ(arg1) * -0.07f;
      .                   } else {
430,560 ( 0.00%)              (arg0 + i)->v.ob[1] += (f32) SQ(arg1 + 1) * -0.07f;
      .                   }
      .           
231,840 ( 0.00%)          (arg0 + i)->v.cn[0] = 0;
231,840 ( 0.00%)          (arg0 + i)->v.cn[1] = 0;
231,840 ( 0.00%)          (arg0 + i)->v.cn[2] = 120;
231,840 ( 0.00%)          (arg0 + i)->v.cn[3] = 255;
      .           
132,480 ( 0.00%)          if (i % 2 == 0) {
149,040 ( 0.00%)              (arg0 + i)->v.ob[2] = arg4;
      .                   } else {
132,480 ( 0.00%)              (arg0 + i)->v.ob[2] = arg5;
      .                   }
      .               }
      .           
124,200 ( 0.00%)      if ((((arg1 / 2) + (arg2 / 2)) & 1) == 0) {
 24,840 ( 0.00%)          r = g = b = 0;
      .               } else {
 20,700 ( 0.00%)          r = g = b = 255;
      .               }
      .           
198,720 ( 0.00%)      gDPSetPrimColor(gDisplayListHead++, 0, 0, r, g, b, 255);
 91,080 ( 0.00%)      gDPPipeSync(gDisplayListHead++);
 82,800 ( 0.00%)      gSPVertex(gDisplayListHead++, VIRTUAL_TO_PHYSICAL2(arg0), 4, 0);
847,892 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPVertex (8,280x)
 91,080 ( 0.00%)      gSP1Triangle(gDisplayListHead++, 1, 2, 0, 0);
 82,800 ( 0.00%)      gSP1Triangle(gDisplayListHead++, 3, 2, 1, 0);
 24,840 ( 0.00%)  }
      .           
      .           void func_800AFC54(Vtx* arg0, s32 arg1, s32 arg2, s32 arg3, s16 arg4[3]);
      .           #ifdef NON_MATCHING
      .           // guess on Vtx type?
  6,624 ( 0.00%)  void func_800AFC54(Vtx* arg0, s32 arg1, s32 arg2, s32 arg3, s16 arg4[3]) {
      .               Vtx *a1, *a2, *a3;
      .               s32 saved1, saved2, saved3;
      .               f32 res;
      .               s32 a, b, c, d, e, f;
      .               f32 f14, f16, f18;
      .           
  5,796 ( 0.00%)      a1 = &arg0[arg1];
  5,796 ( 0.00%)      a2 = &arg0[arg2];
  5,796 ( 0.00%)      a3 = &arg0[arg3];
      .           
  3,312 ( 0.00%)      saved1 = a2->v.ob[0];
  3,312 ( 0.00%)      saved2 = a2->v.ob[1];
  3,312 ( 0.00%)      saved3 = a2->v.ob[2];
      .           
  4,968 ( 0.00%)      a = saved2 - a1->v.ob[1];
  4,968 ( 0.00%)      e = saved3 - a1->v.ob[2];
  4,140 ( 0.00%)      d = a3->v.ob[1] - saved2;
  4,140 ( 0.00%)      b = a3->v.ob[2] - saved3;
  4,140 ( 0.00%)      f = a3->v.ob[0] - saved1;
  4,968 ( 0.00%)      c = saved1 - a1->v.ob[0];
      .           
  6,624 ( 0.00%)      f14 = ((a) * (b)) - ((e) * (d));
  6,624 ( 0.00%)      f16 = ((e) * (f)) - ((c) * (b));
  6,624 ( 0.00%)      f18 = ((c) * (d)) - ((a) * (f));
      .           
 11,592 ( 0.00%)      res = sqrtf(SQ(f14) + SQ(f16) + SQ(f18));
  6,624 ( 0.00%)  => ???:sqrtf (828x)
      .           
  3,312 ( 0.00%)      if (res < 0.001) {
      .                   res = 0.001;
      .               }
      .           
  7,452 ( 0.00%)      arg4[0] = f14 * (f32) (1.0 / res) * 120.0f;
  7,452 ( 0.00%)      arg4[1] = f16 * (f32) (1.0 / res) * 120.0f;
  7,452 ( 0.00%)      arg4[2] = f18 * (f32) (1.0 / res) * 120.0f;
  2,484 ( 0.00%)  }
      .           #else
      .           GLOBAL_ASM("asm/non_matchings/code_800AF9B0/func_800AFC54.s")
      .           #endif
      .           
  4,968 ( 0.00%)  void func_800AFE00(Vtx* arg0, Vec3s* arg1, s32 arg2, s32 arg3) {
      .               s32 idx1;
      .               s32 idx2;
      .               s32 i;
      .               Vtx* vtx;
      .               s16 sp14[2][3];
      .           
  4,830 ( 0.00%)      idx1 = (arg2 == 0) ? 0 : arg2 - 1;
  5,658 ( 0.00%)      idx2 = (arg2 == arg3) ? arg3 : arg2 + 1;
      .           
 10,764 ( 0.00%)      for (i = 0; i < 3; i++) {
 86,940 ( 0.00%)          sp14[0][i] = (arg1[idx1][i] + arg1[arg2][i]) / 2;
 89,424 ( 0.00%)          sp14[1][i] = (arg1[idx2][i] + arg1[arg2][i]) / 2;
      .               }
      .           
 28,152 ( 0.00%)      for (idx2 = 0; idx2 < 0x1E0; idx2 += 0x30) {
132,480 ( 0.00%)          for (i = 0; i < 4; i++) {
231,840 ( 0.00%)              vtx = &arg0[i];
794,880 ( 0.00%)              vtx[idx2 / 1].v.cn[0] = sp14[i % 2][0];
794,880 ( 0.00%)              vtx[idx2 / 1].v.cn[1] = sp14[i % 2][1];
794,880 ( 0.00%)              vtx[idx2 / 1].v.cn[2] = sp14[i % 2][2];
      .                   }
      .               }
  3,312 ( 0.00%)  }
      .           
    276 ( 0.00%)  void func_800AFF58(Vtx* arg0) {
      .               UNUSED u32 pad88[26];
      .               s32 i, j;
      .               s16 sp40[12][3];
      .           
  3,657 ( 0.00%)      for (i = 0, j = 0; i < ARRAY_COUNT(sp40); i++, j += 4) {
 16,560 ( 0.00%)          func_800AFC54(&arg0[j], 1, 2, 0, sp40[i]);
127,512 ( 0.00%)  => src/code_800AF9B0.c:func_800AFC54 (828x)
      .               }
      .           
  3,657 ( 0.00%)      for (i = 0, j = 0; i < ARRAY_COUNT(sp40); i++, j += 4) {
  9,108 ( 0.00%)          func_800AFE00(&arg0[j], sp40, i, 11);
2,983,008 ( 0.00%)  => src/code_800AF9B0.c:func_800AFE00 (828x)
      .               }
    276 ( 0.00%)  }
      .           
      .           #ifdef NON_MATCHING
      .           // Credit to SpazzyLemon for the updated and better attempt
    207 ( 0.00%)  void func_800B0004(void) {
      .               Vtx* vtxs;
      .               s32 res1, res2;
      .               UNUSED u32 pad[0x5];
      .               s32 i, j;
      .           
    828 ( 0.00%)      gSPLight(gDisplayListHead++, VIRTUAL_TO_PHYSICAL2(&D_800E8680.l[0]), LIGHT_1);
    828 ( 0.00%)      gSPLight(gDisplayListHead++, VIRTUAL_TO_PHYSICAL2(&D_800E8680.a), LIGHT_2);
    828 ( 0.00%)      gSPNumLights(gDisplayListHead++, NUMLIGHTS_1);
    759 ( 0.00%)      gSPSetGeometryMode(gDisplayListHead++, G_SHADE | G_SHADING_SMOOTH);
    828 ( 0.00%)      gDPSetCombineLERP(gDisplayListHead++, PRIMITIVE, 0, SHADE, 0, 0, 0, 0, SHADE, PRIMITIVE, 0, SHADE, 0, 0, 0, 0,
      .                                 SHADE);
    759 ( 0.00%)      gSPClearGeometryMode(gDisplayListHead++, G_CULL_BACK);
    690 ( 0.00%)      gSPSetGeometryMode(gDisplayListHead++, G_LIGHTING);
      .           
    586 ( 0.00%)      vtxs = D_8018EDB4 % 2 ? D_8018EDB8 : D_8018EDBC;
    138 ( 0.00%)      D_8018EDB2 = 0x9C0;
  2,346 ( 0.00%)      for (i = 0; i < 10; i++) {
 27,600 ( 0.00%)          for (j = 0; j < 12; j++) {
173,880 ( 0.00%)              res1 = sins(D_8018EDB0 - (j * D_8018EDB2)) * 84.0f * j * 0.18f;
 99,360 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (8,280x)
198,720 ( 0.00%)              res2 = sins(D_8018EDB0 - ((j + 1) * D_8018EDB2)) * 84.0f * (j + 1) * 0.18f;
 99,360 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (8,280x)
248,400 ( 0.00%)              func_800AF9E4(&vtxs[j * 4 + i * 48], j, i, 84, res1, res2, (j * 84), 84);
5,430,872 ( 0.00%)  => src/code_800AF9B0.c:func_800AF9E4 (8,280x)
      .                   }
      .               }
    207 ( 0.00%)      func_800AFF58(vtxs);
3,144,054 ( 0.00%)  => src/code_800AF9B0.c:func_800AFF58 (69x)
    621 ( 0.00%)      D_8018EDB0 += D_8018EDB2;
    414 ( 0.00%)      ++D_8018EDB4;
    759 ( 0.00%)      gSPSetGeometryMode(gDisplayListHead++, G_CULL_BACK);
    828 ( 0.00%)      gSPNumLights(gDisplayListHead++, NUMLIGHTS_1);
    759 ( 0.00%)      gSPClearGeometryMode(gDisplayListHead++, G_LIGHTING);
    207 ( 0.00%)  }
      .           #else
      .           GLOBAL_ASM("asm/non_matchings/code_800AF9B0/func_800B0004.s")
      .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/ptr_traits.h
--------------------------------------------------------------------------------
Ir                 

-- line 126 ----------------------------------------
        .                 using element_type = _Tp;
        .           
        .                 /**
        .                  *  @brief  Obtain a pointer to an object
        .                  *  @param  __r  A reference to an object of type `element_type`
        .                  *  @return `addressof(__r)`
        .                 */
        .                 static _GLIBCXX20_CONSTEXPR pointer
5,664,260 ( 0.00%)        pointer_to(element_type& __r) noexcept
7,080,325 ( 0.01%)        { return std::addressof(__r); }
       30 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>* std::addressof<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> >(std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>&) (2x)
        .               };
        .           
        .             template<typename _Ptr, typename _Elt>
        .               struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
        .               {
        .               private:
        .                 template<typename _Tp>
        .           	using __diff_t = typename _Tp::difference_type;
-- line 143 ----------------------------------------
-- line 197 ----------------------------------------
        .               };
        .           
        .             /// Convenience alias for rebinding pointers.
        .             template<typename _Ptr, typename _Tp>
        .               using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
        .           
        .             template<typename _Tp>
        .               constexpr _Tp*
  893,229 ( 0.00%)      __to_address(_Tp* __ptr) noexcept
        .               {
        .                 static_assert(!std::is_function<_Tp>::value, "not a function pointer");
  297,743 ( 0.00%)        return __ptr;
  595,486 ( 0.00%)      }
        .           
        .           #ifndef __glibcxx_to_address // C++ < 20
        .             template<typename _Ptr>
        .               constexpr typename std::pointer_traits<_Ptr>::element_type*
        .               __to_address(const _Ptr& __ptr)
        .               { return std::__to_address(__ptr.operator->()); }
        .           #else
        .             template<typename _Ptr>
-- line 217 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_deque.h
--------------------------------------------------------------------------------
Ir                     

-- line 89 ----------------------------------------
            .             */
            .           
            .           #ifndef _GLIBCXX_DEQUE_BUF_SIZE
            .           #define _GLIBCXX_DEQUE_BUF_SIZE 512
            .           #endif
            .           
            .             _GLIBCXX_CONSTEXPR inline size_t
            .             __deque_buf_size(size_t __size)
      588,915 ( 0.00%)    { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
    1,570,440 ( 0.00%)  	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
            .           
            .           
            .             /**
            .              *  @brief A deque::iterator.
            .              *
            .              *  Quite a bit of intelligence here.  Much of the functionality of
            .              *  deque is actually passed off to this class.  A deque holds two
            .              *  of these internally, marking its valid range.  Access to
-- line 106 ----------------------------------------
-- line 123 ----------------------------------------
            .           	using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_rebind<_Ptr, _CvTp>>;
            .               public:
            .                 typedef __iter<_Tp>				   iterator;
            .                 typedef __iter<const _Tp>				   const_iterator;
            .                 typedef __ptr_rebind<_Ptr, _Tp>			   _Elt_pointer;
            .                 typedef __ptr_rebind<_Ptr, _Elt_pointer>		   _Map_pointer;
            .           #endif
            .           
      389,082 ( 0.00%)        static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
      778,164 ( 0.00%)        { return __deque_buf_size(sizeof(_Tp)); }
    2,057,759 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::__deque_buf_size(unsigned long) (187,069x)
            .           
            .                 typedef std::random_access_iterator_tag	iterator_category;
            .                 typedef _Tp				value_type;
            .                 typedef _Ptr				pointer;
            .                 typedef _Ref				reference;
            .                 typedef size_t				size_type;
            .                 typedef ptrdiff_t				difference_type;
            .                 typedef _Deque_iterator			_Self;
-- line 140 ----------------------------------------
-- line 143 ----------------------------------------
            .                 _Elt_pointer _M_first;
            .                 _Elt_pointer _M_last;
            .                 _Map_pointer _M_node;
            .           
            .                 _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
            .                 : _M_cur(__x), _M_first(*__y),
            .           	_M_last(*__y + _S_buffer_size()), _M_node(__y) { }
            .           
        4,872 ( 0.00%)        _Deque_iterator() _GLIBCXX_NOEXCEPT
       17,864 ( 0.00%)        : _M_cur(), _M_first(), _M_last(), _M_node() { }
            .           
            .           #if __cplusplus < 201103L
            .                 // Conversion from iterator to const_iterator.
            .                 _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
            .                 : _M_cur(__x._M_cur), _M_first(__x._M_first),
            .           	_M_last(__x._M_last), _M_node(__x._M_node) { }
            .           #else
            .                 // Conversion from iterator to const_iterator.
            .                 template<typename _Iter,
            .           	       typename = _Require<is_same<_Self, const_iterator>,
            .           				   is_same<_Iter, iterator>>>
            .                  _Deque_iterator(const _Iter& __x) noexcept
            .                  : _M_cur(__x._M_cur), _M_first(__x._M_first),
            .           	 _M_last(__x._M_last), _M_node(__x._M_node) { }
            .           
  463,511,248 ( 0.38%)        _Deque_iterator(const _Deque_iterator& __x) noexcept
  927,022,496 ( 0.77%)         : _M_cur(__x._M_cur), _M_first(__x._M_first),
1,274,655,932 ( 1.06%)  	 _M_last(__x._M_last), _M_node(__x._M_node) { }
            .           
            .                 _Deque_iterator& operator=(const _Deque_iterator&) = default;
            .           #endif
            .           
            .                 iterator
            .                 _M_const_cast() const _GLIBCXX_NOEXCEPT
            .                 { return iterator(_M_cur, _M_node); }
            .           
            .                 _GLIBCXX_NODISCARD
            .                 reference
  347,620,119 ( 0.29%)        operator*() const _GLIBCXX_NOEXCEPT
  463,493,492 ( 0.38%)        { return *_M_cur; }
            .           
            .                 _GLIBCXX_NODISCARD
            .                 pointer
            .                 operator->() const _GLIBCXX_NOEXCEPT
            .                 { return _M_cur; }
            .           
            .                 _Self&
            .                 operator++() _GLIBCXX_NOEXCEPT
-- line 190 ----------------------------------------
-- line 202 ----------------------------------------
            .                 operator++(int) _GLIBCXX_NOEXCEPT
            .                 {
            .           	_Self __tmp = *this;
            .           	++*this;
            .           	return __tmp;
            .                 }
            .           
            .                 _Self&
  463,487,044 ( 0.38%)        operator--() _GLIBCXX_NOEXCEPT
            .                 {
  695,230,566 ( 0.58%)  	if (_M_cur == _M_first)
            .           	  {
            .           	    _M_set_node(_M_node - 1);
            .           	    _M_cur = _M_last;
            .           	  }
  579,358,805 ( 0.48%)  	--_M_cur;
  115,871,761 ( 0.10%)  	return *this;
  231,743,522 ( 0.19%)        }
            .           
            .                 _Self
            .                 operator--(int) _GLIBCXX_NOEXCEPT
            .                 {
            .           	_Self __tmp = *this;
            .           	--*this;
            .           	return __tmp;
            .                 }
            .           
            .                 _Self&
        9,672 ( 0.00%)        operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
            .                 {
       19,344 ( 0.00%)  	const difference_type __offset = __n + (_M_cur - _M_first);
       14,508 ( 0.00%)  	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
       27,404 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*>::_S_buffer_size() (1,612x)
       17,732 ( 0.00%)  	  _M_cur += __n;
            .           	else
            .           	  {
            .           	    const difference_type __node_offset =
            .           	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
            .           			   : -difference_type((-__offset - 1)
            .           					      / _S_buffer_size()) - 1;
            .           	    _M_set_node(_M_node + __node_offset);
            .           	    _M_cur = _M_first + (__offset - __node_offset
            .           				 * difference_type(_S_buffer_size()));
            .           	  }
        1,612 ( 0.00%)  	return *this;
        4,836 ( 0.00%)        }
            .           
            .                 _Self&
            .                 operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
            .                 { return *this += -__n; }
            .           
            .                 _GLIBCXX_NODISCARD
            .                 reference
        8,060 ( 0.00%)        operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
       17,732 ( 0.00%)        { return *(*this + __n); }
      164,424 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::operator+(std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*> const&, long) (1,612x)
       11,284 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*>::operator*() const (1,612x)
            .           
            .                 /**
            .                  *  Prepares to traverse new_node.  Sets everything except
            .                  *  _M_cur, which should therefore be set by the caller
            .                  *  immediately afterwards, based on _M_first and _M_last.
            .                  */
            .                 void
        5,892 ( 0.00%)        _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
            .                 {
        2,946 ( 0.00%)  	_M_node = __new_node;
        3,928 ( 0.00%)  	_M_first = *__new_node;
        7,562 ( 0.00%)  	_M_last = _M_first + difference_type(_S_buffer_size());
           34 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::_S_buffer_size() (2x)
        3,928 ( 0.00%)        }
            .           
            .                 _GLIBCXX_NODISCARD
            .                 friend bool
  230,999,284 ( 0.19%)        operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
  461,998,568 ( 0.38%)        { return __x._M_cur == __y._M_cur; }
            .           
            .                 // Note: we also provide overloads whose operands are of the same type in
            .                 // order to avoid ambiguous overload resolution when std::rel_ops
            .                 // operators are in scope (for additional details, see libstdc++/3628)
            .                 template<typename _RefR, typename _PtrR>
            .           	_GLIBCXX_NODISCARD
            .           	friend bool
            .           	operator==(const _Self& __x,
-- line 281 ----------------------------------------
-- line 362 ----------------------------------------
            .           	operator>=(const _Self& __x,
            .           		   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
            .           	_GLIBCXX_NOEXCEPT
            .           	{ return !(__x < __y); }
            .           #endif // three-way comparison
            .           
            .                 _GLIBCXX_NODISCARD
            .                 friend difference_type
      959,735 ( 0.00%)        operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
            .                 {
      383,894 ( 0.00%)  	return difference_type(_S_buffer_size())
    3,180,139 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::_S_buffer_size() (187,067x)
    2,879,205 ( 0.00%)  	  * (__x._M_node - __y._M_node - bool(__x._M_node))
    1,540,456 ( 0.00%)  	  + (__x._M_cur - __x._M_first)
    1,540,456 ( 0.00%)  	  + (__y._M_last - __y._M_cur);
      383,894 ( 0.00%)        }
            .           
            .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
            .                 // According to the resolution of DR179 not only the various comparison
            .                 // operators but also operator- must accept mixed iterator/const_iterator
            .                 // parameters.
            .                 template<typename _RefR, typename _PtrR>
            .           	_GLIBCXX_NODISCARD
            .           	friend difference_type
-- line 384 ----------------------------------------
-- line 389 ----------------------------------------
            .           	  return difference_type(_S_buffer_size())
            .           	    * (__x._M_node - __y._M_node - bool(__x._M_node))
            .           	    + (__x._M_cur - __x._M_first)
            .           	    + (__y._M_last - __y._M_cur);
            .           	}
            .           
            .                 _GLIBCXX_NODISCARD
            .                 friend _Self
        9,672 ( 0.00%)        operator+(const _Self& __x, difference_type __n) _GLIBCXX_NOEXCEPT
            .                 {
        8,060 ( 0.00%)  	_Self __tmp = __x;
       37,076 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*>::_Deque_iterator(std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*> const&) (1,612x)
        8,060 ( 0.00%)  	__tmp += __n;
       95,108 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*>::operator+=(long) (1,612x)
        1,612 ( 0.00%)  	return __tmp;
        4,836 ( 0.00%)        }
            .           
            .                 _GLIBCXX_NODISCARD
            .                 friend _Self
            .                 operator-(const _Self& __x, difference_type __n) _GLIBCXX_NOEXCEPT
            .                 {
            .           	_Self __tmp = __x;
            .           	__tmp -= __n;
            .           	return __tmp;
-- line 410 ----------------------------------------
-- line 450 ----------------------------------------
            .           
            .                 allocator_type
            .                 get_allocator() const _GLIBCXX_NOEXCEPT
            .                 { return allocator_type(_M_get_Tp_allocator()); }
            .           
            .                 typedef _Deque_iterator<_Tp, _Tp&, _Ptr>	  iterator;
            .                 typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;
            .           
        2,045 ( 0.00%)        _Deque_base()
        1,227 ( 0.00%)        : _M_impl()
           63 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_Deque_impl::_Deque_impl() (1x)
        3,272 ( 0.00%)        { _M_initialize_map(0); }
          777 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_initialize_map(unsigned long) (1x)
            .           
            .                 _Deque_base(size_t __num_elements)
            .                 : _M_impl()
            .                 { _M_initialize_map(__num_elements); }
            .           
            .                 _Deque_base(const allocator_type& __a, size_t __num_elements)
            .                 : _M_impl(__a)
            .                 { _M_initialize_map(__num_elements); }
-- line 468 ----------------------------------------
-- line 508 ----------------------------------------
            .           
            .                 struct _Deque_impl_data
            .                 {
            .           	_Map_pointer _M_map;
            .           	size_t _M_map_size;
            .           	iterator _M_start;
            .           	iterator _M_finish;
            .           
        3,248 ( 0.00%)  	_Deque_impl_data() _GLIBCXX_NOEXCEPT
        9,744 ( 0.00%)  	: _M_map(), _M_map_size(), _M_start(), _M_finish()
       22,596 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>::_Deque_iterator() (1,614x)
        2,436 ( 0.00%)  	{ }
            .           
            .           #if __cplusplus >= 201103L
       12,090 ( 0.00%)  	_Deque_impl_data(const _Deque_impl_data&) = default;
       18,538 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>::_Deque_iterator(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*> const&) (806x)
            .           	_Deque_impl_data&
            .           	operator=(const _Deque_impl_data&) = default;
            .           
        2,418 ( 0.00%)  	_Deque_impl_data(_Deque_impl_data&& __x) noexcept
        2,015 ( 0.00%)  	: _Deque_impl_data(__x)
       30,628 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data::_Deque_impl_data(std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data const&) (403x)
        6,851 ( 0.00%)  	{ __x = _Deque_impl_data(); }
       18,941 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data::_Deque_impl_data() (403x)
            .           #endif
            .           
            .           	void
        2,015 ( 0.00%)  	_M_swap_data(_Deque_impl_data& __x) _GLIBCXX_NOEXCEPT
            .           	{
            .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
            .           	  // information used by TBAA.
        2,015 ( 0.00%)  	  std::swap(*this, __x);
       85,033 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data> >, std::is_move_constructible<std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data>, std::is_move_assignable<std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data> >::value, void>::type std::swap<std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data>(std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data&, std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data&) (403x)
        1,209 ( 0.00%)  	}
            .                 };
            .           
            .                 // This struct encapsulates the implementation of the std::deque
            .                 // standard container and at the same time makes use of the EBO
            .                 // for empty allocators.
        3,240 ( 0.00%)        struct _Deque_impl
            .                 : public _Tp_alloc_type, public _Deque_impl_data
            .                 {
        3,272 ( 0.00%)  	_Deque_impl() _GLIBCXX_NOEXCEPT_IF(
            .           	  is_nothrow_default_constructible<_Tp_alloc_type>::value)
        1,227 ( 0.00%)  	: _Tp_alloc_type()
       18,988 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data::_Deque_impl_data() (404x)
        1,227 ( 0.00%)  	{ }
            .           
            .           	_Deque_impl(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
            .           	: _Tp_alloc_type(__a)
            .           	{ }
            .           
            .           #if __cplusplus >= 201103L
            .           	_Deque_impl(_Deque_impl&&) = default;
            .           
-- line 556 ----------------------------------------
-- line 560 ----------------------------------------
            .           
            .           	_Deque_impl(_Deque_impl&& __d, _Tp_alloc_type&& __a)
            .           	: _Tp_alloc_type(std::move(__a)), _Deque_impl_data(std::move(__d))
            .           	{ }
            .           #endif
            .                 };
            .           
            .                 _Tp_alloc_type&
      573,228 ( 0.00%)        _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
      573,228 ( 0.00%)        { return this->_M_impl; }
            .           
            .                 const _Tp_alloc_type&
        2,646 ( 0.00%)        _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
        2,646 ( 0.00%)        { return this->_M_impl; }
            .           
            .                 _Map_alloc_type
        4,070 ( 0.00%)        _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
        9,768 ( 0.00%)        { return _Map_alloc_type(_M_get_Tp_allocator()); }
           12 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_get_Tp_allocator() const (2x)
            .           
            .                 _Ptr
        1,908 ( 0.00%)        _M_allocate_node()
            .                 {
            .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
        4,293 ( 0.00%)  	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
          792 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::__deque_buf_size(unsigned long) (72x)
          954 ( 0.00%)        }
            .           
            .                 void
        2,345 ( 0.00%)        _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
            .                 {
            .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
        6,097 ( 0.00%)  	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
           11 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::__deque_buf_size(unsigned long) (1x)
        1,407 ( 0.00%)        }
            .           
            .                 _Map_pointer
        2,045 ( 0.00%)        _M_allocate_map(size_t __n)
            .                 {
        4,499 ( 0.00%)  	_Map_alloc_type __map_alloc = _M_get_map_allocator();
           25 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_get_map_allocator() const (1x)
          818 ( 0.00%)  	return _Map_alloc_traits::allocate(__map_alloc, __n);
          818 ( 0.00%)        }
            .           
            .                 void
        2,430 ( 0.00%)        _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
            .                 {
        6,075 ( 0.00%)  	_Map_alloc_type __map_alloc = _M_get_map_allocator();
           25 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_get_map_allocator() const (1x)
            .           	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
        1,215 ( 0.00%)        }
            .           
            .                 void _M_initialize_map(size_t);
            .                 void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
            .                 void _M_destroy_nodes(_Map_pointer __nstart,
            .           			    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;
            .                 enum { _S_initial_map_size = 8 };
            .           
            .                 _Deque_impl _M_impl;
            .               };
            .           
            .             template<typename _Tp, typename _Alloc>
        1,620 ( 0.00%)      _Deque_base<_Tp, _Alloc>::
            .               ~_Deque_base() _GLIBCXX_NOEXCEPT
            .               {
        1,620 ( 0.00%)        if (this->_M_impl._M_map)
            .           	{
        2,835 ( 0.00%)  	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
       71,508 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_destroy_nodes(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >**, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >**) (404x)
          810 ( 0.00%)  			   this->_M_impl._M_finish._M_node + 1);
        3,240 ( 0.00%)  	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
       67,902 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_deallocate_map(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >**, unsigned long) (404x)
            .           	}
        2,430 ( 0.00%)      }
        3,636 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl::~_Deque_impl() (404x)
            .           
            .             /**
            .              *  @brief Layout storage.
            .              *  @param  __num_elements  The count of T's for which to allocate space
            .              *                          at first.
            .              *  @return   Nothing.
            .              *
            .              *  The initial underlying memory layout is a bit complicated...
            .             */
            .             template<typename _Tp, typename _Alloc>
            .               void
        2,454 ( 0.00%)      _Deque_base<_Tp, _Alloc>::
            .               _M_initialize_map(size_t __num_elements)
            .               {
        3,272 ( 0.00%)        const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
           11 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::__deque_buf_size(unsigned long) (1x)
            .           				  + 1);
            .           
        3,681 ( 0.00%)        this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
           13 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&) (1x)
        1,227 ( 0.00%)  					   size_t(__num_nodes + 2));
        3,272 ( 0.00%)        this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
          288 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_allocate_map(unsigned long) (1x)
            .           
            .                 // For "small" maps (needing less than _M_map_size nodes), allocation
            .                 // starts in the middle elements and grows outwards.  So nstart may be
            .                 // the beginning of _M_map, but for small maps it may be as far in as
            .                 // _M_map+3.
            .           
        1,636 ( 0.00%)        _Map_pointer __nstart = (this->_M_impl._M_map
        2,045 ( 0.00%)  			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
        2,045 ( 0.00%)        _Map_pointer __nfinish = __nstart + __num_nodes;
            .           
            .                 __try
        2,454 ( 0.00%)  	{ _M_create_nodes(__nstart, __nfinish); }
          283 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_create_nodes(F3DGfx***, F3DGfx***) (1x)
            .                 __catch(...)
            .           	{
            .           	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
            .           	  this->_M_impl._M_map = _Map_pointer();
            .           	  this->_M_impl._M_map_size = 0;
            .           	  __throw_exception_again;
            .           	}
            .           
        2,454 ( 0.00%)        this->_M_impl._M_start._M_set_node(__nstart);
           41 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::_M_set_node(F3DGfx***) (1x)
        2,863 ( 0.00%)        this->_M_impl._M_finish._M_set_node(__nfinish - 1);
           41 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::_M_set_node(F3DGfx***) (1x)
        1,636 ( 0.00%)        this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
        1,636 ( 0.00%)        this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
          830 ( 0.00%)  					+ __num_elements
        3,272 ( 0.00%)  					% __deque_buf_size(sizeof(_Tp)));
           11 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::__deque_buf_size(unsigned long) (1x)
        1,636 ( 0.00%)      }
            .           
            .             template<typename _Tp, typename _Alloc>
            .               void
        2,863 ( 0.00%)      _Deque_base<_Tp, _Alloc>::
            .               _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
            .               {
            .                 _Map_pointer __cur;
            .                 __try
            .           	{
        4,090 ( 0.00%)  	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
        2,045 ( 0.00%)  	    *__cur = this->_M_allocate_node();
       48,617 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_allocate_node() (404x)
            .           	}
            .                 __catch(...)
            .           	{
            .           	  _M_destroy_nodes(__nstart, __cur);
            .           	  __throw_exception_again;
            .           	}
        1,636 ( 0.00%)      }
            .           
            .             template<typename _Tp, typename _Alloc>
            .               void
        4,848 ( 0.00%)      _Deque_base<_Tp, _Alloc>::
            .               _M_destroy_nodes(_Map_pointer __nstart,
            .           		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
            .               {
        6,468 ( 0.00%)        for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
        2,430 ( 0.00%)  	_M_deallocate_node(*__n);
       61,004 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_deallocate_node(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) (404x)
        3,232 ( 0.00%)      }
            .           
            .             /**
            .              *  @brief  A standard container using fixed-size memory allocation and
            .              *  constant-time manipulation of elements at either end.
            .              *
            .              *  @ingroup sequences
            .              *
            .              *  @tparam _Tp  Type of element.
-- line 709 ----------------------------------------
-- line 847 ----------------------------------------
            .               public:
            .                 // [23.2.1.1] construct/copy/destroy
            .                 // (assign() and get_allocator() are also listed in this section)
            .           
            .                 /**
            .                  *  @brief  Creates a %deque with no elements.
            .                  */
            .           #if __cplusplus >= 201103L
        4,090 ( 0.00%)        deque() = default;
      232,430 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_base() (404x)
            .           #else
            .                 deque() { }
            .           #endif
            .           
            .                 /**
            .                  *  @brief  Creates a %deque with no elements.
            .                  *  @param  __a  An allocator object.
            .                  */
-- line 863 ----------------------------------------
-- line 1019 ----------------------------------------
            .           	}
            .           #endif
            .           
            .                 /**
            .                  *  The dtor only erases the elements, and note that if the elements
            .                  *  themselves are pointers, the pointed-to memory is not touched in any
            .                  *  way.  Managing the pointer is the user's responsibility.
            .                  */
        2,025 ( 0.00%)        ~deque()
       10,935 ( 0.00%)        { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
      155,570 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::~_Deque_base() (404x)
       61,004 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_destroy_data(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>, std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) (404x)
       14,948 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::end() (404x)
       14,948 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::begin() (404x)
        2,424 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_get_Tp_allocator() (404x)
            .           
            .                 /**
            .                  *  @brief  %Deque assignment operator.
            .                  *  @param  __x  A %deque of identical element and allocator types.
            .                  *
            .                  *  All the elements of @a x are copied.
            .                  *
            .                  *  The newly-created %deque uses a copy of the allocator object used
-- line 1036 ----------------------------------------
-- line 1044 ----------------------------------------
            .                  *  @brief  %Deque move assignment operator.
            .                  *  @param  __x  A %deque of identical element and allocator types.
            .                  *
            .                  *  The contents of @a __x are moved into this deque (without copying,
            .                  *  if the allocators permit it).
            .                  *  @a __x is a valid, but unspecified %deque.
            .                  */
            .                 deque&
        2,015 ( 0.00%)        operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
            .                 {
            .           	using __always_equal = typename _Alloc_traits::is_always_equal;
        3,224 ( 0.00%)  	_M_move_assign1(std::move(__x), __always_equal{});
      243,412 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_move_assign1(std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&, std::integral_constant<bool, true>) (403x)
        2,418 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&>::type&& std::move<std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&>(std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&) (403x)
          403 ( 0.00%)  	return *this;
          806 ( 0.00%)        }
            .           
            .                 /**
            .                  *  @brief  Assigns an initializer list to a %deque.
            .                  *  @param  __l  An initializer_list.
            .                  *
            .                  *  This function fills a %deque with copies of the elements in the
            .                  *  initializer_list @a __l.
            .                  *
-- line 1065 ----------------------------------------
-- line 1143 ----------------------------------------
            .           
            .                 // iterators
            .                 /**
            .                  *  Returns a read/write iterator that points to the first element in the
            .                  *  %deque.  Iteration is done in ordinary element order.
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 iterator
        4,040 ( 0.00%)        begin() _GLIBCXX_NOEXCEPT
        7,272 ( 0.00%)        { return this->_M_impl._M_start; }
       18,561 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>::_Deque_iterator(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*> const&) (807x)
            .           
            .                 /**
            .                  *  Returns a read-only (constant) iterator that points to the first
            .                  *  element in the %deque.  Iteration is done in ordinary element order.
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 const_iterator
            .                 begin() const _GLIBCXX_NOEXCEPT
-- line 1160 ----------------------------------------
-- line 1162 ----------------------------------------
            .           
            .                 /**
            .                  *  Returns a read/write iterator that points one past the last
            .                  *  element in the %deque.  Iteration is done in ordinary
            .                  *  element order.
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 iterator
  579,362,845 ( 0.48%)        end() _GLIBCXX_NOEXCEPT
1,042,853,121 ( 0.86%)        { return this->_M_impl._M_finish; }
2,665,050,526 ( 2.21%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::_Deque_iterator(std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&) (115,871,762x)
            .           
            .                 /**
            .                  *  Returns a read-only (constant) iterator that points one past
            .                  *  the last element in the %deque.  Iteration is done in
            .                  *  ordinary element order.
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 const_iterator
-- line 1179 ----------------------------------------
-- line 1260 ----------------------------------------
            .                 crend() const noexcept
            .                 { return const_reverse_iterator(this->_M_impl._M_start); }
            .           #endif
            .           
            .                 // [23.2.1.2] capacity
            .                 /**  Returns the number of elements in the %deque.  */
            .                 _GLIBCXX_NODISCARD
            .                 size_type
      767,788 ( 0.00%)        size() const _GLIBCXX_NOEXCEPT
    1,727,523 ( 0.00%)        { return this->_M_impl._M_finish - this->_M_impl._M_start; }
   10,662,819 ( 0.01%)  => /usr/include/c++/14/bits/stl_deque.h:std::operator-(std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&, std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&) (187,067x)
            .           
            .                 /**  Returns the size() of the largest possible %deque.  */
            .                 _GLIBCXX_NODISCARD
            .                 size_type
          272 ( 0.00%)        max_size() const _GLIBCXX_NOEXCEPT
          476 ( 0.00%)        { return _S_max_size(_M_get_Tp_allocator()); }
        2,040 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<OSContPad, std::allocator<OSContPad> >::_S_max_size(std::allocator<OSContPad> const&) (68x)
          408 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<OSContPad, std::allocator<OSContPad> >::_M_get_Tp_allocator() const (68x)
            .           
            .           #if __cplusplus >= 201103L
            .                 /**
            .                  *  @brief  Resizes the %deque to the specified number of elements.
            .                  *  @param  __new_size  Number of elements the %deque should contain.
            .                  *
            .                  *  This function will %resize the %deque to the specified
            .                  *  number of elements.  If the number is smaller than the
-- line 1283 ----------------------------------------
-- line 1339 ----------------------------------------
            .                 { _M_shrink_to_fit(); }
            .           #endif
            .           
            .                 /**
            .                  *  Returns true if the %deque is empty.  (Thus begin() would
            .                  *  equal end().)
            .                  */
            .                 _GLIBCXX_NODISCARD bool
  230,999,284 ( 0.19%)        empty() const _GLIBCXX_NOEXCEPT
  519,748,389 ( 0.43%)        { return this->_M_impl._M_finish == this->_M_impl._M_start; }
  692,997,852 ( 0.57%)  => /usr/include/c++/14/bits/stl_deque.h:std::operator==(std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&, std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**> const&) (57,749,821x)
            .           
            .                 // element access
            .                 /**
            .                  *  @brief Subscript access to the data contained in the %deque.
            .                  *  @param __n The index of the element for which data should be
            .                  *  accessed.
            .                  *  @return  Read/write reference to data.
            .                  *
            .                  *  This operator allows for easy, array-style, data access.
            .                  *  Note that data access with this operator is unchecked and
            .                  *  out_of_range lookups are not defined. (For checked lookups
            .                  *  see at().)
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 reference
        8,060 ( 0.00%)        operator[](size_type __n) _GLIBCXX_NOEXCEPT
            .                 {
            .           	__glibcxx_requires_subscript(__n);
        9,672 ( 0.00%)  	return this->_M_impl._M_start[difference_type(__n)];
      201,500 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<OSContPad, OSContPad&, OSContPad*>::operator[](long) const (1,612x)
        3,224 ( 0.00%)        }
            .           
            .                 /**
            .                  *  @brief Subscript access to the data contained in the %deque.
            .                  *  @param __n The index of the element for which data should be
            .                  *  accessed.
            .                  *  @return  Read-only (constant) reference to data.
            .                  *
            .                  *  This operator allows for easy, array-style, data access.
-- line 1376 ----------------------------------------
-- line 1460 ----------------------------------------
            .                 }
            .           
            .                 /**
            .                  *  Returns a read/write reference to the data at the last element of the
            .                  *  %deque.
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 reference
  463,487,044 ( 0.38%)        back() _GLIBCXX_NOEXCEPT
            .                 {
            .           	__glibcxx_requires_nonempty();
  579,358,805 ( 0.48%)  	iterator __tmp = end();
4,287,255,157 ( 3.55%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::end() (115,871,761x)
  347,615,283 ( 0.29%)  	--__tmp;
2,085,691,698 ( 1.73%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::operator--() (115,871,761x)
  347,615,283 ( 0.29%)  	return *__tmp;
  811,102,327 ( 0.67%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<F3DGfx*, F3DGfx*&, F3DGfx**>::operator*() const (115,871,761x)
  231,743,522 ( 0.19%)        }
            .           
            .                 /**
            .                  *  Returns a read-only (constant) reference to the data at the last
            .                  *  element of the %deque.
            .                  */
            .                 _GLIBCXX_NODISCARD
            .                 const_reference
            .                 back() const _GLIBCXX_NOEXCEPT
-- line 1482 ----------------------------------------
-- line 1493 ----------------------------------------
            .                  *  @param  __x  Data to be added.
            .                  *
            .                  *  This is a typical stack operation.  The function creates an
            .                  *  element at the front of the %deque and assigns the given
            .                  *  data to it.  Due to the nature of a %deque this operation
            .                  *  can be done in constant time.
            .                  */
            .                 void
        8,060 ( 0.00%)        push_front(const value_type& __x)
            .                 {
        9,672 ( 0.00%)  	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
            .           	  {
        9,264 ( 0.00%)  	    _Alloc_traits::construct(this->_M_impl,
        3,088 ( 0.00%)  				     this->_M_impl._M_start._M_cur - 1,
            .           				     __x);
        7,720 ( 0.00%)  	    --this->_M_impl._M_start._M_cur;
            .           	  }
            .           	else
          340 ( 0.00%)  	  _M_push_front_aux(__x);
       34,507 ( 0.00%)  => /usr/include/c++/14/bits/deque.tcc:void std::deque<OSContPad, std::allocator<OSContPad> >::_M_push_front_aux<OSContPad const&>(OSContPad const&) (68x)
        6,380 ( 0.00%)        }
            .           
            .           #if __cplusplus >= 201103L
            .                 void
            .                 push_front(value_type&& __x)
            .                 { emplace_front(std::move(__x)); }
            .           
            .                 template<typename... _Args>
            .           #if __cplusplus > 201402L
-- line 1520 ----------------------------------------
-- line 1530 ----------------------------------------
            .                  *  @param  __x  Data to be added.
            .                  *
            .                  *  This is a typical stack operation.  The function creates an
            .                  *  element at the end of the %deque and assigns the given data
            .                  *  to it.  Due to the nature of a %deque this operation can be
            .                  *  done in constant time.
            .                  */
            .                 void
      935,335 ( 0.00%)        push_back(const value_type& __x)
            .                 {
      748,268 ( 0.00%)  	if (this->_M_impl._M_finish._M_cur
      561,201 ( 0.00%)  	    != this->_M_impl._M_finish._M_last - 1)
            .           	  {
    1,309,469 ( 0.00%)  	    _Alloc_traits::construct(this->_M_impl,
            .           				     this->_M_impl._M_finish._M_cur, __x);
      935,335 ( 0.00%)  	    ++this->_M_impl._M_finish._M_cur;
            .           	  }
            .           	else
            .           	  _M_push_back_aux(__x);
      748,268 ( 0.00%)        }
            .           
            .           #if __cplusplus >= 201103L
            .                 void
            .                 push_back(value_type&& __x)
            .                 { emplace_back(std::move(__x)); }
            .           
            .                 template<typename... _Args>
            .           #if __cplusplus > 201402L
-- line 1557 ----------------------------------------
-- line 1589 ----------------------------------------
            .                  *  @brief  Removes last element.
            .                  *
            .                  *  This is a typical stack operation.  It shrinks the %deque by one.
            .                  *
            .                  *  Note that no data is returned, and if the last element's data is
            .                  *  needed, it should be retrieved before pop_back() is called.
            .                  */
            .                 void
      943,275 ( 0.00%)        pop_back() _GLIBCXX_NOEXCEPT
            .                 {
            .           	__glibcxx_requires_nonempty();
      754,620 ( 0.00%)  	if (this->_M_impl._M_finish._M_cur
      377,310 ( 0.00%)  	    != this->_M_impl._M_finish._M_first)
            .           	  {
      942,955 ( 0.00%)  	    --this->_M_impl._M_finish._M_cur;
    1,320,137 ( 0.00%)  	    _Alloc_traits::destroy(_M_get_Tp_allocator(),
    1,122,402 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<F3DGfx*, std::allocator<F3DGfx*> >::_M_get_Tp_allocator() (187,067x)
            .           				   this->_M_impl._M_finish._M_cur);
            .           	  }
            .           	else
          192 ( 0.00%)  	  _M_pop_back_aux();
       16,000 ( 0.00%)  => /usr/include/c++/14/bits/deque.tcc:std::deque<OSContPad, std::allocator<OSContPad> >::_M_pop_back_aux() (64x)
      754,684 ( 0.00%)        }
            .           
            .           #if __cplusplus >= 201103L
            .                 /**
            .                  *  @brief  Inserts an object in %deque before specified iterator.
            .                  *  @param  __position  A const_iterator into the %deque.
            .                  *  @param  __args  Arguments.
            .                  *  @return  An iterator that points to the inserted data.
            .                  *
-- line 1617 ----------------------------------------
-- line 1827 ----------------------------------------
            .           
            .                 /**
            .                  *  Erases all the elements.  Note that this function only erases the
            .                  *  elements, and that if the elements themselves are pointers, the
            .                  *  pointed-to memory is not touched in any way.  Managing the pointer is
            .                  *  the user's responsibility.
            .                  */
            .                 void
        1,612 ( 0.00%)        clear() _GLIBCXX_NOEXCEPT
        5,239 ( 0.00%)        { _M_erase_at_end(begin()); }
      111,631 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_erase_at_end(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>) (403x)
       14,911 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::begin() (403x)
            .           
            .               protected:
            .                 // Internal constructor functions follow.
            .           
            .           #if __cplusplus < 201103L
            .                 // called by the range constructor to implement [23.1.1]/9
            .           
            .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1844 ----------------------------------------
-- line 1868 ----------------------------------------
            .                 {
            .           	if (__n > _S_max_size(__a))
            .           	  __throw_length_error(
            .           	      __N("cannot create std::deque larger than max_size()"));
            .           	return __n;
            .                 }
            .           
            .                 static size_type
          272 ( 0.00%)        _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
            .                 {
          136 ( 0.00%)  	const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max;
          136 ( 0.00%)  	const size_t __allocmax = _Alloc_traits::max_size(__a);
          408 ( 0.00%)  	return (std::min)(__diffmax, __allocmax);
          952 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (68x)
          136 ( 0.00%)        }
            .           
            .                 // called by the second initialize_dispatch above
            .                 ///@{
            .                 /**
            .                  *  @brief Fills the deque with whatever is in [first,last).
            .                  *  @param  __first  An input iterator.
            .                  *  @param  __last  An input iterator.
            .                  *  @return   Nothing.
-- line 1889 ----------------------------------------
-- line 2079 ----------------------------------------
            .                 // Called by ~deque().
            .                 // NB: Doesn't deallocate the nodes.
            .                 template<typename _Alloc1>
            .           	void
            .           	_M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
            .           	{ _M_destroy_data_aux(__first, __last); }
            .           
            .                 void
        5,655 ( 0.00%)        _M_destroy_data(iterator __first, iterator __last,
            .           		      const std::allocator<_Tp>&)
            .                 {
            .           	if (!__has_trivial_destructor(value_type))
       12,912 ( 0.00%)  	  _M_destroy_data_aux(__first, __last);
       63,753 ( 0.00%)  => /usr/include/c++/14/bits/deque.tcc:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_destroy_data_aux(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>, std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>) (807x)
       37,122 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>::_Deque_iterator(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*> const&) (1,614x)
        2,424 ( 0.00%)        }
            .           
            .                 // Called by erase(q1, q2).
            .                 void
            .                 _M_erase_at_begin(iterator __pos)
            .                 {
            .           	_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
            .           	_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
            .           	this->_M_impl._M_start = __pos;
            .                 }
            .           
            .                 // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
            .                 // _M_fill_assign, operator=.
            .                 void
        2,418 ( 0.00%)        _M_erase_at_end(iterator __pos)
            .                 {
        8,060 ( 0.00%)  	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
       60,853 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_destroy_data(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>, std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) (403x)
       14,911 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::end() (403x)
        9,269 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*>::_Deque_iterator(std::_Deque_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*> const&) (403x)
        2,418 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_get_Tp_allocator() (403x)
        3,224 ( 0.00%)  	_M_destroy_nodes(__pos._M_node + 1,
        6,448 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_destroy_nodes(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >**, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >**) (403x)
          806 ( 0.00%)  			 this->_M_impl._M_finish._M_node + 1);
        1,612 ( 0.00%)  	this->_M_impl._M_finish = __pos;
        1,612 ( 0.00%)        }
            .           
            .                 iterator
            .                 _M_erase(iterator __pos);
            .           
            .                 iterator
            .                 _M_erase(iterator __first, iterator __last);
            .           
            .           #if __cplusplus >= 201103L
-- line 2120 ----------------------------------------
-- line 2168 ----------------------------------------
            .                 _M_reserve_map_at_back(size_type __nodes_to_add = 1)
            .                 {
            .           	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
            .           	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
            .           	  _M_reallocate_map(__nodes_to_add, false);
            .                 }
            .           
            .                 void
          340 ( 0.00%)        _M_reserve_map_at_front(size_type __nodes_to_add = 1)
            .                 {
          272 ( 0.00%)  	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
          340 ( 0.00%)  				       - this->_M_impl._M_map))
           96 ( 0.00%)  	  _M_reallocate_map(__nodes_to_add, true);
        5,456 ( 0.00%)  => /usr/include/c++/14/bits/deque.tcc:std::deque<OSContPad, std::allocator<OSContPad> >::_M_reallocate_map(unsigned long, bool) (16x)
          204 ( 0.00%)        }
            .           
            .                 void
            .                 _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
            .                 ///@}
            .           
            .           #if __cplusplus >= 201103L
            .                 // Constant-time, nothrow move assignment when source object's memory
            .                 // can be moved because the allocators are equal.
            .                 void
        2,418 ( 0.00%)        _M_move_assign1(deque&& __x, /* always equal: */ true_type) noexcept
            .                 {
        2,015 ( 0.00%)  	this->_M_impl._M_swap_data(__x._M_impl);
       90,272 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data::_M_swap_data(std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Deque_impl_data&) (403x)
        1,209 ( 0.00%)  	__x.clear();
      133,393 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::clear() (403x)
        3,627 ( 0.00%)  	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
        4,836 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_get_Tp_allocator() (806x)
        1,612 ( 0.00%)        }
            .           
            .                 // When the allocators are not equal the operation could throw, because
            .                 // we might need to allocate a new map for __x after moving from it
            .                 // or we might need to allocate new elements for *this.
            .                 void
            .                 _M_move_assign1(deque&& __x, /* always equal: */ false_type)
            .                 {
            .           	if (_M_get_Tp_allocator() == __x._M_get_Tp_allocator())
-- line 2204 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imstb_truetype.h
--------------------------------------------------------------------------------
Ir                 

-- line 1166 ----------------------------------------
        .              int i;
        .              STBTT_assert(n >= 1 && n <= 4);
        .              for (i = 0; i < n; i++)
        .                 v = (v << 8) | stbtt__buf_get8(b);
        .              return v;
        .           }
        .           
        .           static stbtt__buf stbtt__new_buf(const void *p, size_t size)
       10 ( 0.00%)  {
        .              stbtt__buf r;
        4 ( 0.00%)     STBTT_assert(size < 0x40000000);
        4 ( 0.00%)     r.data = (stbtt_uint8*) p;
        4 ( 0.00%)     r.size = (int) size;
        2 ( 0.00%)     r.cursor = 0;
        4 ( 0.00%)     return r;
        4 ( 0.00%)  }
        .           
        .           #define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
        .           #define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)
        .           
        .           static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
        .           {
        .              stbtt__buf r = stbtt__new_buf(NULL, 0);
        .              if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
-- line 1189 ----------------------------------------
-- line 1283 ----------------------------------------
        .           
        .           // on platforms that don't allow misaligned reads, if we want to allow
        .           // truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE
        .           
        .           #define ttBYTE(p)     (* (stbtt_uint8 *) (p))
        .           #define ttCHAR(p)     (* (stbtt_int8 *) (p))
        .           #define ttFixed(p)    ttLONG(p)
        .           
  701,790 ( 0.00%)  static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
  241,275 ( 0.00%)  static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
  147,150 ( 0.00%)  static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
        .           static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
        .           
        .           #define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
        .           #define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
        .           
        .           static int stbtt__isfont(stbtt_uint8 *font)
        6 ( 0.00%)  {
        .              // check the version number
        8 ( 0.00%)     if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
       14 ( 0.00%)     if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
       14 ( 0.00%)     if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
       42 ( 0.00%)     if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
        .              if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
        .              return 0;
        4 ( 0.00%)  }
        .           
        .           // @OPTIMIZE: binary search
        .           static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
      108 ( 0.00%)  {
      144 ( 0.00%)     stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
      270 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (18x)
       54 ( 0.00%)     stbtt_uint32 tabledir = fontstart + 12;
        .              stbtt_int32 i;
      618 ( 0.00%)     for (i=0; i < num_tables; ++i) {
      876 ( 0.00%)        stbtt_uint32 loc = tabledir + 16*i;
    2,060 ( 0.00%)        if (stbtt_tag(data+loc+0, tag))
       98 ( 0.00%)           return ttULONG(data+loc+8);
      378 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttULONG(unsigned char*) (14x)
        .              }
        4 ( 0.00%)     return 0;
       36 ( 0.00%)  }
        .           
        .           static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
       10 ( 0.00%)  {
        .              // if it's just a font, there's only one valid index
       14 ( 0.00%)     if (stbtt__isfont(font_collection))
       88 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__isfont(unsigned char*) (2x)
        8 ( 0.00%)        return index == 0 ? 0 : -1;
        .           
        .              // check if it's a TTC
        .              if (stbtt_tag(font_collection, "ttcf")) {
        .                 // version 1?
        .                 if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
        .                    stbtt_int32 n = ttLONG(font_collection+8);
        .                    if (index >= n)
        .                       return -1;
        .                    return ttULONG(font_collection+12+index*4);
        .                 }
        .              }
        .              return -1;
        4 ( 0.00%)  }
        .           
        .           static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
        .           {
        .              // if it's just a font, there's only one valid font
        .              if (stbtt__isfont(font_collection))
        .                 return 1;
        .           
        .              // check if it's a TTC
-- line 1349 ----------------------------------------
-- line 1381 ----------------------------------------
        .                 } else {
        .                    info->svg = 0;
        .                 }
        .              }
        .              return info->svg;
        .           }
        .           
        .           static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
       14 ( 0.00%)  {
        .              stbtt_uint32 cmap, t;
        .              stbtt_int32 i,numTables;
        .           
        6 ( 0.00%)     info->data = data;
        6 ( 0.00%)     info->fontstart = fontstart;
       12 ( 0.00%)     info->cff = stbtt__new_buf(NULL, 0);
       32 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__new_buf(void const*, unsigned long) (2x)
        .           
       14 ( 0.00%)     cmap = stbtt__find_table(data, fontstart, "cmap");       // required
      330 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->loca = stbtt__find_table(data, fontstart, "loca"); // required
      570 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->head = stbtt__find_table(data, fontstart, "head"); // required
      450 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
      422 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
      514 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
      578 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
      580 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
       18 ( 0.00%)     info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
      592 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
        .           
       28 ( 0.00%)     if (!cmap || !info->head || !info->hhea || !info->hmtx)
        .                 return 0;
        8 ( 0.00%)     if (info->glyf) {
        .                 // required for truetype
        8 ( 0.00%)        if (!info->loca) return 0;
        .              } else {
        .                 // initialization for CFF / Type2 fonts (OTF)
        .                 stbtt__buf b, topdict, topdictidx;
        .                 stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
        .                 stbtt_uint32 cff;
        .           
        .                 cff = stbtt__find_table(data, fontstart, "CFF ");
        .                 if (!cff) return 0;
-- line 1418 ----------------------------------------
-- line 1453 ----------------------------------------
        .                    info->fontdicts = stbtt__cff_get_index(&b);
        .                    info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
        .                 }
        .           
        .                 stbtt__buf_seek(&b, charstrings);
        .                 info->charstrings = stbtt__cff_get_index(&b);
        .              }
        .           
       14 ( 0.00%)     t = stbtt__find_table(data, fontstart, "maxp");
      610 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
        4 ( 0.00%)     if (t)
       20 ( 0.00%)        info->numGlyphs = ttUSHORT(data+t+4);
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2x)
        .              else
        .                 info->numGlyphs = 0xffff;
        .           
        4 ( 0.00%)     info->svg = -1;
        .           
        .              // find a cmap encoding table we understand *now* to avoid searching
        .              // later. (todo: could make this installable)
        .              // the same regardless of glyph.
       16 ( 0.00%)     numTables = ttUSHORT(data + cmap + 2);
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2x)
        4 ( 0.00%)     info->index_map = 0;
       34 ( 0.00%)     for (i=0; i < numTables; ++i) {
       42 ( 0.00%)        stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
        .                 // find an encoding we understand:
       56 ( 0.00%)        switch(ttUSHORT(data+encoding_record)) {
       90 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (6x)
        .                    case STBTT_PLATFORM_ID_MICROSOFT:
       18 ( 0.00%)              switch (ttUSHORT(data+encoding_record+2)) {
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2x)
        .                          case STBTT_MS_EID_UNICODE_BMP:
        .                          case STBTT_MS_EID_UNICODE_FULL:
        .                             // MS/Unicode
       22 ( 0.00%)                    info->index_map = cmap + ttULONG(data+encoding_record+4);
       54 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttULONG(unsigned char*) (2x)
        2 ( 0.00%)                    break;
        .                       }
        4 ( 0.00%)              break;
        .                   case STBTT_PLATFORM_ID_UNICODE:
        .                       // Mac/iOS has these
        .                       // all the encodingIDs are unicode, so we don't bother to check it
       22 ( 0.00%)              info->index_map = cmap + ttULONG(data+encoding_record+4);
       54 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttULONG(unsigned char*) (2x)
        2 ( 0.00%)              break;
        .                 }
        .              }
        8 ( 0.00%)     if (info->index_map == 0)
        .                 return 0;
        .           
       22 ( 0.00%)     info->indexToLocFormat = ttUSHORT(data+info->head + 50);
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2x)
        2 ( 0.00%)     return 1;
        6 ( 0.00%)  }
        .           
        .           STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
   13,825 ( 0.00%)  {
    8,295 ( 0.00%)     stbtt_uint8 *data = info->data;
    8,295 ( 0.00%)     stbtt_uint32 index_map = info->index_map;
        .           
   16,590 ( 0.00%)     stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
    5,530 ( 0.00%)     if (format == 0) { // apple byte encoding
        .                 stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
        .                 if (unicode_codepoint < bytes-6)
        .                    return ttBYTE(data + index_map + 6 + unicode_codepoint);
        .                 return 0;
    5,530 ( 0.00%)     } else if (format == 6) {
        .                 stbtt_uint32 first = ttUSHORT(data + index_map + 6);
        .                 stbtt_uint32 count = ttUSHORT(data + index_map + 8);
        .                 if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
        .                    return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
        .                 return 0;
    5,530 ( 0.00%)     } else if (format == 2) {
        .                 STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
        .                 return 0;
    5,530 ( 0.00%)     } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
   22,120 ( 0.00%)        stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
   22,120 ( 0.00%)        stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
   19,355 ( 0.00%)        stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
   22,120 ( 0.00%)        stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
        .           
        .                 // do a binary search of the segments
    8,295 ( 0.00%)        stbtt_uint32 endCount = index_map + 14;
    5,530 ( 0.00%)        stbtt_uint32 search = endCount;
        .           
    5,530 ( 0.00%)        if (unicode_codepoint > 0xffff)
        .                    return 0;
        .           
        .                 // they lie from endCount .. endCount + segCount
        .                 // but searchRange is the nearest power of two, so...
   38,710 ( 0.00%)        if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
    5,178 ( 0.00%)           search += rangeShift*2;
        .           
        .                 // now decrement to bias correctly to find smallest
    2,765 ( 0.00%)        search -= 2;
   31,925 ( 0.00%)        while (entrySelector) {
        .                    stbtt_uint16 end;
   11,815 ( 0.00%)           searchRange >>= 1;
  118,150 ( 0.00%)           end = ttUSHORT(data + search + searchRange*2);
  177,225 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (11,815x)
   35,445 ( 0.00%)           if (unicode_codepoint > end)
   16,512 ( 0.00%)              search += searchRange*2;
   11,815 ( 0.00%)           --entrySelector;
        .                 }
    2,765 ( 0.00%)        search += 2;
        .           
        .                 {
        .                    stbtt_uint16 offset, start, last;
   11,060 ( 0.00%)           stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
        .           
   41,475 ( 0.00%)           start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
   27,650 ( 0.00%)           last = ttUSHORT(data + endCount + 2*item);
   41,475 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,765x)
   16,413 ( 0.00%)           if (unicode_codepoint < start || unicode_codepoint > last)
      118 ( 0.00%)              return 0;
        .           
   48,708 ( 0.00%)           offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
   40,590 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (2,706x)
    5,412 ( 0.00%)           if (offset == 0)
   51,414 ( 0.00%)              return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
   40,590 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2,706x)
        .           
        .                    return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
        .                 }
        .              } else if (format == 12 || format == 13) {
        .                 stbtt_uint32 ngroups = ttULONG(data+index_map+12);
        .                 stbtt_int32 low,high;
        .                 low = 0; high = (stbtt_int32)ngroups;
        .                 // Binary search the right group.
-- line 1570 ----------------------------------------
-- line 1584 ----------------------------------------
        .                          return start_glyph;
        .                    }
        .                 }
        .                 return 0; // not found
        .              }
        .              // @TODO
        .              STBTT_assert(0);
        .              return 0;
    5,530 ( 0.00%)  }
        .           
        .           STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
        .           {
        .              return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
        .           }
        .           
        .           static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
  504,522 ( 0.00%)  {
  168,174 ( 0.00%)     v->type = type;
  224,232 ( 0.00%)     v->x = (stbtt_int16) x;
  224,232 ( 0.00%)     v->y = (stbtt_int16) y;
  224,232 ( 0.00%)     v->cx = (stbtt_int16) cx;
  224,232 ( 0.00%)     v->cy = (stbtt_int16) cy;
  168,174 ( 0.00%)  }
        .           
        .           static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
   21,648 ( 0.00%)  {
        .              int g1,g2;
        .           
   14,432 ( 0.00%)     STBTT_assert(!info->cff.size);
        .           
   14,432 ( 0.00%)     if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   14,432 ( 0.00%)     if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
        .           
   14,432 ( 0.00%)     if (info->indexToLocFormat == 0) {
   16,056 ( 0.00%)        g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
   13,380 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (892x)
   17,840 ( 0.00%)        g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   13,380 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (892x)
        .              } else {
   46,172 ( 0.00%)        g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
   73,332 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttULONG(unsigned char*) (2,716x)
   48,888 ( 0.00%)        g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   73,332 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttULONG(unsigned char*) (2,716x)
        .              }
        .           
   21,596 ( 0.00%)     return g1==g2 ? -1 : g1; // if length is 0, return -1
   10,824 ( 0.00%)  }
        .           
        .           static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
        .           
        .           STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
   24,354 ( 0.00%)  {
   10,824 ( 0.00%)     if (info->cff.size) {
        .                 stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
        .              } else {
   16,236 ( 0.00%)        int g = stbtt__GetGlyfOffset(info, glyph_index);
  310,632 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyfOffset(stbtt_fontinfo const*, int) (2,706x)
    5,490 ( 0.00%)        if (g < 0) return 0;
        .           
   34,671 ( 0.00%)        if (x0) *x0 = ttSHORT(info->data + g + 2);
   40,005 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2,667x)
   34,671 ( 0.00%)        if (y0) *y0 = ttSHORT(info->data + g + 4);
   40,005 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2,667x)
   34,671 ( 0.00%)        if (x1) *x1 = ttSHORT(info->data + g + 6);
   40,005 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2,667x)
   34,671 ( 0.00%)        if (y1) *y1 = ttSHORT(info->data + g + 8);
   40,005 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2,667x)
        .              }
    2,667 ( 0.00%)     return 1;
    5,412 ( 0.00%)  }
        .           
        .           STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
        .           {
        .              return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
        .           }
        .           
        .           STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
        .           {
-- line 1652 ----------------------------------------
-- line 1657 ----------------------------------------
        .              g = stbtt__GetGlyfOffset(info, glyph_index);
        .              if (g < 0) return 1;
        .              numberOfContours = ttSHORT(info->data + g);
        .              return numberOfContours == 0;
        .           }
        .           
        .           static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
        .               stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
   50,841 ( 0.00%)  {
   11,298 ( 0.00%)     if (start_off) {
      986 ( 0.00%)        if (was_off)
   12,040 ( 0.00%)           stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
   13,330 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (430x)
   10,353 ( 0.00%)        stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   15,283 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (493x)
        .              } else {
   10,312 ( 0.00%)        if (was_off)
   27,510 ( 0.00%)           stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
   40,610 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (1,310x)
        .                 else
   69,228 ( 0.00%)           stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
  119,226 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (3,846x)
        .              }
    5,649 ( 0.00%)     return num_vertices;
   11,298 ( 0.00%)  }
        .           
        .           static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
    5,412 ( 0.00%)  {
        .              stbtt_int16 numberOfContours;
        .              stbtt_uint8 *endPtsOfContours;
    2,706 ( 0.00%)     stbtt_uint8 *data = info->data;
      902 ( 0.00%)     stbtt_vertex *vertices=0;
      902 ( 0.00%)     int num_vertices=0;
    5,412 ( 0.00%)     int g = stbtt__GetGlyfOffset(info, glyph_index);
  103,544 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyfOffset(stbtt_fontinfo const*, int) (902x)
        .           
    1,804 ( 0.00%)     *pvertices = NULL;
        .           
    1,830 ( 0.00%)     if (g < 0) return 0;
        .           
    6,223 ( 0.00%)     numberOfContours = ttSHORT(data + g);
   13,335 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (889x)
        .           
    1,778 ( 0.00%)     if (numberOfContours > 0) {
      889 ( 0.00%)        stbtt_uint8 flags=0,flagcount;
    2,667 ( 0.00%)        stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
        .                 stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
        .                 stbtt_uint8 *points;
    5,334 ( 0.00%)        endPtsOfContours = (data + g + 10);
   11,557 ( 0.00%)        ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
   13,335 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (889x)
   11,557 ( 0.00%)        points = data + g + 10 + numberOfContours * 2 + 2 + ins;
        .           
    9,779 ( 0.00%)        n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
   13,335 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (889x)
        .           
    4,445 ( 0.00%)        m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
    8,001 ( 0.00%)        vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
  269,696 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
    1,778 ( 0.00%)        if (vertices == 0)
        .                    return 0;
        .           
      889 ( 0.00%)        next_move = 0;
      889 ( 0.00%)        flagcount=0;
        .           
        .                 // in first pass, we load uninterpreted data into the allocated array
        .                 // above, shifted to the end of the array so we won't overwrite it when
        .                 // we create our final data starting from the front
        .           
    2,667 ( 0.00%)        off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
        .           
        .                 // first load flags
        .           
  253,613 ( 0.00%)        for (i=0; i < n; ++i) {
  124,584 ( 0.00%)           if (flagcount == 0) {
  277,605 ( 0.00%)              flags = *points++;
  222,084 ( 0.00%)              if (flags & 8)
   27,828 ( 0.00%)                 flagcount = *points++;
        .                    } else
    6,771 ( 0.00%)              --flagcount;
  809,796 ( 0.00%)           vertices[off+i].type = flags;
        .                 }
        .           
        .                 // now load x coordinates
      889 ( 0.00%)        x=0;
  253,613 ( 0.00%)        for (i=0; i < n; ++i) {
  809,796 ( 0.00%)           flags = vertices[off+i].type;
  249,168 ( 0.00%)           if (flags & 2) {
  224,646 ( 0.00%)              stbtt_int16 dx = *points++;
  299,528 ( 0.00%)              x += (flags & 16) ? dx : -dx; // ???
        .                    } else {
   99,404 ( 0.00%)              if (!(flags & 16)) {
   88,260 ( 0.00%)                 x = x + (stbtt_int16) (points[0]*256 + points[1]);
    7,355 ( 0.00%)                 points += 2;
        .                       }
        .                    }
  809,796 ( 0.00%)           vertices[off+i].x = (stbtt_int16) x;
        .                 }
        .           
        .                 // now load y coordinates
      889 ( 0.00%)        y=0;
  253,613 ( 0.00%)        for (i=0; i < n; ++i) {
  809,796 ( 0.00%)           flags = vertices[off+i].type;
  249,168 ( 0.00%)           if (flags & 4) {
  241,494 ( 0.00%)              stbtt_int16 dy = *points++;
  321,992 ( 0.00%)              y += (flags & 32) ? dy : -dy; // ???
        .                    } else {
   88,172 ( 0.00%)              if (!(flags & 32)) {
   70,428 ( 0.00%)                 y = y + (stbtt_int16) (points[0]*256 + points[1]);
    5,869 ( 0.00%)                 points += 2;
        .                       }
        .                    }
  809,796 ( 0.00%)           vertices[off+i].y = (stbtt_int16) y;
        .                 }
        .           
        .                 // now convert them to our format
      889 ( 0.00%)        num_vertices=0;
    9,779 ( 0.00%)        sx = sy = cx = cy = scx = scy = 0;
  253,613 ( 0.00%)        for (i=0; i < n; ++i) {
  809,796 ( 0.00%)           flags = vertices[off+i].type;
  872,088 ( 0.00%)           x     = (stbtt_int16) vertices[off+i].x;
  872,088 ( 0.00%)           y     = (stbtt_int16) vertices[off+i].y;
        .           
  186,876 ( 0.00%)           if (next_move == i) {
   11,298 ( 0.00%)              if (i != 0)
   85,680 ( 0.00%)                 num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
  332,098 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__close_shape(stbtt_vertex*, int, int, int, int, int, int, int, int, int) (4,760x)
        .           
        .                       // now start the new one
   22,596 ( 0.00%)              start_off = !(flags & 1);
   11,298 ( 0.00%)              if (start_off) {
        .                          // if we start off with an off-curve point, then when we need to find a point on the curve
        .                          // where we can start, and we need to save some state for when we wraparound.
      986 ( 0.00%)                 scx = x;
      986 ( 0.00%)                 scy = y;
    8,381 ( 0.00%)                 if (!(vertices[off+i+1].type & 1)) {
        .                             // next point is also a curve point, so interpolate an on-point curve
    8,874 ( 0.00%)                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
    9,367 ( 0.00%)                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
        .                          } else {
        .                             // otherwise just use the next point as our start point
        .                             sx = (stbtt_int32) vertices[off+i+1].x;
        .                             sy = (stbtt_int32) vertices[off+i+1].y;
        .                             ++i; // we're using point i+1 as the starting point, so skip it
        .                          }
        .                       } else {
   10,312 ( 0.00%)                 sx = x;
   10,312 ( 0.00%)                 sy = y;
        .                       }
  101,682 ( 0.00%)              stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
  175,119 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (5,649x)
    5,649 ( 0.00%)              was_off = 0;
   56,490 ( 0.00%)              next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
   84,735 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (5,649x)
   11,298 ( 0.00%)              ++j;
        .                    } else {
  226,572 ( 0.00%)              if (!(flags & 1)) { // if it's a curve
   53,664 ( 0.00%)                 if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
  406,532 ( 0.00%)                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
  450,089 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (14,519x)
   53,664 ( 0.00%)                 cx = x;
   53,664 ( 0.00%)                 cy = y;
   53,664 ( 0.00%)                 was_off = 1;
        .                       } else {
   59,622 ( 0.00%)                 if (was_off)
  222,033 ( 0.00%)                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
  327,763 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (10,573x)
        .                          else
  346,284 ( 0.00%)                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
  596,378 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_setvertex(stbtt_vertex*, unsigned char, int, int, int, int) (19,238x)
   29,811 ( 0.00%)                 was_off = 0;
        .                       }
        .                    }
        .                 }
   16,891 ( 0.00%)        num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   65,866 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__close_shape(stbtt_vertex*, int, int, int, int, int, int, int, int, int) (889x)
        .              } else if (numberOfContours < 0) {
        .                 // Compound shapes.
        .                 int more = 1;
        .                 stbtt_uint8 *comp = data + g + 10;
        .                 num_vertices = 0;
        .                 vertices = 0;
        .                 while (more) {
        .                    stbtt_uint16 flags, gidx;
-- line 1824 ----------------------------------------
-- line 1890 ----------------------------------------
        .                    }
        .                    // More components ?
        .                    more = flags & (1<<5);
        .                 }
        .              } else {
        .                 // numberOfCounters == 0, do nothing
        .              }
        .           
    2,667 ( 0.00%)     *pvertices = vertices;
      889 ( 0.00%)     return num_vertices;
    1,804 ( 0.00%)  }
        .           
        .           typedef struct
        .           {
        .              int bounds;
        .              int started;
        .              float first_x, first_y;
        .              float x, y;
        .              stbtt_int32 min_x, max_x, min_y, max_y;
-- line 1908 ----------------------------------------
-- line 2295 ----------------------------------------
        .              if (x0)  *x0 = r ? c.min_x : 0;
        .              if (y0)  *y0 = r ? c.min_y : 0;
        .              if (x1)  *x1 = r ? c.max_x : 0;
        .              if (y1)  *y1 = r ? c.max_y : 0;
        .              return r ? c.num_vertices : 0;
        .           }
        .           
        .           STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
    5,412 ( 0.00%)  {
    3,608 ( 0.00%)     if (!info->cff.size)
    6,314 ( 0.00%)        return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
14,836,766 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyphShapeTT(stbtt_fontinfo const*, int, stbtt_vertex**) (902x)
        .              else
        .                 return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
    1,804 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
    6,314 ( 0.00%)  {
    9,020 ( 0.00%)     stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   13,530 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttUSHORT(unsigned char*) (902x)
    2,706 ( 0.00%)     if (glyph_index < numOfLongHorMetrics) {
   11,543 ( 0.00%)        if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
   10,185 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (679x)
   12,222 ( 0.00%)        if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   10,185 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (679x)
        .              } else {
    4,014 ( 0.00%)        if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
    3,345 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (223x)
    5,129 ( 0.00%)        if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
    3,345 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (223x)
        .              }
    3,385 ( 0.00%)  }
        .           
        .           STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)
        .           {
        .              stbtt_uint8 *data = info->data + info->kern;
        .           
        .              // we only look at the first table. it must be 'horizontal' and format 0.
        .              if (!info->kern)
        .                 return 0;
-- line 2328 ----------------------------------------
-- line 2632 ----------------------------------------
        .           }
        .           
        .           STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
        .           {
        .              stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
        .           }
        .           
        .           STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
       14 ( 0.00%)  {
       28 ( 0.00%)     if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2x)
       28 ( 0.00%)     if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2x)
       28 ( 0.00%)     if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
       30 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (2x)
        6 ( 0.00%)  }
        .           
        .           STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
        .           {
        .              int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
        .              if (!tab)
        .                 return 0;
        .              if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
        .              if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
-- line 2652 ----------------------------------------
-- line 2658 ----------------------------------------
        .           {
        .              *x0 = ttSHORT(info->data + info->head + 36);
        .              *y0 = ttSHORT(info->data + info->head + 38);
        .              *x1 = ttSHORT(info->data + info->head + 40);
        .              *y1 = ttSHORT(info->data + info->head + 42);
        .           }
        .           
        .           STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
       36 ( 0.00%)  {
      138 ( 0.00%)     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
      180 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:ttSHORT(unsigned char*) (12x)
       18 ( 0.00%)     return (float) height / fheight;
       18 ( 0.00%)  }
        .           
        .           STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
        .           {
        .              int unitsPerEm = ttUSHORT(info->data + info->head + 18);
        .              return pixels / unitsPerEm;
        .           }
        .           
        .           STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
-- line 2677 ----------------------------------------
-- line 2719 ----------------------------------------
        .           }
        .           
        .           //////////////////////////////////////////////////////////////////////////////
        .           //
        .           // antialiasing software rasterizer
        .           //
        .           
        .           STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
   35,178 ( 0.00%)  {
    5,412 ( 0.00%)     int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   37,884 ( 0.00%)     if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
  674,319 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBox (2,706x)
        .                 // e.g. space character
      156 ( 0.00%)        if (ix0) *ix0 = 0;
      156 ( 0.00%)        if (iy0) *iy0 = 0;
      130 ( 0.00%)        if (ix1) *ix1 = 0;
      130 ( 0.00%)        if (iy1) *iy1 = 0;
        .              } else {
        .                 // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
   32,004 ( 0.00%)        if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
   34,692 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,667x)
   34,671 ( 0.00%)        if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
   53,298 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,667x)
   24,896 ( 0.00%)        if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
    5,334 ( 0.00%)  => ???:0x00000000000771d0 (1,778x)
    1,135 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
   26,670 ( 0.00%)        if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
    5,334 ( 0.00%)  => ???:0x00000000000771d0 (1,778x)
        .              }
    8,144 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
    9,922 ( 0.00%)  {
   12,628 ( 0.00%)     stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
  334,750 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBoxSubpixel (902x)
    2,706 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
        .           {
        .              stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
        .           }
        .           
        .           STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
        .           {
-- line 2755 ----------------------------------------
-- line 2768 ----------------------------------------
        .           typedef struct stbtt__hheap
        .           {
        .              struct stbtt__hheap_chunk *head;
        .              void   *first_free;
        .              int    num_remaining_in_head_chunk;
        .           } stbtt__hheap;
        .           
        .           static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
  242,538 ( 0.00%)  {
  161,692 ( 0.00%)     if (hh->first_free) {
   77,418 ( 0.00%)        void *p = hh->first_free;
  103,224 ( 0.00%)        hh->first_free = * (void **) p;
   51,612 ( 0.00%)        return p;
        .              } else {
   58,468 ( 0.00%)        if (hh->num_remaining_in_head_chunk == 0) {
    6,223 ( 0.00%)           int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
    6,223 ( 0.00%)           stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
  369,436 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
    1,778 ( 0.00%)           if (c == NULL)
        .                       return NULL;
    3,556 ( 0.00%)           c->next = hh->head;
    2,667 ( 0.00%)           hh->head = c;
    2,667 ( 0.00%)           hh->num_remaining_in_head_chunk = count;
        .                 }
   73,085 ( 0.00%)        --hh->num_remaining_in_head_chunk;
  116,936 ( 0.00%)        return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
        .              }
   80,846 ( 0.00%)  }
        .           
        .           static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
  140,648 ( 0.00%)  {
  140,648 ( 0.00%)     *(void **) p = hh->first_free;
  105,486 ( 0.00%)     hh->first_free = p;
  105,486 ( 0.00%)  }
        .           
        .           static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
    4,445 ( 0.00%)  {
    2,667 ( 0.00%)     stbtt__hheap_chunk *c = hh->head;
    4,445 ( 0.00%)     while (c) {
    2,667 ( 0.00%)        stbtt__hheap_chunk *n = c->next;
    2,667 ( 0.00%)        STBTT_free(c, userdata);
  273,812 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
    1,778 ( 0.00%)        c = n;
        .              }
    3,556 ( 0.00%)  }
        .           
        .           typedef struct stbtt__edge {
        .              float x0,y0, x1,y1;
        .              int invert;
        .           } stbtt__edge;
        .           
        .           
        .           typedef struct stbtt__active_edge
-- line 2818 ----------------------------------------
-- line 2855 ----------------------------------------
        .           
        .              z->ey = e->y1;
        .              z->next = 0;
        .              z->direction = e->invert ? 1 : -1;
        .              return z;
        .           }
        .           #elif STBTT_RASTERIZER_VERSION == 2
        .           static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
  323,384 ( 0.00%)  {
  242,538 ( 0.00%)     stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
1,358,369 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__hheap_alloc(stbtt__hheap*, unsigned long, void*) (40,423x)
  485,076 ( 0.00%)     float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   80,846 ( 0.00%)     STBTT_assert(z != NULL);
        .              //STBTT_assert(e->y0 <= start_point);
   80,846 ( 0.00%)     if (!z) return z;
  121,269 ( 0.00%)     z->fdx = dxdy;
  424,799 ( 0.00%)     z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
  404,230 ( 0.00%)     z->fx = e->x0 + dxdy * (start_point - e->y0);
  242,538 ( 0.00%)     z->fx -= off_x;
  303,035 ( 0.00%)     z->direction = e->invert ? 1.0f : -1.0f;
  161,692 ( 0.00%)     z->sy = e->y0;
  161,692 ( 0.00%)     z->ey = e->y1;
   80,846 ( 0.00%)     z->next = 0;
   40,423 ( 0.00%)     return z;
   80,846 ( 0.00%)  }
        .           #else
        .           #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        .           #endif
        .           
        .           #if STBTT_RASTERIZER_VERSION == 1
        .           // note: this routine clips fills that extend off the edges... ideally this
        .           // wouldn't happen, but it could happen if the truetype glyph bounding boxes
        .           // are wrong, or if the user supplies a too-small bitmap
-- line 2886 ----------------------------------------
-- line 3026 ----------------------------------------
        .                 STBTT_free(scanline, userdata);
        .           }
        .           
        .           #elif STBTT_RASTERIZER_VERSION == 2
        .           
        .           // the edge passed in here does not cross the vertical line at x or the vertical line at x+1
        .           // (i.e. it has already been clipped to those)
        .           static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
  464,320 ( 0.00%)  {
  278,592 ( 0.00%)     if (y0 == y1) return;
  139,296 ( 0.00%)     STBTT_assert(y0 < y1);
  278,592 ( 0.00%)     STBTT_assert(e->sy <= e->ey);
  232,296 ( 0.00%)     if (y0 > e->ey) return;
  185,521 ( 0.00%)     if (y1 < e->sy) return;
  185,196 ( 0.00%)     if (y0 < e->sy) {
  240,492 ( 0.00%)        x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
   60,123 ( 0.00%)        y0 = e->sy;
        .              }
  231,495 ( 0.00%)     if (y1 > e->ey) {
  136,104 ( 0.00%)        x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
   34,026 ( 0.00%)        y1 = e->ey;
        .              }
        .           
  231,495 ( 0.00%)     if (x0 == x)
   62,160 ( 0.00%)        STBTT_assert(x1 <= x+1);
  237,069 ( 0.00%)     else if (x0 == x+1)
    1,176 ( 0.00%)        STBTT_assert(x1 >= x);
  100,719 ( 0.00%)     else if (x0 <= x)
   65,223 ( 0.00%)        STBTT_assert(x1 <= x);
   70,992 ( 0.00%)     else if (x0 >= x+1)
   23,790 ( 0.00%)        STBTT_assert(x1 >= x+1);
        .              else
   70,803 ( 0.00%)        STBTT_assert(x1 >= x && x1 <= x+1);
        .           
  241,416 ( 0.00%)     if (x0 <= x && x1 <= x)
  649,116 ( 0.00%)        scanline[x] += e->direction * (y1-y0);
   98,364 ( 0.00%)     else if (x0 >= x+1 && x1 >= x+1)
        .                 ;
        .              else {
  144,090 ( 0.00%)        STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
  248,155 ( 0.00%)        scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
        .              }
   92,864 ( 0.00%)  }
        .           
        .           static float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)
  259,368 ( 0.00%)  {
  172,912 ( 0.00%)     STBTT_assert(top_width >= 0);
  172,912 ( 0.00%)     STBTT_assert(bottom_width >= 0);
  216,140 ( 0.00%)     return (top_width + bottom_width) / 2.0f * height;
   86,456 ( 0.00%)  }
        .           
        .           static float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)
  345,824 ( 0.00%)  {
  389,052 ( 0.00%)     return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);
  907,788 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sized_trapezoid_area(float, float, float) (43,228x)
   86,456 ( 0.00%)  }
        .           
        .           static float stbtt__sized_triangle_area(float height, float width)
   74,452 ( 0.00%)  {
   74,452 ( 0.00%)     return height * width / 2;
   37,226 ( 0.00%)  }
        .           
        .           static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
   55,600 ( 0.00%)  {
   27,800 ( 0.00%)     float y_bottom = y_top+1;
        .           
  151,160 ( 0.00%)     while (e) {
        .                 // brute force every pixel
        .           
        .                 // compute intersection points with top & bottom
  260,620 ( 0.00%)        STBTT_assert(e->ey >= y_top);
        .           
  521,240 ( 0.00%)        if (e->fdx == 0) {
   64,596 ( 0.00%)           float x0 = e->fx;
   64,596 ( 0.00%)           if (x0 < len) {
   79,532 ( 0.00%)              if (x0 >= 0) {
  298,245 ( 0.00%)                 stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
2,164,567 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (19,883x)
  357,894 ( 0.00%)                 stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
1,920,884 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (19,883x)
        .                       } else {
        .                          stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
        .                       }
        .                    }
        .                 } else {
  130,869 ( 0.00%)           float x0 = e->fx;
  130,869 ( 0.00%)           float dx = e->fdx;
  130,869 ( 0.00%)           float xb = x0 + dx;
        .                    float x_top, x_bottom;
        .                    float sy0,sy1;
  130,869 ( 0.00%)           float dy = e->fdy;
  392,607 ( 0.00%)           STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
        .           
        .                    // compute endpoints of line segment clipped to this scanline (if the
        .                    // line segment starts on this scanline. x0 is the intersection of the
        .                    // line with y_top, but that may be off the line segment.
  174,492 ( 0.00%)           if (e->sy > y_top) {
  213,402 ( 0.00%)              x_top = x0 + dx * (e->sy - y_top);
  121,944 ( 0.00%)              sy0 = e->sy;
        .                    } else {
   26,274 ( 0.00%)              x_top = x0;
   26,274 ( 0.00%)              sy0 = y_top;
        .                    }
  218,115 ( 0.00%)           if (e->ey < y_bottom) {
  205,856 ( 0.00%)              x_bottom = x0 + dx * (e->ey - y_top);
  117,632 ( 0.00%)              sy1 = e->ey;
        .                    } else {
   28,430 ( 0.00%)              x_bottom = xb;
   28,430 ( 0.00%)              sy1 = y_bottom;
        .                    }
        .           
  609,552 ( 0.00%)           if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
        .                       // from here on, we don't have to range check x values
        .           
  259,368 ( 0.00%)              if ((int) x_top == (int) x_bottom) {
        .                          float height;
        .                          // simple case, only spans one pixel
   73,845 ( 0.00%)                 int x = (int) x_top;
  147,690 ( 0.00%)                 height = (sy1 - sy0) * e->direction;
  123,075 ( 0.00%)                 STBTT_assert(x >= 0 && x < len);
  689,220 ( 0.00%)                 scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
  984,600 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__position_trapezoid_area(float, float, float, float, float) (24,615x)
  319,995 ( 0.00%)                 scanline_fill[x] += height; // everything right of this pixel is filled
        .                       } else {
        .                          int x,x1,x2;
        .                          float y_crossing, y_final, step, sign, area;
        .                          // covers 2+ pixels
   55,839 ( 0.00%)                 if (x_top > x_bottom) {
        .                             // flip scanline vertically; signed area is the same
        .                             float t;
   47,700 ( 0.00%)                    sy0 = y_bottom - (sy0 - y_top);
   47,700 ( 0.00%)                    sy1 = y_bottom - (sy1 - y_top);
   57,240 ( 0.00%)                    t = sy0, sy0 = sy1, sy1 = t;
   57,240 ( 0.00%)                    t = x_bottom, x_bottom = x_top, x_top = t;
   38,160 ( 0.00%)                    dx = -dx;
   38,160 ( 0.00%)                    dy = -dy;
   57,240 ( 0.00%)                    t = x0, x0 = xb, xb = t;
        .                          }
   74,452 ( 0.00%)                 STBTT_assert(dy >= 0);
   74,452 ( 0.00%)                 STBTT_assert(dx >= 0);
        .           
   55,839 ( 0.00%)                 x1 = (int) x_top;
   55,839 ( 0.00%)                 x2 = (int) x_bottom;
        .                          // compute intersection with y axis at x1+1
  148,904 ( 0.00%)                 y_crossing = y_top + dy * (x1+1 - x0);
        .           
        .                          // compute intersection with y axis at x2
  111,678 ( 0.00%)                 y_final = y_top + dy * (x2 - x0);
        .           
        .                          //           x1    x_top                            x2    x_bottom
        .                          //     y_top  +------|-----+------------+------------+--------|---+------------+
        .                          //            |            |            |            |            |            |
        .                          //            |            |            |            |            |            |
        .                          //       sy0  |      Txxxxx|............|............|............|............|
        .                          // y_crossing |            *xxxxx.......|............|............|............|
        .                          //            |            |     xxxxx..|............|............|............|
-- line 3177 ----------------------------------------
-- line 3182 ----------------------------------------
        .                          //            |            |            |            |            |            |
        .                          //            |            |            |            |            |            |
        .                          //  y_bottom  +------------+------------+------------+------------+------------+
        .                          //
        .                          // goal is to measure the area covered by '.' in each pixel
        .           
        .                          // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
        .                          // @TODO: maybe test against sy1 rather than y_bottom?
   55,839 ( 0.00%)                 if (y_crossing > y_bottom)
       24 ( 0.00%)                    y_crossing = y_bottom;
        .           
   55,839 ( 0.00%)                 sign = e->direction;
        .           
        .                          // area of the rectangle covered from sy0..y_crossing
   93,065 ( 0.00%)                 area = sign * (y_crossing-sy0);
        .           
        .                          // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
  390,873 ( 0.00%)                 scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
  186,130 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sized_triangle_area(float, float) (18,613x)
        .           
        .                          // check if final y_crossing is blown up; no test case for this
   55,839 ( 0.00%)                 if (y_final > y_bottom) {
      105 ( 0.00%)                    int denom = (x2 - (x1+1));
       42 ( 0.00%)                    y_final = y_bottom;
       42 ( 0.00%)                    if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
       45 ( 0.00%)                       dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
        .                             }
        .                          }
        .           
        .                          // in second pixel, area covered by line segment found in first pixel
        .                          // is always a rectangle 1 wide * the height of that line segment; this
        .                          // is exactly what the variable 'area' stores. it also gets a contribution
        .                          // from the line segment within it. the THIRD pixel will get the first
        .                          // pixel's rectangle contribution, the second pixel's rectangle contribution,
        .                          // and its own contribution. the 'own contribution' is the same in every pixel except
        .                          // the leftmost and rightmost, a trapezoid that slides down in each pixel.
        .                          // the second pixel's contribution to the third pixel will be the
        .                          // rectangle 1 wide times the height change in the second pixel, which is dy.
        .           
   55,839 ( 0.00%)                 step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
        .                          // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
        .                          // so the area advances by 'step' every time
        .           
  155,851 ( 0.00%)                 for (x = x1+1; x < x2; ++x) {
  108,630 ( 0.00%)                    scanline[x] += area + step/2; // area of trapezoid is 1*step/2
   19,170 ( 0.00%)                    area += step;
        .                          }
  111,678 ( 0.00%)                 STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
  111,678 ( 0.00%)                 STBTT_assert(sy1 > y_final-0.01f);
        .           
        .                          // area covered in the last pixel is the rectangle from all the pixels to the left,
        .                          // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
  595,616 ( 0.00%)                 scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
  744,520 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__position_trapezoid_area(float, float, float, float, float) (18,613x)
        .           
        .                          // the rest of the line is filled based on the total height of the line segment in this pixel
  297,808 ( 0.00%)                 scanline_fill[x2] += sign * (sy1-sy0);
        .                       }
   43,228 ( 0.00%)           } else {
        .                       // if edge goes outside of box we're drawing, we require
        .                       // clipping logic. since this does not match the intended use
        .                       // of this library, we use a different, very slow brute
        .                       // force implementation
        .                       // note though that this does happen some of the time because
        .                       // x_top and x_bottom can be extrapolated at the top & bottom of
        .                       // the shape and actually lie outside the bounding box
        .                       int x;
   26,847 ( 0.00%)              for (x=0; x < len; ++x) {
        .                          // cases:
        .                          //
        .                          // there can be up to two intersections with the pixel. any intersection
        .                          // with left or right edges can be handled by splitting into two (or three)
        .                          // regions. intersections with top & bottom do not necessitate case-wise logic.
        .                          //
        .                          // the old way of doing this found the intersections with the left & right edges,
        .                          // then used some simple logic to produce up to three segments in sorted order
        .                          // from top-to-bottom. however, this had a problem: if an x edge was epsilon
        .                          // across the x border, then the corresponding y position might not be distinct
        .                          // from the other y segment, and it might ignored as an empty segment. to avoid
        .                          // that, we need to explicitly produce segments based on x positions.
        .           
        .                          // rename variables to clearly-defined pairs
   12,436 ( 0.00%)                 float y0 = y_top;
   12,436 ( 0.00%)                 float x1 = (float) (x);
   24,872 ( 0.00%)                 float x2 = (float) (x+1);
   12,436 ( 0.00%)                 float x3 = xb;
   12,436 ( 0.00%)                 float y3 = y_bottom;
        .           
        .                          // x = e->x + e->dx * (y-y_top)
        .                          // (y-y_top) = (x - e->x) / e->dx
        .                          // y = (x - e->x) / e->dx + y_top
   37,308 ( 0.00%)                 float y1 = (x - x0) / dx + y_top;
   49,744 ( 0.00%)                 float y2 = (x+1 - x0) / dx + y_top;
        .           
   24,261 ( 0.00%)                 if (x0 < x1 && x3 > x2) {         // three segments descending down-right
      266 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
      907 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (19x)
      266 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
    1,241 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (19x)
      285 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
    2,067 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (19x)
   24,621 ( 0.00%)                 } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
      364 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
    2,430 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (26x)
      364 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
    2,402 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (26x)
      390 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
    1,990 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (26x)
   24,069 ( 0.00%)                 } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
        .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
        .                             stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
   24,465 ( 0.00%)                 } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
    1,848 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
   17,887 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (132x)
    1,980 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
   12,682 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (132x)
   24,081 ( 0.00%)                 } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
    1,666 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
   17,300 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (119x)
    1,785 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
    8,145 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (119x)
   23,667 ( 0.00%)                 } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
    1,498 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
    8,342 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (107x)
    1,605 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
   14,280 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (107x)
        .                          } else {  // one segment
   81,410 ( 0.00%)                    stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
  628,361 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) (5,815x)
        .                          }
        .                       }
        .                    }
        .                 }
  195,465 ( 0.00%)        e = e->next;
        .              }
   27,800 ( 0.00%)  }
        .           
        .           // directly AA rasterize edges w/o supersampling
        .           static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
    8,001 ( 0.00%)  {
    2,667 ( 0.00%)     stbtt__hheap hh = { 0, 0, 0 };
      889 ( 0.00%)     stbtt__active_edge *active = NULL;
      889 ( 0.00%)     int y,j=0, i;
        .              float scanline_data[129], *scanline, *scanline2;
        .           
        .              STBTT__NOTUSED(vsubsample);
        .           
    3,556 ( 0.00%)     if (result->w > 64)
        .                 scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
        .              else
    1,778 ( 0.00%)        scanline = scanline_data;
        .           
    6,223 ( 0.00%)     scanline2 = scanline + result->w;
        .           
    1,778 ( 0.00%)     y = off_y;
   15,113 ( 0.00%)     e[n].y0 = (float) (off_y + result->h) + 1;
        .           
   32,269 ( 0.00%)     while (j < result->h) {
        .                 // find center of pixel for this scanline
   13,912 ( 0.00%)        float scan_y_top    = y + 0.0f;
   27,824 ( 0.00%)        float scan_y_bottom = y + 1.0f;
   13,912 ( 0.00%)        stbtt__active_edge **step = &active;
        .           
   62,604 ( 0.00%)        STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
   88,195 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6,956x)
   69,560 ( 0.00%)        STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
   97,195 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6,956x)
        .           
        .                 // update all active edges;
        .                 // remove all active edges that terminate before the top of this scanline
  274,356 ( 0.00%)        while (*step) {
  179,682 ( 0.00%)           stbtt__active_edge * z = *step;
  299,470 ( 0.00%)           if (z->ey <= scan_y_top) {
  140,648 ( 0.00%)              *step = z->next; // delete from list
  281,296 ( 0.00%)              STBTT_assert(z->direction);
  105,486 ( 0.00%)              z->direction = 0;
  210,972 ( 0.00%)              stbtt__hheap_free(&hh, z);
  492,268 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__hheap_free(stbtt__hheap*, void*) (35,162x)
        .                    } else {
   74,196 ( 0.00%)              step = &((*step)->next); // advance through list
        .                    }
        .                 }
        .           
        .                 // insert all edges that start before the bottom of this scanline
  243,851 ( 0.00%)        while (e->y0 <= scan_y_bottom) {
  323,384 ( 0.00%)           if (e->y0 != e->y1) {
  363,807 ( 0.00%)              stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
4,592,429 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__new_active(stbtt__hheap*, stbtt__edge*, int, float, void*) (40,423x)
   80,846 ( 0.00%)              if (z != NULL) {
   93,030 ( 0.00%)                 if (j == 0 && off_y != 0) {
   30,360 ( 0.00%)                    if (z->ey < scan_y_top) {
        .                                // this can happen due to subpixel positioning and some kind of fp rounding error i think
        .                                z->ey = scan_y_top;
        .                             }
        .                          }
  161,692 ( 0.00%)                 STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
        .                          // insert at front
  121,269 ( 0.00%)                 z->next = active;
   80,846 ( 0.00%)                 active = z;
        .                       }
        .                    }
   40,423 ( 0.00%)           ++e;
        .                 }
        .           
        .                 // now process all active edges
   20,868 ( 0.00%)        if (active)
   76,450 ( 0.00%)           stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
16,622,020 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__fill_active_edges_new(float*, float*, int, stbtt__active_edge*, float) (6,950x)
        .           
        .                 {
   13,912 ( 0.00%)           float sum = 0;
  478,521 ( 0.00%)           for (i=0; i < result->w; ++i) {
        .                       float k;
        .                       int m;
  786,213 ( 0.00%)              sum += scanline2[i];
  786,213 ( 0.00%)              k = scanline[i] + sum;
  698,856 ( 0.00%)              k = (float) STBTT_fabs(k)*255 + 0.5f;
  262,071 ( 0.00%)              m = (int) k;
  174,720 ( 0.00%)              if (m > 255) m = 255;
1,048,284 ( 0.00%)              result->pixels[j*result->stride + i] = (unsigned char) m;
        .                    }
        .                 }
        .                 // advance all the edges
   13,912 ( 0.00%)        step = &active;
  295,400 ( 0.00%)        while (*step) {
  195,465 ( 0.00%)           stbtt__active_edge *z = *step;
  456,085 ( 0.00%)           z->fx += z->fdx; // advance to position for current scanline
  195,465 ( 0.00%)           step = &((*step)->next); // advance through list
        .                 }
        .           
    6,956 ( 0.00%)        ++y;
    6,956 ( 0.00%)        ++j;
        .              }
        .           
    4,445 ( 0.00%)     stbtt__hheap_cleanup(&hh, userdata);
  296,037 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__hheap_cleanup(stbtt__hheap*, void*) (889x)
        .           
    2,667 ( 0.00%)     if (scanline != scanline_data)
        .                 STBTT_free(scanline, userdata);
    2,667 ( 0.00%)  }
        .           #else
        .           #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        .           #endif
        .           
        .           #define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
        .           
        .           static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
    3,556 ( 0.00%)  {
        .              int i,j;
  162,581 ( 0.00%)     for (i=1; i < n; ++i) {
  672,078 ( 0.00%)        stbtt__edge t = p[i], *a = &t;
   79,068 ( 0.00%)        j = i;
  289,216 ( 0.00%)        while (j > 0) {
1,222,280 ( 0.00%)           stbtt__edge *b = &p[j-1];
  977,824 ( 0.00%)           int c = STBTT__COMPARE(a,b);
  282,248 ( 0.00%)           if (!c) break;
2,026,464 ( 0.00%)           p[j] = p[j-1];
   84,436 ( 0.00%)           --j;
        .                 }
  118,602 ( 0.00%)        if (i != j)
  403,065 ( 0.00%)           p[j] = t;
        .              }
    3,556 ( 0.00%)  }
        .           
        .           static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
   26,420 ( 0.00%)  {
        .              /* threshold for transitioning to insertion sort */
   24,642 ( 0.00%)     while (n > 12) {
        .                 stbtt__edge t;
        .                 int c01,c12,c,m,i,j;
        .           
        .                 /* compute median of three */
   13,185 ( 0.00%)        m = n >> 1;
   70,320 ( 0.00%)        c01 = STBTT__COMPARE(&p[0],&p[m]);
  105,480 ( 0.00%)        c12 = STBTT__COMPARE(&p[m],&p[n-1]);
        .                 /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
   13,185 ( 0.00%)        if (c01 != c12) {
        .                    /* otherwise, we'll need to swap something else to middle */
        .                    int z;
   39,616 ( 0.00%)           c = STBTT__COMPARE(&p[0],&p[n-1]);
        .                    /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
        .                    /* 0<mid && mid>n:  0>n => 0; 0<n => n */
   16,036 ( 0.00%)           z = (c == c12) ? 0 : n-1;
   37,140 ( 0.00%)           t = p[z];
   59,424 ( 0.00%)           p[z] = p[m];
   37,140 ( 0.00%)           p[m] = t;
        .                 }
        .                 /* now p[m] is the median-of-three */
        .                 /* swap it to the beginning so it won't move around */
   30,765 ( 0.00%)        t = p[0];
   70,320 ( 0.00%)        p[0] = p[m];
   65,925 ( 0.00%)        p[m] = t;
        .           
        .                 /* partition loop */
    4,395 ( 0.00%)        i=1;
   13,185 ( 0.00%)        j=n-1;
   25,187 ( 0.00%)        for(;;) {
        .                    /* handling of equality is crucial here */
        .                    /* for sentinels & efficiency with duplicates */
   45,467 ( 0.00%)           for (;;++i) {
1,350,882 ( 0.00%)              if (!STBTT__COMPARE(&p[i], &p[0])) break;
        .                    }
   29,334 ( 0.00%)           for (;;--j) {
1,060,488 ( 0.00%)              if (!STBTT__COMPARE(&p[0], &p[j])) break;
        .                    }
        .                    /* make sure we haven't crossed */
   93,141 ( 0.00%)           if (i >= j) break;
  377,805 ( 0.00%)           t = p[i];
  604,488 ( 0.00%)           p[i] = p[j];
  377,805 ( 0.00%)           p[j] = t;
        .           
   25,187 ( 0.00%)           ++i;
   25,187 ( 0.00%)           --j;
        .                 }
        .                 /* recurse on smaller side, iterate on larger */
   17,580 ( 0.00%)        if (j < (n-i)) {
    8,045 ( 0.00%)           stbtt__sort_edges_quicksort(p,j);
  683,385 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int)'2 (1,165x)
   11,263 ( 0.00%)           p = p+i;
    4,827 ( 0.00%)           n = n-i;
        .                 } else {
   41,790 ( 0.00%)           stbtt__sort_edges_quicksort(p+i, n-i);
  602,601 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int)'2 (1,683x)
    5,572 ( 0.00%)           n = j;
        .                 }
        .              }
   21,136 ( 0.00%)  }
        .           
        .           static void stbtt__sort_edges(stbtt__edge *p, int n)
    4,445 ( 0.00%)  {
    4,445 ( 0.00%)     stbtt__sort_edges_quicksort(p, n);
4,752,362 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int) (889x)
    4,445 ( 0.00%)     stbtt__sort_edges_ins_sort(p, n);
6,324,974 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_ins_sort(stbtt__edge*, int) (889x)
    2,667 ( 0.00%)  }
        .           
        .           typedef struct
        .           {
        .              float x,y;
        .           } stbtt__point;
        .           
        .           static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
   11,557 ( 0.00%)  {
    6,223 ( 0.00%)     float y_scale_inv = invert ? -scale_y : scale_y;
        .              stbtt__edge *e;
        .              int n,i,j,k,m;
        .           #if STBTT_RASTERIZER_VERSION == 1
        .              int vsubsample = result->h < 8 ? 15 : 5;
        .           #elif STBTT_RASTERIZER_VERSION == 2
      889 ( 0.00%)     int vsubsample = 1;
        .           #else
        .              #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        .           #endif
        .              // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
        .           
        .              // now we have to blow out the windings into explicit edge lists
      889 ( 0.00%)     n = 0;
   27,041 ( 0.00%)     for (i=0; i < windings; ++i)
   39,543 ( 0.00%)        n += wcount[i];
        .           
    8,890 ( 0.00%)     e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
  230,085 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
    1,778 ( 0.00%)     if (e == 0) return;
      889 ( 0.00%)     n = 0;
        .           
      889 ( 0.00%)     m=0;
   27,041 ( 0.00%)     for (i=0; i < windings; ++i) {
   33,894 ( 0.00%)        stbtt__point *p = pts + m;
   39,543 ( 0.00%)        m += wcount[i];
   45,192 ( 0.00%)        j = wcount[i]-1;
  730,002 ( 0.00%)        for (k=0; k < wcount[i]; j=k++) {
  224,504 ( 0.00%)           int a=k,b=j;
        .                    // skip the edge if horizontal
  898,016 ( 0.00%)           if (p[j].y == p[k].y)
   15,703 ( 0.00%)              continue;
        .                    // add edge from j to k to the list
  404,230 ( 0.00%)           e[n].invert = 0;
  768,037 ( 0.00%)           if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
  200,740 ( 0.00%)              e[n].invert = 1;
   80,296 ( 0.00%)              a=j,b=k;
        .                    }
  727,614 ( 0.00%)           e[n].x0 = p[a].x * scale_x + shift_x;
  808,460 ( 0.00%)           e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
  727,614 ( 0.00%)           e[n].x1 = p[b].x * scale_x + shift_x;
  808,460 ( 0.00%)           e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
   80,846 ( 0.00%)           ++n;
        .                 }
        .              }
        .           
        .              // now sort the edges by their highest point (should snap to integer, and then by x)
        .              //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
    4,445 ( 0.00%)     stbtt__sort_edges(e, n);
11,093,338 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges(stbtt__edge*, int) (889x)
        .           
        .              // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   11,557 ( 0.00%)     stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
31,080,859 ( 0.03%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__rasterize_sorted_edges(stbtt__bitmap*, stbtt__edge*, int, int, int, int, void*) (889x)
        .           
    3,556 ( 0.00%)     STBTT_free(e, userdata);
  194,623 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
    1,778 ( 0.00%)  }
        .           
        .           static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
  673,512 ( 0.00%)  {
  280,630 ( 0.00%)     if (!points) return; // during first pass, it's unallocated
  392,882 ( 0.00%)     points[n].x = x;
  449,008 ( 0.00%)     points[n].y = y;
  224,504 ( 0.00%)  }
        .           
        .           // tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
        .           static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
  713,986 ( 0.00%)  {
        .              // midpoint
  384,454 ( 0.00%)     float mx = (x0 + 2*x1 + x2)/4;
  384,454 ( 0.00%)     float my = (y0 + 2*y1 + y2)/4;
        .              // versus directly drawn line
  329,532 ( 0.00%)     float dx = (x0+x2)/2 - mx;
  329,532 ( 0.00%)     float dy = (y0+y2)/2 - my;
  109,844 ( 0.00%)     if (n > 16) // 65536 segments on one curve better be enough!
        .                 return 1;
  384,454 ( 0.00%)     if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
    3,672 ( 0.00%)        stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
   11,424 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__tesselate_curve(stbtt__point*, int*, float, float, float, float, float, float, float, int)'2 (136x)
    3,808 ( 0.00%)        stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   11,424 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__tesselate_curve(stbtt__point*, int*, float, float, float, float, float, float, float, int)'2 (136x)
        .              } else {
  547,860 ( 0.00%)        stbtt__add_point(points, *num_points,x2,y2);
  981,252 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__add_point(stbtt__point*, int, float, float) (54,514x)
  273,930 ( 0.00%)        *num_points = *num_points+1;
        .              }
   54,922 ( 0.00%)     return 1;
  109,844 ( 0.00%)  }
        .           
        .           static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
        .           {
        .              // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
        .              float dx0 = x1-x0;
        .              float dy0 = y1-y0;
        .              float dx1 = x2-x1;
        .              float dy1 = y2-y1;
-- line 3589 ----------------------------------------
-- line 3619 ----------------------------------------
        .              } else {
        .                 stbtt__add_point(points, *num_points,x3,y3);
        .                 *num_points = *num_points+1;
        .              }
        .           }
        .           
        .           // returns number of contours
        .           static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
    8,001 ( 0.00%)  {
      889 ( 0.00%)     stbtt__point *points=0;
      889 ( 0.00%)     int num_points=0;
        .           
    2,667 ( 0.00%)     float objspace_flatness_squared = objspace_flatness * objspace_flatness;
    1,778 ( 0.00%)     int i,n=0,start=0, pass;
        .           
        .              // count how many "moves" there are to get the contour count
  228,677 ( 0.00%)     for (i=0; i < num_verts; ++i)
  672,696 ( 0.00%)        if (vertices[i].type == STBTT_vmove)
    5,649 ( 0.00%)           ++n;
        .           
    2,667 ( 0.00%)     *num_contours = n;
    1,778 ( 0.00%)     if (n == 0) return 0;
        .           
    6,223 ( 0.00%)     *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
  103,990 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
        .           
    3,556 ( 0.00%)     if (*contour_lengths == 0) {
        .                 *num_contours = 0;
        .                 return 0;
        .              }
        .           
        .              // make two passes through the points so we don't need to realloc
    8,890 ( 0.00%)     for (pass=0; pass < 2; ++pass) {
    7,112 ( 0.00%)        float x=0,y=0;
    3,556 ( 0.00%)        if (pass == 1) {
    5,334 ( 0.00%)           points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
  113,591 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
    1,778 ( 0.00%)           if (points == NULL) goto error;
        .                 }
    1,778 ( 0.00%)        num_points = 0;
    1,778 ( 0.00%)        n= -1;
  457,354 ( 0.00%)        for (i=0; i < num_verts; ++i) {
2,228,172 ( 0.00%)           switch (vertices[i].type) {
        .                       case STBTT_vmove:
        .                          // start the next contour
   22,596 ( 0.00%)                 if (n >= 0)
   85,680 ( 0.00%)                    (*contour_lengths)[n] = num_points - start;
   11,298 ( 0.00%)                 ++n;
   22,596 ( 0.00%)                 start = num_points;
        .           
  293,748 ( 0.00%)                 x = vertices[i].x, y = vertices[i].y;
  124,278 ( 0.00%)                 stbtt__add_point(points, num_points++, x,y);
  203,364 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__add_point(stbtt__point*, int, float, float) (11,298x)
   11,298 ( 0.00%)                 break;
        .                       case STBTT_vline:
1,200,368 ( 0.00%)                 x = vertices[i].x, y = vertices[i].y;
  507,848 ( 0.00%)                 stbtt__add_point(points, num_points++, x, y);
  831,024 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__add_point(stbtt__point*, int, float, float) (46,168x)
   46,168 ( 0.00%)                 break;
        .                       case STBTT_vcurve:
1,311,600 ( 0.00%)                 stbtt__tesselate_curve(points, &num_points, x,y,
4,616,440 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__tesselate_curve(stbtt__point*, int*, float, float, float, float, float, float, float, int) (54,650x)
1,093,000 ( 0.00%)                                          vertices[i].cx, vertices[i].cy,
1,093,000 ( 0.00%)                                          vertices[i].x,  vertices[i].y,
        .                                                   objspace_flatness_squared, 0);
1,420,900 ( 0.00%)                 x = vertices[i].x, y = vertices[i].y;
   54,650 ( 0.00%)                 break;
        .                       case STBTT_vcubic:
        .                          stbtt__tesselate_cubic(points, &num_points, x,y,
        .                                                   vertices[i].cx, vertices[i].cy,
        .                                                   vertices[i].cx1, vertices[i].cy1,
        .                                                   vertices[i].x,  vertices[i].y,
        .                                                   objspace_flatness_squared, 0);
        .                          x = vertices[i].x, y = vertices[i].y;
        .                          break;
        .                    }
        .                 }
   16,002 ( 0.00%)        (*contour_lengths)[n] = num_points - start;
        .              }
        .           
    1,778 ( 0.00%)     return points;
        .           error:
        .              STBTT_free(points, userdata);
        .              STBTT_free(*contour_lengths, userdata);
        .              *contour_lengths = 0;
        .              *num_contours = 0;
        .              return NULL;
    1,778 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
   12,446 ( 0.00%)  {
    5,120 ( 0.00%)     float scale            = scale_x > scale_y ? scale_y : scale_x;
      889 ( 0.00%)     int winding_count      = 0;
      889 ( 0.00%)     int *winding_lengths   = NULL;
   10,668 ( 0.00%)     stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
16,838,217 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_FlattenCurves(stbtt_vertex*, int, float, int**, int*, void*) (889x)
    1,778 ( 0.00%)     if (windings) {
   18,669 ( 0.00%)        stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
49,339,021 ( 0.04%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__rasterize(stbtt__bitmap*, stbtt__point*, int*, int, float, float, float, float, int, int, int, void*) (889x)
    2,667 ( 0.00%)        STBTT_free(winding_lengths, userdata);
  141,351 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
    2,667 ( 0.00%)        STBTT_free(windings, userdata);
  145,105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
        .              }
    2,667 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
        .           {
        .              STBTT_free(bitmap, userdata);
        .           }
        .           
        .           STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
        .           {
-- line 3722 ----------------------------------------
-- line 3759 ----------------------------------------
        .           }
        .           
        .           STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
        .           {
        .              return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
        .           }
        .           
        .           STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
   11,726 ( 0.00%)  {
        .              int ix0,iy0;
        .              stbtt_vertex *vertices;
    6,314 ( 0.00%)     int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
14,853,904 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphShape (902x)
        .              stbtt__bitmap gbm;
        .           
   14,432 ( 0.00%)     stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
  308,904 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBoxSubpixel (902x)
    1,804 ( 0.00%)     gbm.pixels = output;
    1,804 ( 0.00%)     gbm.w = out_w;
    1,804 ( 0.00%)     gbm.h = out_h;
    1,804 ( 0.00%)     gbm.stride = out_stride;
        .           
    5,373 ( 0.00%)     if (gbm.w && gbm.h)
   20,447 ( 0.00%)        stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
66,522,154 ( 0.06%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_Rasterize (889x)
        .           
    2,706 ( 0.00%)     STBTT_free(vertices, info->userdata);
  188,705 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (902x)
    2,706 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
        .           {
        .              stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
        .           }
        .           
        .           STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
        .           {
-- line 3791 ----------------------------------------
-- line 3958 ----------------------------------------
        .           //////////////////////////////////////////////////////////////////////////////
        .           //
        .           // bitmap baking
        .           //
        .           // This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
        .           // stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.
        .           
        .           STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
        9 ( 0.00%)  {
        3 ( 0.00%)     stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
      118 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        3 ( 0.00%)     int            num_nodes = pw - padding;
        6 ( 0.00%)     stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
      411 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        .           
        4 ( 0.00%)     if (context == NULL || nodes == NULL) {
        .                 if (context != NULL) STBTT_free(context, alloc_context);
        .                 if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
        .                 return 0;
        .              }
        .           
        3 ( 0.00%)     spc->user_allocator_context = alloc_context;
        3 ( 0.00%)     spc->width = pw;
        3 ( 0.00%)     spc->height = ph;
        3 ( 0.00%)     spc->pixels = pixels;
        3 ( 0.00%)     spc->pack_info = context;
        3 ( 0.00%)     spc->nodes = nodes;
        3 ( 0.00%)     spc->padding = padding;
        5 ( 0.00%)     spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
        2 ( 0.00%)     spc->h_oversample = 1;
        2 ( 0.00%)     spc->v_oversample = 1;
        2 ( 0.00%)     spc->skip_missing = 0;
        .           
       12 ( 0.00%)     stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
    9,776 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_rectpack.h:stbrp_init_target (1x)
        .           
        2 ( 0.00%)     if (pixels)
        .                 STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
        .           
        1 ( 0.00%)     return 1;
        2 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
        4 ( 0.00%)  {
        4 ( 0.00%)     STBTT_free(spc->nodes    , spc->user_allocator_context);
      283 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
        4 ( 0.00%)     STBTT_free(spc->pack_info, spc->user_allocator_context);
      159 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
        3 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
        .           {
        .              STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
        .              STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
        .              if (h_oversample <= STBTT_MAX_OVERSAMPLE)
        .                 spc->h_oversample = h_oversample;
        .              if (v_oversample <= STBTT_MAX_OVERSAMPLE)
-- line 4009 ----------------------------------------
-- line 4013 ----------------------------------------
        .           STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
        .           {
        .              spc->skip_missing = skip;
        .           }
        .           
        .           #define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)
        .           
        .           static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
    5,432 ( 0.00%)  {
        .              unsigned char buffer[STBTT_MAX_OVERSAMPLE];
    2,037 ( 0.00%)     int safe_w = w - kernel_width;
        .              int j;
    4,074 ( 0.00%)     STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
    8,827 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (679x)
   24,743 ( 0.00%)     for (j=0; j < h; ++j) {
        .                 int i;
        .                 unsigned int total;
   32,022 ( 0.00%)        STBTT_memset(buffer, 0, kernel_width);
   96,066 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (5,337x)
        .           
    5,337 ( 0.00%)        total = 0;
        .           
        .                 // make kernel_width a constant in common cases so compiler can optimize out the divide
   53,370 ( 0.00%)        switch (kernel_width) {
        .                    case 2:
  343,505 ( 0.00%)              for (i=0; i <= safe_w; ++i) {
1,108,870 ( 0.00%)                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];
  871,255 ( 0.00%)                 buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
  712,845 ( 0.00%)                 pixels[i] = (unsigned char) (total / 2);
        .                       }
    5,337 ( 0.00%)              break;
        .                    case 3:
        .                       for (i=0; i <= safe_w; ++i) {
        .                          total += pixels[i] - buffer[i & STBTT__OVER_MASK];
        .                          buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
        .                          pixels[i] = (unsigned char) (total / 3);
        .                       }
        .                       break;
        .                    case 4:
-- line 4049 ----------------------------------------
-- line 4064 ----------------------------------------
        .                       for (i=0; i <= safe_w; ++i) {
        .                          total += pixels[i] - buffer[i & STBTT__OVER_MASK];
        .                          buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
        .                          pixels[i] = (unsigned char) (total / kernel_width);
        .                       }
        .                       break;
        .                 }
        .           
   42,696 ( 0.00%)        for (; i < w; ++i) {
   37,359 ( 0.00%)           STBTT_assert(pixels[i] == 0);
   32,022 ( 0.00%)           total -= buffer[i & STBTT__OVER_MASK];
   53,370 ( 0.00%)           pixels[i] = (unsigned char) (total / kernel_width);
        .                 }
        .           
   16,011 ( 0.00%)        pixels += stride_in_bytes;
        .              }
    2,716 ( 0.00%)  }
        .           
        .           static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
        .           {
        .              unsigned char buffer[STBTT_MAX_OVERSAMPLE];
        .              int safe_h = h - kernel_width;
        .              int j;
        .              STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
        .              for (j=0; j < w; ++j) {
-- line 4088 ----------------------------------------
-- line 4137 ----------------------------------------
        .                    pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
        .                 }
        .           
        .                 pixels += 1;
        .              }
        .           }
        .           
        .           static float stbtt__oversample_shift(int oversample)
       12 ( 0.00%)  {
        8 ( 0.00%)     if (!oversample)
        .                 return 0.0f;
        .           
        .              // The prefilter is a box filter of width "oversample",
        .              // which shifts phase by (oversample - 1)/2 pixels in
        .              // oversampled space. We want to shift in the opposite
        .              // direction to counter this.
       24 ( 0.00%)     return (float)-(oversample - 1) / (2.0f * (float)oversample);
        8 ( 0.00%)  }
        .           
        .           // rects array must be big enough to accommodate all characters in the given ranges
        .           STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
        .           {
        .              int i,j,k;
        .              int missing_glyph_added = 0;
        .           
        .              k=0;
-- line 4162 ----------------------------------------
-- line 4209 ----------------------------------------
        .                 stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);
        .           
        .              *sub_x = stbtt__oversample_shift(prefilter_x);
        .              *sub_y = stbtt__oversample_shift(prefilter_y);
        .           }
        .           
        .           // rects array must be big enough to accommodate all characters in the given ranges
        .           STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
       16 ( 0.00%)  {
        4 ( 0.00%)     int i,j,k, missing_glyph = -1, return_value = 1;
        .           
        .              // save current values
        6 ( 0.00%)     int old_h_over = spc->h_oversample;
        6 ( 0.00%)     int old_v_over = spc->v_oversample;
        .           
        2 ( 0.00%)     k = 0;
       18 ( 0.00%)     for (i=0; i < num_ranges; ++i) {
       22 ( 0.00%)        float fh = ranges[i].font_size;
       24 ( 0.00%)        float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      130 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_ScaleForPixelHeight (2x)
        .                 float recip_h,recip_v,sub_x,sub_y;
       26 ( 0.00%)        spc->h_oversample = ranges[i].h_oversample;
       26 ( 0.00%)        spc->v_oversample = ranges[i].v_oversample;
       20 ( 0.00%)        recip_h = 1.0f / spc->h_oversample;
       20 ( 0.00%)        recip_v = 1.0f / spc->v_oversample;
       12 ( 0.00%)        sub_x = stbtt__oversample_shift(spc->h_oversample);
       26 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__oversample_shift(int) (2x)
       12 ( 0.00%)        sub_y = stbtt__oversample_shift(spc->v_oversample);
       26 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__oversample_shift(int) (2x)
   11,754 ( 0.00%)        for (j=0; j < ranges[i].num_chars; ++j) {
    9,020 ( 0.00%)           stbrp_rect *r = &rects[k];
   10,824 ( 0.00%)           if (r->was_packed && r->w != 0 && r->h != 0) {
   16,236 ( 0.00%)              stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
        .                       int advance, lsb, x0,y0,x1,y1;
   25,256 ( 0.00%)              int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
    5,412 ( 0.00%)              int glyph = stbtt_FindGlyphIndex(info, codepoint);
  407,787 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_FindGlyphIndex (902x)
    2,706 ( 0.00%)              stbrp_coord pad = (stbrp_coord) spc->padding;
        .           
        .                       // pad on left and top
    5,412 ( 0.00%)              r->x += pad;
    5,412 ( 0.00%)              r->y += pad;
    5,412 ( 0.00%)              r->w -= pad;
    5,412 ( 0.00%)              r->h -= pad;
    5,412 ( 0.00%)              stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
   94,923 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphHMetrics (902x)
   19,844 ( 0.00%)              stbtt_GetGlyphBitmapBox(info, glyph,
  360,006 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBox (902x)
    1,804 ( 0.00%)                                      scale * spc->h_oversample,
    1,804 ( 0.00%)                                      scale * spc->v_oversample,
        .                                               &x0,&y0,&x1,&y1);
   25,256 ( 0.00%)              stbtt_MakeGlyphBitmapSubpixel(info,
81,944,587 ( 0.07%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_MakeGlyphBitmapSubpixel (902x)
   10,824 ( 0.00%)                                            spc->pixels + r->x + r->y*spc->stride_in_bytes,
    6,314 ( 0.00%)                                            r->w - spc->h_oversample+1,
    6,314 ( 0.00%)                                            r->h - spc->v_oversample+1,
        .                                                     spc->stride_in_bytes,
    1,804 ( 0.00%)                                            scale * spc->h_oversample,
    1,804 ( 0.00%)                                            scale * spc->v_oversample,
        .                                                     0,0,
        .                                                     glyph);
        .           
    3,608 ( 0.00%)              if (spc->h_oversample > 1)
   16,296 ( 0.00%)                 stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
3,457,894 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__h_prefilter(unsigned char*, int, int, int, unsigned int) (679x)
        .                                             r->w, r->h, spc->stride_in_bytes,
        .                                             spc->h_oversample);
        .           
    3,608 ( 0.00%)              if (spc->v_oversample > 1)
        .                          stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
        .                                             r->w, r->h, spc->stride_in_bytes,
        .                                             spc->v_oversample);
        .           
    4,510 ( 0.00%)              bc->x0       = (stbtt_int16)  r->x;
    4,510 ( 0.00%)              bc->y0       = (stbtt_int16)  r->y;
    7,216 ( 0.00%)              bc->x1       = (stbtt_int16) (r->x + r->w);
    7,216 ( 0.00%)              bc->y1       = (stbtt_int16) (r->y + r->h);
    4,510 ( 0.00%)              bc->xadvance =                scale * advance;
    5,412 ( 0.00%)              bc->xoff     =       (float)  x0 * recip_h + sub_x;
    5,412 ( 0.00%)              bc->yoff     =       (float)  y0 * recip_v + sub_y;
    8,118 ( 0.00%)              bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
    8,118 ( 0.00%)              bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
        .           
    1,804 ( 0.00%)              if (glyph == 0)
        .                          missing_glyph = j;
      902 ( 0.00%)           } else if (spc->skip_missing) {
        .                       return_value = 0;
        .                    } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
        .                       ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
        .                    } else {
        .                       return_value = 0; // if any fail, report failure
        .                    }
        .           
      902 ( 0.00%)           ++k;
        .                 }
        .              }
        .           
        .              // restore original values
        6 ( 0.00%)     spc->h_oversample = old_h_over;
        6 ( 0.00%)     spc->v_oversample = old_v_over;
        .           
        2 ( 0.00%)     return return_value;
        4 ( 0.00%)  }
        .           
        .           STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
        .           {
        .              stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
        .           }
        .           
        .           STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
        .           {
-- line 4311 ----------------------------------------
-- line 4364 ----------------------------------------
        .              scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
        .              stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
        .              *ascent  = (float) i_ascent  * scale;
        .              *descent = (float) i_descent * scale;
        .              *lineGap = (float) i_lineGap * scale;
        .           }
        .           
        .           STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
    8,118 ( 0.00%)  {
    7,216 ( 0.00%)     float ipw = 1.0f / pw, iph = 1.0f / ph;
    9,020 ( 0.00%)     const stbtt_packedchar *b = chardata + char_index;
        .           
    1,804 ( 0.00%)     if (align_to_integer) {
        .                 float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
        .                 float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
        .                 q->x0 = x;
        .                 q->y0 = y;
        .                 q->x1 = x + b->xoff2 - b->xoff;
        .                 q->y1 = y + b->yoff2 - b->yoff;
        .              } else {
    6,314 ( 0.00%)        q->x0 = *xpos + b->xoff;
    6,314 ( 0.00%)        q->y0 = *ypos + b->yoff;
    6,314 ( 0.00%)        q->x1 = *xpos + b->xoff2;
    6,314 ( 0.00%)        q->y1 = *ypos + b->yoff2;
        .              }
        .           
    6,314 ( 0.00%)     q->s0 = b->x0 * ipw;
    6,314 ( 0.00%)     q->t0 = b->y0 * iph;
    6,314 ( 0.00%)     q->s1 = b->x1 * ipw;
    6,314 ( 0.00%)     q->t1 = b->y1 * iph;
        .           
    6,314 ( 0.00%)     *xpos += b->xadvance;
    2,706 ( 0.00%)  }
        .           
        .           //////////////////////////////////////////////////////////////////////////////
        .           //
        .           // sdf computation
        .           //
        .           
        .           #define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
        .           #define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))
-- line 4404 ----------------------------------------
-- line 4943 ----------------------------------------
        .           STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
        .                                           float pixel_height, unsigned char *pixels, int pw, int ph,
        .                                           int first_char, int num_chars, stbtt_bakedchar *chardata)
        .           {
        .              return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
        .           }
        .           
        .           STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
       10 ( 0.00%)  {
       10 ( 0.00%)     return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
      124 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetFontOffsetForIndex_internal(unsigned char*, int) (2x)
        4 ( 0.00%)  }
        .           
        .           STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
        .           {
        .              return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
        .           }
        .           
        .           STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
       12 ( 0.00%)  {
       12 ( 0.00%)     return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
    5,520 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_InitFont_internal(stbtt_fontinfo*, unsigned char*, int) (2x)
        4 ( 0.00%)  }
        .           
        .           STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
        .           {
        .              return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
        .           }
        .           
        .           STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
        .           {
-- line 4971 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/move.h
--------------------------------------------------------------------------------
Ir                  

-- line 43 ----------------------------------------
         .           
         .             // Used, in C++03 mode too, by allocators, etc.
         .             /**
         .              *  @brief Same as C++11 std::addressof
         .              *  @ingroup utilities
         .              */
         .             template<typename _Tp>
         .               inline _GLIBCXX_CONSTEXPR _Tp*
 8,982,015 ( 0.01%)      __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 8,982,015 ( 0.01%)      { return __builtin_addressof(__r); }
         .           
         .           #if __cplusplus >= 201103L
         .           
         .             /**
         .              *  @addtogroup utilities
         .              *  @{
         .              */
         .           
-- line 60 ----------------------------------------
-- line 62 ----------------------------------------
         .              *  @brief  Forward an lvalue.
         .              *  @return The parameter cast to the specified type.
         .              *
         .              *  This function is used to implement "perfect forwarding".
         .              */
         .             template<typename _Tp>
         .               _GLIBCXX_NODISCARD
         .               constexpr _Tp&&
71,852,742 ( 0.06%)      forward(typename std::remove_reference<_Tp>::type& __t) noexcept
71,859,138 ( 0.06%)      { return static_cast<_Tp&&>(__t); }
         .           
         .             /**
         .              *  @brief  Forward an rvalue.
         .              *  @return The parameter cast to the specified type.
         .              *
         .              *  This function is used to implement "perfect forwarding".
         .              */
         .             template<typename _Tp>
-- line 79 ----------------------------------------
-- line 119 ----------------------------------------
         .             /**
         .              *  @brief  Convert a value to an rvalue.
         .              *  @param  __t  A thing of arbitrary type.
         .              *  @return The parameter cast to an rvalue-reference to allow moving it.
         .             */
         .             template<typename _Tp>
         .               _GLIBCXX_NODISCARD
         .               constexpr typename std::remove_reference<_Tp>::type&&
 7,657,227 ( 0.01%)      move(_Tp&& __t) noexcept
 7,657,401 ( 0.01%)      { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
         .           
         .           
         .             template<typename _Tp>
         .               struct __move_if_noexcept_cond
         .               : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
         .                               is_copy_constructible<_Tp>>::type { };
         .           
         .             /**
-- line 136 ----------------------------------------
-- line 155 ----------------------------------------
         .              *         referenced by r, even in the presence of an overloaded
         .              *         operator&.
         .              *  @param  __r  Reference to an object or function.
         .              *  @return   The actual address.
         .             */
         .             template<typename _Tp>
         .               _GLIBCXX_NODISCARD
         .               inline _GLIBCXX17_CONSTEXPR _Tp*
 5,664,260 ( 0.00%)      addressof(_Tp& __r) noexcept
 7,080,325 ( 0.01%)      { return std::__addressof(__r); }
     7,680 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true>* std::__addressof<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true> >(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true>&) (1,280x)
         .           
         .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .             // 2598. addressof works on temporaries
         .             template<typename _Tp>
         .               const _Tp* addressof(const _Tp&&) = delete;
         .           
         .             // C++11 version of std::exchange for internal use.
         .             template <typename _Tp, typename _Up = _Tp>
-- line 172 ----------------------------------------
-- line 206 ----------------------------------------
         .               inline
         .           #if __cplusplus >= 201103L
         .               typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         .           			      is_move_constructible<_Tp>,
         .           			      is_move_assignable<_Tp>>::value>::type
         .           #else
         .               void
         .           #endif
 1,047,788 ( 0.00%)      swap(_Tp& __a, _Tp& __b)
         .               _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,
         .           				is_nothrow_move_assignable<_Tp>>::value)
         .               {
         .           #if __cplusplus < 201103L
         .                 // concept requirements
         .                 __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
         .           #endif
   853,344 ( 0.00%)        _Tp __tmp = _GLIBCXX_MOVE(__a);
         6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<Ship::Console*&>::type&& std::move<Ship::Console*&>(Ship::Console*&) (1x)
   969,813 ( 0.00%)        __a = _GLIBCXX_MOVE(__b);
         6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<Ship::Console*&>::type&& std::move<Ship::Console*&>(Ship::Console*&) (1x)
   965,866 ( 0.00%)        __b = _GLIBCXX_MOVE(__tmp);
         6 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<Ship::Console*&>::type&& std::move<Ship::Console*&>(Ship::Console*&) (1x)
   628,834 ( 0.00%)      }
         .           
         .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .             // DR 809. std::swap should be overloaded for array types.
         .             /// Swap the contents of two arrays.
         .             template<typename _Tp, size_t _Nm>
         .               _GLIBCXX20_CONSTEXPR
         .               inline
         .           #if __cplusplus >= 201103L
-- line 233 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/string_view
--------------------------------------------------------------------------------
Ir                 

-- line 63 ----------------------------------------
        .           
        .           namespace std _GLIBCXX_VISIBILITY(default)
        .           {
        .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
        .           
        .             // Helper for basic_string and basic_string_view members.
        .             constexpr size_t
        .             __sv_check(size_t __size, size_t __pos, const char* __s)
  477,324 ( 0.00%)    {
  238,662 ( 0.00%)      if (__pos > __size)
        .                 __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > __size "
        .           				   "(which is %zu)"), __s, __pos, __size);
   79,554 ( 0.00%)      return __pos;
  159,108 ( 0.00%)    }
        .           
        .             // Helper for basic_string members.
        .             // NB: __sv_limit doesn't check for a bad __pos value.
        .             constexpr size_t
        .             __sv_limit(size_t __size, size_t __pos, size_t __off) noexcept
        .             {
        .              const bool __testoff =  __off < __size - __pos;
        .              return __testoff ? __off : __size - __pos;
-- line 84 ----------------------------------------
-- line 132 ----------------------------------------
        .                 basic_string_view() noexcept
        .                 : _M_len{0}, _M_str{nullptr}
        .                 { }
        .           
        .                 constexpr basic_string_view(const basic_string_view&) noexcept = default;
        .           
        .                 [[__gnu__::__nonnull__]]
        .                 constexpr
        5 ( 0.00%)        basic_string_view(const _CharT* __str) noexcept
        5 ( 0.00%)        : _M_len{traits_type::length(__str)},
       28 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::length(char const*) (1x)
        3 ( 0.00%)  	_M_str{__str}
        3 ( 0.00%)        { }
        .           
        .                 constexpr
  945,165 ( 0.00%)        basic_string_view(const _CharT* __str, size_type __len) noexcept
1,134,198 ( 0.00%)        : _M_len{__len}, _M_str{__str}
  567,099 ( 0.00%)        { }
        .           
        .           #if __cplusplus >= 202002L && __cpp_lib_concepts
        .                 template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
        .           	requires same_as<iter_value_t<_It>, _CharT>
        .           	  && (!convertible_to<_End, size_type>)
        .           	constexpr
        .           	basic_string_view(_It __first, _End __last)
        .           	noexcept(noexcept(__last - __first))
-- line 156 ----------------------------------------
-- line 221 ----------------------------------------
        .                 constexpr const_reverse_iterator
        .                 crend() const noexcept
        .                 { return const_reverse_iterator(this->begin()); }
        .           
        .                 // [string.view.capacity], capacity
        .           
        .                 [[nodiscard]]
        .                 constexpr size_type
  706,431 ( 0.00%)        size() const noexcept
  941,908 ( 0.00%)        { return this->_M_len; }
        .           
        .                 [[nodiscard]]
        .                 constexpr size_type
   49,662 ( 0.00%)        length() const noexcept
   66,216 ( 0.00%)        { return _M_len; }
        .           
        .                 [[nodiscard]]
        .                 constexpr size_type
        .                 max_size() const noexcept
        .                 {
        .           	return (npos - sizeof(size_type) - sizeof(void*))
        .           		/ sizeof(value_type) / 4;
        .                 }
-- line 243 ----------------------------------------
-- line 281 ----------------------------------------
        .                 back() const noexcept
        .                 {
        .           	__glibcxx_assert(this->_M_len > 0);
        .           	return *(this->_M_str + this->_M_len - 1);
        .                 }
        .           
        .                 [[nodiscard]]
        .                 constexpr const_pointer
   49,755 ( 0.00%)        data() const noexcept
   66,340 ( 0.00%)        { return this->_M_str; }
        .           
        .                 // [string.view.modifiers], modifiers:
        .           
        .                 constexpr void
        .                 remove_prefix(size_type __n) noexcept
        .                 {
        .           	__glibcxx_assert(this->_M_len >= __n);
        .           	this->_M_str += __n;
-- line 298 ----------------------------------------
-- line 326 ----------------------------------------
        .           	// _GLIBCXX_RESOLVE_LIB_DEFECTS
        .           	// 2777. basic_string_view::copy should use char_traits::copy
        .           	traits_type::copy(__str, data() + __pos, __rlen);
        .           	return __rlen;
        .                 }
        .           
        .                 [[nodiscard]]
        .                 constexpr basic_string_view
  477,324 ( 0.00%)        substr(size_type __pos = 0, size_type __n = npos) const noexcept(false)
        .                 {
  795,540 ( 0.00%)  	__pos = std::__sv_check(size(), __pos, "basic_string_view::substr");
  954,648 ( 0.00%)  => /usr/include/c++/14/string_view:std::__sv_check(unsigned long, unsigned long, char const*) (79,554x)
  556,878 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const (79,554x)
  875,094 ( 0.00%)  	const size_type __rlen = std::min<size_t>(__n, _M_len - __pos);
1,034,208 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (79,554x)
  875,094 ( 0.00%)  	return basic_string_view{_M_str + __pos, __rlen};
1,113,756 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::basic_string_view(char const*, unsigned long) (79,554x)
  159,108 ( 0.00%)        }
        .           
        .                 [[nodiscard]]
        .                 constexpr int
  510,906 ( 0.00%)        compare(basic_string_view __str) const noexcept
        .                 {
  325,122 ( 0.00%)  	const size_type __rlen = std::min(this->_M_len, __str._M_len);
  603,798 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (46,446x)
  371,568 ( 0.00%)  	int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
2,016,589 ( 0.00%)  => /usr/include/c++/14/bits/char_traits.h:std::char_traits<char>::compare(char const*, char const*, unsigned long) (46,446x)
   92,892 ( 0.00%)  	if (__ret == 0)
        .           	  __ret = _S_compare(this->_M_len, __str._M_len);
   46,446 ( 0.00%)  	return __ret;
   92,892 ( 0.00%)        }
        .           
        .                 [[nodiscard]]
        .                 constexpr int
        .                 compare(size_type __pos1, size_type __n1, basic_string_view __str) const
        .                 { return this->substr(__pos1, __n1).compare(__str); }
        .           
        .                 [[nodiscard]]
        .                 constexpr int
-- line 358 ----------------------------------------
-- line 379 ----------------------------------------
        .                 {
        .           	return this->substr(__pos1, __n1)
        .           		   .compare(basic_string_view(__str, __n2));
        .                 }
        .           
        .           #ifdef __cpp_lib_starts_ends_with // C++ >= 20
        .                 [[nodiscard]]
        .                 constexpr bool
  557,352 ( 0.00%)        starts_with(basic_string_view __x) const noexcept
  928,920 ( 0.00%)        { return this->substr(0, __x.size()) == __x; }
6,289,621 ( 0.01%)  => /usr/include/c++/14/string_view:bool std::operator==<char, std::char_traits<char> >(std::basic_string_view<char, std::char_traits<char> >, std::type_identity<std::basic_string_view<char, std::char_traits<char> > >::type) (46,446x)
3,994,356 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::substr(unsigned long, unsigned long) const (46,446x)
  325,122 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const (46,446x)
        .           
        .                 [[nodiscard]]
        .                 constexpr bool
        .                 starts_with(_CharT __x) const noexcept
        .                 { return !this->empty() && traits_type::eq(this->front(), __x); }
        .           
        .                 [[nodiscard, __gnu__::__nonnull__]]
        .                 constexpr bool
-- line 396 ----------------------------------------
-- line 439 ----------------------------------------
        .                 contains(const _CharT* __x) const noexcept
        .                 { return this->find(__x) != npos; }
        .           #endif // C++23
        .           
        .                 // [string.view.find], searching
        .           
        .                 [[nodiscard]]
        .                 constexpr size_type
  198,648 ( 0.00%)        find(basic_string_view __str, size_type __pos = 0) const noexcept
  132,432 ( 0.00%)        { return this->find(__str._M_str, __pos, __str._M_len); }
2,370,924 ( 0.00%)  => /usr/include/c++/14/bits/string_view.tcc:std::basic_string_view<char, std::char_traits<char> >::find(char const*, unsigned long, unsigned long) const (16,554x)
        .           
        .                 [[nodiscard]]
        .                 constexpr size_type
        .                 find(_CharT __c, size_type __pos = 0) const noexcept;
        .           
        .                 [[nodiscard]]
        .                 constexpr size_type
        .                 find(const _CharT* __str, size_type __pos, size_type __n) const noexcept;
-- line 456 ----------------------------------------
-- line 601 ----------------------------------------
        .             // context, so that only one argument participates in template argument
        .             // deduction and the other argument gets implicitly converted to the deduced
        .             // type (see N3766).
        .           
        .           #if __cpp_lib_three_way_comparison
        .             template<typename _CharT, typename _Traits>
        .               [[nodiscard]]
        .               constexpr bool
  603,798 ( 0.00%)      operator==(basic_string_view<_CharT, _Traits> __x,
        .           	       type_identity_t<basic_string_view<_CharT, _Traits>> __y)
        .               noexcept
  975,366 ( 0.00%)      { return __x.size() == __y.size() && __x.compare(__y) == 0; }
4,060,213 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::compare(std::basic_string_view<char, std::char_traits<char> >) const (46,446x)
  650,244 ( 0.00%)  => /usr/include/c++/14/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const (92,892x)
        .           
        .             template<typename _CharT, typename _Traits>
        .               [[nodiscard]]
        .               constexpr auto
        .               operator<=>(basic_string_view<_CharT, _Traits> __x,
        .           		__type_identity_t<basic_string_view<_CharT, _Traits>> __y)
        .               noexcept
        .               -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
-- line 620 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_list.h
--------------------------------------------------------------------------------
Ir               

-- line 102 ----------------------------------------
      .           
      .               /// The %list node header.
      .               struct _List_node_header : public _List_node_base
      .               {
      .           #if _GLIBCXX_USE_CXX11_ABI
      .                 std::size_t _M_size;
      .           #endif
      .           
      4 ( 0.00%)        _List_node_header() _GLIBCXX_NOEXCEPT
      6 ( 0.00%)        { _M_init(); }
     15 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__detail::_List_node_header::_M_init() (1x)
      .           
      .           #if __cplusplus >= 201103L
      .                 _List_node_header(_List_node_header&& __x) noexcept
      .                 : _List_node_base{ __x._M_next, __x._M_prev }
      .           # if _GLIBCXX_USE_CXX11_ABI
      .                 , _M_size(__x._M_size)
      .           # endif
      .                 {
-- line 119 ----------------------------------------
-- line 142 ----------------------------------------
      .           	    _M_size = __x._M_size;
      .           # endif
      .           	    __x._M_init();
      .           	  }
      .                 }
      .           #endif
      .           
      .                 void
      6 ( 0.00%)        _M_init() _GLIBCXX_NOEXCEPT
      .                 {
     14 ( 0.00%)  	this->_M_next = this->_M_prev = this;
      .           #if _GLIBCXX_USE_CXX11_ABI
      4 ( 0.00%)  	this->_M_size = 0;
      .           #endif
      6 ( 0.00%)        }
      .           
      .               private:
      .                 _List_node_base* _M_base() { return this; }
      .               };
      .           
      .               // Used by list::sort to hold nodes being sorted.
      .               struct _Scratch_list : _List_node_base
      .               {
-- line 164 ----------------------------------------
-- line 230 ----------------------------------------
      .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
      .           
      .             /// An actual node in the %list.
      .             template<typename _Tp>
      .               struct _List_node : public __detail::_List_node_base
      .               {
      .           #if __cplusplus >= 201103L
      .                 __gnu_cxx::__aligned_membuf<_Tp> _M_storage;
  8,000 ( 0.00%)        _Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
 12,000 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<TextureCacheMapIter>::_M_ptr() (800x)
      .                 _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }
      .           #else
      .                 _Tp _M_data;
      .                 _Tp*       _M_valptr()       { return std::__addressof(_M_data); }
      .                 _Tp const* _M_valptr() const { return std::__addressof(_M_data); }
      .           #endif
      .               };
      .           
-- line 246 ----------------------------------------
-- line 256 ----------------------------------------
      .                 typedef _List_node<_Tp>			_Node;
      .           
      .                 typedef ptrdiff_t				difference_type;
      .                 typedef std::bidirectional_iterator_tag	iterator_category;
      .                 typedef _Tp				value_type;
      .                 typedef _Tp*				pointer;
      .                 typedef _Tp&				reference;
      .           
  1,200 ( 0.00%)        _List_iterator() _GLIBCXX_NOEXCEPT
  2,000 ( 0.00%)        : _M_node() { }
      .           
      .                 explicit
509,800 ( 0.00%)        _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
764,700 ( 0.00%)        : _M_node(__x) { }
      .           
      .                 _Self
      .                 _M_const_cast() const _GLIBCXX_NOEXCEPT
      .                 { return *this; }
      .           
      .                 // Must downcast from _List_node_base to _List_node to get to value.
      .                 _GLIBCXX_NODISCARD
      .                 reference
-- line 277 ----------------------------------------
-- line 279 ----------------------------------------
      .                 { return *static_cast<_Node*>(_M_node)->_M_valptr(); }
      .           
      .                 _GLIBCXX_NODISCARD
      .                 pointer
      .                 operator->() const _GLIBCXX_NOEXCEPT
      .                 { return static_cast<_Node*>(_M_node)->_M_valptr(); }
      .           
      .                 _Self&
 99,087 ( 0.00%)        operator++() _GLIBCXX_NOEXCEPT
      .                 {
165,145 ( 0.00%)  	_M_node = _M_node->_M_next;
 33,029 ( 0.00%)  	return *this;
 66,058 ( 0.00%)        }
      .           
      .                 _Self
      .                 operator++(int) _GLIBCXX_NOEXCEPT
      .                 {
      .           	_Self __tmp = *this;
      .           	_M_node = _M_node->_M_next;
      .           	return __tmp;
      .                 }
-- line 299 ----------------------------------------
-- line 350 ----------------------------------------
      .                 _List_const_iterator() _GLIBCXX_NOEXCEPT
      .                 : _M_node() { }
      .           
      .                 explicit
      .                 _List_const_iterator(const __detail::_List_node_base* __x)
      .                 _GLIBCXX_NOEXCEPT
      .                 : _M_node(__x) { }
      .           
397,948 ( 0.00%)        _List_const_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
696,409 ( 0.00%)        : _M_node(__x._M_node) { }
      .           
      .                 iterator
374,484 ( 0.00%)        _M_const_cast() const _GLIBCXX_NOEXCEPT
842,589 ( 0.00%)        { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }
936,210 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_iterator<TextureCacheMapIter>::_List_iterator(std::__detail::_List_node_base*) (93,621x)
      .           
      .                 // Must downcast from List_node_base to _List_node to get to value.
      .                 _GLIBCXX_NODISCARD
      .                 reference
      .                 operator*() const _GLIBCXX_NOEXCEPT
      .                 { return *static_cast<_Node*>(_M_node)->_M_valptr(); }
      .           
      .                 _GLIBCXX_NODISCARD
-- line 371 ----------------------------------------
-- line 400 ----------------------------------------
      .                 {
      .           	_Self __tmp = *this;
      .           	_M_node = _M_node->_M_prev;
      .           	return __tmp;
      .                 }
      .           
      .                 _GLIBCXX_NODISCARD
      .                 friend bool
264,232 ( 0.00%)        operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
528,464 ( 0.00%)        { return __x._M_node == __y._M_node; }
      .           
      .           #if __cpp_impl_three_way_comparison < 201907L
      .                 _GLIBCXX_NODISCARD
      .                 friend bool
      .                 operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
      .                 { return __x._M_node != __y._M_node; }
      .           #endif
      .           
-- line 417 ----------------------------------------
-- line 442 ----------------------------------------
      .           	  {
      .           	    __first = __first->_M_next;
      .           	    ++__n;
      .           	  }
      .           	return __n;
      .                 }
      .           #endif
      .           
      8 ( 0.00%)        struct _List_impl
      .                 : public _Node_alloc_type
      .                 {
      .           	__detail::_List_node_header _M_node;
      .           
      8 ( 0.00%)  	_List_impl() _GLIBCXX_NOEXCEPT_IF(
      .           	    is_nothrow_default_constructible<_Node_alloc_type>::value)
      3 ( 0.00%)  	: _Node_alloc_type()
     25 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__detail::_List_node_header::_List_node_header() (1x)
      3 ( 0.00%)  	{ }
      .           
      .           	_List_impl(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
      .           	: _Node_alloc_type(__a)
      .           	{ }
      .           
      .           #if __cplusplus >= 201103L
      .           	_List_impl(_List_impl&&) = default;
      .           
-- line 466 ----------------------------------------
-- line 476 ----------------------------------------
      .           
      .                 _List_impl _M_impl;
      .           
      .           #if _GLIBCXX_USE_CXX11_ABI
      .                 size_t _M_get_size() const { return _M_impl._M_node._M_size; }
      .           
      .                 void _M_set_size(size_t __n) { _M_impl._M_node._M_size = __n; }
      .           
396,448 ( 0.00%)        void _M_inc_size(size_t __n) { _M_impl._M_node._M_size += __n; }
      .           
391,248 ( 0.00%)        void _M_dec_size(size_t __n) { _M_impl._M_node._M_size -= __n; }
      .           
      .           # if !_GLIBCXX_INLINE_VERSION
      .                 size_t
      .                 _M_distance(const __detail::_List_node_base* __first,
      .           		  const __detail::_List_node_base* __last) const
      .                 { return _S_distance(__first, __last); }
      .           
      .                 // return the stored size
-- line 494 ----------------------------------------
-- line 509 ----------------------------------------
      .                 {
      .           	return _S_distance(_M_impl._M_node._M_next,
      .           			   std::__addressof(_M_impl._M_node));
      .                 }
      .           # endif
      .           #endif
      .           
      .                 typename _Node_alloc_traits::pointer
  1,600 ( 0.00%)        _M_get_node()
  3,600 ( 0.00%)        { return _Node_alloc_traits::allocate(_M_impl, 1); }
      .           
      .                 void
  2,000 ( 0.00%)        _M_put_node(typename _Node_alloc_traits::pointer __p) _GLIBCXX_NOEXCEPT
  5,600 ( 0.00%)        { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }
      .           
      .             public:
      .                 typedef _Alloc allocator_type;
      .           
      .                 _Node_alloc_type&
  2,400 ( 0.00%)        _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
  2,400 ( 0.00%)        { return _M_impl; }
      .           
      .                 const _Node_alloc_type&
      .                 _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
      .                 { return _M_impl; }
      .           
      .           #if __cplusplus >= 201103L
     10 ( 0.00%)        _List_base() = default;
     41 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_List_impl::_List_impl() (1x)
      .           #else
      .                 _List_base() { }
      .           #endif
      .           
      .                 _List_base(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
      .                 : _M_impl(__a)
      .                 { }
      .           
-- line 544 ----------------------------------------
-- line 566 ----------------------------------------
      .                 { }
      .           
      .                 void
      .                 _M_move_nodes(_List_base&& __x)
      .                 { _M_impl._M_node._M_move_nodes(std::move(__x._M_impl._M_node)); }
      .           #endif
      .           
      .                 // This is what actually destroys the list.
      4 ( 0.00%)        ~_List_base() _GLIBCXX_NOEXCEPT
      9 ( 0.00%)        { _M_clear(); }
 94,015 ( 0.00%)  => /usr/include/c++/14/bits/list.tcc:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_clear() (1x)
      9 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_List_impl::~_List_impl() (1x)
      .           
      .                 void
      .                 _M_clear() _GLIBCXX_NOEXCEPT;
      .           
      .                 void
      4 ( 0.00%)        _M_init() _GLIBCXX_NOEXCEPT
      6 ( 0.00%)        { this->_M_impl._M_node._M_init(); }
     15 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__detail::_List_node_header::_M_init() (1x)
      .               };
      .           
      .             /**
      .              *  @brief A standard container with linear time access to elements,
      .              *  and fixed time insertion/deletion at any point in the sequence.
      .              *
      .              *  @ingroup sequences
      .              *
-- line 590 ----------------------------------------
-- line 700 ----------------------------------------
      .           	    _M_put_node(__p);
      .           	    __throw_exception_again;
      .           	  }
      .           	return __p;
      .                 }
      .           #else
      .                 template<typename... _Args>
      .           	_Node*
  2,400 ( 0.00%)  	_M_create_node(_Args&&... __args)
      .           	{
  1,600 ( 0.00%)  	  auto __p = this->_M_get_node();
 45,611 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_get_node() (400x)
  1,600 ( 0.00%)  	  auto& __alloc = _M_get_Node_allocator();
  2,400 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_get_Node_allocator() (400x)
  2,400 ( 0.00%)  	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
  9,200 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_List_node<TextureCacheMapIter> > >::__allocated_ptr(std::allocator<std::_List_node<TextureCacheMapIter> >&, std::_List_node<TextureCacheMapIter>*) (400x)
  4,400 ( 0.00%)  	  _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
 10,000 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_node<TextureCacheMapIter>::_M_valptr() (400x)
  2,400 ( 0.00%)  => /usr/include/c++/14/bits/move.h:TextureCacheMapIter&& std::forward<TextureCacheMapIter>(std::remove_reference<TextureCacheMapIter>::type&) (400x)
      .           					std::forward<_Args>(__args)...);
  1,600 ( 0.00%)  	  __guard = nullptr;
  3,600 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_List_node<TextureCacheMapIter> > >::operator=(decltype(nullptr)) (400x)
    800 ( 0.00%)  	  return __p;
  2,400 ( 0.00%)  	}
  4,400 ( 0.00%)  => /usr/include/c++/14/bits/allocated_ptr.h:std::__allocated_ptr<std::allocator<std::_List_node<TextureCacheMapIter> > >::~__allocated_ptr() (400x)
      .           #endif
      .           
      .           #if _GLIBCXX_USE_CXX11_ABI
      .                 static size_t
      .                 _S_distance(const_iterator __first, const_iterator __last)
      .                 { return std::distance(__first, __last); }
      .           
      .                 // return the stored size
-- line 725 ----------------------------------------
-- line 741 ----------------------------------------
      .               public:
      .                 // [23.2.2.1] construct/copy/destroy
      .                 // (assign() and get_allocator() are also listed in this section)
      .           
      .                 /**
      .                  *  @brief  Creates a %list with no elements.
      .                  */
      .           #if __cplusplus >= 201103L
     10 ( 0.00%)        list() = default;
     51 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_List_base() (1x)
      .           #else
      .                 list() { }
      .           #endif
      .           
      .                 /**
      .                  *  @brief  Creates a %list with no elements.
      .                  *  @param  __a  An allocator object.
      .                  */
-- line 757 ----------------------------------------
-- line 895 ----------------------------------------
      .           #if __cplusplus >= 201103L
      .                 /**
      .                  *  No explicit dtor needed as the _Base dtor takes care of
      .                  *  things.  The _Base dtor only erases the elements, and note
      .                  *  that if the elements themselves are pointers, the pointed-to
      .                  *  memory is not touched in any way.  Managing the pointer is
      .                  *  the user's responsibility.
      .                  */
     10 ( 0.00%)        ~list() = default;
 94,037 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::~_List_base() (1x)
      .           #endif
      .           
      .                 /**
      .                  *  @brief  %List assignment operator.
      .                  *  @param  __x  A %list of identical element and allocator types.
      .                  *
      .                  *  All the elements of @a __x are copied.
      .                  *
-- line 911 ----------------------------------------
-- line 1034 ----------------------------------------
      .           
      .                 /**
      .                  *  Returns a read/write iterator that points one past the last
      .                  *  element in the %list.  Iteration is done in ordinary element
      .                  *  order.
      .                  */
      .                 _GLIBCXX_NODISCARD
      .                 iterator
133,716 ( 0.00%)        end() _GLIBCXX_NOEXCEPT
267,432 ( 0.00%)        { return iterator(&this->_M_impl._M_node); }
334,290 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_iterator<TextureCacheMapIter>::_List_iterator(std::__detail::_List_node_base*) (33,429x)
      .           
      .                 /**
      .                  *  Returns a read-only (constant) iterator that points one past
      .                  *  the last element in the %list.  Iteration is done in ordinary
      .                  *  element order.
      .                  */
      .                 _GLIBCXX_NODISCARD
      .                 const_iterator
-- line 1051 ----------------------------------------
-- line 1394 ----------------------------------------
      .                  *  @return  An iterator that points to the inserted data.
      .                  *
      .                  *  This function will insert a copy of the given rvalue before
      .                  *  the specified location.  Due to the nature of a %list this
      .                  *  operation can be done in constant time, and does not
      .                  *  invalidate iterators and references.
      .           	*/
      .                 iterator
  2,400 ( 0.00%)        insert(const_iterator __position, value_type&& __x)
  4,400 ( 0.00%)        { return emplace(__position, std::move(__x)); }
154,638 ( 0.00%)  => /usr/include/c++/14/bits/list.tcc:std::_List_iterator<TextureCacheMapIter> std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::emplace<TextureCacheMapIter>(std::_List_const_iterator<TextureCacheMapIter>, TextureCacheMapIter&&) (400x)
  2,400 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<TextureCacheMapIter&>::type&& std::move<TextureCacheMapIter&>(TextureCacheMapIter&) (400x)
      .           
      .                 /**
      .                  *  @brief  Inserts the contents of an initializer_list into %list
      .                  *          before specified const_iterator.
      .                  *  @param  __p  A const_iterator into the %list.
      .                  *  @param  __l  An initializer_list of value_type.
      .                  *  @return  An iterator pointing to the first element inserted
      .                  *           (or __position).
-- line 1411 ----------------------------------------
-- line 1584 ----------------------------------------
      .           
      .                 /**
      .                  *  Erases all the elements.  Note that this function only erases
      .                  *  the elements, and that if the elements themselves are
      .                  *  pointers, the pointed-to memory is not touched in any way.
      .                  *  Managing the pointer is the user's responsibility.
      .                  */
      .                 void
      4 ( 0.00%)        clear() _GLIBCXX_NOEXCEPT
      .                 {
      3 ( 0.00%)  	_Base::_M_clear();
     15 ( 0.00%)  => /usr/include/c++/14/bits/list.tcc:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_clear() (1x)
      3 ( 0.00%)  	_Base::_M_init();
     25 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_init() (1x)
      3 ( 0.00%)        }
      .           
      .                 // [23.2.2.4] list operations
      .                 /**
      .                  *  @brief  Insert contents of another %list.
      .                  *  @param  __position  Iterator referencing the element to insert before.
      .                  *  @param  __x  Source list.
      .                  *
      .                  *  The elements of @a __x are inserted in constant time in front of
-- line 1604 ----------------------------------------
-- line 1639 ----------------------------------------
      .                  *                      insert before.
      .                  *  @param  __x  Source list.
      .                  *  @param  __i  Const_iterator referencing the element to move.
      .                  *
      .                  *  Removes the element in list @a __x referenced by @a __i and
      .                  *  inserts it into the current list before @a __position.
      .                  */
      .                 void
264,232 ( 0.00%)        splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
      .           #else
      .                 /**
      .                  *  @brief  Insert element from another %list.
      .                  *  @param  __position  Iterator referencing the element to insert before.
      .                  *  @param  __x  Source list.
      .                  *  @param  __i  Iterator referencing the element to move.
      .                  *
      .                  *  Removes the element in list @a __x referenced by @a __i and
      .                  *  inserts it into the current list before @a __position.
      .                  */
      .                 void
      .                 splice(iterator __position, list& __x, iterator __i)
      .           #endif
      .                 {
132,116 ( 0.00%)  	iterator __j = __i._M_const_cast();
759,667 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_const_iterator<TextureCacheMapIter>::_M_const_cast() const (33,029x)
 99,087 ( 0.00%)  	++__j;
363,319 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_iterator<TextureCacheMapIter>::operator++() (33,029x)
729,571 ( 0.00%)  	if (__position == __i || __position == __j)
792,696 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::operator==(std::_List_const_iterator<TextureCacheMapIter> const&, std::_List_const_iterator<TextureCacheMapIter> const&) (66,058x)
363,319 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_const_iterator<TextureCacheMapIter>::_List_const_iterator(std::_List_iterator<TextureCacheMapIter> const&) (33,029x)
  2,933 ( 0.00%)  	  return;
      .           
210,672 ( 0.00%)  	if (this != std::__addressof(__x))
180,576 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >* std::__addressof<std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> > >(std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&) (30,096x)
      .           	  _M_check_equal_allocators(__x);
      .           
421,344 ( 0.00%)  	this->_M_transfer(__position._M_const_cast(),
1,384,416 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_const_iterator<TextureCacheMapIter>::_M_const_cast() const (60,192x)
994,668 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_transfer(std::_List_iterator<TextureCacheMapIter>, std::_List_iterator<TextureCacheMapIter>, std::_List_iterator<TextureCacheMapIter>) (30,096x)
      .           			  __i._M_const_cast(), __j);
      .           
120,384 ( 0.00%)  	this->_M_inc_size(1);
391,248 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_inc_size(unsigned long) (30,096x)
150,480 ( 0.00%)  	__x._M_dec_size(1);
391,248 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::_List_base<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::_M_dec_size(unsigned long) (30,096x)
 99,087 ( 0.00%)        }
      .           
      .           #if __cplusplus >= 201103L
      .                 /**
      .                  *  @brief  Insert element from another %list.
      .                  *  @param  __position  Const_iterator referencing the element to
      .                  *                      insert before.
      .                  *  @param  __x  Source list.
      .                  *  @param  __i  Const_iterator referencing the element to move.
      .                  *
      .                  *  Removes the element in list @a __x referenced by @a __i and
      .                  *  inserts it into the current list before @a __position.
      .                  */
      .                 void
231,203 ( 0.00%)        splice(const_iterator __position, list& __x, const_iterator __i) noexcept
462,406 ( 0.00%)        { splice(__position, std::move(__x), __i); }
7,851,063 ( 0.01%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::splice(std::_List_const_iterator<TextureCacheMapIter>, std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&&, std::_List_const_iterator<TextureCacheMapIter>) (33,029x)
198,174 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&>::type&& std::move<std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&>(std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&) (33,029x)
      .           #endif
      .           
      .           #if __cplusplus >= 201103L
      .                 /**
      .                  *  @brief  Insert range from another %list.
      .                  *  @param  __position  Const_iterator referencing the element to
      .                  *                      insert before.
      .                  *  @param  __x  Source list.
-- line 1698 ----------------------------------------
-- line 1979 ----------------------------------------
      .                 // Called by assign(n,t), and the range assign when it turns out
      .                 // to be the same thing.
      .                 void
      .                 _M_fill_assign(size_type __n, const value_type& __val);
      .           
      .           
      .                 // Moves the elements from [first,last) before position.
      .                 void
210,672 ( 0.00%)        _M_transfer(iterator __position, iterator __first, iterator __last)
300,964 ( 0.00%)        { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
481,536 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++98/../../../../../libstdc++-v3/src/c++98/list.cc:std::__detail::_List_node_base::_M_transfer(std::__detail::_List_node_base*, std::__detail::_List_node_base*) (30,096x)
  1,496 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      .           
      .                 // Inserts new element at position given and with value given.
      .           #if __cplusplus < 201103L
      .                 void
      .                 _M_insert(iterator __position, const value_type& __x)
      .                 {
      .           	_Node* __tmp = _M_create_node(__x);
      .           	__tmp->_M_hook(__position._M_node);
-- line 1996 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_cc.h
--------------------------------------------------------------------------------
Ir                 

-- line 57 ----------------------------------------
        .               TEXEL1_BLEND,
        .               MAX
        .           };
        .           
        .           #define SHADER_OPT(opt) ((uint64_t)(1 << static_cast<int>(ShaderOpts::opt)))
        .           #endif
        .           
        .           struct ColorCombinerKey {
2,711,752 ( 0.00%)      uint64_t combine_mode;
2,433,152 ( 0.00%)      uint64_t options;
        .           
        .           #ifdef __cplusplus
8,748,049 ( 0.01%)      auto operator<=>(const ColorCombinerKey&) const = default;
1,351,664 ( 0.00%)  => /usr/include/c++/14/compare:std::operator==(std::strong_ordering, std::__cmp_cat::__unspec) (168,958x)
        .           #endif
        .           };
        .           
        .           #define SHADER_MAX_TEXTURES 6
        .           #define SHADER_FIRST_TEXTURE 0
        .           #define SHADER_FIRST_MASK_TEXTURE 2
        .           #define SHADER_FIRST_REPLACEMENT_TEXTURE 4
        .           
-- line 77 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_pc.cpp
--------------------------------------------------------------------------------
Ir                     

-- line 37 ----------------------------------------
            .           #include "resource/ResourceManager.h"
            .           #include "utils/Utils.h"
            .           #include "Context.h"
            .           #include "libultraship/bridge.h"
            .           
            .           #include <spdlog/fmt/fmt.h>
            .           
            .           uintptr_t gfxFramebuffer;
            2 ( 0.00%)  std::stack<std::string> currentDir;
          881 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::stack<std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, void>() (1x)
            .           
            .           using namespace std;
            .           
            .           #define SEG_ADDR(seg, addr) (addr | (seg << 24) | 1)
            .           #define SUPPORT_CHECK(x) assert(x)
            .           
            .           // SCALE_M_N: upscale/downscale M-bit integer to N-bit
            .           #define SCALE_5_8(VAL_) (((VAL_) * 0xFF) / 0x1F)
-- line 53 ----------------------------------------
-- line 64 ----------------------------------------
            .           // Ratios for current window dimensions or active framebuffer scaled size
            .           #define RATIO_X \
            .               ((fbActive ? active_fb->second.applied_width : gfx_current_dimensions.width) / (2.0f * HALF_SCREEN_WIDTH))
            .           #define RATIO_Y \
            .               ((fbActive ? active_fb->second.applied_height : gfx_current_dimensions.height) / (2.0f * HALF_SCREEN_HEIGHT))
            .           
            .           #define TEXTURE_CACHE_MAX_SIZE 500
            .           
           36 ( 0.00%)  static struct {
      126,328 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::~unordered_map() (1x)
       94,047 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::~list() (1x)
           98 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<unsigned int, std::allocator<unsigned int> >::~vector() (1x)
            .               TextureCacheMap map;
            .               list<TextureCacheMapIter> lru;
            .               vector<uint32_t> free_texture_ids;
            2 ( 0.00%)  } gfx_texture_cache;
          247 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:._anon_484::._anon_484() (1x)
            .           
            .           struct ColorCombiner {
            .               uint64_t shader_id0;
            .               uint32_t shader_id1;
            .               bool used_textures[2];
            .               struct ShaderProgram* prg[16];
            .               uint8_t shader_input_mapping[2][7];
            .           };
            .           
            2 ( 0.00%)  static map<ColorCombinerKey, struct ColorCombiner> color_combiner_pool;
           74 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::map() (1x)
            3 ( 0.00%)  static map<ColorCombinerKey, struct ColorCombiner>::iterator prev_combiner = color_combiner_pool.end();
           32 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::end() (1x)
            .           
            .           static uint8_t* tex_upload_buffer = nullptr;
            .           
            .           RSP g_rsp;
            2 ( 0.00%)  RDP g_rdp;
          213 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RDP::RDP() (1x)
            .           static struct RenderingState {
            .               uint8_t depth_test_and_mask; // 1: depth test, 2: depth mask
            .               bool decal_mode;
            .               bool alpha_blend;
            .               struct XYWidthHeight viewport, scissor;
            .               struct ShaderProgram* shader_program;
            .               TextureCacheNode* textures[SHADER_MAX_TEXTURES];
            .           } rendering_state;
-- line 100 ----------------------------------------
-- line 131 ----------------------------------------
            .           struct FBInfo {
            .               uint32_t orig_width, orig_height;       // Original shape
            .               uint32_t applied_width, applied_height; // Up-scaled for the viewport
            .               uint32_t native_width, native_height;   // Max "native" size of the screen, used for up-scaling
            .               bool resize;                            // Scale to match the viewport
            .           };
            .           
            .           static bool fbActive = 0;
            2 ( 0.00%)  static map<int, FBInfo>::iterator active_fb;
            8 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<int const, FBInfo> >::_Rb_tree_iterator() (1x)
            2 ( 0.00%)  static map<int, FBInfo> framebuffers;
           74 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<int, FBInfo, std::less<int>, std::allocator<std::pair<int const, FBInfo> > >::map() (1x)
            .           
            2 ( 0.00%)  static set<pair<float, float>> get_pixel_depth_pending;
           74 ( 0.00%)  => /usr/include/c++/14/bits/stl_set.h:std::set<std::pair<float, float>, std::less<std::pair<float, float> >, std::allocator<std::pair<float, float> > >::set() (1x)
            2 ( 0.00%)  static unordered_map<pair<float, float>, uint16_t, hash_pair_ff> get_pixel_depth_cached;
          120 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<std::pair<float, float>, unsigned short, hash_pair_ff, std::equal_to<std::pair<float, float> >, std::allocator<std::pair<std::pair<float, float> const, unsigned short> > >::unordered_map() (1x)
            .           
            .           struct MaskedTextureEntry {
            .               uint8_t* mask;
            .               uint8_t* replacementData;
            .           };
            .           
            2 ( 0.00%)  static map<string, MaskedTextureEntry> masked_textures;
           74 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MaskedTextureEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::map() (1x)
            .           
            .           static UcodeHandlers ucode_handler_index = ucode_f3dex2;
            .           
            .           const static std::unordered_map<Attribute, std::any> f3dex2AttrHandler = {
            3 ( 0.00%)      { MTX_PROJECTION, F3DEX2_G_MTX_PROJECTION }, { MTX_LOAD, F3DEX2_G_MTX_LOAD },     { MTX_PUSH, F3DEX2_G_MTX_PUSH },
            3 ( 0.00%)      { MTX_NOPUSH, F3DEX_G_MTX_NOPUSH },          { CULL_FRONT, F3DEX2_G_CULL_FRONT }, { CULL_BACK, F3DEX2_G_CULL_BACK },
            1 ( 0.00%)      { CULL_BOTH, F3DEX2_G_CULL_BOTH },
           75 ( 0.00%)  };
       10,516 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > >::unordered_map(std::initializer_list<std::pair<Attribute const, std::any> >, unsigned long, std::hash<Attribute> const&, std::equal_to<Attribute> const&, std::allocator<std::pair<Attribute const, std::any> > const&) (1x)
          504 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<Attribute const, std::any>::~pair() (7x)
            .           
            1 ( 0.00%)  const static std::unordered_map<Attribute, std::any> f3dexAttrHandler = { { MTX_PROJECTION, F3DEX_G_MTX_PROJECTION },
            1 ( 0.00%)                                                                            { MTX_LOAD, F3DEX_G_MTX_LOAD },
            1 ( 0.00%)                                                                            { MTX_PUSH, F3DEX_G_MTX_PUSH },
            1 ( 0.00%)                                                                            { MTX_NOPUSH, F3DEX_G_MTX_NOPUSH },
            1 ( 0.00%)                                                                            { CULL_FRONT, F3DEX_G_CULL_FRONT },
            1 ( 0.00%)                                                                            { CULL_BACK, F3DEX_G_CULL_BACK },
           74 ( 0.00%)                                                                            { CULL_BOTH, F3DEX_G_CULL_BOTH } };
       10,694 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > >::unordered_map(std::initializer_list<std::pair<Attribute const, std::any> >, unsigned long, std::hash<Attribute> const&, std::equal_to<Attribute> const&, std::allocator<std::pair<Attribute const, std::any> > const&) (1x)
          504 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<Attribute const, std::any>::~pair() (7x)
            .           
            .           static constexpr std::array ucode_attr_handlers = {
            .               &f3dexAttrHandler,
            .               &f3dexAttrHandler,
            .               &f3dex2AttrHandler,
            .               &f3dex2AttrHandler,
            .           };
            .           
   22,953,624 ( 0.02%)  template <typename T> static constexpr T get_attr(Attribute attr) {
   40,168,842 ( 0.03%)      const auto ucode_map = ucode_attr_handlers[ucode_handler_index];
    1,590,720 ( 0.00%)  => /usr/include/c++/14/array:std::array<std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > > const*, 4ul>::operator[](unsigned long) const (159,072x)
   40,168,842 ( 0.03%)      assert(ucode_map->contains(attr) && "Attribute not found in the current ucode handler");
   66,492,096 ( 0.06%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > >::contains(Attribute const&) const (159,072x)
   40,168,842 ( 0.03%)      return std::any_cast<T>(ucode_map->at(attr));
   65,219,520 ( 0.05%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<Attribute, std::any, std::hash<Attribute>, std::equal_to<Attribute>, std::allocator<std::pair<Attribute const, std::any> > >::at(Attribute const&) const (159,072x)
    8,589,888 ( 0.01%)  => /usr/include/c++/14/any:signed char std::any_cast<signed char>(std::any const&) (159,072x)
   11,476,812 ( 0.01%)  }
            .           
            .           static std::string GetPathWithoutFileName(char* filePath) {
            .               size_t len = strlen(filePath);
            .           
            .               for (size_t i = len - 1; i >= 0; i--) {
            .                   if (filePath[i] == '/' || filePath[i] == '\\') {
            .                       return std::string(filePath).substr(0, i);
            .                   }
            .               }
            .           
            .               return filePath;
            .           }
            .           
      172,054 ( 0.00%)  static void gfx_flush(void) {
      258,081 ( 0.00%)      if (buf_vbo_len > 0) {
      334,782 ( 0.00%)          gfx_rapi->draw_triangles(buf_vbo, buf_vbo_len, buf_vbo_num_tris);
  446,622,851 ( 0.37%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_draw_triangles(float*, unsigned long, unsigned long) (47,826x)
       47,826 ( 0.00%)          buf_vbo_len = 0;
       47,826 ( 0.00%)          buf_vbo_num_tris = 0;
            .               }
      258,081 ( 0.00%)  }
            .           
          110 ( 0.00%)  static struct ShaderProgram* gfx_lookup_or_create_shader_program(uint64_t shader_id0, uint32_t shader_id1) {
          176 ( 0.00%)      struct ShaderProgram* prg = gfx_rapi->lookup_shader(shader_id0, shader_id1);
       20,529 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_lookup_shader(unsigned long, unsigned int) (22x)
           44 ( 0.00%)      if (prg == NULL) {
           90 ( 0.00%)          gfx_rapi->unload_shader(rendering_state.shader_program);
        5,346 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_unload_shader(ShaderProgram*) (18x)
          144 ( 0.00%)          prg = gfx_rapi->create_and_load_new_shader(shader_id0, shader_id1);
   17,518,715 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_create_and_load_new_shader(unsigned long, unsigned int) (18x)
           36 ( 0.00%)          rendering_state.shader_program = prg;
            .               }
           22 ( 0.00%)      return prg;
           44 ( 0.00%)  }
            .           
            .           static const char* ccmux_to_string(uint32_t ccmux) {
            .               static const char* const tbl[] = {
            .                   "G_CCMUX_COMBINED",
            .                   "G_CCMUX_TEXEL0",
            .                   "G_CCMUX_TEXEL1",
            .                   "G_CCMUX_PRIMITIVE",
            .                   "G_CCMUX_SHADE",
-- line 217 ----------------------------------------
-- line 244 ----------------------------------------
            .                   "G_ACMUX_SHADE",
            .                   "G_ACMUX_ENVIRONMENT",
            .                   "G_ACMUX_1 or G_ACMUX_PRIM_LOD_FRAC",
            .                   "G_ACMUX_0",
            .               };
            .               return tbl[acmux];
            .           }
            .           
          100 ( 0.00%)  static void gfx_generate_cc(struct ColorCombiner* comb, const ColorCombinerKey& key) {
          120 ( 0.00%)      bool is_2cyc = (key.options & SHADER_OPT(_2CYC)) != 0;
            .           
            .               uint8_t c[2][2][4];
           20 ( 0.00%)      uint64_t shader_id0 = 0;
           60 ( 0.00%)      uint32_t shader_id1 = key.options;
           40 ( 0.00%)      uint8_t shader_input_mapping[2][7] = { { 0 } };
           40 ( 0.00%)      bool used_textures[2] = { false, false };
          260 ( 0.00%)      for (uint32_t i = 0; i < 2 && (i == 0 || is_2cyc); i++) {
          140 ( 0.00%)          uint32_t rgb_a = (key.combine_mode >> (i * 28)) & 0xf;
          160 ( 0.00%)          uint32_t rgb_b = (key.combine_mode >> (i * 28 + 4)) & 0xf;
          160 ( 0.00%)          uint32_t rgb_c = (key.combine_mode >> (i * 28 + 8)) & 0x1f;
          160 ( 0.00%)          uint32_t rgb_d = (key.combine_mode >> (i * 28 + 13)) & 7;
          160 ( 0.00%)          uint32_t alpha_a = (key.combine_mode >> (i * 28 + 16)) & 7;
          160 ( 0.00%)          uint32_t alpha_b = (key.combine_mode >> (i * 28 + 16 + 3)) & 7;
          160 ( 0.00%)          uint32_t alpha_c = (key.combine_mode >> (i * 28 + 16 + 6)) & 7;
          160 ( 0.00%)          uint32_t alpha_d = (key.combine_mode >> (i * 28 + 16 + 9)) & 7;
            .           
           40 ( 0.00%)          if (rgb_a >= 8) {
            9 ( 0.00%)              rgb_a = G_CCMUX_0;
            .                   }
           40 ( 0.00%)          if (rgb_b >= 8) {
           14 ( 0.00%)              rgb_b = G_CCMUX_0;
            .                   }
           40 ( 0.00%)          if (rgb_c >= 16) {
            9 ( 0.00%)              rgb_c = G_CCMUX_0;
            .                   }
           40 ( 0.00%)          if (rgb_d == 7) {
            5 ( 0.00%)              rgb_d = G_CCMUX_0;
            .                   }
            .           
           76 ( 0.00%)          if (rgb_a == rgb_b || rgb_c == G_CCMUX_0) {
            .                       // Normalize
           12 ( 0.00%)              rgb_a = G_CCMUX_0;
           12 ( 0.00%)              rgb_b = G_CCMUX_0;
           12 ( 0.00%)              rgb_c = G_CCMUX_0;
            .                   }
           70 ( 0.00%)          if (alpha_a == alpha_b || alpha_c == G_ACMUX_0) {
            .                       // Normalize
           15 ( 0.00%)              alpha_a = G_ACMUX_0;
           15 ( 0.00%)              alpha_b = G_ACMUX_0;
           15 ( 0.00%)              alpha_c = G_ACMUX_0;
            .                   }
           40 ( 0.00%)          if (i == 1) {
            .                       if (rgb_a != G_CCMUX_COMBINED && rgb_b != G_CCMUX_COMBINED && rgb_c != G_CCMUX_COMBINED &&
            .                           rgb_d != G_CCMUX_COMBINED) {
            .                           // First cycle RGB not used, so clear it away
            .                           c[0][0][0] = c[0][0][1] = c[0][0][2] = c[0][0][3] = G_CCMUX_0;
            .                       }
            .                       if (rgb_c != G_CCMUX_COMBINED_ALPHA && alpha_a != G_ACMUX_COMBINED && alpha_b != G_ACMUX_COMBINED &&
            .                           alpha_d != G_ACMUX_COMBINED) {
            .                           // First cycle ALPHA not used, so clear it away
            .                           c[0][1][0] = c[0][1][1] = c[0][1][2] = c[0][1][3] = G_ACMUX_0;
            .                       }
            .                   }
            .           
           80 ( 0.00%)          c[i][0][0] = rgb_a;
           80 ( 0.00%)          c[i][0][1] = rgb_b;
           80 ( 0.00%)          c[i][0][2] = rgb_c;
           80 ( 0.00%)          c[i][0][3] = rgb_d;
           80 ( 0.00%)          c[i][1][0] = alpha_a;
           80 ( 0.00%)          c[i][1][1] = alpha_b;
           80 ( 0.00%)          c[i][1][2] = alpha_c;
           80 ( 0.00%)          c[i][1][3] = alpha_d;
            .               }
           80 ( 0.00%)      if (!is_2cyc) {
          200 ( 0.00%)          for (uint32_t i = 0; i < 2; i++) {
          640 ( 0.00%)              for (uint32_t k = 0; k < 4; k++) {
        1,840 ( 0.00%)                  c[1][i][k] = i == 0 ? G_CCMUX_0 : G_ACMUX_0;
            .                       }
            .                   }
            .               }
            .               {
           40 ( 0.00%)          uint8_t input_number[32] = { 0 };
           20 ( 0.00%)          uint32_t next_input_number = SHADER_INPUT_1;
          260 ( 0.00%)          for (uint32_t i = 0; i < 2 && (i == 0 || is_2cyc); i++) {
          320 ( 0.00%)              for (uint32_t j = 0; j < 4; j++) {
           80 ( 0.00%)                  uint32_t val = 0;
        1,120 ( 0.00%)                  switch (c[i][0][j]) {
            .                               case G_CCMUX_0:
           46 ( 0.00%)                          val = SHADER_0;
           46 ( 0.00%)                          break;
            .                               case G_CCMUX_1:
            1 ( 0.00%)                          val = SHADER_1;
            1 ( 0.00%)                          break;
            .                               case G_CCMUX_TEXEL0:
           12 ( 0.00%)                          val = SHADER_TEXEL0;
            .                                   // Set the opposite texture when reading from the second cycle color options
           24 ( 0.00%)                          if (i == 0) {
           12 ( 0.00%)                              used_textures[0] = true;
            .                                   } else {
            .                                       used_textures[1] = true;
            .                                   }
           12 ( 0.00%)                          break;
            .                               case G_CCMUX_TEXEL1:
            .                                   val = SHADER_TEXEL1;
            .                                   if (i == 0) {
            .                                       used_textures[1] = true;
            .                                   } else {
            .                                       used_textures[0] = true;
            .                                   }
            .                                   break;
            .                               case G_CCMUX_TEXEL0_ALPHA:
            1 ( 0.00%)                          val = SHADER_TEXEL0A;
            2 ( 0.00%)                          if (i == 0) {
            1 ( 0.00%)                              used_textures[0] = true;
            .                                   } else {
            .                                       used_textures[1] = true;
            .                                   }
            1 ( 0.00%)                          break;
            .                               case G_CCMUX_TEXEL1_ALPHA:
            .                                   val = SHADER_TEXEL1A;
            .                                   if (i == 0) {
            .                                       used_textures[1] = true;
            .                                   } else {
            .                                       used_textures[0] = true;
            .                                   }
            .                                   break;
-- line 369 ----------------------------------------
-- line 372 ----------------------------------------
            .                                   break;
            .                               case G_CCMUX_PRIMITIVE:
            .                               case G_CCMUX_PRIMITIVE_ALPHA:
            .                               case G_CCMUX_PRIM_LOD_FRAC:
            .                               case G_CCMUX_SHADE:
            .                               case G_CCMUX_ENVIRONMENT:
            .                               case G_CCMUX_ENV_ALPHA:
            .                               case G_CCMUX_LOD_FRACTION:
          260 ( 0.00%)                          if (input_number[c[i][0][j]] == 0) {
          216 ( 0.00%)                              shader_input_mapping[0][next_input_number - 1] = c[i][0][j];
          270 ( 0.00%)                              input_number[c[i][0][j]] = next_input_number++;
            .                                   }
          260 ( 0.00%)                          val = input_number[c[i][0][j]];
           20 ( 0.00%)                          break;
            .                               case G_CCMUX_COMBINED:
            .                                   val = SHADER_COMBINED;
            .                                   break;
            .                               default:
            .                                   fprintf(stderr, "Unsupported ccmux: %d\n", c[i][0][j]);
            .                                   break;
            .                           }
          640 ( 0.00%)                  shader_id0 |= (uint64_t)val << (i * 32 + j * 4);
            .                       }
            .                   }
            .               }
            .               {
           40 ( 0.00%)          uint8_t input_number[16] = { 0 };
           20 ( 0.00%)          uint32_t next_input_number = SHADER_INPUT_1;
          200 ( 0.00%)          for (uint32_t i = 0; i < 2; i++) {
          640 ( 0.00%)              for (uint32_t j = 0; j < 4; j++) {
          160 ( 0.00%)                  uint32_t val = 0;
        2,240 ( 0.00%)                  switch (c[i][1][j]) {
            .                               case G_ACMUX_0:
          135 ( 0.00%)                          val = SHADER_0;
          135 ( 0.00%)                          break;
            .                               case G_ACMUX_TEXEL0:
           12 ( 0.00%)                          val = SHADER_TEXEL0;
            .                                   // Set the opposite texture when reading from the second cycle color options
           24 ( 0.00%)                          if (i == 0) {
           12 ( 0.00%)                              used_textures[0] = true;
            .                                   } else {
            .                                       used_textures[1] = true;
            .                                   }
           12 ( 0.00%)                          break;
            .                               case G_ACMUX_TEXEL1:
            .                                   val = SHADER_TEXEL1;
            .                                   if (i == 0) {
            .                                       used_textures[1] = true;
            .                                   } else {
            .                                       used_textures[0] = true;
            .                                   }
            .                                   break;
            .                               case G_ACMUX_LOD_FRACTION:
            .                                   // case G_ACMUX_COMBINED: same numerical value
           12 ( 0.00%)                          if (j != 2) {
            6 ( 0.00%)                              val = SHADER_COMBINED;
            6 ( 0.00%)                              break;
            .                                   }
            .                                   c[i][1][j] = G_CCMUX_LOD_FRACTION;
            .                                   [[fallthrough]]; // for G_ACMUX_LOD_FRACTION
            .                               case G_ACMUX_1:
            .                                   // case G_ACMUX_PRIM_LOD_FRAC: same numerical value
            .                                   if (j != 2) {
            .                                       val = SHADER_1;
            .                                       break;
            .                                   }
            .                                   [[fallthrough]]; // for G_ACMUX_PRIM_LOD_FRAC
            .                               case G_ACMUX_PRIMITIVE:
            .                               case G_ACMUX_SHADE:
            .                               case G_ACMUX_ENVIRONMENT:
           91 ( 0.00%)                          if (input_number[c[i][1][j]] == 0) {
           84 ( 0.00%)                              shader_input_mapping[1][next_input_number - 1] = c[i][1][j];
          105 ( 0.00%)                              input_number[c[i][1][j]] = next_input_number++;
            .                                   }
           91 ( 0.00%)                          val = input_number[c[i][1][j]];
            7 ( 0.00%)                          break;
            .                           }
        1,440 ( 0.00%)                  shader_id0 |= (uint64_t)val << (i * 32 + 16 + j * 4);
            .                       }
            .                   }
            .               }
           60 ( 0.00%)      comb->shader_id0 = shader_id0;
           60 ( 0.00%)      comb->shader_id1 = shader_id1;
           60 ( 0.00%)      comb->used_textures[0] = used_textures[0];
           60 ( 0.00%)      comb->used_textures[1] = used_textures[1];
            .               // comb->prg = gfx_lookup_or_create_shader_program(shader_id0, shader_id1);
          120 ( 0.00%)      memcpy(comb->shader_input_mapping, shader_input_mapping, sizeof(shader_input_mapping));
           60 ( 0.00%)  }
            .           
    2,257,852 ( 0.00%)  static struct ColorCombiner* gfx_lookup_or_create_color_combiner(const ColorCombinerKey& key) {
   12,961,032 ( 0.01%)      if (prev_combiner != color_combiner_pool.end() && prev_combiner->first == key) {
   19,756,170 ( 0.02%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator->() const (564,462x)
   18,062,816 ( 0.01%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::end() (564,463x)
   10,676,449 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_cc.h:ColorCombinerKey::operator==(ColorCombinerKey const&) const (564,462x)
    6,773,556 ( 0.01%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&, std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&) (564,463x)
    2,171,420 ( 0.00%)          return &prev_combiner->second;
   18,999,925 ( 0.02%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator->() const (542,855x)
            .               }
            .           
      108,040 ( 0.00%)      prev_combiner = color_combiner_pool.find(key);
   18,145,293 ( 0.02%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::find(ColorCombinerKey const&) (21,608x)
      216,080 ( 0.00%)      if (prev_combiner != color_combiner_pool.end()) {
      691,456 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::end() (21,608x)
      259,296 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&, std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&) (21,608x)
       86,352 ( 0.00%)          return &prev_combiner->second;
      755,580 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator->() const (21,588x)
            .               }
           20 ( 0.00%)      gfx_flush();
      773,489 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (20x)
          400 ( 0.00%)      prev_combiner = color_combiner_pool.insert(make_pair(key, ColorCombiner())).first;
       36,751 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::enable_if<std::is_constructible<std::pair<ColorCombinerKey const, ColorCombiner>, std::pair<ColorCombinerKey, ColorCombiner> >::value, std::pair<std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >, bool> >::type std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::insert<std::pair<ColorCombinerKey, ColorCombiner> >(std::pair<ColorCombinerKey, ColorCombiner>&&) (20x)
        1,580 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__strip_reference_wrapper<std::decay<ColorCombinerKey const&>::type>::__type, std::__strip_reference_wrapper<std::decay<ColorCombiner>::type>::__type> std::make_pair<ColorCombinerKey const&, ColorCombiner>(ColorCombinerKey const&, ColorCombiner&&) (20x)
          140 ( 0.00%)      gfx_generate_cc(&prev_combiner->second, key);
          700 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator->() const (20x)
       15,321 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_generate_cc(ColorCombiner*, ColorCombinerKey const&) (20x)
           60 ( 0.00%)      return &prev_combiner->second;
          700 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator->() const (20x)
    1,128,926 ( 0.00%)  }
            .           
            3 ( 0.00%)  void gfx_texture_cache_clear() {
           18 ( 0.00%)      for (const auto& entry : gfx_texture_cache.map) {
           54 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::begin() (1x)
           43 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::end() (1x)
           12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<TextureCacheKey const, TextureCacheValue>, false> const&, std::__detail::_Node_iterator_base<std::pair<TextureCacheKey const, TextureCacheValue>, false> const&) (1x)
            .                   gfx_texture_cache.free_texture_ids.push_back(entry.second.texture_id);
            .               }
            2 ( 0.00%)      gfx_texture_cache.map.clear();
           70 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::clear() (1x)
            2 ( 0.00%)      gfx_texture_cache.lru.clear();
           53 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::clear() (1x)
            3 ( 0.00%)  }
            .           
      200,574 ( 0.00%)  static bool gfx_texture_cache_lookup(int i, const TextureCacheKey& key) {
      167,145 ( 0.00%)      TextureCacheMap::iterator it = gfx_texture_cache.map.find(key);
   16,146,181 ( 0.01%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::find(TextureCacheKey const&) (33,429x)
      234,003 ( 0.00%)      TextureCacheNode** n = &rendering_state.textures[i];
            .           
      367,719 ( 0.00%)      if (it != gfx_texture_cache.map.end()) {
    1,437,447 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::end() (33,429x)
      401,148 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<TextureCacheKey const, TextureCacheValue>, false> const&, std::__detail::_Node_iterator_base<std::pair<TextureCacheKey const, TextureCacheValue>, false> const&) (33,429x)
      330,290 ( 0.00%)          gfx_rapi->select_texture(i, it->second.texture_id);
    7,145,949 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_select_texture(int, unsigned int) (33,029x)
      957,841 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::operator->() const (33,029x)
      165,145 ( 0.00%)          *n = &*it;
    1,056,928 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::operator*() const (33,029x)
      627,551 ( 0.00%)          gfx_texture_cache.lru.splice(gfx_texture_cache.lru.end(), gfx_texture_cache.lru,
    8,742,846 ( 0.01%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::splice(std::_List_const_iterator<TextureCacheMapIter>, std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >&, std::_List_const_iterator<TextureCacheMapIter>) (33,029x)
      726,638 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::end() (33,029x)
      726,638 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_const_iterator<TextureCacheMapIter>::_List_const_iterator(std::_List_iterator<TextureCacheMapIter> const&) (66,058x)
      132,116 ( 0.00%)                                       it->second.lru_location); // move to back
      957,841 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::operator->() const (33,029x)
       66,058 ( 0.00%)          return true;
            .               }
            .           
        2,400 ( 0.00%)      if (gfx_texture_cache.map.size() >= TEXTURE_CACHE_MAX_SIZE) {
        6,400 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::size() const (400x)
            .                   // Remove the texture that was least recently used
            .                   it = gfx_texture_cache.lru.front().it;
            .                   gfx_texture_cache.free_texture_ids.push_back(it->second.texture_id);
            .                   gfx_texture_cache.map.erase(it);
            .                   gfx_texture_cache.lru.pop_front();
            .               }
            .           
            .               uint32_t texture_id;
        2,000 ( 0.00%)      if (!gfx_texture_cache.free_texture_ids.empty()) {
       38,800 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<unsigned int, std::allocator<unsigned int> >::empty() const (400x)
            .                   texture_id = gfx_texture_cache.free_texture_ids.back();
            .                   gfx_texture_cache.free_texture_ids.pop_back();
            .               } else {
        1,600 ( 0.00%)          texture_id = gfx_rapi->new_texture();
      137,894 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_new_texture() (400x)
            .               }
            .           
        8,800 ( 0.00%)      it = gfx_texture_cache.map.insert(make_pair(key, TextureCacheValue())).first;
      588,918 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::enable_if<std::is_constructible<std::pair<TextureCacheKey const, TextureCacheValue>, std::pair<TextureCacheKey, TextureCacheValue>&&>::value, std::pair<std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>, bool> >::type std::unordered_map<TextureCacheKey, TextureCacheValue, TextureCacheKey::Hasher, std::equal_to<TextureCacheKey>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> > >::insert<std::pair<TextureCacheKey, TextureCacheValue> >(std::pair<TextureCacheKey, TextureCacheValue>&&) (400x)
       28,400 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__strip_reference_wrapper<std::decay<TextureCacheKey const&>::type>::__type, std::__strip_reference_wrapper<std::decay<TextureCacheValue>::type>::__type> std::make_pair<TextureCacheKey const&, TextureCacheValue>(TextureCacheKey const&, TextureCacheValue&&) (400x)
        7,600 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:TextureCacheValue::TextureCacheValue() (400x)
        1,600 ( 0.00%)      TextureCacheNode* node = &*it;
       12,800 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<TextureCacheKey const, TextureCacheValue>, false, false>::operator*() const (400x)
        1,200 ( 0.00%)      node->second.texture_id = texture_id;
        6,800 ( 0.00%)      node->second.lru_location = gfx_texture_cache.lru.insert(gfx_texture_cache.lru.end(), { it });
        8,800 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::end() (400x)
        4,400 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_const_iterator<TextureCacheMapIter>::_List_const_iterator(std::_List_iterator<TextureCacheMapIter> const&) (400x)
      163,838 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::__cxx11::list<TextureCacheMapIter, std::allocator<TextureCacheMapIter> >::insert(std::_List_const_iterator<TextureCacheMapIter>, TextureCacheMapIter&&) (400x)
            .           
        2,800 ( 0.00%)      gfx_rapi->select_texture(i, texture_id);
    1,444,474 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_select_texture(int, unsigned int) (400x)
        3,200 ( 0.00%)      gfx_rapi->set_sampler_parameters(i, false, 0, 0);
    1,027,200 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_sampler_parameters(int, bool, unsigned int, unsigned int) (400x)
        1,200 ( 0.00%)      *n = node;
          400 ( 0.00%)      return false;
      100,287 ( 0.00%)  }
            .           
      232,230 ( 0.00%)  static std::string gfx_get_base_texture_path(const std::string& path) {
      418,014 ( 0.00%)      if (path.starts_with(Ship::IResource::gAltAssetPrefix)) {
   15,393,037 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::starts_with(std::basic_string_view<char, std::char_traits<char> >) const (46,446x)
    2,786,760 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator std::basic_string_view<char, std::char_traits<char> >() const (46,446x)
            .                   return path.substr(Ship::IResource::gAltAssetPrefix.length());
            .               }
            .           
      232,230 ( 0.00%)      return path;
   25,810,401 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (46,446x)
      139,338 ( 0.00%)  }
            .           
            .           void gfx_texture_cache_delete(const uint8_t* orig_addr) {
            .               while (gfx_texture_cache.map.bucket_count() > 0) {
            .                   TextureCacheKey key = { orig_addr, { 0 }, 0, 0, 0 }; // bucket index only depends on the address
            .                   size_t bucket = gfx_texture_cache.map.bucket(key);
            .                   bool again = false;
            .                   for (auto it = gfx_texture_cache.map.begin(bucket); it != gfx_texture_cache.map.end(bucket); ++it) {
            .                       if (it->first.texture_addr == orig_addr) {
-- line 537 ----------------------------------------
-- line 543 ----------------------------------------
            .                       }
            .                   }
            .                   if (!again) {
            .                       break;
            .                   }
            .               }
            .           }
            .           
        1,422 ( 0.00%)  static void import_texture_rgba16(int tile, bool importReplacement) {
        2,844 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
        2,370 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
        1,580 ( 0.00%)              : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
        2,686 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
        1,264 ( 0.00%)      uint32_t full_image_line_size_bytes =
        1,422 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
        2,686 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .               // SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
        1,580 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes / 2;
        1,896 ( 0.00%)      uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
            .               // A single line of pixels should not equal the entire image (height == 1 non-withstanding)
          474 ( 0.00%)      if (full_image_line_size_bytes == size_bytes)
           93 ( 0.00%)          full_image_line_size_bytes = width * 2;
            .           
          158 ( 0.00%)      uint32_t i = 0;
            .           
        7,274 ( 0.00%)      for (uint32_t y = 0; y < height; y++) {
      528,809 ( 0.00%)          for (uint32_t x = 0; x < width; x++) {
      911,232 ( 0.00%)              uint32_t clrIdx = (y * (full_image_line_size_bytes / 2)) + (x);
            .           
    2,473,344 ( 0.00%)              uint16_t col16 = (addr[2 * clrIdx] << 8) | addr[2 * clrIdx + 1];
      390,528 ( 0.00%)              uint8_t a = col16 & 1;
      390,528 ( 0.00%)              uint8_t r = col16 >> 11;
      520,704 ( 0.00%)              uint8_t g = (col16 >> 6) & 0x1f;
      520,704 ( 0.00%)              uint8_t b = (col16 >> 1) & 0x1f;
    2,473,344 ( 0.00%)              tex_upload_buffer[4 * i + 0] = SCALE_5_8(r);
    2,603,520 ( 0.00%)              tex_upload_buffer[4 * i + 1] = SCALE_5_8(g);
    2,603,520 ( 0.00%)              tex_upload_buffer[4 * i + 2] = SCALE_5_8(b);
    1,409,645 ( 0.00%)              tex_upload_buffer[4 * i + 3] = a ? 255 : 0;
            .           
      130,176 ( 0.00%)              i++;
            .                   }
            .               }
            .           
        1,264 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
    2,293,577 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (158x)
        1,106 ( 0.00%)  }
            .           
          288 ( 0.00%)  static void import_texture_rgba32(int tile, bool importReplacement) {
          576 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
          480 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
          320 ( 0.00%)              : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
          544 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
          256 ( 0.00%)      uint32_t full_image_line_size_bytes =
          288 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
          544 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
           96 ( 0.00%)      SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
          320 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes / 2;
          480 ( 0.00%)      uint32_t height = (size_bytes / 2) / g_rdp.texture_tile[tile].line_size_bytes;
          256 ( 0.00%)      gfx_rapi->upload_texture(addr, width, height);
      474,844 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (32x)
          224 ( 0.00%)  }
            .           
            .           static void import_texture_ia4(int tile, bool importReplacement) {
            .               const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
            .                       ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
-- line 618 ----------------------------------------
-- line 699 ----------------------------------------
            .               }
            .           
            .               uint32_t width = g_rdp.texture_tile[tile].line_size_bytes / 2;
            .               uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
            .               gfx_rapi->upload_texture(tex_upload_buffer, width, height);
            .           }
            .           
          162 ( 0.00%)  static void import_texture_i4(int tile, bool importReplacement) {
          324 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
          270 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
          180 ( 0.00%)              : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
          306 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
          144 ( 0.00%)      uint32_t full_image_line_size_bytes =
          162 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
          306 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .               // SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
      191,408 ( 0.00%)      for (uint32_t i = 0; i < size_bytes * 2; i++) {
      267,820 ( 0.00%)          uint8_t byte = addr[i / 2];
      306,080 ( 0.00%)          uint8_t part = (byte >> (4 - (i % 2) * 4)) & 0xf;
       76,520 ( 0.00%)          uint8_t intensity = part;
       76,520 ( 0.00%)          uint8_t r = intensity;
       76,520 ( 0.00%)          uint8_t g = intensity;
       76,520 ( 0.00%)          uint8_t b = intensity;
       76,520 ( 0.00%)          uint8_t a = intensity;
      382,600 ( 0.00%)          tex_upload_buffer[4 * i + 0] = SCALE_4_8(r);
      420,860 ( 0.00%)          tex_upload_buffer[4 * i + 1] = SCALE_4_8(g);
      420,860 ( 0.00%)          tex_upload_buffer[4 * i + 2] = SCALE_4_8(b);
      420,860 ( 0.00%)          tex_upload_buffer[4 * i + 3] = SCALE_4_8(a);
            .               }
            .           
          180 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes * 2;
          216 ( 0.00%)      uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
          144 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
      280,971 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (18x)
          126 ( 0.00%)  }
            .           
           63 ( 0.00%)  static void import_texture_i8(int tile, bool importReplacement) {
          126 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
          105 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
           70 ( 0.00%)              : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
          119 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
           56 ( 0.00%)      uint32_t full_image_line_size_bytes =
           63 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
          119 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .               // SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
       40,995 ( 0.00%)      for (uint32_t i = 0; i < size_bytes; i++) {
       51,200 ( 0.00%)          uint8_t intensity = addr[i];
       20,480 ( 0.00%)          uint8_t r = intensity;
       20,480 ( 0.00%)          uint8_t g = intensity;
       20,480 ( 0.00%)          uint8_t b = intensity;
       20,480 ( 0.00%)          uint8_t a = intensity;
       71,680 ( 0.00%)          tex_upload_buffer[4 * i + 0] = r;
       81,920 ( 0.00%)          tex_upload_buffer[4 * i + 1] = g;
       81,920 ( 0.00%)          tex_upload_buffer[4 * i + 2] = b;
       81,920 ( 0.00%)          tex_upload_buffer[4 * i + 3] = a;
            .               }
            .           
           63 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes;
           84 ( 0.00%)      uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
           56 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
      106,646 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (7x)
           49 ( 0.00%)  }
            .           
            9 ( 0.00%)  static void import_texture_ci4(int tile, bool importReplacement) {
           18 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
           15 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
           10 ( 0.00%)              : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
           17 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
            8 ( 0.00%)      uint32_t full_image_line_size_bytes =
            9 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
           17 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
           10 ( 0.00%)      uint32_t pal_idx = g_rdp.texture_tile[tile].palette; // 0-15
            .           
            1 ( 0.00%)      uint8_t* palette = nullptr;
            .               // const uint8_t* palette = g_rdp.palettes[pal_idx / 8] + (pal_idx % 8) * 16 * 2; // 16 pixel entries, 16 bits each
            .           
            2 ( 0.00%)      if (pal_idx > 7)
            .                   palette = (uint8_t*)g_rdp.palettes[pal_idx / 8]; // 16 pixel entries, 16 bits each
            .               else
           10 ( 0.00%)          palette = (uint8_t*)(g_rdp.palettes[pal_idx / 8] + (pal_idx % 8) * 16 * 2);
            .           
            3 ( 0.00%)      SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
       20,486 ( 0.00%)      for (uint32_t i = 0; i < size_bytes * 2; i++) {
       28,672 ( 0.00%)          uint8_t byte = addr[i / 2];
       32,768 ( 0.00%)          uint8_t idx = (byte >> (4 - (i % 2) * 4)) & 0xf;
       77,824 ( 0.00%)          uint16_t col16 = (palette[idx * 2] << 8) | palette[idx * 2 + 1]; // Big endian load
       12,288 ( 0.00%)          uint8_t a = col16 & 1;
       12,288 ( 0.00%)          uint8_t r = col16 >> 11;
       16,384 ( 0.00%)          uint8_t g = (col16 >> 6) & 0x1f;
       16,384 ( 0.00%)          uint8_t b = (col16 >> 1) & 0x1f;
       77,824 ( 0.00%)          tex_upload_buffer[4 * i + 0] = SCALE_5_8(r);
       81,920 ( 0.00%)          tex_upload_buffer[4 * i + 1] = SCALE_5_8(g);
       81,920 ( 0.00%)          tex_upload_buffer[4 * i + 2] = SCALE_5_8(b);
       43,448 ( 0.00%)          tex_upload_buffer[4 * i + 3] = a ? 255 : 0;
            .               }
            .           
            9 ( 0.00%)      uint32_t result_line_size = g_rdp.texture_tile[tile].line_size_bytes;
            8 ( 0.00%)      if (metadata->h_byte_scale != 1) {
            .                   result_line_size *= metadata->h_byte_scale;
            .               }
            .           
            3 ( 0.00%)      uint32_t width = result_line_size * 2;
            4 ( 0.00%)      uint32_t height = size_bytes / result_line_size;
            .           
            8 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
       18,248 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (1x)
            7 ( 0.00%)  }
            .           
        1,656 ( 0.00%)  static void import_texture_ci8(int tile, bool importReplacement) {
        3,312 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
        2,760 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
        1,840 ( 0.00%)              : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
        3,128 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
        1,472 ( 0.00%)      uint32_t full_image_line_size_bytes =
        1,656 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
        3,128 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .           
        2,208 ( 0.00%)      for (uint32_t i = 0, j = 0; i < size_bytes; j += full_image_line_size_bytes - line_size_bytes) {
    2,177,432 ( 0.00%)          for (uint32_t k = 0; k < line_size_bytes; i++, k++, j++) {
    1,813,760 ( 0.00%)              uint8_t idx = addr[j];
    5,804,032 ( 0.00%)              uint16_t col16 = (g_rdp.palettes[idx / 128][(idx % 128) * 2] << 8) |
    4,715,776 ( 0.00%)                               g_rdp.palettes[idx / 128][(idx % 128) * 2 + 1]; // Big endian load
    1,088,256 ( 0.00%)              uint8_t a = col16 & 1;
    1,088,256 ( 0.00%)              uint8_t r = col16 >> 11;
    1,451,008 ( 0.00%)              uint8_t g = (col16 >> 6) & 0x1f;
    1,451,008 ( 0.00%)              uint8_t b = (col16 >> 1) & 0x1f;
    6,892,288 ( 0.01%)              tex_upload_buffer[4 * i + 0] = SCALE_5_8(r);
    7,255,040 ( 0.01%)              tex_upload_buffer[4 * i + 1] = SCALE_5_8(g);
    7,255,040 ( 0.01%)              tex_upload_buffer[4 * i + 2] = SCALE_5_8(b);
    3,747,948 ( 0.00%)              tex_upload_buffer[4 * i + 3] = a ? 255 : 0;
            .                   }
            .               }
            .           
        1,656 ( 0.00%)      uint32_t result_line_size = g_rdp.texture_tile[tile].line_size_bytes;
        1,472 ( 0.00%)      if (metadata->h_byte_scale != 1) {
            .                   result_line_size *= metadata->h_byte_scale;
            .               }
            .           
          368 ( 0.00%)      uint32_t width = result_line_size;
          736 ( 0.00%)      uint32_t height = size_bytes / result_line_size;
            .           
        1,472 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
    2,842,097 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (184x)
        1,288 ( 0.00%)  }
            .           
            .           static void import_texture_raw(int tile, bool importReplacement) {
            .               const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
            .                       ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
-- line 864 ----------------------------------------
-- line 927 ----------------------------------------
            .               // Set the remaining bytes to load as 0
            .               if (num_loaded_bytes > resource_image_size_bytes) {
            .                   memset(tex_upload_buffer + resource_image_size_bytes, 0, num_loaded_bytes - resource_image_size_bytes);
            .               }
            .           
            .               gfx_rapi->upload_texture(tex_upload_buffer, result_new_line_size / 4, result_new_height);
            .           }
            .           
      334,290 ( 0.00%)  static void import_texture(int i, int tile, bool importReplacement) {
      300,861 ( 0.00%)      uint8_t fmt = g_rdp.texture_tile[tile].fmt;
      300,861 ( 0.00%)      uint8_t siz = g_rdp.texture_tile[tile].siz;
      568,293 ( 0.00%)      uint32_t texFlags = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].tex_flags;
      334,290 ( 0.00%)      uint32_t tmem_index = g_rdp.texture_tile[tile].tmem_index;
      300,861 ( 0.00%)      uint8_t palette_index = g_rdp.texture_tile[tile].palette;
      568,293 ( 0.00%)      uint32_t orig_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes;
            .           
      601,722 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* orig_addr =
            .                   importReplacement && (metadata->resource != nullptr)
      501,435 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
       33,429 ( 0.00%)              : g_rdp.loaded_texture[tmem_index].addr;
            .           
            .               TextureCacheKey key;
       66,858 ( 0.00%)      if (fmt == G_IM_FMT_CI) {
       81,945 ( 0.00%)          key = { orig_addr, { g_rdp.palettes[0], g_rdp.palettes[1] }, fmt, siz, palette_index, orig_size_bytes };
            .               } else {
      335,592 ( 0.00%)          key = { orig_addr, {}, fmt, siz, palette_index, orig_size_bytes };
            .               }
            .           
      234,003 ( 0.00%)      if (gfx_texture_cache_lookup(i, key)) {
   44,191,869 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_cache_lookup(int, TextureCacheKey const&) (33,429x)
       66,058 ( 0.00%)          return;
            .               }
            .           
            .               // if load as raw is set then we load_raw();
        1,600 ( 0.00%)      if ((texFlags & TEX_FLAG_LOAD_AS_RAW) != 0) {
            .                   import_texture_raw(tile, importReplacement);
            .                   return;
            .               }
            .           
          800 ( 0.00%)      if (fmt == G_IM_FMT_RGBA) {
          380 ( 0.00%)          if (siz == G_IM_SIZ_16b) {
          790 ( 0.00%)              import_texture_rgba16(tile, importReplacement);
   17,279,750 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_rgba16(int, bool) (158x)
           64 ( 0.00%)          } else if (siz == G_IM_SIZ_32b) {
          160 ( 0.00%)              import_texture_rgba32(tile, importReplacement);
      479,516 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_rgba32(int, bool) (32x)
            .                   } else {
            .                       // abort(); // OTRTODO: Sometimes, seemingly randomly, we end up here. Could be a bad dlist, could be
            .                       // something F3D does not have supported. Further investigation is needed.
            .                   }
          420 ( 0.00%)      } else if (fmt == G_IM_FMT_IA) {
            .                   if (siz == G_IM_SIZ_4b) {
            .                       import_texture_ia4(tile, importReplacement);
            .                   } else if (siz == G_IM_SIZ_8b) {
            .                       import_texture_ia8(tile, importReplacement);
            .                   } else if (siz == G_IM_SIZ_16b) {
            .                       import_texture_ia16(tile, importReplacement);
            .                   } else {
            .                       abort();
            .                   }
          420 ( 0.00%)      } else if (fmt == G_IM_FMT_CI) {
          370 ( 0.00%)          if (siz == G_IM_SIZ_4b) {
            5 ( 0.00%)              import_texture_ci4(tile, importReplacement);
      520,622 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_ci4(int, bool) (1x)
          368 ( 0.00%)          } else if (siz == G_IM_SIZ_8b) {
          920 ( 0.00%)              import_texture_ci8(tile, importReplacement);
   47,610,093 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_ci8(int, bool) (184x)
            .                   } else {
            .                       abort();
            .                   }
           50 ( 0.00%)      } else if (fmt == G_IM_FMT_I) {
           50 ( 0.00%)          if (siz == G_IM_SIZ_4b) {
           90 ( 0.00%)              import_texture_i4(tile, importReplacement);
    3,076,579 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_i4(int, bool) (18x)
           14 ( 0.00%)          } else if (siz == G_IM_SIZ_8b) {
           35 ( 0.00%)              import_texture_i8(tile, importReplacement);
      599,174 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_i8(int, bool) (7x)
            .                   } else {
            .                       abort();
            .                   }
            .               } else {
            .                   abort();
            .               }
      201,374 ( 0.00%)  }
            .           
            .           static void import_texture_mask(int i, int tile) {
            .               uint32_t tmem_index = g_rdp.texture_tile[tile].tmem_index;
            .               RawTexMetadata metadata = g_rdp.loaded_texture[tmem_index].raw_tex_metadata;
            .           
            .               if (metadata.resource == nullptr) {
            .                   return;
            .               }
-- line 1013 ----------------------------------------
-- line 1060 ----------------------------------------
            .                       tex_upload_buffer[4 * texIndex + 2] = 0;
            .                       tex_upload_buffer[4 * texIndex + 3] = 0;
            .                   }
            .               }
            .           
            .               gfx_rapi->upload_texture(tex_upload_buffer, width, height);
            .           }
            .           
      311,592 ( 0.00%)  static void gfx_normalize_vector(float v[3]) {
    2,103,246 ( 0.00%)      float s = sqrtf(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      623,184 ( 0.00%)  => ???:sqrtf (77,898x)
      389,490 ( 0.00%)      v[0] /= s;
      545,286 ( 0.00%)      v[1] /= s;
      545,286 ( 0.00%)      v[2] /= s;
      233,694 ( 0.00%)  }
            .           
      389,490 ( 0.00%)  static void gfx_transposed_matrix_mul(float res[3], const float a[3], const float b[4][4]) {
    1,635,858 ( 0.00%)      res[0] = a[0] * b[0][0] + a[1] * b[0][1] + a[2] * b[0][2];
    1,947,450 ( 0.00%)      res[1] = a[0] * b[1][0] + a[1] * b[1][1] + a[2] * b[1][2];
    1,947,450 ( 0.00%)      res[2] = a[0] * b[2][0] + a[1] * b[2][1] + a[2] * b[2][2];
      233,694 ( 0.00%)  }
            .           
      389,490 ( 0.00%)  static void calculate_normal_dir(const F3DLight_t* light, float coeffs[3]) {
    1,635,858 ( 0.00%)      float light_dir[3] = { light->dir[0] / 127.0f, light->dir[1] / 127.0f, light->dir[2] / 127.0f };
            .           
      856,878 ( 0.00%)      gfx_transposed_matrix_mul(coeffs, light_dir, g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1]);
    6,153,942 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_transposed_matrix_mul(float*, float const*, float const (*) [4]) (77,898x)
      233,694 ( 0.00%)      gfx_normalize_vector(coeffs);
    4,751,778 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_normalize_vector(float*) (77,898x)
      233,694 ( 0.00%)  }
            .           
      397,062 ( 0.00%)  static void gfx_matrix_mul(float res[4][4], const float a[4][4], const float b[4][4]) {
            .               float tmp[4][4];
    1,058,832 ( 0.00%)      for (int i = 0; i < 4; i++) {
    4,235,328 ( 0.00%)          for (int j = 0; j < 4; j++) {
   64,588,752 ( 0.05%)              tmp[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j] + a[i][3] * b[3][j];
            .                   }
            .               }
      463,239 ( 0.00%)      memcpy(res, tmp, sizeof(tmp));
      794,124 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (66,177x)
      198,531 ( 0.00%)  }
            .           
      318,144 ( 0.00%)  static void gfx_sp_matrix(uint8_t parameters, const int32_t* addr) {
            .               float matrix[4][4];
            .           
    1,060,480 ( 0.00%)      if (auto it = current_mtx_replacements->find((Mtx*)addr); it != current_mtx_replacements->end()) {
    5,249,376 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<MtxS*, MtxF, std::hash<MtxS*>, std::equal_to<MtxS*>, std::allocator<std::pair<MtxS* const, MtxF> > >::find(MtxS* const&) const (53,024x)
    2,280,032 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<MtxS*, MtxF, std::hash<MtxS*>, std::equal_to<MtxS*>, std::allocator<std::pair<MtxS* const, MtxF> > >::end() const (53,024x)
      636,288 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<MtxS* const, MtxF>, false> const&, std::__detail::_Node_iterator_base<std::pair<MtxS* const, MtxF>, false> const&) (53,024x)
            .                   for (int i = 0; i < 4; i++) {
            .                       for (int j = 0; j < 4; j++) {
            .                           float v = it->second.mf[i][j];
            .                           int as_int = (int)(v * 65536.0f);
            .                           matrix[i][j] = as_int * (1.0f / 65536.0f);
            .                       }
            .                   }
            .               } else {
            .           #ifndef GBI_FLOATS
            .                   // Original GBI where fixed point matrices are used
      848,384 ( 0.00%)          for (int i = 0; i < 4; i++) {
    2,120,960 ( 0.00%)              for (int j = 0; j < 4; j += 2) {
    5,938,688 ( 0.00%)                  int32_t int_part = addr[i * 2 + j / 2];
    6,362,880 ( 0.01%)                  uint32_t frac_part = addr[8 + i * 2 + j / 2];
    6,787,072 ( 0.01%)                  matrix[i][j] = (int32_t)((int_part & 0xffff0000) | (frac_part >> 16)) / 65536.0f;
    7,211,264 ( 0.01%)                  matrix[i][j + 1] = (int32_t)((int_part << 16) | (frac_part & 0xffff)) / 65536.0f;
            .                       }
            .                   }
            .           #else
            .                   // For a modified GBI where fixed point values are replaced with floats
            .                   memcpy(matrix, addr, sizeof(matrix));
            .           #endif
            .               }
            .           
      159,072 ( 0.00%)      const auto mtx_projection = get_attr<int8_t>(MTX_PROJECTION);
   48,729,056 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:signed char get_attr<signed char>(Attribute) (53,024x)
      159,072 ( 0.00%)      const auto mtx_load = get_attr<int8_t>(MTX_LOAD);
   48,729,056 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:signed char get_attr<signed char>(Attribute) (53,024x)
      159,072 ( 0.00%)      const auto mtx_push = get_attr<int8_t>(MTX_PUSH);
   48,729,056 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:signed char get_attr<signed char>(Attribute) (53,024x)
            .           
      265,120 ( 0.00%)      if (parameters & mtx_projection) {
       27,595 ( 0.00%)          if (parameters & mtx_load) {
       20,955 ( 0.00%)              memcpy(g_rsp.P_matrix, matrix, sizeof(matrix));
            .                   } else {
        7,968 ( 0.00%)              gfx_matrix_mul(g_rsp.P_matrix, matrix, g_rsp.P_matrix);
    1,439,552 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_matrix_mul(float (*) [4], float const (*) [4], float const (*) [4]) (1,328x)
            .                   }
            .               } else { // G_MTX_MODELVIEW
      254,745 ( 0.00%)          if ((parameters & mtx_push) && g_rsp.modelview_matrix_stack_size < 11) {
       17,220 ( 0.00%)              ++g_rsp.modelview_matrix_stack_size;
       63,140 ( 0.00%)              memcpy(g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1],
       68,880 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,740x)
       34,440 ( 0.00%)                     g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 2], sizeof(matrix));
            .                   }
      237,525 ( 0.00%)          if (parameters & mtx_load) {
      124,260 ( 0.00%)              if (g_rsp.modelview_matrix_stack_size == 0)
            .                           ++g_rsp.modelview_matrix_stack_size;
      538,460 ( 0.00%)              memcpy(g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1], matrix, sizeof(matrix));
      497,040 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (41,420x)
            .                   } else {
       60,850 ( 0.00%)              gfx_matrix_mul(g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1], matrix,
    6,596,140 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_matrix_mul(float (*) [4], float const (*) [4], float const (*) [4]) (6,085x)
       36,510 ( 0.00%)                             g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1]);
            .                   }
       47,505 ( 0.00%)          g_rsp.lights_changed = 1;
            .               }
      530,240 ( 0.00%)      gfx_matrix_mul(g_rsp.MP_matrix, g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1],
   57,478,016 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_matrix_mul(float (*) [4], float const (*) [4], float const (*) [4]) (53,024x)
            .                              g_rsp.P_matrix);
      159,072 ( 0.00%)  }
            .           
       22,960 ( 0.00%)  static void gfx_sp_pop_matrix(uint32_t count) {
       86,100 ( 0.00%)      while (count--) {
       17,220 ( 0.00%)          if (g_rsp.modelview_matrix_stack_size > 0) {
       17,220 ( 0.00%)              --g_rsp.modelview_matrix_stack_size;
       17,220 ( 0.00%)              if (g_rsp.modelview_matrix_stack_size > 0) {
       57,400 ( 0.00%)                  gfx_matrix_mul(g_rsp.MP_matrix, g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1],
    6,222,160 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_matrix_mul(float (*) [4], float const (*) [4], float const (*) [4]) (5,740x)
            .                                          g_rsp.P_matrix);
            .                       }
            .                   }
            .               }
        5,740 ( 0.00%)      g_rsp.lights_changed = true;
       17,220 ( 0.00%)  }
            .           
  604,303,605 ( 0.50%)  static float gfx_adjust_x_for_aspect_ratio(float x) {
  604,303,605 ( 0.50%)      if (fbActive) {
            .                   return x;
            .               } else {
3,424,387,095 ( 2.84%)          return x * (4.0f / 3.0f) / ((float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height);
            .               }
  402,869,070 ( 0.33%)  }
            .           
            .           // Scale the width and height value based on the ratio of the viewport to the native size
            .           static void gfx_adjust_width_height_for_scale(uint32_t& width, uint32_t& height, uint32_t native_width,
            .                                                         uint32_t native_height) {
            .               width = round(width * (gfx_current_dimensions.width / (2.0f * (native_width / 2))));
            .               height = round(height * (gfx_current_dimensions.height / (2.0f * (native_height / 2))));
            .           
            .               if (width == 0) {
-- line 1183 ----------------------------------------
-- line 1184 ----------------------------------------
            .                   width = 1;
            .               }
            .               if (height == 0) {
            .                   height = 1;
            .               }
            .           }
            .           
            .           [[always_inline]]
   38,252,430 ( 0.03%)  static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const F3DVtx* vertices) {
            .           #pragma omp parallel for
1,045,231,575 ( 0.87%)      for (size_t i = 0; i < n_vertices; i++, dest_index++) {
1,208,374,974 ( 1.00%)          const F3DVtx_t* v = &vertices[i].v;
1,208,374,974 ( 1.00%)          const F3DVtx_tn* vn = &vertices[i].n;
1,208,374,974 ( 1.00%)          struct LoadedVertex* d = &g_rsp.loaded_vertices[dest_index];
            .           
  402,791,658 ( 0.33%)          if (v == NULL) {
            .                       return;
            .                   }
            .           
3,222,333,264 ( 2.67%)          float x = v->ob[0] * g_rsp.MP_matrix[0][0] + v->ob[1] * g_rsp.MP_matrix[1][0] +
1,409,770,803 ( 1.17%)                    v->ob[2] * g_rsp.MP_matrix[2][0] + g_rsp.MP_matrix[3][0];
3,222,333,264 ( 2.67%)          float y = v->ob[0] * g_rsp.MP_matrix[0][1] + v->ob[1] * g_rsp.MP_matrix[1][1] +
1,409,770,803 ( 1.17%)                    v->ob[2] * g_rsp.MP_matrix[2][1] + g_rsp.MP_matrix[3][1];
3,222,333,264 ( 2.67%)          float z = v->ob[0] * g_rsp.MP_matrix[0][2] + v->ob[1] * g_rsp.MP_matrix[1][2] +
1,409,770,803 ( 1.17%)                    v->ob[2] * g_rsp.MP_matrix[2][2] + g_rsp.MP_matrix[3][2];
3,222,333,264 ( 2.67%)          float w = v->ob[0] * g_rsp.MP_matrix[0][3] + v->ob[1] * g_rsp.MP_matrix[1][3] +
1,409,770,803 ( 1.17%)                    v->ob[2] * g_rsp.MP_matrix[2][3] + g_rsp.MP_matrix[3][3];
            .           
            .                   float world_pos[3];
  805,583,316 ( 0.67%)          if (g_rsp.geometry_mode & G_LIGHTING_POSITIONAL) {
            .                       float(*mtx)[4] = g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1];
            .                       world_pos[0] = v->ob[0] * mtx[0][0] + v->ob[1] * mtx[1][0] + v->ob[2] * mtx[2][0] + mtx[3][0];
            .                       world_pos[1] = v->ob[0] * mtx[0][1] + v->ob[1] * mtx[1][1] + v->ob[2] * mtx[2][1] + mtx[3][1];
            .                       world_pos[2] = v->ob[0] * mtx[0][2] + v->ob[1] * mtx[1][2] + v->ob[2] * mtx[2][2] + mtx[3][2];
            .                   }
            .           
1,006,979,145 ( 0.83%)          x = gfx_adjust_x_for_aspect_ratio(x);
5,034,895,725 ( 4.17%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_x_for_aspect_ratio(float) (201,395,829x)
            .           
1,611,166,632 ( 1.33%)          short U = v->tc[0] * g_rsp.texture_scaling_factor.s >> 16;
1,611,166,632 ( 1.33%)          short V = v->tc[1] * g_rsp.texture_scaling_factor.t >> 16;
            .           
  805,583,316 ( 0.67%)          if (g_rsp.geometry_mode & G_LIGHTING) {
  602,741,292 ( 0.50%)              if (g_rsp.lights_changed) {
      337,558 ( 0.00%)                  for (int i = 0; i < g_rsp.current_num_lights - 1; i++) {
      441,422 ( 0.00%)                      calculate_normal_dir(&g_rsp.current_lights[i].l, g_rsp.current_lights_coeffs[i]);
    4,751,778 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) (25,966x)
            .                           }
            .                           /*static const Light_t lookat_x = {{0, 0, 0}, 0, {0, 0, 0}, 0, {127, 0, 0}, 0};
            .                           static const Light_t lookat_y = {{0, 0, 0}, 0, {0, 0, 0}, 0, {0, 127, 0}, 0};*/
       77,898 ( 0.00%)                  calculate_normal_dir(&g_rsp.lookat[0], g_rsp.current_lookat_coeffs[0]);
    4,751,778 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) (25,966x)
       77,898 ( 0.00%)                  calculate_normal_dir(&g_rsp.lookat[1], g_rsp.current_lookat_coeffs[1]);
    4,751,778 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) (25,966x)
       25,966 ( 0.00%)                  g_rsp.lights_changed = false;
            .                       }
            .           
2,009,137,640 ( 1.66%)              int r = g_rsp.current_lights[g_rsp.current_num_lights - 1].l.col[0];
1,808,223,876 ( 1.50%)              int g = g_rsp.current_lights[g_rsp.current_num_lights - 1].l.col[1];
1,808,223,876 ( 1.50%)              int b = g_rsp.current_lights[g_rsp.current_num_lights - 1].l.col[2];
            .           
2,611,878,932 ( 2.16%)              for (int i = 0; i < g_rsp.current_num_lights - 1; i++) {
  401,827,528 ( 0.33%)                  float intensity = 0;
  803,655,056 ( 0.67%)                  if ((g_rsp.geometry_mode & G_LIGHTING_POSITIONAL) && (g_rsp.current_lights[i].p.unk3 != 0)) {
            .                               // Calculate distance from the light to the vertex
            .                               float dist_vec[3] = { g_rsp.current_lights[i].p.pos[0] - world_pos[0],
            .                                                     g_rsp.current_lights[i].p.pos[1] - world_pos[1],
            .                                                     g_rsp.current_lights[i].p.pos[2] - world_pos[2] };
            .                               float dist_sq =
            .                                   dist_vec[0] * dist_vec[0] + dist_vec[1] * dist_vec[1] +
            .                                   dist_vec[2] * dist_vec[2] * 2; // The *2 comes from GLideN64, unsure of why it does it
            .                               float dist = sqrt(dist_sq);
-- line 1251 ----------------------------------------
-- line 1273 ----------------------------------------
            .                               // https://github.com/gonetz/GLideN64/blob/3b43a13a80dfc2eb6357673440b335e54eaa3896/src/gSP.cpp#L636
            .                               float distf = floorf(dist);
            .                               float attenuation = (distf * g_rsp.current_lights[i].p.unk7 * 2.0f +
            .                                                    distf * distf * g_rsp.current_lights[i].p.unkE / 8.0f) /
            .                                                       (float)0xFFFF +
            .                                                   1.0f;
            .                               intensity = total_intensity / attenuation;
            .                           } else {
3,214,620,224 ( 2.66%)                      intensity += vn->n[0] * g_rsp.current_lights_coeffs[i][0];
3,214,620,224 ( 2.66%)                      intensity += vn->n[1] * g_rsp.current_lights_coeffs[i][1];
3,214,620,224 ( 2.66%)                      intensity += vn->n[2] * g_rsp.current_lights_coeffs[i][2];
  803,655,056 ( 0.67%)                      intensity /= 127.0f;
            .                           }
  803,655,056 ( 0.67%)                  if (intensity > 0.0f) {
1,306,461,143 ( 1.08%)                      r += intensity * g_rsp.current_lights[i].l.col[0];
1,205,964,132 ( 1.00%)                      g += intensity * g_rsp.current_lights[i].l.col[1];
1,205,964,132 ( 1.00%)                      b += intensity * g_rsp.current_lights[i].l.col[2];
            .                           }
            .                       }
            .           
1,406,396,348 ( 1.17%)              d->color.r = r > 255 ? 255 : r;
1,406,396,348 ( 1.17%)              d->color.g = g > 255 ? 255 : g;
1,406,396,348 ( 1.17%)              d->color.b = b > 255 ? 255 : b;
            .           
  803,655,056 ( 0.67%)              if (g_rsp.geometry_mode & G_TEXTURE_GEN) {
            .                           float dotx = 0, doty = 0;
            .                           dotx += vn->n[0] * g_rsp.current_lookat_coeffs[0][0];
            .                           dotx += vn->n[1] * g_rsp.current_lookat_coeffs[0][1];
            .                           dotx += vn->n[2] * g_rsp.current_lookat_coeffs[0][2];
            .                           doty += vn->n[0] * g_rsp.current_lookat_coeffs[1][0];
            .                           doty += vn->n[1] * g_rsp.current_lookat_coeffs[1][1];
            .                           doty += vn->n[2] * g_rsp.current_lookat_coeffs[1][2];
            .           
-- line 1305 ----------------------------------------
-- line 1321 ----------------------------------------
            .                               dotx = (dotx + 1.0f) / 4.0f;
            .                               doty = (doty + 1.0f) / 4.0f;
            .                           }
            .           
            .                           U = (int32_t)(dotx * g_rsp.texture_scaling_factor.s);
            .                           V = (int32_t)(doty * g_rsp.texture_scaling_factor.t);
            .                       }
            .                   } else {
    1,928,260 ( 0.00%)              d->color.r = v->cn[0];
    1,928,260 ( 0.00%)              d->color.g = v->cn[1];
    1,928,260 ( 0.00%)              d->color.b = v->cn[2];
            .                   }
            .           
  805,583,316 ( 0.67%)          d->u = U;
  805,583,316 ( 0.67%)          d->v = V;
            .           
            .                   // trivial clip rejection
  402,791,658 ( 0.33%)          d->clip_rej = 0;
1,006,979,145 ( 0.83%)          if (x < -w) {
  575,553,366 ( 0.48%)              d->clip_rej |= 1; // CLIP_LEFT
            .                   }
  604,187,487 ( 0.50%)          if (x > w) {
  830,612,682 ( 0.69%)              d->clip_rej |= 2; // CLIP_RIGHT
            .                   }
1,006,979,145 ( 0.83%)          if (y < -w) {
  756,917,868 ( 0.63%)              d->clip_rej |= 4; // CLIP_BOTTOM
            .                   }
  604,187,487 ( 0.50%)          if (y > w) {
  972,302,178 ( 0.81%)              d->clip_rej |= 8; // CLIP_TOP
            .                   }
            .                   // if (z < -w) d->clip_rej |= 16; // CLIP_NEAR
  604,187,487 ( 0.50%)          if (z > w) {
            .                       d->clip_rej |= 32; // CLIP_FAR
            .                   }
            .           
  604,187,487 ( 0.50%)          d->x = x;
  604,187,487 ( 0.50%)          d->y = y;
  604,187,487 ( 0.50%)          d->z = z;
  604,187,487 ( 0.50%)          d->w = w;
            .           
  805,583,316 ( 0.67%)          if (g_rsp.geometry_mode & G_FOG) {
          360 ( 0.00%)              if (fabsf(w) < 0.001f) {
            .                           // To avoid division by zero
            .                           w = 0.001f;
            .                       }
            .           
          180 ( 0.00%)              float winv = 1.0f / w;
          180 ( 0.00%)              if (winv < 0.0f) {
          240 ( 0.00%)                  winv = std::numeric_limits<int16_t>::max();
          300 ( 0.00%)  => /usr/include/c++/14/limits:std::numeric_limits<short>::max() (60x)
            .                       }
            .           
          660 ( 0.00%)              float fog_z = z * winv * g_rsp.fog_mul + g_rsp.fog_offset;
          420 ( 0.00%)              fog_z = Ship::Math::clamp(fog_z, 0.0f, 255.0f);
        1,020 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/Utils.cpp:Ship::Math::clamp(float, float, float) (60x)
          300 ( 0.00%)              d->color.a = fog_z; // Use alpha variable to store fog factor
            .                   } else {
  805,583,076 ( 0.67%)              d->color.a = v->cn[3];
            .                   }
            .               }
   12,750,810 ( 0.01%)  }
            .           
            .           static void gfx_sp_modify_vertex(uint16_t vtx_idx, uint8_t where, uint32_t val) {
            .               SUPPORT_CHECK(where == G_MWO_POINT_ST);
            .           
            .               int16_t s = (int16_t)(val >> 16);
            .               int16_t t = (int16_t)val;
            .           
            .               struct LoadedVertex* v = &g_rsp.loaded_vertices[vtx_idx];
            .               v->u = s;
            .               v->v = t;
            .           }
            .           
  990,788,660 ( 0.82%)  static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx, bool is_rect) {
  693,552,062 ( 0.57%)      struct LoadedVertex* v1 = &g_rsp.loaded_vertices[vtx1_idx];
  693,552,062 ( 0.57%)      struct LoadedVertex* v2 = &g_rsp.loaded_vertices[vtx2_idx];
  693,552,062 ( 0.57%)      struct LoadedVertex* v3 = &g_rsp.loaded_vertices[vtx3_idx];
  594,473,196 ( 0.49%)      struct LoadedVertex* v_arr[3] = { v1, v2, v3 };
            .           
            .               // if (rand()%2) return;
            .           
  990,788,660 ( 0.82%)      if (v1->clip_rej & v2->clip_rej & v3->clip_rej) {
            .                   // The whole triangle lies outside the visible area
  194,438,176 ( 0.16%)          return;
            .               }
            .           
    5,579,334 ( 0.00%)      const auto cull_both = get_attr<uint32_t>(CULL_BOTH);
1,709,135,982 ( 1.42%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:unsigned int get_attr<unsigned int>(Attribute) (1,859,778x)
    5,579,334 ( 0.00%)      const auto cull_front = get_attr<uint32_t>(CULL_FRONT);
1,709,135,982 ( 1.42%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:unsigned int get_attr<unsigned int>(Attribute) (1,859,778x)
    5,579,334 ( 0.00%)      const auto cull_back = get_attr<uint32_t>(CULL_BACK);
1,709,135,982 ( 1.42%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:unsigned int get_attr<unsigned int>(Attribute) (1,859,778x)
            .           
    7,439,112 ( 0.01%)      if ((g_rsp.geometry_mode & cull_both) != 0) {
   21,287,568 ( 0.02%)          float dx1 = v1->x / (v1->w) - v2->x / (v2->w);
   21,287,568 ( 0.02%)          float dy1 = v1->y / (v1->w) - v2->y / (v2->w);
   21,287,568 ( 0.02%)          float dx2 = v3->x / (v3->w) - v2->x / (v2->w);
   21,287,568 ( 0.02%)          float dy2 = v3->y / (v3->w) - v2->y / (v2->w);
   10,643,784 ( 0.01%)          float cross = dx1 * dy2 - dy1 * dx2;
            .           
   37,253,244 ( 0.03%)          if ((v1->w < 0) ^ (v2->w < 0) ^ (v3->w < 0)) {
            .                       // If one vertex lies behind the eye, negating cross will give the correct result.
            .                       // If all vertices lie behind the eye, the triangle will be rejected anyway.
        7,428 ( 0.00%)              cross = -cross;
            .                   }
            .           
            .                   // If inverted culling is requested, negate the cross
    5,321,892 ( 0.00%)          if (ucode_handler_index == UcodeHandlers::ucode_f3dex2 &&
            .                       (g_rsp.extra_geometry_mode & G_EX_INVERT_CULLING) == 1) {
            .                       cross = -cross;
            .                   }
            .           
    5,321,892 ( 0.00%)          auto cull_type = g_rsp.geometry_mode & cull_both;
            .           
    5,321,892 ( 0.00%)          if (cull_type == cull_front) {
            .                       if (cross <= 0) {
            .                           return;
            .                       }
    5,321,892 ( 0.00%)          } else if (cull_type == cull_back) {
    7,574,505 ( 0.01%)              if (cross >= 0) {
    2,590,630 ( 0.00%)                  return;
            .                       }
            .                   } else if (cull_type == cull_both) {
            .                       // Why is this even an option?
            .                       return;
            .                   }
            .               }
            .           
    2,822,315 ( 0.00%)      bool depth_test = (g_rsp.geometry_mode & G_ZBUFFER) == G_ZBUFFER;
    2,822,315 ( 0.00%)      bool depth_mask = (g_rdp.other_mode_l & Z_UPD) == Z_UPD;
    5,530,914 ( 0.00%)      uint8_t depth_test_and_mask = (depth_test ? 1 : 0) | (depth_mask ? 2 : 0);
    1,693,389 ( 0.00%)      if (depth_test_and_mask != rendering_state.depth_test_and_mask) {
       14,027 ( 0.00%)          gfx_flush();
  156,413,577 ( 0.13%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (14,027x)
       98,189 ( 0.00%)          gfx_rapi->set_depth_test_and_mask(depth_test, depth_mask);
      182,351 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_depth_test_and_mask(bool, bool) (14,027x)
       28,054 ( 0.00%)          rendering_state.depth_test_and_mask = depth_test_and_mask;
            .               }
            .           
    2,822,315 ( 0.00%)      bool zmode_decal = (g_rdp.other_mode_l & ZMODE_DEC) == ZMODE_DEC;
    1,693,389 ( 0.00%)      if (zmode_decal != rendering_state.decal_mode) {
       10,704 ( 0.00%)          gfx_flush();
    1,330,457 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (10,704x)
       53,520 ( 0.00%)          gfx_rapi->set_zmode_decal(zmode_decal);
       96,336 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_zmode_decal(bool) (10,704x)
       21,408 ( 0.00%)          rendering_state.decal_mode = zmode_decal;
            .               }
            .           
    1,693,389 ( 0.00%)      if (g_rdp.viewport_or_scissor_changed) {
      145,096 ( 0.00%)          if (memcmp(&g_rdp.viewport, &rendering_state.viewport, sizeof(g_rdp.viewport)) != 0) {
      395,149 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (20,728x)
          439 ( 0.00%)              gfx_flush();
      166,867 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (439x)
        5,268 ( 0.00%)              gfx_rapi->set_viewport(g_rdp.viewport.x, g_rdp.viewport.y, g_rdp.viewport.width, g_rdp.viewport.height);
      113,677 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_viewport(int, int, int, int) (439x)
        1,756 ( 0.00%)              rendering_state.viewport = g_rdp.viewport;
            .                   }
      145,096 ( 0.00%)          if (memcmp(&g_rdp.scissor, &rendering_state.scissor, sizeof(g_rdp.scissor)) != 0) {
      395,149 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (20,728x)
          439 ( 0.00%)              gfx_flush();
        3,512 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (439x)
        5,268 ( 0.00%)              gfx_rapi->set_scissor(g_rdp.scissor.x, g_rdp.scissor.y, g_rdp.scissor.width, g_rdp.scissor.height);
       90,794 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_scissor(int, int, int, int) (439x)
        1,756 ( 0.00%)              rendering_state.scissor = g_rdp.scissor;
            .                   }
       20,728 ( 0.00%)          g_rdp.viewport_or_scissor_changed = false;
            .               }
            .           
    1,128,926 ( 0.00%)      uint64_t cc_id = g_rdp.combine_mode;
      564,463 ( 0.00%)      uint64_t cc_options = 0;
    2,754,395 ( 0.00%)      bool use_alpha = ((g_rdp.other_mode_l & (3 << 20)) == (G_BL_CLR_MEM << 20) &&
    3,845,971 ( 0.00%)                        (g_rdp.other_mode_l & (3 << 16)) == (G_BL_1MA << 16)) ||
    2,040,532 ( 0.00%)                       ((g_rdp.other_mode_l & (3 << 22)) == (G_BL_CLR_MEM << 22) &&
      986,306 ( 0.00%)                        (g_rdp.other_mode_l & (3 << 18)) == (G_BL_1MA << 18));
    2,822,315 ( 0.00%)      bool use_fog = (g_rdp.other_mode_l >> 30) == G_BL_CLR_FOG;
    2,822,315 ( 0.00%)      bool texture_edge = (g_rdp.other_mode_l & CVG_X_ALPHA) == CVG_X_ALPHA;
    2,822,315 ( 0.00%)      bool use_noise = (g_rdp.other_mode_l & (3U << G_MDSFT_ALPHACOMPARE)) == G_AC_DITHER;
    2,822,315 ( 0.00%)      bool use_2cyc = (g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE)) == G_CYC_2CYCLE;
    2,822,315 ( 0.00%)      bool alpha_threshold = (g_rdp.other_mode_l & (3U << G_MDSFT_ALPHACOMPARE)) == G_AC_THRESHOLD;
      564,463 ( 0.00%)      bool invisible =
    2,958,155 ( 0.00%)          (g_rdp.other_mode_l & (3 << 24)) == (G_BL_0 << 24) && (g_rdp.other_mode_l & (3 << 20)) == (G_BL_CLR_MEM << 20);
    1,128,926 ( 0.00%)      bool use_grayscale = g_rdp.grayscale;
            .           
    1,128,926 ( 0.00%)      if (texture_edge) {
       38,911 ( 0.00%)          use_alpha = true;
            .               }
            .           
    1,128,926 ( 0.00%)      if (use_alpha) {
       76,261 ( 0.00%)          cc_options |= SHADER_OPT(ALPHA);
            .               }
    1,128,926 ( 0.00%)      if (use_fog) {
            .                   cc_options |= SHADER_OPT(FOG);
            .               }
    1,128,926 ( 0.00%)      if (texture_edge) {
       38,911 ( 0.00%)          cc_options |= SHADER_OPT(TEXTURE_EDGE);
            .               }
    1,128,926 ( 0.00%)      if (use_noise) {
            .                   cc_options |= SHADER_OPT(NOISE);
            .               }
    1,128,926 ( 0.00%)      if (use_2cyc) {
            .                   cc_options |= SHADER_OPT(_2CYC);
            .               }
    1,128,926 ( 0.00%)      if (alpha_threshold) {
        4,364 ( 0.00%)          cc_options |= SHADER_OPT(ALPHA_THRESHOLD);
            .               }
    1,128,926 ( 0.00%)      if (invisible) {
            .                   cc_options |= SHADER_OPT(INVISIBLE);
            .               }
    1,128,926 ( 0.00%)      if (use_grayscale) {
            .                   cc_options |= SHADER_OPT(GRAYSCALE);
            .               }
    1,693,389 ( 0.00%)      if (g_rdp.loaded_texture[0].masked) {
            .                   cc_options |= SHADER_OPT(TEXEL0_MASK);
            .               }
    1,693,389 ( 0.00%)      if (g_rdp.loaded_texture[1].masked) {
            .                   cc_options |= SHADER_OPT(TEXEL1_MASK);
            .               }
    1,693,389 ( 0.00%)      if (g_rdp.loaded_texture[0].blended) {
            .                   cc_options |= SHADER_OPT(TEXEL0_BLEND);
            .               }
    1,693,389 ( 0.00%)      if (g_rdp.loaded_texture[1].blended) {
            .                   cc_options |= SHADER_OPT(TEXEL1_BLEND);
            .               }
            .           
            .               ColorCombinerKey key;
    1,128,926 ( 0.00%)      key.combine_mode = g_rdp.combine_mode;
    1,128,926 ( 0.00%)      key.options = cc_options;
            .           
            .               // If we are not using alpha, clear the alpha components of the combiner as they have no effect
    2,257,852 ( 0.00%)      if (!use_alpha) {
    1,952,808 ( 0.00%)          key.combine_mode &= ~((0xfff << 16) | ((uint64_t)0xfff << 44));
            .               }
            .           
    2,257,852 ( 0.00%)      ColorCombiner* comb = gfx_lookup_or_create_color_combiner(key);
  113,879,404 ( 0.09%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_lookup_or_create_color_combiner(ColorCombinerKey const&) (564,463x)
            .           
      564,463 ( 0.00%)      uint32_t tm = 0;
            .               uint32_t tex_width[2], tex_height[2], tex_width2[2], tex_height2[2];
            .           
    5,644,630 ( 0.00%)      for (int i = 0; i < 2; i++) {
    5,644,630 ( 0.00%)          uint32_t tile = g_rdp.first_tile_index + i;
    6,773,556 ( 0.01%)          if (comb->used_textures[i]) {
    2,592,655 ( 0.00%)              if (g_rdp.textures_changed[i]) {
       33,429 ( 0.00%)                  gfx_flush();
  233,420,011 ( 0.19%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (33,429x)
      200,574 ( 0.00%)                  import_texture(i, tile, false);
  118,594,304 ( 0.10%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture(int, int, bool) (33,429x)
      334,290 ( 0.00%)                  if (g_rdp.loaded_texture[i].masked) {
            .                               import_texture_mask(SHADER_FIRST_MASK_TEXTURE + i, tile);
            .                           }
      334,290 ( 0.00%)                  if (g_rdp.loaded_texture[i].blended) {
            .                               import_texture(SHADER_FIRST_REPLACEMENT_TEXTURE + i, tile, true);
            .                           }
      100,287 ( 0.00%)                  g_rdp.textures_changed[i] = false;
            .                       }
            .           
    4,148,248 ( 0.00%)              uint8_t cms = g_rdp.texture_tile[tile].cms;
    4,148,248 ( 0.00%)              uint8_t cmt = g_rdp.texture_tile[tile].cmt;
            .           
    8,296,496 ( 0.01%)              uint32_t tex_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes;
    4,148,248 ( 0.00%)              uint32_t line_size = g_rdp.texture_tile[tile].line_size_bytes;
            .           
    1,037,062 ( 0.00%)              if (line_size == 0) {
            .                           line_size = 1;
            .                       }
            .           
    3,629,717 ( 0.00%)              tex_height[i] = tex_size_bytes / line_size;
    7,462,265 ( 0.01%)              switch (g_rdp.texture_tile[tile].siz) {
            .                           case G_IM_SIZ_4b:
       17,370 ( 0.00%)                      line_size <<= 1;
       17,370 ( 0.00%)                      break;
            .                           case G_IM_SIZ_8b:
       30,203 ( 0.00%)                      break;
            .                           case G_IM_SIZ_16b:
    1,399,626 ( 0.00%)                      line_size /= G_IM_SIZ_16b_LINE_BYTES;
      466,542 ( 0.00%)                      break;
            .                           case G_IM_SIZ_32b:
       13,248 ( 0.00%)                      line_size /= G_IM_SIZ_32b_LINE_BYTES; // this is 2!
       35,328 ( 0.00%)                      tex_height[i] /= 2;
        4,416 ( 0.00%)                      break;
            .                       }
    2,074,124 ( 0.00%)              tex_width[i] = line_size;
            .           
   14,000,337 ( 0.01%)              tex_width2[i] = (g_rdp.texture_tile[tile].lrs - g_rdp.texture_tile[tile].uls + 4) / 4;
   14,000,337 ( 0.01%)              tex_height2[i] = (g_rdp.texture_tile[tile].lrt - g_rdp.texture_tile[tile].ult + 4) / 4;
            .           
    3,629,717 ( 0.00%)              uint32_t tex_width1 = tex_width[i] << (cms & G_TX_MIRROR);
    3,629,717 ( 0.00%)              uint32_t tex_height1 = tex_height[i] << (cmt & G_TX_MIRROR);
            .           
    2,535,933 ( 0.00%)              if ((cms & G_TX_CLAMP) && ((cms & G_TX_MIRROR) || tex_width1 != tex_width2[i])) {
       51,060 ( 0.00%)                  tm |= 1 << 2 * i;
       10,212 ( 0.00%)                  cms &= ~G_TX_CLAMP;
            .                       }
    2,561,142 ( 0.00%)              if ((cmt & G_TX_CLAMP) && ((cmt & G_TX_MIRROR) || tex_height1 != tex_height2[i])) {
       61,272 ( 0.00%)                  tm |= 1 << 2 * i + 1;
       10,212 ( 0.00%)                  cmt &= ~G_TX_CLAMP;
            .                       }
            .           
    2,592,655 ( 0.00%)              bool linear_filter = (g_rdp.other_mode_h & (3U << G_MDSFT_TEXTFILT)) != G_TF_POINT;
    4,666,081 ( 0.00%)              if (linear_filter != rendering_state.textures[i]->second.linear_filter ||
    6,217,855 ( 0.01%)                  cms != rendering_state.textures[i]->second.cms || cmt != rendering_state.textures[i]->second.cmt) {
          396 ( 0.00%)                  gfx_flush();
        3,168 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (396x)
            .           
            .                           // Set the same sampler params on the blended texture. Needed for opengl.
        3,960 ( 0.00%)                  if (g_rdp.loaded_texture[i].blended) {
            .                               gfx_rapi->set_sampler_parameters(SHADER_FIRST_REPLACEMENT_TEXTURE + i, linear_filter, cms, cmt);
            .                           }
            .           
        3,168 ( 0.00%)                  gfx_rapi->set_sampler_parameters(i, linear_filter, cms, cmt);
      840,110 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_sampler_parameters(int, bool, unsigned int, unsigned int) (396x)
        2,376 ( 0.00%)                  rendering_state.textures[i]->second.linear_filter = linear_filter;
        2,376 ( 0.00%)                  rendering_state.textures[i]->second.cms = cms;
        2,376 ( 0.00%)                  rendering_state.textures[i]->second.cmt = cmt;
            .                       }
            .                   }
            .               }
            .           
    2,257,852 ( 0.00%)      struct ShaderProgram* prg = comb->prg[tm];
    1,128,926 ( 0.00%)      if (prg == NULL) {
           88 ( 0.00%)          comb->prg[tm] = prg =
          242 ( 0.00%)              gfx_lookup_or_create_shader_program(comb->shader_id0, comb->shader_id1 | tm * SHADER_OPT(TEXEL0_CLAMP_S));
   17,545,256 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_lookup_or_create_shader_program(unsigned long, unsigned int) (22x)
            .               }
    1,693,389 ( 0.00%)      if (prg != rendering_state.shader_program) {
       21,544 ( 0.00%)          gfx_flush();
   20,712,824 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (21,544x)
      107,720 ( 0.00%)          gfx_rapi->unload_shader(rendering_state.shader_program);
    5,773,504 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_unload_shader(ShaderProgram*) (21,544x)
      107,720 ( 0.00%)          gfx_rapi->load_shader(prg);
   99,707,003 ( 0.08%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_load_shader(ShaderProgram*) (21,544x)
       43,088 ( 0.00%)          rendering_state.shader_program = prg;
            .               }
    1,693,389 ( 0.00%)      if (use_alpha != rendering_state.alpha_blend) {
        3,647 ( 0.00%)          gfx_flush();
       29,176 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (3,647x)
       18,235 ( 0.00%)          gfx_rapi->set_use_alpha(use_alpha);
      286,289 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_use_alpha(bool) (3,647x)
        7,294 ( 0.00%)          rendering_state.alpha_blend = use_alpha;
            .               }
            .               uint8_t num_inputs;
            .               bool used_textures[2];
            .           
    4,515,704 ( 0.00%)      gfx_rapi->shader_get_info(prg, &num_inputs, used_textures);
   11,853,723 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_shader_get_info(ShaderProgram*, unsigned char*, bool*) (564,463x)
            .           
    2,257,852 ( 0.00%)      struct GfxClipParameters clip_parameters = gfx_rapi->get_clip_parameters();
   16,369,427 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_clip_parameters() (564,463x)
            .           
    7,338,019 ( 0.01%)      for (int i = 0; i < 3; i++) {
   16,933,890 ( 0.01%)          float z = v_arr[i]->z, w = v_arr[i]->w;
    5,080,167 ( 0.00%)          if (clip_parameters.z_is_from_0_to_1) {
            .                       z = (z + w) / 2.0f;
            .                   }
            .           
   13,547,112 ( 0.01%)          buf_vbo[buf_vbo_len++] = v_arr[i]->x;
   18,627,279 ( 0.02%)          buf_vbo[buf_vbo_len++] = clip_parameters.invert_y ? -v_arr[i]->y : v_arr[i]->y;
    8,466,945 ( 0.01%)          buf_vbo[buf_vbo_len++] = z;
    8,466,945 ( 0.01%)          buf_vbo[buf_vbo_len++] = w;
            .           
   16,933,890 ( 0.01%)          for (int t = 0; t < 2; t++) {
   20,320,668 ( 0.02%)              if (!used_textures[t]) {
    1,831,185 ( 0.00%)                  continue;
            .                       }
   10,889,151 ( 0.01%)              float u = v_arr[i]->u / 32.0f;
   10,889,151 ( 0.01%)              float v = v_arr[i]->v / 32.0f;
            .           
   20,222,709 ( 0.02%)              int shifts = g_rdp.texture_tile[g_rdp.first_tile_index + t].shifts;
   20,222,709 ( 0.02%)              int shiftt = g_rdp.texture_tile[g_rdp.first_tile_index + t].shiftt;
    3,111,186 ( 0.00%)              if (shifts != 0) {
            .                           if (shifts <= 10) {
            .                               u /= 1 << shifts;
            .                           } else {
            .                               u *= 1 << (16 - shifts);
            .                           }
            .                       }
    3,111,186 ( 0.00%)              if (shiftt != 0) {
            .                           if (shiftt <= 10) {
            .                               v /= 1 << shiftt;
            .                           } else {
            .                               v *= 1 << (16 - shiftt);
            .                           }
            .                       }
            .           
   28,000,674 ( 0.02%)              u -= g_rdp.texture_tile[g_rdp.first_tile_index + t].uls / 4.0f;
   28,000,674 ( 0.02%)              v -= g_rdp.texture_tile[g_rdp.first_tile_index + t].ult / 4.0f;
            .           
    6,222,372 ( 0.01%)              if ((g_rdp.other_mode_h & (3U << G_MDSFT_TEXTFILT)) != G_TF_POINT) {
            .                           // Linear filter adds 0.5f to the coordinates
    5,965,524 ( 0.00%)                  if (!is_rect) {
    5,762,292 ( 0.00%)                      u += 0.5f;
    5,762,292 ( 0.00%)                      v += 0.5f;
            .                           }
            .                       }
            .           
   21,778,302 ( 0.02%)              buf_vbo[buf_vbo_len++] = u / tex_width[t];
   21,778,302 ( 0.02%)              buf_vbo[buf_vbo_len++] = v / tex_height[t];
            .           
   12,444,744 ( 0.01%)              bool clampS = tm & (1 << 2 * t);
   14,000,337 ( 0.01%)              bool clampT = tm & (1 << 2 * t + 1);
            .           
    3,111,186 ( 0.00%)              if (clampS) {
      704,628 ( 0.00%)                  buf_vbo[buf_vbo_len++] = (tex_width2[t] - 0.5f) / tex_width[t];
            .                       }
            .           
    3,111,186 ( 0.00%)              if (clampT) {
      735,264 ( 0.00%)                  buf_vbo[buf_vbo_len++] = (tex_height2[t] - 0.5f) / tex_height[t];
            .                       }
            .                   }
            .           
    3,386,778 ( 0.00%)          if (use_fog) {
            .                       buf_vbo[buf_vbo_len++] = g_rdp.fog_color.r / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.fog_color.g / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.fog_color.b / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = v_arr[i]->color.a / 255.0f; // fog factor (not alpha)
            .                   }
            .           
    3,386,778 ( 0.00%)          if (use_grayscale) {
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.r / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.g / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.b / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.a / 255.0f; // lerp interpolation factor (not alpha)
            .                   }
            .           
   12,471,849 ( 0.01%)          for (int j = 0; j < num_inputs; j++) {
      462,303 ( 0.00%)              struct RGBA* color = 0;
            .                       struct RGBA tmp;
    7,877,880 ( 0.01%)              for (int k = 0; k < 1 + (use_alpha ? 1 : 0); k++) {
   12,339,207 ( 0.01%)                  switch (comb->shader_input_mapping[k][j]) {
            .                                   // Note: CCMUX constants and ACMUX constants used here have same value, which is why this works
            .                                   // (except LOD fraction).
            .                               case G_CCMUX_PRIMITIVE:
      183,768 ( 0.00%)                          color = &g_rdp.prim_color;
      183,768 ( 0.00%)                          break;
            .                               case G_CCMUX_SHADE:
    1,552,185 ( 0.00%)                          color = &v_arr[i]->color;
      310,437 ( 0.00%)                          break;
            .                               case G_CCMUX_ENVIRONMENT:
       46,320 ( 0.00%)                          color = &g_rdp.env_color;
       46,320 ( 0.00%)                          break;
            .                               case G_CCMUX_PRIMITIVE_ALPHA: {
            .                                   tmp.r = tmp.g = tmp.b = g_rdp.prim_color.a;
            .                                   color = &tmp;
            .                                   break;
            .                               }
            .                               case G_CCMUX_ENV_ALPHA: {
            .                                   tmp.r = tmp.g = tmp.b = g_rdp.env_color.a;
            .                                   color = &tmp;
-- line 1740 ----------------------------------------
-- line 1762 ----------------------------------------
            .                                   color = &tmp;
            .                                   break;
            .                               }
            .                               case G_ACMUX_PRIM_LOD_FRAC:
            .                                   tmp.a = g_rdp.prim_lod_fraction;
            .                                   color = &tmp;
            .                                   break;
            .                               default:
      775,962 ( 0.00%)                          memset(&tmp, 0, sizeof(tmp));
    1,939,905 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (129,327x)
      258,654 ( 0.00%)                          color = &tmp;
      129,327 ( 0.00%)                          break;
            .                           }
    1,339,704 ( 0.00%)                  if (k == 0) {
    4,623,030 ( 0.00%)                      buf_vbo[buf_vbo_len++] = color->r / 255.0f;
    4,623,030 ( 0.00%)                      buf_vbo[buf_vbo_len++] = color->g / 255.0f;
    5,085,333 ( 0.00%)                      buf_vbo[buf_vbo_len++] = color->b / 255.0f;
            .                           } else {
      415,098 ( 0.00%)                      if (use_fog && color == &v_arr[i]->color) {
            .                                   // Shade alpha is 100% for fog
            .                                   buf_vbo[buf_vbo_len++] = 1.0f;
            .                               } else {
    2,075,490 ( 0.00%)                          buf_vbo[buf_vbo_len++] = color->a / 255.0f;
            .                               }
            .                           }
            .                       }
            .                   }
            .           
            .                   // struct RGBA *color = &v_arr[i]->color;
            .                   // buf_vbo[buf_vbo_len++] = color->r / 255.0f;
            .                   // buf_vbo[buf_vbo_len++] = color->g / 255.0f;
            .                   // buf_vbo[buf_vbo_len++] = color->b / 255.0f;
            .                   // buf_vbo[buf_vbo_len++] = color->a / 255.0f;
            .               }
            .           
    4,515,704 ( 0.00%)      if (++buf_vbo_num_tris == MAX_BUFFERED) {
            .                   // if (++buf_vbo_num_tris == 1) {
        1,958 ( 0.00%)          gfx_flush();
   30,779,031 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (979x)
            .               }
  198,157,732 ( 0.16%)  }
            .           
      951,640 ( 0.00%)  static void gfx_sp_geometry_mode(uint32_t clear, uint32_t set) {
    1,189,550 ( 0.00%)      g_rsp.geometry_mode &= ~clear;
      713,730 ( 0.00%)      g_rsp.geometry_mode |= set;
      713,730 ( 0.00%)  }
            .           
            .           static void gfx_sp_extra_geometry_mode(uint32_t clear, uint32_t set) {
            .               g_rsp.extra_geometry_mode &= ~clear;
            .               g_rsp.extra_geometry_mode |= set;
            .           }
            .           
      107,524 ( 0.00%)  static void gfx_adjust_viewport_or_scissor(XYWidthHeight* area) {
      107,524 ( 0.00%)      if (!fbActive) {
            .                   // Adjust the y origin based on the y-inversion for the active framebuffer
      107,524 ( 0.00%)          GfxClipParameters clipParameters = gfx_rapi->get_clip_parameters();
      779,549 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_clip_parameters() (26,881x)
       80,643 ( 0.00%)          if (clipParameters.invert_y) {
            .                       area->y -= area->height;
            .                   } else {
      268,810 ( 0.00%)              area->y = gfx_native_dimensions.height - area->y;
            .                   }
            .           
      940,835 ( 0.00%)          area->width *= RATIO_X;
      940,835 ( 0.00%)          area->height *= RATIO_Y;
      860,192 ( 0.00%)          area->x *= RATIO_X;
      860,192 ( 0.00%)          area->y *= RATIO_Y;
            .           
      107,524 ( 0.00%)          if (!game_renders_to_framebuffer ||
            .                       (gfx_msaa_level > 1 && gfx_current_dimensions.width == gfx_current_game_window_viewport.width &&
            .                        gfx_current_dimensions.height == gfx_current_game_window_viewport.height)) {
      215,048 ( 0.00%)              area->x += gfx_current_game_window_viewport.x;
      295,691 ( 0.00%)              area->y += gfx_current_window_dimensions.height -
      107,524 ( 0.00%)                         (gfx_current_game_window_viewport.y + gfx_current_game_window_viewport.height);
            .                   }
            .               } else {
            .                   area->y = active_fb->second.orig_height - area->y;
            .           
            .                   if (active_fb->second.resize) {
            .                       area->width *= RATIO_X;
            .                       area->height *= RATIO_Y;
            .                       area->x *= RATIO_X;
            .                       area->y *= RATIO_Y;
            .                   }
            .               }
      107,524 ( 0.00%)  }
            .           
       10,128 ( 0.00%)  static void gfx_calc_and_set_viewport(const F3DVp_t* viewport) {
            .               // 2 bits fraction
       20,256 ( 0.00%)      float width = 2.0f * viewport->vscale[0] / 4.0f;
       20,256 ( 0.00%)      float height = 2.0f * viewport->vscale[1] / 4.0f;
       27,852 ( 0.00%)      float x = (viewport->vtrans[0] / 4.0f) - width / 2.0f;
       27,852 ( 0.00%)      float y = ((viewport->vtrans[1] / 4.0f) + height / 2.0f);
            .           
        7,596 ( 0.00%)      g_rdp.viewport.x = x;
        7,596 ( 0.00%)      g_rdp.viewport.y = y;
        7,596 ( 0.00%)      g_rdp.viewport.width = width;
        7,596 ( 0.00%)      g_rdp.viewport.height = height;
            .           
        5,064 ( 0.00%)      gfx_adjust_viewport_or_scissor(&g_rdp.viewport);
      554,508 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) (2,532x)
            .           
        2,532 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
        7,596 ( 0.00%)  }
            .           
            .           static void gfx_sp_movemem_f3dex2(uint8_t index, uint8_t offset, const void* data) {
            .               switch (index) {
            .                   case F3DEX2_G_MV_VIEWPORT:
            .                       gfx_calc_and_set_viewport((const F3DVp_t*)data);
            .                       break;
            .                   case F3DEX2_G_MV_LIGHT: {
            .                       int lightidx = offset / 24 - 2;
-- line 1869 ----------------------------------------
-- line 1873 ----------------------------------------
            .                       } else if (lightidx < 0) {
            .                           memcpy(g_rsp.lookat + offset / 24, data, sizeof(F3DLight_t)); // TODO Light?
            .                       }
            .                       break;
            .                   }
            .               }
            .           }
            .           
       41,958 ( 0.00%)  static void gfx_sp_movemem_f3d(uint8_t index, uint8_t offset, const void* data) {
       93,120 ( 0.00%)      switch (index) {
            .                   case F3DEX_G_MV_VIEWPORT:
        7,596 ( 0.00%)              gfx_calc_and_set_viewport((const F3DVp_t*)data);
      706,428 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_calc_and_set_viewport(F3DVp_t const*) (2,532x)
        2,532 ( 0.00%)              break;
            .                   case F3DEX_G_MV_LOOKATY:
            .                   case F3DEX_G_MV_LOOKATX:
            .                       memcpy(g_rsp.lookat + (index - F3DEX_G_MV_LOOKATY) / 2, data, sizeof(F3DLight_t));
            .                       break;
            .                   case F3DEX_G_MV_L0:
            .                   case F3DEX_G_MV_L1:
            .                   case F3DEX_G_MV_L2:
            .                   case F3DEX_G_MV_L3:
            .                   case F3DEX_G_MV_L4:
            .                   case F3DEX_G_MV_L5:
            .                   case F3DEX_G_MV_L6:
            .                   case F3DEX_G_MV_L7:
            .                       // NOTE: reads out of bounds if it is an ambient light
       31,950 ( 0.00%)              memcpy(g_rsp.current_lights + (index - F3DEX_G_MV_L0) / 2, data, sizeof(F3DLight_t));
       27,690 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,130x)
        2,130 ( 0.00%)              break;
            .               }
       13,986 ( 0.00%)  }
            .           
            .           static void gfx_sp_moveword_f3dex2(uint8_t index, uint16_t offset, uintptr_t data) {
            .               switch (index) {
            .                   case G_MW_NUMLIGHT:
            .                       g_rsp.current_num_lights = data / 24 + 1; // add ambient light
            .                       g_rsp.lights_changed = 1;
            .                       break;
            .                   case G_MW_FOG:
-- line 1910 ----------------------------------------
-- line 1913 ----------------------------------------
            .                       break;
            .                   case G_MW_SEGMENT:
            .                       int segNumber = offset / 4;
            .                       gSegmentPointers[segNumber] = data;
            .                       break;
            .               }
            .           }
            .           
      133,240 ( 0.00%)  static void gfx_sp_moveword_f3d(uint8_t index, uint16_t offset, uintptr_t data) {
      143,367 ( 0.00%)      switch (index) {
            .                   case G_MW_NUMLIGHT:
            .                       // Ambient light is included
            .                       // The 31th bit is a flag that lights should be recalculated
        4,536 ( 0.00%)              g_rsp.current_num_lights = (data - 0x80000000U) / 32;
        1,134 ( 0.00%)              g_rsp.lights_changed = 1;
        1,134 ( 0.00%)              break;
            .                   case G_MW_FOG:
            .                       g_rsp.fog_mul = (int16_t)(data >> 16);
            .                       g_rsp.fog_offset = (int16_t)data;
            .                       break;
            .                   case G_MW_SEGMENT:
       30,144 ( 0.00%)              int segNumber = offset / 4;
       30,144 ( 0.00%)              gSegmentPointers[segNumber] = data;
        7,536 ( 0.00%)              break;
            .               }
       56,885 ( 0.00%)  }
            .           
      968,583 ( 0.00%)  static void gfx_sp_texture(uint16_t sc, uint16_t tc, uint8_t level, uint8_t tile, uint8_t on) {
      176,106 ( 0.00%)      g_rsp.texture_scaling_factor.s = sc;
      176,106 ( 0.00%)      g_rsp.texture_scaling_factor.t = tc;
      264,159 ( 0.00%)      if (g_rdp.first_tile_index != tile) {
          150 ( 0.00%)          g_rdp.textures_changed[0] = true;
          150 ( 0.00%)          g_rdp.textures_changed[1] = true;
            .               }
            .           
      176,106 ( 0.00%)      g_rdp.first_tile_index = tile;
      264,159 ( 0.00%)  }
            .           
       39,968 ( 0.00%)  static void gfx_dp_set_scissor(uint32_t mode, uint32_t ulx, uint32_t uly, uint32_t lrx, uint32_t lry) {
       39,968 ( 0.00%)      float x = ulx / 4.0f;
       39,968 ( 0.00%)      float y = lry / 4.0f;
       49,960 ( 0.00%)      float width = (lrx - ulx) / 4.0f;
       49,960 ( 0.00%)      float height = (lry - uly) / 4.0f;
            .           
       14,988 ( 0.00%)      g_rdp.scissor.x = x;
       14,988 ( 0.00%)      g_rdp.scissor.y = y;
       14,988 ( 0.00%)      g_rdp.scissor.width = width;
       14,988 ( 0.00%)      g_rdp.scissor.height = height;
            .           
        9,992 ( 0.00%)      gfx_adjust_viewport_or_scissor(&g_rdp.scissor);
    1,094,124 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) (4,996x)
            .           
        4,996 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
       14,988 ( 0.00%)  }
            .           
            .           static void gfx_dp_set_texture_image(uint32_t format, uint32_t size, uint32_t width, const char* texPath,
      645,948 ( 0.00%)                                       uint32_t texFlags, RawTexMetadata rawTexMetdata, const void* addr) {
            .               // fprintf(stderr, "gfx_dp_set_texture_image: %s (width=%d; size=0x%X)\n",
            .               //         rawTexMetdata.resource ? rawTexMetdata.resource->GetInitData()->Path.c_str() : nullptr, width, size);
      143,544 ( 0.00%)      g_rdp.texture_to_load.addr = (const uint8_t*)addr;
      143,544 ( 0.00%)      g_rdp.texture_to_load.siz = size;
      143,544 ( 0.00%)      g_rdp.texture_to_load.width = width;
      143,544 ( 0.00%)      g_rdp.texture_to_load.tex_flags = texFlags;
      287,088 ( 0.00%)      g_rdp.texture_to_load.raw_tex_metadata = rawTexMetdata;
    7,632,622 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::operator=(RawTexMetadata const&) (71,772x)
      215,316 ( 0.00%)  }
            .           
            .           static void gfx_dp_set_tile(uint8_t fmt, uint32_t siz, uint32_t line, uint32_t tmem, uint8_t tile, uint32_t palette,
            .                                       uint32_t cmt, uint32_t maskt, uint32_t shiftt, uint32_t cms, uint32_t masks,
    1,465,178 ( 0.00%)                              uint32_t shifts) {
            .               // OTRTODO:
            .               // SUPPORT_CHECK(tmem == 0 || tmem == 256);
            .           
      460,430 ( 0.00%)      if (cms == G_TX_WRAP && masks == G_TX_NOMASK) {
       49,038 ( 0.00%)          cms = G_TX_CLAMP;
            .               }
      458,744 ( 0.00%)      if (cmt == G_TX_WRAP && maskt == G_TX_NOMASK) {
       49,038 ( 0.00%)          cmt = G_TX_CLAMP;
            .               }
            .           
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].palette = palette; // palette should set upper 4 bits of color index in 4b mode
    1,198,782 ( 0.00%)      g_rdp.texture_tile[tile].fmt = fmt;
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].siz = siz;
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].cms = cms;
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].cmt = cmt;
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].shifts = shifts;
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].shiftt = shiftt;
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].line_size_bytes = line * 8;
            .           
    1,331,980 ( 0.00%)      g_rdp.texture_tile[tile].tmem = tmem;
            .               // g_rdp.texture_tile[tile].tmem_index = tmem / 256; // tmem is the 64-bit word offset, so 256 words means 2 kB
            .           
    1,065,584 ( 0.00%)      g_rdp.texture_tile[tile].tmem_index =
      399,594 ( 0.00%)          tmem != 0; // assume one texture is loaded at address 0 and another texture at any other address
            .           
      133,198 ( 0.00%)      g_rdp.textures_changed[0] = true;
      133,198 ( 0.00%)      g_rdp.textures_changed[1] = true;
      399,594 ( 0.00%)  }
            .           
      712,206 ( 0.00%)  static void gfx_dp_set_tile_size(uint8_t tile, uint16_t uls, uint16_t ult, uint16_t lrs, uint16_t lrt) {
      582,714 ( 0.00%)      g_rdp.texture_tile[tile].uls = uls;
      582,714 ( 0.00%)      g_rdp.texture_tile[tile].ult = ult;
      582,714 ( 0.00%)      g_rdp.texture_tile[tile].lrs = lrs;
      582,714 ( 0.00%)      g_rdp.texture_tile[tile].lrt = lrt;
       64,746 ( 0.00%)      g_rdp.textures_changed[0] = true;
       64,746 ( 0.00%)      g_rdp.textures_changed[1] = true;
      194,238 ( 0.00%)  }
            .           
       17,592 ( 0.00%)  static void gfx_dp_load_tlut(uint8_t tile, uint32_t high_index) {
        5,864 ( 0.00%)      SUPPORT_CHECK(tile == G_TX_LOADTILE);
        8,796 ( 0.00%)      SUPPORT_CHECK(g_rdp.texture_to_load.siz == G_IM_SIZ_16b);
            .               // BENTODO
            .               // SUPPORT_CHECK((g_rdp.texture_tile[tile].tmem == 256 && (high_index <= 127 || high_index == 255)) ||
            .               //              (g_rdp.texture_tile[tile].tmem == 384 && high_index == 127));
            .           
       29,320 ( 0.00%)      if (g_rdp.texture_tile[tile].tmem == 256) {
        5,864 ( 0.00%)          g_rdp.palettes[0] = g_rdp.texture_to_load.addr;
        5,864 ( 0.00%)          if (high_index == 255) {
        8,589 ( 0.00%)              g_rdp.palettes[1] = g_rdp.texture_to_load.addr + 2 * 128;
            .                   }
            .               } else {
            .                   g_rdp.palettes[1] = g_rdp.texture_to_load.addr;
            .               }
       11,659 ( 0.00%)  }
            .           
      576,037 ( 0.00%)  static void gfx_dp_load_block(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t lrs, uint32_t dxt) {
      104,734 ( 0.00%)      SUPPORT_CHECK(uls == 0);
      104,734 ( 0.00%)      SUPPORT_CHECK(ult == 0);
            .           
            .               // The lrs field rather seems to be number of pixels to load
       52,367 ( 0.00%)      uint32_t word_size_shift = 0;
      418,936 ( 0.00%)      switch (g_rdp.texture_to_load.siz) {
            .                   case G_IM_SIZ_4b:
            .                       word_size_shift = -1;
            .                       break;
            .                   case G_IM_SIZ_8b:
            .                       word_size_shift = 0;
            .                       break;
            .                   case G_IM_SIZ_16b:
       52,367 ( 0.00%)              word_size_shift = 1;
       52,367 ( 0.00%)              break;
            .                   case G_IM_SIZ_32b:
            .                       word_size_shift = 2;
            .                       break;
            .               }
       52,367 ( 0.00%)      uint32_t orig_size_bytes =
      366,569 ( 0.00%)          word_size_shift > 0 ? (lrs + 1) << word_size_shift : (lrs + 1) >> (-(int64_t)word_size_shift);
      104,734 ( 0.00%)      uint32_t size_bytes = orig_size_bytes;
      680,771 ( 0.00%)      if (g_rdp.texture_to_load.raw_tex_metadata.h_byte_scale != 1 ||
       52,367 ( 0.00%)          g_rdp.texture_to_load.raw_tex_metadata.v_pixel_scale != 1) {
            .                   size_bytes *= g_rdp.texture_to_load.raw_tex_metadata.h_byte_scale;
            .                   size_bytes *= g_rdp.texture_to_load.raw_tex_metadata.v_pixel_scale;
            .               }
      890,239 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes = orig_size_bytes;
      890,239 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes = size_bytes;
      890,239 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes = size_bytes;
      890,239 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes = size_bytes;
            .               // assert(size_bytes <= 4096 && "bug: too big texture");
      890,239 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].tex_flags = g_rdp.texture_to_load.tex_flags;
    1,047,340 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata = g_rdp.texture_to_load.raw_tex_metadata;
    5,747,150 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::operator=(RawTexMetadata const&) (52,367x)
      890,239 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr = g_rdp.texture_to_load.addr;
            .               // fprintf(stderr, "gfx_dp_load_block: line_size = 0x%x; orig = 0x%x; bpp=%d; lrs=%d\n", size_bytes,
            .               // orig_size_bytes,
            .               //         g_rdp.texture_to_load.siz, lrs);
            .           
            .               const std::string& texPath =
      209,468 ( 0.00%)          g_rdp.texture_to_load.raw_tex_metadata.resource != nullptr
    1,047,340 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<LUS::Texture>(std::shared_ptr<LUS::Texture> const&, decltype(nullptr)) (52,367x)
      822,402 ( 0.00%)              ? gfx_get_base_texture_path(g_rdp.texture_to_load.raw_tex_metadata.resource->GetInitData()->Path)
    3,984,071 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.cpp:Ship::IResource::GetInitData() (43,781x)
    3,590,042 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (43,781x)
    1,094,525 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (43,781x)
    1,094,525 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (43,781x)
      750,310 ( 0.00%)              : "";
   42,432,102 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_get_base_texture_path(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (43,781x)
   12,373,213 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (52,367x)
    2,644,488 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (8,586x)
      261,835 ( 0.00%)      auto maskedTextureIter = masked_textures.find(texPath);
    8,483,454 ( 0.01%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MaskedTextureEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::find(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (52,367x)
      576,037 ( 0.00%)      if (maskedTextureIter != masked_textures.end()) {
    1,675,744 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MaskedTextureEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::end() (52,367x)
      628,404 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > const&, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > const&) (52,367x)
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = true;
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended =
            .                       maskedTextureIter->second.replacementData != nullptr;
            .               } else {
      837,872 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = false;
      837,872 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended = false;
            .               }
            .           
      576,037 ( 0.00%)      g_rdp.textures_changed[g_rdp.texture_tile[tile].tmem_index] = true;
      314,202 ( 0.00%)  }
            .           
      144,683 ( 0.00%)  static void gfx_dp_load_tile(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t lrs, uint32_t lrt) {
       26,306 ( 0.00%)      SUPPORT_CHECK(tile == G_TX_LOADTILE);
            .           
       13,153 ( 0.00%)      uint32_t word_size_shift = 0;
      110,012 ( 0.00%)      switch (g_rdp.texture_to_load.siz) {
            .                   case G_IM_SIZ_4b:
            .                       word_size_shift = 0;
            .                       break;
            .                   case G_IM_SIZ_8b:
        2,270 ( 0.00%)              word_size_shift = 0;
        2,270 ( 0.00%)              break;
            .                   case G_IM_SIZ_16b:
        8,675 ( 0.00%)              word_size_shift = 1;
        8,675 ( 0.00%)              break;
            .                   case G_IM_SIZ_32b:
        2,208 ( 0.00%)              word_size_shift = 2;
        2,208 ( 0.00%)              break;
            .               }
            .           
       39,459 ( 0.00%)      uint32_t offset_x = uls >> G_TEXTURE_IMAGE_FRAC;
       39,459 ( 0.00%)      uint32_t offset_y = ult >> G_TEXTURE_IMAGE_FRAC;
       65,765 ( 0.00%)      uint32_t tile_width = ((lrs - uls) >> G_TEXTURE_IMAGE_FRAC) + 1;
       65,765 ( 0.00%)      uint32_t tile_height = ((lrt - ult) >> G_TEXTURE_IMAGE_FRAC) + 1;
       39,459 ( 0.00%)      uint32_t full_image_width = g_rdp.texture_to_load.width + 1;
            .           
       52,612 ( 0.00%)      uint32_t offset_x_in_bytes = offset_x << word_size_shift;
       52,612 ( 0.00%)      uint32_t tile_line_size_bytes = tile_width << word_size_shift;
       52,612 ( 0.00%)      uint32_t full_image_line_size_bytes = full_image_width << word_size_shift;
            .           
       39,459 ( 0.00%)      uint32_t orig_size_bytes = tile_line_size_bytes * tile_height;
       26,306 ( 0.00%)      uint32_t size_bytes = orig_size_bytes;
       78,918 ( 0.00%)      uint32_t start_offset_bytes = full_image_line_size_bytes * offset_y + offset_x_in_bytes;
            .           
       26,306 ( 0.00%)      float h_byte_scale = g_rdp.texture_to_load.raw_tex_metadata.h_byte_scale;
       26,306 ( 0.00%)      float v_pixel_scale = g_rdp.texture_to_load.raw_tex_metadata.v_pixel_scale;
            .           
      157,836 ( 0.00%)      if (h_byte_scale != 1 || v_pixel_scale != 1) {
            .                   start_offset_bytes = h_byte_scale * (v_pixel_scale * offset_y * full_image_line_size_bytes + offset_x_in_bytes);
            .                   size_bytes *= h_byte_scale * v_pixel_scale;
            .                   full_image_line_size_bytes *= h_byte_scale;
            .                   tile_line_size_bytes *= h_byte_scale;
            .               }
            .           
      223,601 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes = orig_size_bytes;
      223,601 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes = size_bytes;
      223,601 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes = full_image_line_size_bytes;
      223,601 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes = tile_line_size_bytes;
            .           
            .               //    assert(size_bytes <= 4096 && "bug: too big texture");
      223,601 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].tex_flags = g_rdp.texture_to_load.tex_flags;
      263,060 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata = g_rdp.texture_to_load.raw_tex_metadata;
    1,287,113 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::operator=(RawTexMetadata const&) (13,153x)
      249,907 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr = g_rdp.texture_to_load.addr + start_offset_bytes;
            .           
            .               const std::string& texPath =
       52,612 ( 0.00%)          g_rdp.texture_to_load.raw_tex_metadata.resource != nullptr
      263,060 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<LUS::Texture>(std::shared_ptr<LUS::Texture> const&, decltype(nullptr)) (13,153x)
       89,922 ( 0.00%)              ? gfx_get_base_texture_path(g_rdp.texture_to_load.raw_tex_metadata.resource->GetInitData()->Path)
      242,515 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.cpp:Ship::IResource::GetInitData() (2,665x)
      218,530 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (2,665x)
       66,625 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (2,665x)
       66,625 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (2,665x)
      205,118 ( 0.00%)              : "";
    3,230,304 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (10,488x)
    2,579,908 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_get_base_texture_path(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (2,665x)
    1,749,695 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (13,153x)
       65,765 ( 0.00%)      auto maskedTextureIter = masked_textures.find(texPath);
    2,130,786 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MaskedTextureEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::find(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (13,153x)
      144,683 ( 0.00%)      if (maskedTextureIter != masked_textures.end()) {
      420,896 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MaskedTextureEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::end() (13,153x)
      157,836 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > const&, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > const&) (13,153x)
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = true;
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended =
            .                       maskedTextureIter->second.replacementData != nullptr;
            .               } else {
      210,448 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = false;
      210,448 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended = false;
            .               }
            .           
      131,530 ( 0.00%)      g_rdp.texture_tile[tile].uls = uls;
      131,530 ( 0.00%)      g_rdp.texture_tile[tile].ult = ult;
      131,530 ( 0.00%)      g_rdp.texture_tile[tile].lrs = lrs;
      131,530 ( 0.00%)      g_rdp.texture_tile[tile].lrt = lrt;
            .           
      144,683 ( 0.00%)      g_rdp.textures_changed[g_rdp.texture_tile[tile].tmem_index] = true;
       78,918 ( 0.00%)  }
            .           
            .           /*static uint8_t color_comb_component(uint32_t v) {
            .               switch (v) {
            .                   case G_CCMUX_TEXEL0:
            .                       return CC_TEXEL0;
            .                   case G_CCMUX_TEXEL1:
            .                       return CC_TEXEL1;
            .                   case G_CCMUX_PRIMITIVE:
-- line 2174 ----------------------------------------
-- line 2192 ----------------------------------------
            .                      (color_comb_component(c) << 6) |
            .                      (color_comb_component(d) << 9);
            .           }
            .           
            .           static void gfx_dp_set_combine_mode(uint32_t rgb, uint32_t alpha) {
            .               g_rdp.combine_mode = rgb | (alpha << 12);
            .           }*/
            .           
      612,696 ( 0.00%)  static void gfx_dp_set_combine_mode(uint32_t rgb, uint32_t alpha, uint32_t rgb_cyc2, uint32_t alpha_cyc2) {
    1,123,276 ( 0.00%)      g_rdp.combine_mode = rgb | (alpha << 16) | ((uint64_t)rgb_cyc2 << 28) | ((uint64_t)alpha_cyc2 << 44);
      306,348 ( 0.00%)  }
            .           
    1,181,094 ( 0.00%)  static inline uint32_t color_comb(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {
    2,952,735 ( 0.00%)      return (a & 0xf) | ((b & 0xf) << 4) | ((c & 0x1f) << 8) | ((d & 7) << 13);
      393,698 ( 0.00%)  }
            .           
    1,181,094 ( 0.00%)  static inline uint32_t alpha_comb(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {
    2,952,735 ( 0.00%)      return (a & 7) | ((b & 7) << 3) | ((c & 7) << 6) | ((d & 7) << 9);
      393,698 ( 0.00%)  }
            .           
            .           static void gfx_dp_set_grayscale_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               g_rdp.grayscale_color.r = r;
            .               g_rdp.grayscale_color.g = g;
            .               g_rdp.grayscale_color.b = b;
            .               g_rdp.grayscale_color.a = a;
            .           }
            .           
       70,416 ( 0.00%)  static void gfx_dp_set_env_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
       15,648 ( 0.00%)      g_rdp.env_color.r = r;
       15,648 ( 0.00%)      g_rdp.env_color.g = g;
       15,648 ( 0.00%)      g_rdp.env_color.b = b;
       15,648 ( 0.00%)      g_rdp.env_color.a = a;
       23,472 ( 0.00%)  }
            .           
      292,575 ( 0.00%)  static void gfx_dp_set_prim_color(uint8_t m, uint8_t l, uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
       39,010 ( 0.00%)      g_rdp.prim_lod_fraction = l;
       39,010 ( 0.00%)      g_rdp.prim_color.r = r;
       39,010 ( 0.00%)      g_rdp.prim_color.g = g;
       39,010 ( 0.00%)      g_rdp.prim_color.b = b;
       39,010 ( 0.00%)      g_rdp.prim_color.a = a;
       58,515 ( 0.00%)  }
            .           
            .           static void gfx_dp_set_fog_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               g_rdp.fog_color.r = r;
            .               g_rdp.fog_color.g = g;
            .               g_rdp.fog_color.b = b;
            .               g_rdp.fog_color.a = a;
            .           }
            .           
            .           static void gfx_dp_set_blend_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               // TODO: Implement this command..
            .           }
            .           
        3,186 ( 0.00%)  static void gfx_dp_set_fill_color(uint32_t packed_color) {
        2,124 ( 0.00%)      uint16_t col16 = (uint16_t)packed_color;
        4,248 ( 0.00%)      uint32_t r = col16 >> 11;
        5,310 ( 0.00%)      uint32_t g = (col16 >> 6) & 0x1f;
        5,310 ( 0.00%)      uint32_t b = (col16 >> 1) & 0x1f;
        3,186 ( 0.00%)      uint32_t a = col16 & 1;
       14,868 ( 0.00%)      g_rdp.fill_color.r = SCALE_5_8(r);
       14,868 ( 0.00%)      g_rdp.fill_color.g = SCALE_5_8(g);
       14,868 ( 0.00%)      g_rdp.fill_color.b = SCALE_5_8(b);
        3,186 ( 0.00%)      g_rdp.fill_color.a = a * 255;
        3,186 ( 0.00%)  }
            .           
      174,177 ( 0.00%)  static void gfx_draw_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
       38,706 ( 0.00%)      uint32_t saved_other_mode_h = g_rdp.other_mode_h;
       58,059 ( 0.00%)      uint32_t cycle_type = (g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
            .           
       38,706 ( 0.00%)      if (cycle_type == G_CYC_COPY) {
       21,375 ( 0.00%)          g_rdp.other_mode_h = (g_rdp.other_mode_h & ~(3U << G_MDSFT_TEXTFILT)) | G_TF_POINT;
            .               }
            .           
            .               // U10.2 coordinates
       38,706 ( 0.00%)      float ulxf = ulx;
       38,706 ( 0.00%)      float ulyf = uly;
       38,706 ( 0.00%)      float lrxf = lrx;
       38,706 ( 0.00%)      float lryf = lry;
            .           
      329,001 ( 0.00%)      ulxf = ulxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
      329,001 ( 0.00%)      ulyf = -(ulyf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
      329,001 ( 0.00%)      lrxf = lrxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
      329,001 ( 0.00%)      lryf = -(lryf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
            .           
       96,765 ( 0.00%)      ulxf = gfx_adjust_x_for_aspect_ratio(ulxf);
      483,825 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_x_for_aspect_ratio(float) (19,353x)
       96,765 ( 0.00%)      lrxf = gfx_adjust_x_for_aspect_ratio(lrxf);
      483,825 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_x_for_aspect_ratio(float) (19,353x)
            .           
       19,353 ( 0.00%)      struct LoadedVertex* ul = &g_rsp.loaded_vertices[MAX_VERTICES + 0];
       19,353 ( 0.00%)      struct LoadedVertex* ll = &g_rsp.loaded_vertices[MAX_VERTICES + 1];
       19,353 ( 0.00%)      struct LoadedVertex* lr = &g_rsp.loaded_vertices[MAX_VERTICES + 2];
       19,353 ( 0.00%)      struct LoadedVertex* ur = &g_rsp.loaded_vertices[MAX_VERTICES + 3];
            .           
       58,059 ( 0.00%)      ul->x = ulxf;
       58,059 ( 0.00%)      ul->y = ulyf;
       58,059 ( 0.00%)      ul->z = -1.0f;
       58,059 ( 0.00%)      ul->w = 1.0f;
            .           
       58,059 ( 0.00%)      ll->x = ulxf;
       58,059 ( 0.00%)      ll->y = lryf;
       58,059 ( 0.00%)      ll->z = -1.0f;
       58,059 ( 0.00%)      ll->w = 1.0f;
            .           
       58,059 ( 0.00%)      lr->x = lrxf;
       58,059 ( 0.00%)      lr->y = lryf;
       58,059 ( 0.00%)      lr->z = -1.0f;
       58,059 ( 0.00%)      lr->w = 1.0f;
            .           
       58,059 ( 0.00%)      ur->x = lrxf;
       58,059 ( 0.00%)      ur->y = ulyf;
       58,059 ( 0.00%)      ur->z = -1.0f;
       58,059 ( 0.00%)      ur->w = 1.0f;
            .           
            .               // The coordinates for texture rectangle shall bypass the viewport setting
            .               struct XYWidthHeight default_viewport;
       77,412 ( 0.00%)      if (!fbActive) {
      154,824 ( 0.00%)          default_viewport = { 0, (int16_t)gfx_native_dimensions.height, gfx_native_dimensions.width,
       19,353 ( 0.00%)                               gfx_native_dimensions.height };
            .               } else {
            .                   default_viewport = { 0, (int16_t)active_fb->second.orig_height, active_fb->second.orig_width,
            .                                        active_fb->second.orig_height };
            .               }
            .           
       77,412 ( 0.00%)      struct XYWidthHeight viewport_saved = g_rdp.viewport;
       38,706 ( 0.00%)      uint32_t geometry_mode_saved = g_rsp.geometry_mode;
            .           
       58,059 ( 0.00%)      gfx_adjust_viewport_or_scissor(&default_viewport);
    4,238,307 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) (19,353x)
            .           
       77,412 ( 0.00%)      g_rdp.viewport = default_viewport;
       19,353 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
       19,353 ( 0.00%)      g_rsp.geometry_mode = 0;
            .           
       96,765 ( 0.00%)      gfx_sp_tri1(MAX_VERTICES + 0, MAX_VERTICES + 1, MAX_VERTICES + 3, true);
  209,546,509 ( 0.17%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (19,353x)
       96,765 ( 0.00%)      gfx_sp_tri1(MAX_VERTICES + 1, MAX_VERTICES + 2, MAX_VERTICES + 3, true);
   78,926,551 ( 0.07%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (19,353x)
            .           
       38,706 ( 0.00%)      g_rsp.geometry_mode = geometry_mode_saved;
       77,412 ( 0.00%)      g_rdp.viewport = viewport_saved;
       19,353 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
            .           
       38,706 ( 0.00%)      if (cycle_type == G_CYC_COPY) {
       14,250 ( 0.00%)          g_rdp.other_mode_h = saved_other_mode_h;
            .               }
      116,118 ( 0.00%)  }
            .           
            .           static void gfx_dp_texture_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry, uint8_t tile, int16_t uls,
      391,902 ( 0.00%)                                       int16_t ult, int16_t dsdx, int16_t dtdy, bool flip) {
            .               // printf("render %d at %d\n", tile, lrx);
       37,324 ( 0.00%)      uint64_t saved_combine_mode = g_rdp.combine_mode;
       74,648 ( 0.00%)      if ((g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE)) == G_CYC_COPY) {
            .                   // Per RDP Command Summary Set Tile's shift s and this dsdx should be set to 4 texels
            .                   // Divide by 4 to get 1 instead
        7,125 ( 0.00%)          dsdx >>= 2;
            .           
            .                   // Color combiner is turned off in copy mode
      114,000 ( 0.00%)          gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_TEXEL0), alpha_comb(0, 0, 0, G_ACMUX_TEXEL0), 0, 0);
      163,875 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:alpha_comb(unsigned int, unsigned int, unsigned int, unsigned int) (7,125x)
      163,875 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:color_comb(unsigned int, unsigned int, unsigned int, unsigned int) (7,125x)
      142,500 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_combine_mode(unsigned int, unsigned int, unsigned int, unsigned int) (7,125x)
            .           
            .                   // Per documentation one extra pixel is added in this modes to each edge
        7,125 ( 0.00%)          lrx += 1 << 2;
        7,125 ( 0.00%)          lry += 1 << 2;
            .               }
            .           
            .               // uls and ult are S10.5
            .               // dsdx and dtdy are S5.10
            .               // lrx, lry, ulx, uly are U10.2
            .               // lrs, lrt are S10.5
       37,324 ( 0.00%)      if (flip) {
            .                   dsdx = -dsdx;
            .                   dtdy = -dtdy;
            .               }
      167,958 ( 0.00%)      int16_t width = !flip ? lrx - ulx : lry - uly;
      167,958 ( 0.00%)      int16_t height = !flip ? lry - uly : lrx - ulx;
      186,620 ( 0.00%)      float lrs = ((uls << 7) + dsdx * width) >> 7;
      186,620 ( 0.00%)      float lrt = ((ult << 7) + dtdy * height) >> 7;
            .           
       18,662 ( 0.00%)      struct LoadedVertex* ul = &g_rsp.loaded_vertices[MAX_VERTICES + 0];
       18,662 ( 0.00%)      struct LoadedVertex* ll = &g_rsp.loaded_vertices[MAX_VERTICES + 1];
       18,662 ( 0.00%)      struct LoadedVertex* lr = &g_rsp.loaded_vertices[MAX_VERTICES + 2];
       18,662 ( 0.00%)      struct LoadedVertex* ur = &g_rsp.loaded_vertices[MAX_VERTICES + 3];
       74,648 ( 0.00%)      ul->u = uls;
       74,648 ( 0.00%)      ul->v = ult;
       55,986 ( 0.00%)      lr->u = lrs;
       55,986 ( 0.00%)      lr->v = lrt;
       74,648 ( 0.00%)      if (!flip) {
       74,648 ( 0.00%)          ll->u = uls;
       55,986 ( 0.00%)          ll->v = lrt;
       55,986 ( 0.00%)          ur->u = lrs;
       93,310 ( 0.00%)          ur->v = ult;
            .               } else {
            .                   ll->u = lrs;
            .                   ll->v = ult;
            .                   ur->u = uls;
            .                   ur->v = lrt;
            .               }
            .           
       37,324 ( 0.00%)      uint8_t saved_tile = g_rdp.first_tile_index;
       55,986 ( 0.00%)      if (saved_tile != tile) {
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
       37,324 ( 0.00%)      g_rdp.first_tile_index = tile;
            .           
      111,972 ( 0.00%)      gfx_draw_rectangle(ulx, uly, lrx, lry);
  285,176,660 ( 0.24%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_draw_rectangle(int, int, int, int) (18,662x)
       55,986 ( 0.00%)      if (saved_tile != tile) {
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
       37,324 ( 0.00%)      g_rdp.first_tile_index = saved_tile;
       37,324 ( 0.00%)      g_rdp.combine_mode = saved_combine_mode;
       74,648 ( 0.00%)  }
            .           
            .           static void gfx_dp_image_rectangle(int32_t tile, int32_t w, int32_t h, int32_t ulx, int32_t uly, int16_t uls,
            .                                              int16_t ult, int32_t lrx, int32_t lry, int16_t lrs, int16_t lrt) {
            .           
            .               struct LoadedVertex* ul = &g_rsp.loaded_vertices[MAX_VERTICES + 0];
            .               struct LoadedVertex* ll = &g_rsp.loaded_vertices[MAX_VERTICES + 1];
            .               struct LoadedVertex* lr = &g_rsp.loaded_vertices[MAX_VERTICES + 2];
            .               struct LoadedVertex* ur = &g_rsp.loaded_vertices[MAX_VERTICES + 3];
-- line 2407 ----------------------------------------
-- line 2441 ----------------------------------------
            .               gfx_draw_rectangle(ulx, uly, lrx, lry);
            .               if (saved_tile != tile) {
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
            .               g_rdp.first_tile_index = saved_tile;
            .           }
            .           
        8,752 ( 0.00%)  static void gfx_dp_fill_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
        4,376 ( 0.00%)      if (g_rdp.color_image_address == g_rdp.z_buf_address) {
            .                   // Don't clear Z buffer here since we already did it with glClear
          403 ( 0.00%)          return;
            .               }
        2,073 ( 0.00%)      uint32_t mode = (g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
            .           
            .               // OTRTODO: This is a bit of a hack for widescreen screen fades, but it'll work for now...
        4,952 ( 0.00%)      if (ulx == 0 && uly == 0 && lrx == (319 * 4) && lry == (239 * 4)) {
          403 ( 0.00%)          ulx = -1024;
          403 ( 0.00%)          uly = -1024;
          403 ( 0.00%)          lrx = 2048;
          403 ( 0.00%)          lry = 2048;
            .               }
            .           
        2,764 ( 0.00%)      if (mode == G_CYC_COPY || mode == G_CYC_FILL) {
            .                   // Per documentation one extra pixel is added in this modes to each edge
          258 ( 0.00%)          lrx += 1 << 2;
          258 ( 0.00%)          lry += 1 << 2;
            .               }
            .           
       11,056 ( 0.00%)      for (int i = MAX_VERTICES; i < MAX_VERTICES + 4; i++) {
       19,348 ( 0.00%)          struct LoadedVertex* v = &g_rsp.loaded_vertices[i];
        8,292 ( 0.00%)          v->color = g_rdp.fill_color;
            .               }
            .           
        1,382 ( 0.00%)      uint64_t saved_combine_mode = g_rdp.combine_mode;
            .           
        1,382 ( 0.00%)      if (mode == G_CYC_FILL) {
        4,128 ( 0.00%)          gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_SHADE), alpha_comb(0, 0, 0, G_ACMUX_SHADE), 0, 0);
        5,934 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:color_comb(unsigned int, unsigned int, unsigned int, unsigned int) (258x)
        5,934 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:alpha_comb(unsigned int, unsigned int, unsigned int, unsigned int) (258x)
        5,160 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_combine_mode(unsigned int, unsigned int, unsigned int, unsigned int) (258x)
            .               }
            .           
        4,146 ( 0.00%)      gfx_draw_rectangle(ulx, uly, lrx, lry);
   12,544,053 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_draw_rectangle(int, int, int, int) (691x)
        2,073 ( 0.00%)      g_rdp.combine_mode = saved_combine_mode;
        3,282 ( 0.00%)  }
            .           
        1,206 ( 0.00%)  static void gfx_dp_set_z_image(void* z_buf_address) {
          804 ( 0.00%)      g_rdp.z_buf_address = z_buf_address;
        1,206 ( 0.00%)  }
            .           
        7,236 ( 0.00%)  static void gfx_dp_set_color_image(uint32_t format, uint32_t size, uint32_t width, void* address) {
        2,412 ( 0.00%)      g_rdp.color_image_address = address;
        3,618 ( 0.00%)  }
            .           
    1,098,065 ( 0.00%)  static void gfx_sp_set_other_mode(uint32_t shift, uint32_t num_bits, uint64_t mode) {
    1,537,291 ( 0.00%)      uint64_t mask = (((uint64_t)1 << num_bits) - 1) << shift;
    1,537,291 ( 0.00%)      uint64_t om = g_rdp.other_mode_l | ((uint64_t)g_rdp.other_mode_h << 32);
    1,098,065 ( 0.00%)      om = (om & ~mask) | mode;
      439,226 ( 0.00%)      g_rdp.other_mode_l = (uint32_t)om;
      658,839 ( 0.00%)      g_rdp.other_mode_h = (uint32_t)(om >> 32);
      658,839 ( 0.00%)  }
            .           
            .           static void gfx_dp_set_other_mode(uint32_t h, uint32_t l) {
            .               g_rdp.other_mode_h = h;
            .               g_rdp.other_mode_l = l;
            .           }
            .           
            .           static void gfx_s2dex_bg_copy(F3DuObjBg* bg) {
            .               /*
-- line 2507 ----------------------------------------
-- line 2619 ----------------------------------------
            .               int testX = (realX + (realW / realSW));
            .               int testY = (realY + (realH / realSH));
            .           
            .               gfx_dp_texture_rectangle(realX << 2, realY << 2, testX << 2, testY << 2, G_TX_RENDERTILE,
            .                                        g_rdp.texture_tile[0].uls << 3, g_rdp.texture_tile[0].ult << 3, (float)(1 << 10) * realSW,
            .                                        (float)(1 << 10) * realSH, false);
            .           }
            .           
   19,877,736 ( 0.02%)  static inline void* seg_addr(uintptr_t w1) {
            .               // Segmented?
   26,503,648 ( 0.02%)      if (w1 & 1) {
       19,920 ( 0.00%)          uint32_t segNum = (uint32_t)(w1 >> 24);
            .           
       19,920 ( 0.00%)          uint32_t offset = w1 & 0x00FFFFFE;
            .           
       26,560 ( 0.00%)          if (gSegmentPointers[segNum] != 0) {
       33,200 ( 0.00%)              return (void*)(gSegmentPointers[segNum] + offset);
            .                   } else {
            .                       return (void*)w1;
            .                   }
            .               } else {
    6,619,272 ( 0.01%)          return (void*)w1;
            .               }
   13,251,824 ( 0.01%)  }
            .           
            .           #define C0(pos, width) ((cmd->words.w0 >> (pos)) & ((1U << width) - 1))
            .           #define C1(pos, width) ((cmd->words.w1 >> (pos)) & ((1U << width) - 1))
            .           
        2,015 ( 0.00%)  void GfxExecStack::start(F3DGfx* dlist) {
        2,821 ( 0.00%)      while (!cmd_stack.empty())
       13,702 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::empty() const (403x)
            .                   cmd_stack.pop();
        1,612 ( 0.00%)      gfx_path.clear();
       11,284 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::clear() (403x)
        2,015 ( 0.00%)      cmd_stack.push(dlist);
       35,867 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::push(F3DGfx* const&) (403x)
        1,612 ( 0.00%)      disp_stack.clear();
       11,284 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<GfxExecStack::CodeDisp, std::allocator<GfxExecStack::CodeDisp> >::clear() (403x)
        1,209 ( 0.00%)  }
            .           
            .           void GfxExecStack::stop() {
            .               while (!cmd_stack.empty())
            .                   cmd_stack.pop();
            .               gfx_path.clear();
            .           }
            .           
  230,996,060 ( 0.19%)  F3DGfx*& GfxExecStack::currCmd() {
  173,247,045 ( 0.14%)      return cmd_stack.top();
5,081,913,320 ( 4.21%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::top() (57,749,015x)
  115,498,030 ( 0.10%)  }
            .           
            .           void GfxExecStack::openDisp(const char* file, int line) {
            .               disp_stack.push_back({ file, line });
            .           }
            .           void GfxExecStack::closeDisp() {
            .               disp_stack.pop_back();
            .           }
            .           const std::vector<GfxExecStack::CodeDisp>& GfxExecStack::getDisp() const {
-- line 2671 ----------------------------------------
-- line 2676 ----------------------------------------
            .               F3DGfx* old = cmd_stack.top();
            .               cmd_stack.pop();
            .               cmd_stack.push(nullptr);
            .               cmd_stack.push(old);
            .           
            .               gfx_path.push_back(caller);
            .           }
            .           
    1,119,984 ( 0.00%)  void GfxExecStack::call(F3DGfx* caller, F3DGfx* callee) {
      933,320 ( 0.00%)      cmd_stack.push(callee);
   16,613,096 ( 0.01%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::push(F3DGfx* const&) (186,664x)
    1,119,984 ( 0.00%)      gfx_path.push_back(caller);
   14,002,118 ( 0.01%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::push_back(F3DGfx const* const&) (186,664x)
      559,992 ( 0.00%)  }
            .           
      748,268 ( 0.00%)  F3DGfx* GfxExecStack::ret() {
      935,335 ( 0.00%)      F3DGfx* cmd = cmd_stack.top();
   16,461,896 ( 0.01%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::top() (187,067x)
            .           
      561,201 ( 0.00%)      cmd_stack.pop();
    9,914,551 ( 0.01%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::pop() (187,067x)
    1,309,469 ( 0.00%)      if (!gfx_path.empty()) {
   18,145,499 ( 0.02%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::empty() const (187,067x)
      746,656 ( 0.00%)          gfx_path.pop_back();
    5,039,928 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::pop_back() (186,664x)
            .               }
            .           
    2,803,184 ( 0.00%)      while (cmd_stack.size() > 0 && cmd_stack.top() == nullptr) {
   16,426,432 ( 0.01%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::top() (186,664x)
   14,778,293 ( 0.01%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::size() const (187,067x)
            .                   cmd_stack.pop();
            .                   if (!gfx_path.empty()) {
            .                       gfx_path.pop_back();
            .                   }
            .               }
      187,067 ( 0.00%)      return cmd;
      374,134 ( 0.00%)  }
            .           
            .           void gfx_set_framebuffer(int fb, float noise_scale);
            .           void gfx_reset_framebuffer();
            .           void gfx_copy_framebuffer(int fb_dst_id, int fb_src_id, bool copyOnce, bool* hasCopiedPtr);
            .           
            .           // The main type of the handler function. These function will take a pointer to a pointer to a Gfx. It needs to be a
            .           // double pointer because we sometimes need to increment and decrement the underlying pointer Returns false if the
            .           // current opcode should be incremented after the handler ends.
-- line 2712 ----------------------------------------
-- line 2713 ----------------------------------------
            .           typedef bool (*GfxOpcodeHandlerFunc)(F3DGfx** gfx);
            .           
            .           bool gfx_load_ucode_handler_f3dex2(F3DGfx** cmd) {
            .               g_rsp.fog_mul = 0;
            .               g_rsp.fog_offset = 0;
            .               return false;
            .           }
            .           
       75,696 ( 0.00%)  bool gfx_cull_dl_handler_f3dex2(F3DGfx** cmd) {
            .               // TODO:
       25,232 ( 0.00%)      return false;
       50,464 ( 0.00%)  }
            .           
      423,700 ( 0.00%)  bool gfx_marker_handler_otr(F3DGfx** cmd0) {
      423,700 ( 0.00%)      (*cmd0)++;
      254,220 ( 0.00%)      F3DGfx* cmd = (*cmd0);
      847,400 ( 0.00%)      const uint64_t hash = ((uint64_t)(cmd)->words.w0 << 32) + (cmd)->words.w1;
      762,660 ( 0.00%)      std::string dlName = ResourceGetNameByCrc(hash);
  110,448,880 ( 0.09%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (84,740x)
   45,289,021 ( 0.04%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (84,740x)
       84,740 ( 0.00%)      markerOn = true;
      254,220 ( 0.00%)      return false;
      508,440 ( 0.00%)  }
   22,287,634 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (84,740x)
            .           
            .           bool gfx_invalidate_tex_cache_handler_f3dex2(F3DGfx** cmd) {
            .               const uintptr_t texAddr = (*cmd)->words.w1;
            .           
            .               if (texAddr == 0) {
            .                   gfx_texture_cache_clear();
            .               } else {
            .                   gfx_texture_cache_delete((const uint8_t*)texAddr);
            .               }
            .               return false;
            .           }
            .           
       72,548 ( 0.00%)  bool gfx_noop_handler_f3dex2(F3DGfx** cmd0) {
       31,092 ( 0.00%)      F3DGfx* cmd = *cmd0;
       31,092 ( 0.00%)      const char* filename = (const char*)(cmd)->words.w1;
       51,820 ( 0.00%)      uint32_t p = C0(16, 8);
       41,456 ( 0.00%)      uint32_t l = C0(0, 16);
       31,092 ( 0.00%)      if (p == 7) {
            .                   g_exec_stack.openDisp(filename, l);
       31,092 ( 0.00%)      } else if (p == 8) {
            .                   if (g_exec_stack.disp_stack.size() == 0) {
            .                       SPDLOG_WARN("CLOSE_DISPS without matching open {}:{}", p, l);
            .                   } else {
            .                       g_exec_stack.closeDisp();
            .                   }
            .               }
       10,364 ( 0.00%)      return false;
       62,184 ( 0.00%)  }
            .           
            .           bool gfx_mtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               uintptr_t mtxAddr = cmd->words.w1;
            .           
            .               gfx_sp_matrix(C0(0, 8) ^ F3DEX2_G_MTX_PUSH, (const int32_t*)seg_addr(mtxAddr));
            .               return false;
            .           }
            .           // Seems to be the same for all other non F3DEX2 microcodes...
      212,096 ( 0.00%)  bool gfx_mtx_handler_f3d(F3DGfx** cmd0) {
      159,072 ( 0.00%)      F3DGfx* cmd = *cmd0;
      159,072 ( 0.00%)      uintptr_t mtxAddr = cmd->words.w1;
            .           
      636,288 ( 0.00%)      gfx_sp_matrix(C0(16, 8), (const int32_t*)seg_addr(cmd->words.w1));
  253,983,185 ( 0.21%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_matrix(unsigned char, int const*) (53,024x)
      530,240 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (53,024x)
       53,024 ( 0.00%)      return false;
      106,048 ( 0.00%)  }
            .           
            .           bool gfx_mtx_otr_handler_custom_f3dex2(F3DGfx** cmd0) {
            .               (*cmd0)++;
            .               F3DGfx* cmd = *cmd0;
            .           
            .               const uint64_t hash = ((uint64_t)cmd->words.w0 << 32) + cmd->words.w1;
            .           
            .               const int32_t* mtx = (const int32_t*)ResourceGetDataByCrc(hash);
-- line 2785 ----------------------------------------
-- line 2809 ----------------------------------------
            .           bool gfx_pop_mtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_pop_matrix((uint32_t)(cmd->words.w1 / 64));
            .           
            .               return false;
            .           }
            .           
       22,960 ( 0.00%)  bool gfx_pop_mtx_handler_f3d(F3DGfx** cmd0) {
       17,220 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
       11,480 ( 0.00%)      gfx_sp_pop_matrix(1);
    6,463,240 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_pop_matrix(unsigned int) (5,740x)
            .           
        5,740 ( 0.00%)      return false;
       11,480 ( 0.00%)  }
            .           
            .           bool gfx_movemem_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_movemem_f3dex2(C0(0, 8), C0(8, 8) * 8, seg_addr(cmd->words.w1));
            .           
            .               return false;
            .           }
            .           
       18,648 ( 0.00%)  bool gfx_movemem_handler_f3d(F3DGfx** cmd0) {
       13,986 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
       55,944 ( 0.00%)      gfx_sp_movemem_f3d(C0(16, 8), 0, seg_addr(cmd->words.w1));
      927,390 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_movemem_f3d(unsigned char, unsigned char, void const*) (4,662x)
       46,620 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (4,662x)
            .           
        4,662 ( 0.00%)      return false;
        9,324 ( 0.00%)  }
            .           
            .           bool gfx_movemem_handler_otr(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               const uint8_t index = C1(24, 8);
            .               const uint8_t offset = C1(16, 8);
            .               const uint8_t hasOffset = C1(8, 8);
            .           
-- line 2847 ----------------------------------------
-- line 2862 ----------------------------------------
            .           bool gfx_moveword_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_moveword_f3dex2(C0(16, 8), C0(0, 16), cmd->words.w1);
            .           
            .               return false;
            .           }
            .           
       66,620 ( 0.00%)  bool gfx_moveword_handler_f3d(F3DGfx** cmd0) {
       49,965 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      199,860 ( 0.00%)      gfx_sp_moveword_f3d(C0(0, 8), C0(8, 16), cmd->words.w1);
      408,120 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_moveword_f3d(unsigned char, unsigned short, unsigned long) (16,655x)
            .           
       16,655 ( 0.00%)      return false;
       33,310 ( 0.00%)  }
            .           
            .           bool gfx_texture_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_texture(C1(16, 16), C1(0, 16), C0(11, 3), C0(8, 3), C0(1, 7));
            .           
            .               return false;
            .           }
            .           
            .           // Seems to be the same for all other non F3DEX2 microcodes...
      352,212 ( 0.00%)  bool gfx_texture_handler_f3d(F3DGfx** cmd0) {
      264,159 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    2,201,325 ( 0.00%)      gfx_sp_texture(C1(16, 16), C1(0, 16), C0(11, 3), C0(8, 3), C0(0, 8));
    2,025,519 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_texture(unsigned short, unsigned short, unsigned char, unsigned char, unsigned char) (88,053x)
            .           
       88,053 ( 0.00%)      return false;
      176,106 ( 0.00%)  }
            .           
            .           // Almost all versions of the microcode have their own version of this opcode
            .           bool gfx_vtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), (const F3DVtx*)seg_addr(cmd->words.w1));
            .           
            .               return false;
            .           }
            .           
   25,394,960 ( 0.02%)  bool gfx_vtx_handler_f3dex(F3DGfx** cmd0) {
   19,046,220 ( 0.02%)      F3DGfx* cmd = *cmd0;
  107,928,580 ( 0.09%)      gfx_sp_vertex(C0(10, 6), C0(17, 7), (const F3DVtx*)seg_addr(cmd->words.w1));
77,528,540,361 (64.23%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) (6,348,740x)
   63,487,400 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (6,348,740x)
            .           
    6,348,740 ( 0.01%)      return false;
   12,697,480 ( 0.01%)  }
            .           
            .           bool gfx_vtx_handler_f3d(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_vertex((C0(0, 16)) / sizeof(F3DVtx), C0(16, 4), (const F3DVtx*)seg_addr(cmd->words.w1));
            .           
            .               return false;
            .           }
            .           
      106,660 ( 0.00%)  bool gfx_vtx_hash_handler_custom(F3DGfx** cmd0) {
            .               // Offset added to the start of the vertices
      106,660 ( 0.00%)      const uintptr_t offset = (*cmd0)->words.w1;
            .               // This is a two-part display list command, so increment the instruction pointer so we can get the CRC64
            .               // hash from the second
      133,325 ( 0.00%)      (*cmd0)++;
      266,650 ( 0.00%)      const uint64_t hash = ((uint64_t)(*cmd0)->words.w0 << 32) + (*cmd0)->words.w1;
            .           
            .               // We need to know if the offset is a cached pointer or not. An offset greater than one million is not a
            .               // real offset, so it must be a real pointer
       53,330 ( 0.00%)      if (offset > 0xFFFFF) {
      132,840 ( 0.00%)          (*cmd0)--;
       79,704 ( 0.00%)          F3DGfx* cmd = *cmd0;
      478,224 ( 0.00%)          gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), (F3DVtx*)offset);
   61,958,056 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) (26,568x)
      159,408 ( 0.00%)          (*cmd0)++;
            .               } else {
          388 ( 0.00%)          F3DVtx* vtx = (F3DVtx*)ResourceGetDataByCrc(hash);
    1,323,476 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByCrc (97x)
            .           
          194 ( 0.00%)          if (vtx != NULL) {
          194 ( 0.00%)              vtx = (F3DVtx*)((char*)vtx + offset);
            .           
          485 ( 0.00%)              (*cmd0)--;
          291 ( 0.00%)              F3DGfx* cmd = *cmd0;
            .           
            .                       // TODO: WTF??
          291 ( 0.00%)              cmd->words.w1 = (uintptr_t)vtx;
            .           
        1,843 ( 0.00%)              gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), vtx);
      322,494 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) (97x)
          485 ( 0.00%)              (*cmd0)++;
            .                   }
            .               }
       26,665 ( 0.00%)      return false;
       53,330 ( 0.00%)  }
            .           
            .           bool gfx_vtx_otr_filepath_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               char* fileName = (char*)cmd->words.w1;
            .               cmd++;
            .               size_t vtxCnt = cmd->words.w0;
            .               size_t vtxIdxOff = cmd->words.w1 >> 16;
            .               size_t vtxDataOff = cmd->words.w1 & 0xFFFF;
-- line 2959 ----------------------------------------
-- line 2990 ----------------------------------------
            .           // The original F3D microcode doesn't seem to have this opcode. Glide handles it as part of moveword
            .           bool gfx_modify_vtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               gfx_sp_modify_vertex(C0(1, 15), C0(16, 8), (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
            .           // F3D, F3DEX, and F3DEX2 do the same thing but F3DEX2 has its own opcode number
      616,000 ( 0.00%)  bool gfx_dl_handler_common(F3DGfx** cmd0) {
      462,000 ( 0.00%)      F3DGfx* cmd = *cmd0;
      770,000 ( 0.00%)      F3DGfx* subGFX = (F3DGfx*)seg_addr(cmd->words.w1);
    1,540,000 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (154,000x)
      770,000 ( 0.00%)      if (C0(16, 1) == 0) {
            .                   // Push return address
      308,000 ( 0.00%)          if (subGFX != nullptr) {
    1,078,000 ( 0.00%)              g_exec_stack.call(*cmd0, subGFX);
   28,336,614 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::call(F3DGfx*, F3DGfx*) (154,000x)
            .                   }
            .               } else {
            .                   (*cmd0) = subGFX;
            .                   g_exec_stack.branch(cmd);
            .                   return true; // shortcut cmd increment
            .               }
      154,000 ( 0.00%)      return false;
      308,000 ( 0.00%)  }
            .           
      130,656 ( 0.00%)  bool gfx_dl_otr_hash_handler_custom(F3DGfx** cmd0) {
       97,992 ( 0.00%)      F3DGfx* cmd = *cmd0;
      163,320 ( 0.00%)      if (C0(16, 1) == 0) {
            .                   // Push return address
      163,320 ( 0.00%)          (*cmd0)++;
            .           
      326,640 ( 0.00%)          uint64_t hash = ((uint64_t)(*cmd0)->words.w0 << 32) + (*cmd0)->words.w1;
            .           
      130,656 ( 0.00%)          F3DGfx* gfx = (F3DGfx*)ResourceGetDataByCrc(hash);
  394,254,971 ( 0.33%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByCrc (32,664x)
            .           
       65,328 ( 0.00%)          if (gfx != 0) {
      195,984 ( 0.00%)              g_exec_stack.call(cmd, gfx);
    6,011,880 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::call(F3DGfx*, F3DGfx*) (32,664x)
            .                   }
            .               } else {
            .                   assert(0 && "????");
            .                   (*cmd0) = (F3DGfx*)seg_addr((*cmd0)->words.w1);
            .                   return true;
            .               }
       32,664 ( 0.00%)      return false;
       65,328 ( 0.00%)  }
            .           bool gfx_dl_index_handler(F3DGfx** cmd0) {
            .               // Compute seg addr by converting an index value to a offset value
            .               // handling 32 vs 64 bit size differences for Gfx
            .               // adding 1 to trigger the segaddr flow
            .               F3DGfx* cmd = (*cmd0);
            .               uint8_t segNum = (uint8_t)(cmd->words.w1 >> 24);
            .               uint32_t index = (uint32_t)(cmd->words.w1 & 0x00FFFFFF);
            .               uintptr_t segAddr = (segNum << 24) | (index * sizeof(F3DGfx)) + 1;
-- line 3041 ----------------------------------------
-- line 3080 ----------------------------------------
            .                       g_exec_stack.branch(cmd);
            .                       return true; // shortcut cmd increment
            .                   }
            .               }
            .               return false;
            .           }
            .           
            .           // F3D, F3DEX, and F3DEX2 do the same thing but F3DEX2 has its own opcode number
      748,268 ( 0.00%)  bool gfx_end_dl_handler_common(F3DGfx** cmd0) {
      187,067 ( 0.00%)      markerOn = false;
      748,268 ( 0.00%)      *cmd0 = g_exec_stack.ret();
   88,431,913 ( 0.07%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::ret() (187,067x)
      187,067 ( 0.00%)      return true;
      374,134 ( 0.00%)  }
            .           
            .           bool gfx_set_prim_depth_handler_rdp(F3DGfx** cmd) {
            .               // TODO Implement this command...
            .               return false;
            .           }
            .           
            .           // Only on F3DEX2
            .           bool gfx_geometry_mode_handler_f3dex2(F3DGfx** cmd0) {
-- line 3100 ----------------------------------------
-- line 3130 ----------------------------------------
            .           bool gfx_tri1_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_tri1(C0(16, 8) / 2, C0(8, 8) / 2, C0(0, 8) / 2, false);
            .           
            .               return false;
            .           }
            .           
      164,336 ( 0.00%)  bool gfx_tri1_handler_f3dex(F3DGfx** cmd0) {
      123,252 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      821,680 ( 0.00%)      gfx_sp_tri1(C1(17, 7), C1(9, 7), C1(1, 7), false);
  296,867,334 ( 0.25%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (41,084x)
            .           
       41,084 ( 0.00%)      return false;
       82,168 ( 0.00%)  }
            .           
            .           bool gfx_tri1_handler_f3d(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_tri1(C1(16, 8) / 10, C1(8, 8) / 10, C1(0, 8) / 10, false);
            .           
            .               return false;
            .           }
            .           
            .           // F3DEX, and F3DEX2 share a tri2 function, however F3DEX has a different quad function.
  197,998,152 ( 0.16%)  bool gfx_tri2_handler_f3dex(F3DGfx** cmd0) {
  148,498,614 ( 0.12%)      F3DGfx* cmd = *cmd0;
            .           
  989,990,760 ( 0.82%)      gfx_sp_tri1(C0(17, 7), C0(9, 7), C0(1, 7), false);
5,756,026,575 ( 4.77%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (49,499,538x)
  989,990,760 ( 0.82%)      gfx_sp_tri1(C1(17, 7), C1(9, 7), C1(1, 7), false);
5,466,931,362 ( 4.53%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (49,499,538x)
   49,499,538 ( 0.04%)      return false;
   98,999,076 ( 0.08%)  }
            .           
            .           bool gfx_quad_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_tri1(C0(16, 8) / 2, C0(8, 8) / 2, C0(0, 8) / 2, false);
            .               gfx_sp_tri1(C1(16, 8) / 2, C1(8, 8) / 2, C1(0, 8) / 2, false);
            .               return false;
            .           }
-- line 3169 ----------------------------------------
-- line 3178 ----------------------------------------
            .           bool gfx_othermode_l_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_set_other_mode(31 - C0(8, 8) - C0(0, 8), C0(0, 8) + 1, cmd->words.w1);
            .           
            .               return false;
            .           }
            .           
      266,340 ( 0.00%)  bool gfx_othermode_l_handler_f3d(F3DGfx** cmd0) {
      199,755 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      799,020 ( 0.00%)      gfx_sp_set_other_mode(C0(8, 8), C0(0, 8), cmd->words.w1);
    2,130,720 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_set_other_mode(unsigned int, unsigned int, unsigned long) (66,585x)
            .           
       66,585 ( 0.00%)      return false;
      133,170 ( 0.00%)  }
            .           
            .           bool gfx_othermode_h_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_set_other_mode(63 - C0(8, 8) - C0(0, 8), C0(0, 8) + 1, (uint64_t)cmd->words.w1 << 32);
            .           
            .               return false;
            .           }
            .           
            .           // Only on F3DEX and older
      435,512 ( 0.00%)  bool gfx_set_geometry_mode_handler_f3dex(F3DGfx** cmd0) {
      326,634 ( 0.00%)      F3DGfx* cmd = *cmd0;
      544,390 ( 0.00%)      gfx_sp_geometry_mode(0, (uint32_t)cmd->words.w1);
    1,633,170 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_geometry_mode(unsigned int, unsigned int) (108,878x)
      108,878 ( 0.00%)      return false;
      217,756 ( 0.00%)  }
            .           
            .           // Only on F3DEX and older
      516,128 ( 0.00%)  bool gfx_clear_geometry_mode_handler_f3dex(F3DGfx** cmd0) {
      387,096 ( 0.00%)      F3DGfx* cmd = *cmd0;
      645,160 ( 0.00%)      gfx_sp_geometry_mode((uint32_t)cmd->words.w1, 0);
    1,935,480 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_geometry_mode(unsigned int, unsigned int) (129,032x)
      129,032 ( 0.00%)      return false;
      258,064 ( 0.00%)  }
            .           
      612,112 ( 0.00%)  bool gfx_othermode_h_handler_f3d(F3DGfx** cmd0) {
      459,084 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    2,295,420 ( 0.00%)      gfx_sp_set_other_mode(C0(8, 8) + 32, C0(0, 8), (uint64_t)cmd->words.w1 << 32);
    4,896,896 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_set_other_mode(unsigned int, unsigned int, unsigned long) (153,028x)
            .           
      153,028 ( 0.00%)      return false;
      306,056 ( 0.00%)  }
            .           
      511,024 ( 0.00%)  bool gfx_set_timg_handler_rdp(F3DGfx** cmd0) {
      191,634 ( 0.00%)      F3DGfx* cmd = *cmd0;
      319,390 ( 0.00%)      uintptr_t i = (uintptr_t)seg_addr(cmd->words.w1);
      731,740 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (63,878x)
            .           
      127,756 ( 0.00%)      char* imgData = (char*)i;
       63,878 ( 0.00%)      uint32_t texFlags = 0;
      447,146 ( 0.00%)      RawTexMetadata rawTexMetdata = {};
            .           
      255,512 ( 0.00%)      if ((i & 1) != 1) {
      447,146 ( 0.00%)          if (gfx_check_image_signature(imgData) == 1) {
   35,805,112 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_check_image_signature(char const*) (63,878x)
            .                       std::shared_ptr<LUS::Texture> tex = std::static_pointer_cast<LUS::Texture>(
    2,174,535 ( 0.00%)                  Ship::Context::GetInstance()->GetResourceManager()->LoadResourceProcess(imgData));
  207,564,036 ( 0.17%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (39,537x)
   21,264,647 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (39,537x)
   10,398,469 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (39,537x)
    5,970,087 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (39,537x)
    4,467,681 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture> std::static_pointer_cast<LUS::Texture, Ship::IResource>(std::shared_ptr<Ship::IResource>&&) (39,537x)
    3,597,867 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (39,537x)
    3,242,034 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (39,537x)
    3,242,034 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (39,537x)
    1,660,554 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(decltype(nullptr)) (39,537x)
    1,265,184 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (39,537x)
    1,265,184 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (39,537x)
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
            .           
      237,222 ( 0.00%)              if (tex == nullptr) {
      790,740 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<LUS::Texture>(std::shared_ptr<LUS::Texture> const&, decltype(nullptr)) (39,537x)
            .                           (*cmd0)++;
            .                           return false;
            .                       }
            .           
      197,685 ( 0.00%)              i = (uintptr_t) reinterpret_cast<char*>(tex->ImageData);
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      197,685 ( 0.00%)              texFlags = tex->Flags;
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      197,685 ( 0.00%)              rawTexMetdata.width = tex->Width;
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      197,685 ( 0.00%)              rawTexMetdata.height = tex->Height;
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      197,685 ( 0.00%)              rawTexMetdata.h_byte_scale = tex->HByteScale;
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      197,685 ( 0.00%)              rawTexMetdata.v_pixel_scale = tex->VPixelScale;
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      197,685 ( 0.00%)              rawTexMetdata.type = tex->Type;
      988,425 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (39,537x)
      237,222 ( 0.00%)              rawTexMetdata.resource = tex;
    3,321,108 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::operator=(std::shared_ptr<LUS::Texture> const&) (39,537x)
      237,222 ( 0.00%)          }
    3,242,034 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::~shared_ptr() (39,537x)
            .               }
            .           
    2,107,974 ( 0.00%)      gfx_dp_set_texture_image(C0(21, 3), C0(19, 2), C0(0, 10), imgData, texFlags, rawTexMetdata, (void*)i);
    4,723,604 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::~RawTexMetadata() (63,878x)
    7,860,128 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_texture_image(unsigned int, unsigned int, unsigned int, char const*, unsigned int, RawTexMetadata, void const*) (63,878x)
    6,448,447 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::RawTexMetadata(RawTexMetadata const&) (63,878x)
            .           
       63,878 ( 0.00%)      return false;
      702,658 ( 0.00%)  }
    4,723,604 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::~RawTexMetadata() (63,878x)
            .           
       63,152 ( 0.00%)  bool gfx_set_timg_otr_hash_handler_custom(F3DGfx** cmd0) {
       31,576 ( 0.00%)      uintptr_t addr = (*cmd0)->words.w1;
       39,470 ( 0.00%)      (*cmd0)++;
       78,940 ( 0.00%)      uint64_t hash = ((uint64_t)(*cmd0)->words.w0 << 32) + (uint64_t)(*cmd0)->words.w1;
            .           
       31,576 ( 0.00%)      const char* fileName = ResourceGetNameByCrc(hash);
    9,873,056 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (7,894x)
        7,894 ( 0.00%)      uint32_t texFlags = 0;
       55,258 ( 0.00%)      RawTexMetadata rawTexMetadata = {};
            .           
       15,788 ( 0.00%)      if (fileName == nullptr) {
            .                   (*cmd0)++;
            .                   return false;
            .               }
            .           
            .               std::shared_ptr<LUS::Texture> texture = std::static_pointer_cast<LUS::Texture>(
      457,852 ( 0.00%)          Ship::Context::GetInstance()->GetResourceManager()->LoadResourceProcess(ResourceGetNameByCrc(hash)));
   34,313,851 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (7,894x)
    9,873,056 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (7,894x)
    4,288,976 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (7,894x)
    2,076,150 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (7,894x)
    1,191,994 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (7,894x)
      892,022 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture> std::static_pointer_cast<LUS::Texture, Ship::IResource>(std::shared_ptr<Ship::IResource>&&) (7,894x)
      718,354 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (7,894x)
      647,308 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (7,894x)
      647,308 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (7,894x)
      331,548 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(decltype(nullptr)) (7,894x)
      252,608 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (7,894x)
      252,608 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (7,894x)
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       55,258 ( 0.00%)      if (texture != nullptr) {
      157,880 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<LUS::Texture>(std::shared_ptr<LUS::Texture> const&, decltype(nullptr)) (7,894x)
       39,470 ( 0.00%)          texFlags = texture->Flags;
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       39,470 ( 0.00%)          rawTexMetadata.width = texture->Width;
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       39,470 ( 0.00%)          rawTexMetadata.height = texture->Height;
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       39,470 ( 0.00%)          rawTexMetadata.h_byte_scale = texture->HByteScale;
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       39,470 ( 0.00%)          rawTexMetadata.v_pixel_scale = texture->VPixelScale;
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       39,470 ( 0.00%)          rawTexMetadata.type = texture->Type;
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
       47,364 ( 0.00%)          rawTexMetadata.resource = texture;
      663,096 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::operator=(std::shared_ptr<LUS::Texture> const&) (7,894x)
            .           
            .                   // #if _DEBUG && 0
            .                   // tex = reinterpret_cast<char*>(texture->imageData);
            .                   // ResourceMgr_GetNameByCRC(hash, fileName);
            .                   // fprintf(stderr, "G_SETTIMG_OTR_HASH: %s (%dx%d) size=0x%x, %08X\n", fileName, texture->Width,
            .                   //         texture->Height, texture->ImageDataSize, hash);
            .                   // #else
        7,894 ( 0.00%)          char* tex = NULL;
            .                   // #endif
            .           
            .                   // OTRTODO: We have disabled caching for now to fix a texture corruption issue with HD texture
            .                   // support. In doing so, there is a potential performance hit since we are not caching lookups. We
            .                   // need to do proper profiling to see whether or not it is worth it to keep the caching system.
            .           
       39,470 ( 0.00%)          tex = reinterpret_cast<char*>(texture->ImageData);
      197,350 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (7,894x)
            .           
       15,788 ( 0.00%)          if (tex != nullptr) {
       39,470 ( 0.00%)              (*cmd0)--;
       31,576 ( 0.00%)              uintptr_t oldData = (*cmd0)->words.w1;
            .                       // TODO: wtf??
       31,576 ( 0.00%)              (*cmd0)->words.w1 = (uintptr_t)tex;
            .           
            .                       // if (ourHash != (uint64_t)-1) {
            .                       //     auto res = ResourceLoad(ourHash);
            .                       // }
            .           
       39,470 ( 0.00%)              (*cmd0)++;
            .                   }
            .           
       39,470 ( 0.00%)          (*cmd0)--;
       23,682 ( 0.00%)          F3DGfx* cmd = (*cmd0);
       39,470 ( 0.00%)          uint32_t fmt = C0(21, 3);
       39,470 ( 0.00%)          uint32_t size = C0(19, 2);
       31,576 ( 0.00%)          uint32_t width = C0(0, 10);
            .           
       15,788 ( 0.00%)          if (tex != NULL) {
      173,668 ( 0.00%)              gfx_dp_set_texture_image(fmt, size, width, fileName, texFlags, rawTexMetadata, tex);
    1,495,022 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_texture_image(unsigned int, unsigned int, unsigned int, char const*, unsigned int, RawTexMetadata, void const*) (7,894x)
      734,142 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::~RawTexMetadata() (7,894x)
      884,128 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::RawTexMetadata(RawTexMetadata const&) (7,894x)
            .                   }
            .               } else {
            .                   SPDLOG_ERROR("G_SETTIMG_OTR_HASH: Texture is null");
            .               }
            .           
       39,470 ( 0.00%)      (*cmd0)++;
        7,894 ( 0.00%)      return false;
      110,516 ( 0.00%)  }
      734,142 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::~RawTexMetadata() (7,894x)
      647,308 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::~shared_ptr() (7,894x)
            .           
            .           bool gfx_set_timg_otr_filepath_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               const char* fileName = (char*)cmd->words.w1;
            .           
            .               uint32_t texFlags = 0;
            .               RawTexMetadata rawTexMetadata = {};
            .           
-- line 3334 ----------------------------------------
-- line 3435 ----------------------------------------
            .           
            .           bool gfx_set_grayscale_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               g_rdp.grayscale = cmd->words.w1;
            .               return false;
            .           }
            .           
      209,468 ( 0.00%)  bool gfx_load_block_handler_rdp(F3DGfx** cmd0) {
      157,101 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    1,361,542 ( 0.00%)      gfx_dp_load_block(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
   99,005,389 ( 0.08%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_block(unsigned char, unsigned int, unsigned int, unsigned int, unsigned int) (52,367x)
       52,367 ( 0.00%)      return false;
      104,734 ( 0.00%)  }
            .           
       52,612 ( 0.00%)  bool gfx_load_tile_handler_rdp(F3DGfx** cmd0) {
       39,459 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      341,978 ( 0.00%)      gfx_dp_load_tile(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
   16,877,892 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_tile(unsigned char, unsigned int, unsigned int, unsigned int, unsigned int) (13,153x)
       13,153 ( 0.00%)      return false;
       26,306 ( 0.00%)  }
            .           
      932,386 ( 0.00%)  bool gfx_set_tile_handler_rdp(F3DGfx** cmd0) {
      399,594 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    8,258,276 ( 0.01%)      gfx_dp_set_tile(C0(21, 3), C0(19, 2), C0(9, 9), C0(0, 9), C1(24, 3), C1(20, 4), C1(18, 2), C1(14, 4), C1(10, 4),
   16,468,218 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_tile(unsigned char, unsigned int, unsigned int, unsigned int, unsigned char, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int) (133,198x)
    1,065,584 ( 0.00%)                      C1(8, 2), C1(4, 4), C1(0, 4));
      133,198 ( 0.00%)      return false;
      799,188 ( 0.00%)  }
            .           
      258,984 ( 0.00%)  bool gfx_set_tile_size_handler_rdp(F3DGfx** cmd0) {
      194,238 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    1,942,380 ( 0.00%)      gfx_dp_set_tile_size(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
    3,366,792 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_tile_size(unsigned char, unsigned short, unsigned short, unsigned short, unsigned short) (64,746x)
       64,746 ( 0.00%)      return false;
      129,492 ( 0.00%)  }
            .           
       11,728 ( 0.00%)  bool gfx_load_tlut_handler_rdp(F3DGfx** cmd0) {
        8,796 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
       38,116 ( 0.00%)      gfx_dp_load_tlut(C1(24, 3), C1(14, 10));
       93,548 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_tlut(unsigned char, unsigned int) (2,932x)
        2,932 ( 0.00%)      return false;
        5,864 ( 0.00%)  }
            .           
       31,296 ( 0.00%)  bool gfx_set_env_color_handler_rdp(F3DGfx** cmd0) {
       23,472 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      133,008 ( 0.00%)      gfx_dp_set_env_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
      156,480 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_env_color(unsigned char, unsigned char, unsigned char, unsigned char) (7,824x)
        7,824 ( 0.00%)      return false;
       15,648 ( 0.00%)  }
            .           
       78,020 ( 0.00%)  bool gfx_set_prim_color_handler_rdp(F3DGfx** cmd0) {
       58,515 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      507,130 ( 0.00%)      gfx_dp_set_prim_color(C0(8, 8), C0(0, 8), C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
      546,140 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_prim_color(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char) (19,505x)
       19,505 ( 0.00%)      return false;
       39,010 ( 0.00%)  }
            .           
            .           bool gfx_set_fog_color_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_dp_set_fog_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
            .           }
            .           
            .           bool gfx_set_blend_color_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_dp_set_blend_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
            .           }
            .           
        4,248 ( 0.00%)  bool gfx_set_fill_color_handler_rdp(F3DGfx** cmd0) {
        3,186 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
        4,248 ( 0.00%)      gfx_dp_set_fill_color((uint32_t)cmd->words.w1);
       74,340 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_fill_color(unsigned int) (1,062x)
        1,062 ( 0.00%)      return false;
        2,124 ( 0.00%)  }
            .           
            .           bool gfx_set_intensity_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_dp_set_grayscale_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
            .           }
            .           
      663,131 ( 0.00%)  bool gfx_set_combine_handler_rdp(F3DGfx** cmd0) {
      284,199 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    4,168,252 ( 0.00%)      gfx_dp_set_combine_mode(
    4,357,718 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:alpha_comb(unsigned int, unsigned int, unsigned int, unsigned int) (189,466x)
    4,357,718 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:color_comb(unsigned int, unsigned int, unsigned int, unsigned int) (189,466x)
    1,894,660 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_combine_mode(unsigned int, unsigned int, unsigned int, unsigned int) (94,733x)
    2,273,592 ( 0.00%)          color_comb(C0(20, 4), C1(28, 4), C0(15, 5), C1(15, 3)), alpha_comb(C0(12, 3), C1(12, 3), C0(9, 3), C1(9, 3)),
    2,084,126 ( 0.00%)          color_comb(C0(5, 4), C1(24, 4), C0(0, 5), C1(6, 3)), alpha_comb(C1(21, 3), C1(3, 3), C1(18, 3), C1(0, 3)));
       94,733 ( 0.00%)      return false;
      568,398 ( 0.00%)  }
            .           
       93,310 ( 0.00%)  bool gfx_tex_rect_and_flip_handler_rdp(F3DGfx** cmd0) {
       55,986 ( 0.00%)      F3DGfx* cmd = *cmd0;
       74,648 ( 0.00%)      int8_t opcode = (int8_t)(cmd->words.w0 >> 24);
            .               int32_t lrx, lry, tile, ulx, uly;
            .               uint32_t uls, ult, dsdx, dtdy;
            .           
       93,310 ( 0.00%)      lrx = C0(12, 12);
       74,648 ( 0.00%)      lry = C0(0, 12);
       93,310 ( 0.00%)      tile = C1(24, 3);
       93,310 ( 0.00%)      ulx = C1(12, 12);
       74,648 ( 0.00%)      uly = C1(0, 12);
            .               // TODO make sure I don't need to increment cmd0
       93,310 ( 0.00%)      ++(*cmd0);
       55,986 ( 0.00%)      cmd = *cmd0;
       93,310 ( 0.00%)      uls = C1(16, 16);
       74,648 ( 0.00%)      ult = C1(0, 16);
       93,310 ( 0.00%)      ++(*cmd0);
       55,986 ( 0.00%)      cmd = *cmd0;
       93,310 ( 0.00%)      dsdx = C1(16, 16);
       74,648 ( 0.00%)      dtdy = C1(0, 16);
            .           
      485,212 ( 0.00%)      gfx_dp_texture_rectangle(ulx, uly, lrx, lry, tile, uls, ult, dsdx, dtdy, opcode == RDP_G_TEXRECTFLIP);
  288,171,021 ( 0.24%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_texture_rectangle(int, int, int, int, unsigned char, short, short, short, short, bool) (18,662x)
       18,662 ( 0.00%)      return false;
       55,986 ( 0.00%)  }
            .           
            .           bool gfx_tex_rect_wide_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               int8_t opcode = (int8_t)(cmd->words.w0 >> 24);
            .               int32_t lrx, lry, tile, ulx, uly;
            .               uint32_t uls, ult, dsdx, dtdy;
            .           
            .               lrx = static_cast<int32_t>((C0(0, 24) << 8)) >> 8;
-- line 3561 ----------------------------------------
-- line 3593 ----------------------------------------
            .               y1 = C0(0, 16);
            .               s1 = C1(16, 16);
            .               t1 = C1(0, 16);
            .               gfx_dp_image_rectangle(tile, iw, ih, x0, y0, s0, t0, x1, y1, s1, t1);
            .           
            .               return false;
            .           }
            .           
        4,376 ( 0.00%)  bool gfx_fill_rect_handler_rdp(F3DGfx** cmd0) {
        3,282 ( 0.00%)      F3DGfx* cmd = *(cmd0);
            .           
       20,786 ( 0.00%)      gfx_dp_fill_rectangle(C1(12, 12), C1(0, 12), C0(12, 12), C0(0, 12));
   12,641,618 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_fill_rectangle(int, int, int, int) (1,094x)
        1,094 ( 0.00%)      return false;
        2,188 ( 0.00%)  }
            .           
            .           bool gfx_fill_wide_rect_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .               int32_t lrx, lry, ulx, uly;
            .           
            .               lrx = (int32_t)(C0(0, 24) << 8) >> 8;
            .               lry = (int32_t)(C1(0, 24) << 8) >> 8;
            .               cmd = ++(*cmd0);
            .               ulx = (int32_t)(C0(0, 24) << 8) >> 8;
            .               uly = (int32_t)(C1(0, 24) << 8) >> 8;
            .               gfx_dp_fill_rectangle(ulx, uly, lrx, lry);
            .           
            .               return false;
            .           }
            .           
       19,984 ( 0.00%)  bool gfx_set_scissor_handler_rdp(F3DGfx** cmd0) {
       14,988 ( 0.00%)      F3DGfx* cmd = *(cmd0);
            .           
      124,900 ( 0.00%)      gfx_dp_set_scissor(C1(24, 2), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
    1,403,876 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_scissor(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int) (4,996x)
        4,996 ( 0.00%)      return false;
        9,992 ( 0.00%)  }
            .           
        1,608 ( 0.00%)  bool gfx_set_z_img_handler_rdp(F3DGfx** cmd0) {
        1,206 ( 0.00%)      F3DGfx* cmd = *(cmd0);
            .           
        2,412 ( 0.00%)      gfx_dp_set_z_image(seg_addr(cmd->words.w1));
        4,020 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (402x)
        3,216 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_z_image(void*) (402x)
          402 ( 0.00%)      return false;
          804 ( 0.00%)  }
            .           
        4,824 ( 0.00%)  bool gfx_set_c_img_handler_rdp(F3DGfx** cmd0) {
        3,618 ( 0.00%)      F3DGfx* cmd = *(cmd0);
            .           
       24,120 ( 0.00%)      gfx_dp_set_color_image(C0(21, 3), C0(19, 2), C0(0, 11), seg_addr(cmd->words.w1));
       13,266 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_set_color_image(unsigned int, unsigned int, unsigned int, void*) (1,206x)
       12,060 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:seg_addr(unsigned long) (1,206x)
        1,206 ( 0.00%)      return false;
        2,412 ( 0.00%)  }
            .           
            .           bool gfx_rdp_set_other_mode_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .           
            .               gfx_dp_set_other_mode(C0(0, 24), (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
-- line 3649 ----------------------------------------
-- line 3674 ----------------------------------------
            .           
            .           bool gfx_extra_geometry_mode_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .           
            .               gfx_sp_extra_geometry_mode(~C0(0, 24), (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
      676,836 ( 0.00%)  bool gfx_stubbed_command_handler(F3DGfx** cmd0) {
      225,612 ( 0.00%)      return false;
      451,224 ( 0.00%)  }
            .           
            .           bool gfx_spnoop_command_handler_f3dex2(F3DGfx** cmd0) {
            .               return false;
            .           }
            .           
            .           class UcodeHandler {
            .             public:
            .               inline constexpr UcodeHandler(
-- line 3692 ----------------------------------------
-- line 3694 ----------------------------------------
            .                   std::fill(std::begin(mHandlers), std::end(mHandlers),
            .                             std::pair<const char*, GfxOpcodeHandlerFunc>(nullptr, nullptr));
            .           
            .                   for (const auto& [opcode, handler] : initializer) {
            .                       mHandlers[static_cast<uint8_t>(opcode)] = handler;
            .                   }
            .               }
            .           
  861,188,745 ( 0.71%)      inline bool contains(int8_t opcode) const {
1,550,139,741 ( 1.28%)          return mHandlers[static_cast<uint8_t>(opcode)].first != nullptr;
  344,475,498 ( 0.29%)      }
            .           
  288,745,075 ( 0.24%)      inline std::pair<const char*, GfxOpcodeHandlerFunc> at(int8_t opcode) const {
  461,992,120 ( 0.38%)          return mHandlers[static_cast<uint8_t>(opcode)];
  115,498,030 ( 0.10%)      }
            .           
            .             private:
            .               std::pair<const char*, GfxOpcodeHandlerFunc> mHandlers[std::numeric_limits<uint8_t>::max() + 1];
            .           };
            .           
            .           static constexpr UcodeHandler rdpHandlers = {
            .               { RDP_G_TEXRECT, { "G_TEXRECT", gfx_tex_rect_and_flip_handler_rdp } },           // G_TEXRECT (-28)
            .               { RDP_G_TEXRECTFLIP, { "G_TEXRECTFLIP", gfx_tex_rect_and_flip_handler_rdp } },   // G_TEXRECTFLIP (-27)
-- line 3716 ----------------------------------------
-- line 3882 ----------------------------------------
            .           // TODO, implement a system where we can get the current opcode handler by writing to the GWords. If the powers that be
            .           // are OK with that...
            .           static void gfx_set_ucode_handler(UcodeHandlers ucode) {
            .               // Loaded ucode must be in range of the supported ucode_handlers
            .               assert(ucode < ucode_max);
            .               ucode_handler_index = ucode;
            .           }
            .           
  461,992,120 ( 0.38%)  static void gfx_step() {
  173,247,045 ( 0.14%)      auto& cmd = g_exec_stack.currCmd();
5,601,654,455 ( 4.64%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::currCmd() (57,749,015x)
  173,247,045 ( 0.14%)      auto cmd0 = cmd;
  288,745,075 ( 0.24%)      int8_t opcode = (int8_t)(cmd->words.w0 >> 24);
            .           
  115,498,030 ( 0.10%)      if (opcode == F3DEX2_G_LOAD_UCODE) {
            .                   gfx_set_ucode_handler((UcodeHandlers)(cmd->words.w0 & 0xFFFFFF));
            .                   ++cmd;
            .                   return;
            .                   // Instead of having a handler for each ucode for switching ucode, just check for it early and return.
            .               }
            .           
  346,494,090 ( 0.29%)      if (otrHandlers.contains(opcode)) {
  923,984,240 ( 0.77%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::contains(signed char) const (57,749,015x)
    1,367,667 ( 0.00%)          if (otrHandlers.at(opcode).second(&cmd)) {
    2,279,445 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::at(signed char) const (151,963x)
  401,638,739 ( 0.33%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dl_otr_hash_handler_custom(F3DGfx**) (32,664x)
  181,838,835 ( 0.15%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_marker_handler_otr(F3DGfx**) (84,740x)
   74,321,585 ( 0.06%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_timg_otr_hash_handler_custom(F3DGfx**) (7,894x)
   65,204,993 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_vtx_hash_handler_custom(F3DGfx**) (26,665x)
            .                       return;
            .                   }
  345,582,312 ( 0.29%)      } else if (rdpHandlers.contains(opcode)) {
  921,552,832 ( 0.76%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::contains(signed char) const (57,597,052x)
    6,348,330 ( 0.01%)          if (rdpHandlers.at(opcode).second(&cmd)) {
   10,580,550 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::at(signed char) const (705,370x)
  350,106,722 ( 0.29%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_timg_handler_rdp(F3DGfx**) (63,878x)
  290,018,559 ( 0.24%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tex_rect_and_flip_handler_rdp(F3DGfx**) (18,662x)
  100,890,601 ( 0.08%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_load_block_handler_rdp(F3DGfx**) (52,367x)
   28,056,444 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_handler_rdp(F3DGfx**) (133,198x)
   20,746,527 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_combine_handler_rdp(F3DGfx**) (94,733x)
   17,351,400 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_load_tile_handler_rdp(F3DGfx**) (13,153x)
   12,673,344 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_fill_rect_handler_rdp(F3DGfx**) (1,094x)
    5,956,632 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_size_handler_rdp(F3DGfx**) (64,746x)
    1,578,736 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_scissor_handler_rdp(F3DGfx**) (4,996x)
    1,353,672 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_stubbed_command_handler(F3DGfx**) (225,612x)
    1,248,320 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_prim_color_handler_rdp(F3DGfx**) (19,505x)
      367,728 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_env_color_handler_rdp(F3DGfx**) (7,824x)
      160,984 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_load_tlut_handler_rdp(F3DGfx**) (2,932x)
       89,208 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_fill_color_handler_rdp(F3DGfx**) (1,062x)
       61,506 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_c_img_handler_rdp(F3DGfx**) (1,206x)
       13,668 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_z_img_handler_rdp(F3DGfx**) (402x)
            .                       return;
            .                   }
  227,566,728 ( 0.19%)      } else if (ucode_handler_index < ucode_handlers.size()) {
  682,700,184 ( 0.57%)          if (ucode_handlers[ucode_handler_index]->contains(opcode)) {
  910,266,912 ( 0.75%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::contains(signed char) const (56,891,682x)
  568,916,820 ( 0.47%)  => /usr/include/c++/14/array:std::array<UcodeHandler const*, 4ul>::operator[](unsigned long) const (56,891,682x)
  853,375,230 ( 0.71%)              if (ucode_handlers[ucode_handler_index]->at(opcode).second(&cmd)) {
77,763,443,741 (64.42%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_vtx_handler_f3dex(F3DGfx**) (6,348,740x)
13,697,934,837 (11.35%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tri2_handler_f3dex(F3DGfx**) (49,499,538x)
  568,916,820 ( 0.47%)  => /usr/include/c++/14/array:std::array<UcodeHandler const*, 4ul>::operator[](unsigned long) const (56,891,682x)
  853,375,230 ( 0.71%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:UcodeHandler::at(signed char) const (56,891,682x)
  298,099,854 ( 0.25%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tri1_handler_f3dex(F3DGfx**) (41,084x)
  255,839,025 ( 0.21%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_mtx_handler_f3d(F3DGfx**) (53,024x)
   90,676,717 ( 0.08%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_end_dl_handler_common(F3DGfx**) (187,067x)
   34,342,614 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dl_handler_common(F3DGfx**) (154,000x)
    8,722,596 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_othermode_h_handler_f3d(F3DGfx**) (153,028x)
    6,532,120 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_pop_mtx_handler_f3d(F3DGfx**) (5,740x)
    5,107,374 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_handler_f3d(F3DGfx**) (88,053x)
    3,870,960 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_clear_geometry_mode_handler_f3dex(F3DGfx**) (129,032x)
    3,595,590 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_othermode_l_handler_f3d(F3DGfx**) (66,585x)
    3,266,340 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_geometry_mode_handler_f3dex(F3DGfx**) (108,878x)
    1,076,574 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_movemem_handler_f3d(F3DGfx**) (4,662x)
      774,530 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_moveword_handler_f3d(F3DGfx**) (16,655x)
      362,740 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_noop_handler_f3dex2(F3DGfx**) (10,364x)
      151,392 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_cull_dl_handler_f3dex2(F3DGfx**) (25,232x)
      187,067 ( 0.00%)                  return;
            .                       }
            .                   } else {
            .                       SPDLOG_CRITICAL("Unhandled OP code: 0x{:X}, for loaded ucode: {}", (uint8_t)opcode,
            .                                       (uint32_t)ucode_handler_index);
            .                   }
            .               } else {
            .                   SPDLOG_CRITICAL("Unhandled OP code: 0x{:X}, invalid ucode: {}", (uint8_t)opcode, (uint32_t)ucode_handler_index);
            .               }
            .           
  287,809,740 ( 0.24%)      ++cmd;
  461,992,120 ( 0.38%)  }
            .           
          806 ( 0.00%)  static void gfx_sp_reset() {
          403 ( 0.00%)      g_rsp.modelview_matrix_stack_size = 1;
          403 ( 0.00%)      g_rsp.current_num_lights = 2;
          403 ( 0.00%)      g_rsp.lights_changed = true;
        1,209 ( 0.00%)  }
            .           
            .           void gfx_get_dimensions(uint32_t* width, uint32_t* height, int32_t* posX, int32_t* posY) {
            .               gfx_wapi->get_dimensions(width, height, posX, posY);
            .           }
            .           
            .           void gfx_init(struct GfxWindowManagerAPI* wapi, struct GfxRenderingAPI* rapi, const char* game_name,
           14 ( 0.00%)                bool start_in_fullscreen, uint32_t width, uint32_t height, uint32_t posX, uint32_t posY) {
            2 ( 0.00%)      gfx_wapi = wapi;
            2 ( 0.00%)      gfx_rapi = rapi;
           21 ( 0.00%)      gfx_wapi->init(game_name, rapi->get_name(), start_in_fullscreen, width, height, posX, posY);
  202,718,346 ( 0.17%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_init(char const*, char const*, bool, unsigned int, unsigned int, int, int) (1x)
            5 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_name() (1x)
            3 ( 0.00%)      gfx_rapi->init();
       98,257 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_init() (1x)
           13 ( 0.00%)      gfx_rapi->update_framebuffer_parameters(0, width, height, 1, false, true, true, true);
          471 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_update_framebuffer_parameters(int, unsigned int, unsigned int, unsigned int, bool, bool, bool, bool) (1x)
            .           #ifdef __APPLE__
            .               gfx_current_dimensions.internal_mul = 1;
            .           #else
            6 ( 0.00%)      gfx_current_dimensions.internal_mul = CVarGetFloat(CVAR_INTERNAL_RESOLUTION, 1);
        1,851 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/consolevariablebridge.cpp:CVarGetFloat (1x)
            .           #endif
            4 ( 0.00%)      gfx_msaa_level = CVarGetInteger(CVAR_MSAA_VALUE, 1);
        1,578 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/consolevariablebridge.cpp:CVarGetInteger (1x)
            .           
            2 ( 0.00%)      gfx_current_dimensions.width = width;
            2 ( 0.00%)      gfx_current_dimensions.height = height;
            .           
            4 ( 0.00%)      game_framebuffer = gfx_rapi->create_framebuffer();
       24,795 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_create_framebuffer() (1x)
            4 ( 0.00%)      game_framebuffer_msaa_resolved = gfx_rapi->create_framebuffer();
       22,372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_create_framebuffer() (1x)
            .           
            1 ( 0.00%)      gfx_native_dimensions.width = SCREEN_WIDTH;
            1 ( 0.00%)      gfx_native_dimensions.height = SCREEN_HEIGHT;
            .           
           52 ( 0.00%)      for (int i = 0; i < 16; i++) {
           48 ( 0.00%)          gSegmentPointers[i] = 0;
            .               }
            .           
            3 ( 0.00%)      if (tex_upload_buffer == nullptr) {
            .                   // We cap texture max to 8k, because why would you need more?
           12 ( 0.00%)          int max_tex_size = min(8192, gfx_rapi->get_max_texture_size());
          148 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_max_texture_size() (1x)
           13 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:int const& std::min<int>(int const&, int const&) (1x)
            8 ( 0.00%)          tex_upload_buffer = (uint8_t*)malloc(max_tex_size * max_tex_size * 4);
          606 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (1x)
            .               }
            .           
            1 ( 0.00%)      ucode_handler_index = UcodeHandlers::ucode_f3dex2;
            8 ( 0.00%)  }
            .           
            .           void gfx_destroy(void) {
            .               // TODO: should also destroy rapi, and any other resources acquired in fast3d
            .               free(tex_upload_buffer);
            .               gfx_wapi->destroy();
            .           
            .               // Texture cache and loaded textures store references to Resources which need to be unreferenced.
            .               gfx_texture_cache_clear();
            .               g_rdp.texture_to_load.raw_tex_metadata.resource = nullptr;
            .               g_rdp.loaded_texture[0].raw_tex_metadata.resource = nullptr;
            .               g_rdp.loaded_texture[1].raw_tex_metadata.resource = nullptr;
            .           }
            .           
            2 ( 0.00%)  struct GfxRenderingAPI* gfx_get_current_rendering_api(void) {
            1 ( 0.00%)      return gfx_rapi;
            2 ( 0.00%)  }
            .           
        1,206 ( 0.00%)  void gfx_start_frame(void) {
        1,206 ( 0.00%)      gfx_wapi->handle_events();
  122,755,766 ( 0.10%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_handle_events() (402x)
        2,814 ( 0.00%)      gfx_wapi->get_dimensions(&gfx_current_window_dimensions.width, &gfx_current_window_dimensions.height,
       44,220 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_get_dimensions(unsigned int*, unsigned int*, int*, int*) (402x)
            .                                        &gfx_current_window_position_x, &gfx_current_window_position_y);
        1,206 ( 0.00%)      if (gfx_current_dimensions.height == 0) {
            .                   // Avoid division by zero
            .                   gfx_current_dimensions.height = 1;
            .               }
        5,628 ( 0.00%)      gfx_current_dimensions.aspect_ratio = (float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height;
            .           
            .               // Update the framebuffer sizes when the viewport or native dimension changes
        2,410 ( 0.00%)      if (gfx_current_dimensions.width != gfx_prev_dimensions.width ||
        1,604 ( 0.00%)          gfx_current_dimensions.height != gfx_prev_dimensions.height ||
        1,604 ( 0.00%)          gfx_native_dimensions.width != gfx_prev_native_dimensions.width ||
          802 ( 0.00%)          gfx_native_dimensions.height != gfx_prev_native_dimensions.height) {
            .           
           18 ( 0.00%)          for (auto& fb : framebuffers) {
           32 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<int, FBInfo, std::less<int>, std::allocator<std::pair<int const, FBInfo> > >::begin() (1x)
           32 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<int, FBInfo, std::less<int>, std::allocator<std::pair<int const, FBInfo> > >::end() (1x)
           12 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<int const, FBInfo> > const&, std::_Rb_tree_iterator<std::pair<int const, FBInfo> > const&) (1x)
            .                       uint32_t width = fb.second.orig_width, height = fb.second.orig_height;
            .                       if (fb.second.resize) {
            .                           gfx_adjust_width_height_for_scale(width, height, fb.second.native_width, fb.second.native_height);
            .                       }
            .                       if (width != fb.second.applied_width || height != fb.second.applied_height) {
            .                           gfx_rapi->update_framebuffer_parameters(fb.first, width, height, 1, true, true, true, true);
            .                           fb.second.applied_width = width;
            .                           fb.second.applied_height = height;
            .                       }
            .                   }
            .               }
            .           
        1,608 ( 0.00%)      gfx_prev_dimensions = gfx_current_dimensions;
        1,608 ( 0.00%)      gfx_prev_native_dimensions = gfx_native_dimensions;
            .           
        3,216 ( 0.00%)      bool different_size = gfx_current_dimensions.width != gfx_current_game_window_viewport.width ||
          804 ( 0.00%)                            gfx_current_dimensions.height != gfx_current_game_window_viewport.height;
        2,010 ( 0.00%)      if (different_size || gfx_msaa_level > 1) {
            .                   game_renders_to_framebuffer = true;
            .                   if (different_size) {
            .                       gfx_rapi->update_framebuffer_parameters(game_framebuffer, gfx_current_dimensions.width,
            .                                                               gfx_current_dimensions.height, gfx_msaa_level, true, true, true,
            .                                                               true);
            .                   } else {
            .                       // MSAA framebuffer needs to be resolved to an equally sized target when complete, which must therefore
            .                       // match the window size
-- line 4030 ----------------------------------------
-- line 4032 ----------------------------------------
            .                                                               gfx_current_window_dimensions.height, gfx_msaa_level, false, true,
            .                                                               true, true);
            .                   }
            .                   if (gfx_msaa_level > 1 && different_size) {
            .                       gfx_rapi->update_framebuffer_parameters(game_framebuffer_msaa_resolved, gfx_current_dimensions.width,
            .                                                               gfx_current_dimensions.height, 1, false, false, false, false);
            .                   }
            .               } else {
          804 ( 0.00%)          game_renders_to_framebuffer = false;
            .               }
            .           
          402 ( 0.00%)      fbActive = 0;
        1,206 ( 0.00%)  }
            .           
           12 ( 0.00%)  GfxExecStack g_exec_stack = {};
          881 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::stack<std::deque<F3DGfx*, std::allocator<F3DGfx*> >, void>() (1x)
           48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::vector() (1x)
           48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<GfxExecStack::CodeDisp, std::allocator<GfxExecStack::CodeDisp> >::vector() (1x)
            .           
        2,418 ( 0.00%)  void gfx_run(Gfx* commands, const std::unordered_map<Mtx*, MtxF>& mtx_replacements) {
          403 ( 0.00%)      gfx_sp_reset();
        3,224 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_reset() (403x)
       13,299 ( 0.00%)      Ship::Context::GetInstance()->GetWindow()->GetGui()->DrawMenu();
  174,343,642 ( 0.14%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/gui/Gui.cpp:Ship::Gui::DrawMenu() (403x)
       60,853 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetWindow() (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/Window.cpp:Ship::Window::GetGui() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Gui>::~shared_ptr() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::~shared_ptr() (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Window, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Gui, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
            .           
            .               // puts("New frame");
          806 ( 0.00%)      get_pixel_depth_pending.clear();
       29,419 ( 0.00%)  => /usr/include/c++/14/bits/stl_set.h:std::set<std::pair<float, float>, std::less<std::pair<float, float> >, std::allocator<std::pair<float, float> > >::clear() (403x)
          806 ( 0.00%)      get_pixel_depth_cached.clear();
       28,210 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<std::pair<float, float>, unsigned short, hash_pair_ff, std::equal_to<std::pair<float, float> >, std::allocator<std::pair<std::pair<float, float> const, unsigned short> > >::clear() (403x)
            .           
        2,418 ( 0.00%)      if (!gfx_wapi->start_frame()) {
        2,015 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_start_frame() (403x)
            .                   dropped_frame = true;
            .                   Ship::Context::GetInstance()->GetWindow()->GetGui()->StartFrame();
            .                   Ship::Context::GetInstance()->GetWindow()->GetGui()->EndFrame();
            .                   return;
            .               }
          403 ( 0.00%)      dropped_frame = false;
            .           
          806 ( 0.00%)      current_mtx_replacements = &mtx_replacements;
            .           
        5,642 ( 0.00%)      gfx_rapi->update_framebuffer_parameters(0, gfx_current_window_dimensions.width,
      189,815 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_update_framebuffer_parameters(int, unsigned int, unsigned int, unsigned int, bool, bool, bool, bool) (403x)
            .                                                       gfx_current_window_dimensions.height, 1, false, true, true,
          806 ( 0.00%)                                              !game_renders_to_framebuffer);
        1,209 ( 0.00%)      gfx_rapi->start_frame();
        3,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_start_frame() (403x)
        6,448 ( 0.00%)      gfx_rapi->start_draw_to_framebuffer(game_renders_to_framebuffer ? game_framebuffer : 0,
      157,573 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_start_draw_to_framebuffer(int, float) (403x)
        2,821 ( 0.00%)                                          (float)gfx_current_dimensions.height / gfx_native_dimensions.height);
        1,209 ( 0.00%)      gfx_rapi->clear_framebuffer();
    5,675,462 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_clear_framebuffer() (403x)
          403 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
          806 ( 0.00%)      rendering_state.viewport = {};
          806 ( 0.00%)      rendering_state.scissor = {};
            .           
        5,642 ( 0.00%)      auto dbg = Ship::Context::GetInstance()->GetGfxDebugger();
       60,853 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetGfxDebugger() (403x)
        1,612 ( 0.00%)      g_exec_stack.start((F3DGfx*)commands);
       83,421 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::start(F3DGfx*) (403x)
  288,747,896 ( 0.24%)      while (!g_exec_stack.cmd_stack.empty()) {
1,963,480,212 ( 1.63%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::empty() const (57,749,418x)
  230,996,060 ( 0.19%)          auto cmd = g_exec_stack.cmd_stack.top();
5,081,913,320 ( 4.21%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::top() (57,749,015x)
            .           
  404,243,105 ( 0.33%)          if (dbg->IsDebugging()) {
1,443,725,375 ( 1.20%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Fast::GfxDebugger, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (57,749,015x)
  404,243,105 ( 0.33%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/debug/GfxDebugger.cpp:Fast::GfxDebugger::IsDebugging() const (57,749,015x)
            .                       g_exec_stack.gfx_path.push_back(cmd);
            .                       if (dbg->HasBreakPoint(g_exec_stack.gfx_path)) {
            .                           // On a breakpoint with the active framebuffer still set, we need to reset back to prevent
            .                           // soft locking the renderer
            .                           if (fbActive) {
            .                               fbActive = 0;
            .                               gfx_rapi->start_draw_to_framebuffer(game_renders_to_framebuffer ? game_framebuffer : 0, 1);
            .                           }
            .           
            .                           break;
            .                       }
            .                       g_exec_stack.gfx_path.pop_back();
            .                   }
   57,749,015 ( 0.05%)          gfx_step();
108,572,046,976 (89.95%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_step() (57,749,015x)
            .               }
            .           
          403 ( 0.00%)      gfx_flush();
    4,109,389 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_flush() (403x)
          403 ( 0.00%)      gfxFramebuffer = 0;
        4,030 ( 0.00%)      currentDir = std::stack<std::string>();
      265,174 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::~stack() (403x)
      257,517 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::operator=(std::stack<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >&&) (403x)
      241,649 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::stack<std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, void>() (403x)
            .           
        1,209 ( 0.00%)      if (game_renders_to_framebuffer) {
            .                   gfx_rapi->start_draw_to_framebuffer(0, 1);
            .                   gfx_rapi->clear_framebuffer();
            .           
            .                   if (gfx_msaa_level > 1) {
            .                       bool different_size = gfx_current_dimensions.width != gfx_current_game_window_viewport.width ||
            .                                             gfx_current_dimensions.height != gfx_current_game_window_viewport.height;
            .           
            .                       if (different_size) {
-- line 4111 ----------------------------------------
-- line 4112 ----------------------------------------
            .                           gfx_rapi->resolve_msaa_color_buffer(game_framebuffer_msaa_resolved, game_framebuffer);
            .                           gfxFramebuffer = (uintptr_t)gfx_rapi->get_framebuffer_texture_id(game_framebuffer_msaa_resolved);
            .                       } else {
            .                           gfx_rapi->resolve_msaa_color_buffer(0, game_framebuffer);
            .                       }
            .                   } else {
            .                       gfxFramebuffer = (uintptr_t)gfx_rapi->get_framebuffer_texture_id(game_framebuffer);
            .                   }
        1,209 ( 0.00%)      } else if (fbActive) {
            .                   // Failsafe reset to main framebuffer to prevent softlocking the renderer
            .                   fbActive = 0;
            .                   gfx_rapi->start_draw_to_framebuffer(0, 1);
            .           
            .                   assert(0 && "active framebuffer was never reset back to original");
            .               }
            .           
       13,299 ( 0.00%)      Ship::Context::GetInstance()->GetWindow()->GetGui()->StartFrame();
   11,376,636 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/gui/Gui.cpp:Ship::Gui::StartFrame() (403x)
       60,853 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/Window.cpp:Ship::Window::GetGui() (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetWindow() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Gui>::~shared_ptr() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::~shared_ptr() (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Gui, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Window, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       13,299 ( 0.00%)      Ship::Context::GetInstance()->GetWindow()->GetGui()->RenderViewports();
   25,215,727 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/gui/Gui.cpp:Ship::Gui::RenderViewports() (403x)
       60,853 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/Window.cpp:Ship::Window::GetGui() (403x)
       36,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetWindow() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Gui>::~shared_ptr() (403x)
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::~shared_ptr() (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Window, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
       10,075 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Gui, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (403x)
        1,209 ( 0.00%)      gfx_rapi->end_frame();
    4,244,154 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_end_frame() (403x)
        1,209 ( 0.00%)      gfx_wapi->swap_buffers_begin();
   14,723,567 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_swap_buffers_begin() (403x)
        2,821 ( 0.00%)  }
       33,046 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger>::~shared_ptr() (403x)
            .           
          806 ( 0.00%)  void gfx_end_frame(void) {
        1,612 ( 0.00%)      if (!dropped_frame) {
        1,209 ( 0.00%)          gfx_rapi->finish_render();
        2,015 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_finish_render() (403x)
        1,209 ( 0.00%)          gfx_wapi->swap_buffers_end();
        2,015 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_swap_buffers_end() (403x)
            .               }
        1,209 ( 0.00%)  }
            .           
            3 ( 0.00%)  void gfx_set_target_ucode(UcodeHandlers ucode) {
            2 ( 0.00%)      ucode_handler_index = ucode;
            3 ( 0.00%)  }
            .           
        1,612 ( 0.00%)  void gfx_set_target_fps(int fps) {
        2,015 ( 0.00%)      gfx_wapi->set_target_fps(fps);
        3,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_set_target_fps(int) (403x)
        1,209 ( 0.00%)  }
            .           
        1,612 ( 0.00%)  void gfx_set_maximum_frame_latency(int latency) {
        2,015 ( 0.00%)      gfx_wapi->set_maximum_frame_latency(latency);
        2,418 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_set_maximum_frame_latency(int) (403x)
        1,209 ( 0.00%)  }
            .           
            .           extern "C" int gfx_create_framebuffer(uint32_t width, uint32_t height, uint32_t native_width, uint32_t native_height,
            .                                                 uint8_t resize) {
            .               uint32_t orig_width = width, orig_height = height;
            .               if (resize) {
            .                   gfx_adjust_width_height_for_scale(width, height, native_width, native_height);
            .               }
            .           
-- line 4159 ----------------------------------------
-- line 4255 ----------------------------------------
            .           
            .           void gfx_push_current_dir(char* path) {
            .               if (gfx_check_image_signature(path) == 1)
            .                   path = &path[7];
            .           
            .               currentDir.push(GetPathWithoutFileName(path));
            .           }
            .           
      319,390 ( 0.00%)  int32_t gfx_check_image_signature(const char* imgData) {
      127,756 ( 0.00%)      uintptr_t i = (uintptr_t)(imgData);
            .           
      255,512 ( 0.00%)      if ((i & 1) == 1) {
            .                   return 0;
            .               }
            .           
      127,756 ( 0.00%)      if (i != 0) {
    1,724,706 ( 0.00%)          return Ship::Context::GetInstance()->GetResourceManager()->OtrSignatureCheck(imgData);
    9,645,578 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (63,878x)
    5,812,898 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (63,878x)
    5,237,996 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (63,878x)
    5,237,996 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (63,878x)
    3,802,234 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::OtrSignatureCheck(char const*) (63,878x)
    1,596,950 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (63,878x)
    1,596,950 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (63,878x)
            .               }
            .           
            .               return 0;
      319,390 ( 0.00%)  }
            .           
            .           void gfx_register_blended_texture(const char* name, uint8_t* mask, uint8_t* replacement) {
            .               if (gfx_check_image_signature(name)) {
            .                   name += 7;
            .               }
            .           
            .               if (gfx_check_image_signature(reinterpret_cast<char*>(replacement))) {
            .                   LUS::Texture* tex = std::static_pointer_cast<LUS::Texture>(
-- line 4283 ----------------------------------------
-- line 4292 ----------------------------------------
            .           }
            .           
            .           void gfx_unregister_blended_texture(const char* name) {
            .               if (gfx_check_image_signature(name)) {
            .                   name += 7;
            .               }
            .           
            .               masked_textures.erase(name);
          124 ( 0.00%)  }
       29,858 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/public/bridge/resourcebridge.cpp
--------------------------------------------------------------------------------
Ir                 

        .           #include "public/bridge/resourcebridge.h"
        .           #include "Context.h"
        .           #include <string>
        .           #include <algorithm>
        .           #include "utils/StrHash64.h"
        .           
  276,384 ( 0.00%)  std::shared_ptr<Ship::IResource> ResourceLoad(const char* name) {
2,257,136 ( 0.00%)      return Ship::Context::GetInstance()->GetResourceManager()->LoadResource(name);
434,708,114 ( 0.36%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (46,064x)
24,661,718 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (46,064x)
12,115,400 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (46,064x)
6,955,664 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (46,064x)
4,191,824 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (46,064x)
3,777,248 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (46,064x)
3,777,248 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (46,064x)
1,934,688 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(decltype(nullptr)) (46,064x)
1,474,048 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (46,064x)
1,151,600 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (46,064x)
1,151,600 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (46,064x)
  184,256 ( 0.00%)  }
        .           
        .           std::shared_ptr<Ship::IResource> ResourceLoad(uint64_t crc) {
        .               auto name = ResourceGetNameByCrc(crc);
        .           
        .               if (name == nullptr || strlen(name) == 0) {
        .                   SPDLOG_TRACE("ResourceLoad: Unknown crc {}\n", crc);
        .                   return nullptr;
        .               }
-- line 17 ----------------------------------------
-- line 20 ----------------------------------------
        .           }
        .           
        .           extern "C" {
        .           
        .           uint64_t ResourceGetCrcByName(const char* name) {
        .               return CRC64(name);
        .           }
        .           
  666,445 ( 0.00%)  const char* ResourceGetNameByCrc(uint64_t crc) {
        .               const std::string* hashStr =
4,931,693 ( 0.00%)          Ship::Context::GetInstance()->GetResourceManager()->GetArchiveManager()->HashToString(crc);
77,873,513 ( 0.06%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::HashToString[abi:cxx11](unsigned long) const (133,289x)
20,126,639 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetInstance() (133,289x)
12,129,299 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetArchiveManager() (133,289x)
12,129,299 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (133,289x)
10,929,698 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (133,289x)
10,929,698 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager>::~shared_ptr() (133,289x)
10,929,698 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context>::~shared_ptr() (133,289x)
3,332,225 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (133,289x)
3,332,225 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (133,289x)
3,332,225 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (133,289x)
  799,734 ( 0.00%)      return hashStr != nullptr ? hashStr->c_str() : nullptr;
2,132,624 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (133,289x)
  399,867 ( 0.00%)  }
        .           
        .           size_t ResourceGetSizeByName(const char* name) {
        .               auto resource = ResourceLoad(name);
        .           
        .               if (resource == nullptr) {
        .                   return 0;
        .               }
        .           
-- line 40 ----------------------------------------
-- line 54 ----------------------------------------
        .           
        .               return resource->GetInitData()->IsCustom;
        .           }
        .           
        .           uint8_t ResourceGetIsCustomByCrc(uint64_t crc) {
        .               return ResourceGetIsCustomByName(ResourceGetNameByCrc(crc));
        .           }
        .           
  221,335 ( 0.00%)  void* ResourceGetDataByName(const char* name) {
  221,335 ( 0.00%)      auto resource = ResourceLoad(name);
477,922,149 ( 0.40%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceLoad(char const*) (44,267x)
        .           
  265,602 ( 0.00%)      if (resource == nullptr) {
  885,340 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, decltype(nullptr)) (44,267x)
        .                   return nullptr;
        .               }
        .           
  442,670 ( 0.00%)      return resource->GetRawPointer();
1,371,888 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<Gfx>::GetRawPointer() (32,664x)
1,106,675 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::IResource, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (44,267x)
  296,016 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<Vtx>::GetRawPointer() (7,048x)
   76,040 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<unsigned char>::GetRawPointer() (3,802x)
   13,280 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<MtxS>::GetRawPointer() (664x)
    2,016 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<KartAIBehaviour>::GetRawPointer() (48x)
    1,722 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<TrackWaypoint>::GetRawPointer() (41x)
  354,136 ( 0.00%)  }
3,629,894 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (44,267x)
        .           
  229,327 ( 0.00%)  void* ResourceGetDataByCrc(uint64_t crc) {
  131,044 ( 0.00%)      auto name = ResourceGetNameByCrc(crc);
43,779,890 ( 0.04%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (32,761x)
        .           
  196,566 ( 0.00%)      if (name == nullptr || strlen(name) == 0) {
        .                   SPDLOG_TRACE("ResourceGetDataByCrc: Unknown crc 0x{:X}\n", crc);
        .                   return nullptr;
        .               }
        .           
  131,044 ( 0.00%)      return ResourceGetDataByName(name);
350,914,010 ( 0.29%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (32,761x)
  196,566 ( 0.00%)  }
        .           
        .           uint16_t ResourceGetTexWidthByName(const char* name) {
        .               const auto res = static_pointer_cast<LUS::Texture>(ResourceLoad(name));
        .           
        .               if (res != nullptr) {
        .                   return res->Width;
        .               }
        .           
-- line 89 ----------------------------------------
-- line 119 ----------------------------------------
        .               if (res != nullptr) {
        .                   return res->Height;
        .               }
        .           
        .               SPDLOG_ERROR("Given texture path is a non-existent resource");
        .               return -1;
        .           }
        .           
   10,782 ( 0.00%)  size_t ResourceGetTexSizeByName(const char* name) {
   23,361 ( 0.00%)      const auto res = static_pointer_cast<LUS::Texture>(ResourceLoad(name));
20,832,971 ( 0.02%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceLoad(char const*) (1,797x)
  203,061 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture> std::static_pointer_cast<LUS::Texture, Ship::IResource>(std::shared_ptr<Ship::IResource>&&) (1,797x)
   57,504 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (1,797x)
        .           
   12,579 ( 0.00%)      if (res != nullptr) {
   35,940 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<LUS::Texture>(std::shared_ptr<LUS::Texture> const&, decltype(nullptr)) (1,797x)
   10,782 ( 0.00%)          return res->ImageDataSize;
   44,925 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<LUS::Texture, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1,797x)
        .               }
        .           
        .               SPDLOG_ERROR("Given texture path is a non-existent resource");
        .               return -1;
   17,970 ( 0.00%)  }
  147,354 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::~shared_ptr() (1,797x)
        .           
        .           size_t ResourceGetTexSizeByCrc(uint64_t crc) {
        .               const auto res = static_pointer_cast<LUS::Texture>(ResourceLoad(crc));
        .           
        .               if (res != nullptr) {
        .                   return res->ImageDataSize;
        .               }
        .           
-- line 144 ----------------------------------------
-- line 195 ----------------------------------------
        .           
        .           void ResourceUnloadDirectory(const char* name) {
        .               Ship::Context::GetInstance()->GetResourceManager()->UnloadDirectory(name);
        .           }
        .           
        .           uint32_t ResourceDoesOtrFileExist() {
        .               return Ship::Context::GetInstance()->GetResourceManager()->DidLoadSuccessfully();
        .           }
       10 ( 0.00%)  }
        9 ( 0.00%)  => libultraship/src/public/bridge/resourcebridge.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/stormlib-src/src/SFileListFile.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 64 ----------------------------------------
        .           
        .               bResult = FileStream_Read(pHandle->pStream, &ByteOffset, pvBuffer, cbBuffer);
        .               if(bResult)
        .                   *pdwBytesRead = cbBuffer;
        .               return bResult;
        .           }
        .           
        .           static bool LoadListFile_MPQ(TListFileHandle * pHandle, void * pvBuffer, DWORD cbBuffer, LPDWORD pdwBytesRead)
       21 ( 0.00%)  {
       24 ( 0.00%)      return SFileReadFile(pHandle->hFile, pvBuffer, cbBuffer, pdwBytesRead, NULL);
5,144,424 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileReadFile.cpp:SFileReadFile (3x)
        6 ( 0.00%)  }
        .           
        .           static bool FreeListFileCache(TListFileCache * pCache)
       12 ( 0.00%)  {
        .               // Valid parameter check
        6 ( 0.00%)      if(pCache != NULL)
       12 ( 0.00%)          STORM_FREE(pCache);
      333 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (3x)
        3 ( 0.00%)      return true;
        6 ( 0.00%)  }
        .           
        .           static TListFileCache * CreateListFileCache(
        .               LOAD_LISTFILE PfnLoadFile,
        .               TListFileHandle * pHandle,
        .               const char * szWildCard,
        .               DWORD dwFileSize,
        .               DWORD dwMaxSize,
        .               DWORD dwFlags)
       27 ( 0.00%)  {
        3 ( 0.00%)      TListFileCache * pCache = NULL;
        3 ( 0.00%)      size_t cchWildCardAligned = 0;
        3 ( 0.00%)      size_t cchWildCard = 0;
        3 ( 0.00%)      DWORD dwBytesRead = 0;
        .           
        .               // Get the amount of bytes that need to be allocated
       15 ( 0.00%)      if(dwFileSize == 0 || dwFileSize > dwMaxSize)
        .                   return NULL;
        .           
        .               // Append buffer for name mask, if any
        6 ( 0.00%)      if(szWildCard != NULL)
        .               {
        .                   cchWildCard = strlen(szWildCard) + 1;
        .                   cchWildCardAligned = (cchWildCard + 3) & 0xFFFFFFFC;
        .               }
        .           
        .               // Allocate cache for one file block
       24 ( 0.00%)      pCache = (TListFileCache *)STORM_ALLOC(BYTE, sizeof(TListFileCache) + cchWildCardAligned + dwFileSize + 1);
      576 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (3x)
        6 ( 0.00%)      if(pCache != NULL)
        .               {
        .                   // Clear the entire structure
       21 ( 0.00%)          memset(pCache, 0, sizeof(TListFileCache) + cchWildCard);
       36 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (3x)
        9 ( 0.00%)          pCache->dwFlags = dwFlags;
        .           
        .                   // Shall we copy the mask?
        6 ( 0.00%)          if(cchWildCard != 0)
        .                   {
        .                       pCache->szWildCard = (char *)(pCache + 1);
        .                       memcpy(pCache->szWildCard, szWildCard, cchWildCard);
        .                   }
        .           
        .                   // Fill-in the rest of the cache pointers
       18 ( 0.00%)          pCache->pBegin = (LPBYTE)(pCache + 1) + cchWildCardAligned;
        .           
        .                   // Load the entire listfile to the cache
       24 ( 0.00%)          PfnLoadFile(pHandle, pCache->pBegin, dwFileSize, &dwBytesRead);
5,144,475 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:LoadListFile_MPQ(TListFileHandle*, void*, unsigned int, unsigned int*) (3x)
        9 ( 0.00%)          if(dwBytesRead != 0)
        .                   {
        .                       // Allocate pointers
       12 ( 0.00%)              pCache->pPos = pCache->pBegin;
       24 ( 0.00%)              pCache->pEnd = pCache->pBegin + dwBytesRead;
        .                   }
        .                   else
        .                   {
        .                       FreeListFileCache(pCache);
        .                       pCache = NULL;
        .                   }
        .               }
        .           
        .               // Return the cache
        3 ( 0.00%)      return pCache;
        6 ( 0.00%)  }
        .           
        .           static TListFileCache * CreateListFileCache(
        .               HANDLE hMpq,
        .               const TCHAR * szListFile,
        .               const char * szWildCard,
        .               DWORD dwMaxSize,
        .               DWORD dwFlags)
       24 ( 0.00%)  {
        3 ( 0.00%)      TListFileCache * pCache = NULL;
        3 ( 0.00%)      TListFileHandle ListHandle = {NULL};
        .           
        .               // Put default value to dwMaxSize
        6 ( 0.00%)      if(dwMaxSize == 0)
        .                   dwMaxSize = MAX_LISTFILE_SIZE;
        .           
        .               // Internal listfile: hMPQ must be non NULL and szListFile must be NULL.
        .               // We load the MPQ::(listfile) file
       12 ( 0.00%)      if(hMpq != NULL && szListFile == NULL)
        .               {
        3 ( 0.00%)          DWORD dwFileSize = 0;
        .           
        .                   // Open the file from the MPQ
       27 ( 0.00%)          if(SFileOpenFileEx(hMpq, LISTFILE_NAME, 0, &ListHandle.hFile))
    6,705 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenFileEx.cpp:SFileOpenFileEx (3x)
        .                   {
        .                       // Get the file size and create the listfile cache
       15 ( 0.00%)              dwFileSize = SFileGetFileSize(ListHandle.hFile, NULL);
      246 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileReadFile.cpp:SFileGetFileSize (3x)
       33 ( 0.00%)              pCache = CreateListFileCache(LoadListFile_MPQ, &ListHandle, szWildCard, dwFileSize, dwMaxSize, dwFlags);
5,145,309 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:CreateListFileCache(bool (*)(TListFileHandle*, void*, unsigned int, unsigned int*), TListFileHandle*, char const*, unsigned int, unsigned int, unsigned int) (3x)
        .           
        .                       // Close the MPQ file
        9 ( 0.00%)              SFileCloseFile(ListHandle.hFile);
    1,326 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenFileEx.cpp:SFileCloseFile (3x)
        .                   }
        .           
        .                   // Return the loaded cache
        6 ( 0.00%)          return pCache;
        .               }
        .           
        .               // External listfile: hMpq must be NULL and szListFile must be non-NULL.
        .               // We load the file using TFileStream
        .               if(hMpq == NULL && szListFile != NULL)
        .               {
        .                   ULONGLONG FileSize = 0;
        .           
-- line 185 ----------------------------------------
-- line 201 ----------------------------------------
        .                   // Return the loaded cache
        .                   return pCache;
        .               }
        .           
        .               // This combination should never happen
        .               SetLastError(ERROR_INVALID_PARAMETER);
        .               assert(false);
        .               return NULL;
        6 ( 0.00%)  }
        .           
        .           #ifdef _DEBUG
        .           /*
        .           TMPQNameCache * CreateNameCache(HANDLE hListFile, const char * szSearchMask)
        .           {
        .               TMPQNameCache * pNameCache;
        .               char * szCachePointer;
        .               size_t cbToAllocate;
-- line 217 ----------------------------------------
-- line 268 ----------------------------------------
        .               if(pNameCache != NULL)
        .                   STORM_FREE(pNameCache);
        .               pNameCache = NULL;
        .           }
        .           */
        .           #endif  // _DEBUG
        .           
        .           static char * ReadListFileLine(TListFileCache * pCache, size_t * PtrLength)
   66,216 ( 0.00%)  {
        .               LPBYTE pbLineBegin;
        .               LPBYTE pbLineEnd;
        .           
        .               // Skip newlines. Keep spaces and tabs, as they can be a legal part of the file name
  463,449 ( 0.00%)      while(pCache->pPos < pCache->pEnd && (pCache->pPos[0] == 0x0A || pCache->pPos[0] == 0x0D))
   82,755 ( 0.00%)          pCache->pPos++;
        .           
        .               // Set the line begin and end
   99,324 ( 0.00%)      if(pCache->pPos >= pCache->pEnd)
        6 ( 0.00%)          return NULL;
   82,755 ( 0.00%)      pbLineBegin = pbLineEnd = pCache->pPos;
        .           
        .               // Find the end of the line
9,058,103 ( 0.01%)      while(pCache->pPos < pCache->pEnd && pCache->pPos[0] != 0x0A && pCache->pPos[0] != 0x0D)
2,742,730 ( 0.00%)          pCache->pPos++;
        .           
        .               // Remember the end of the line
   99,306 ( 0.00%)      pbLineEnd = pCache->pPos++;
   33,102 ( 0.00%)      pbLineEnd[0] = 0;
        .           
        .               // Give the line to the caller
   33,102 ( 0.00%)      if(PtrLength != NULL)
   82,755 ( 0.00%)          PtrLength[0] = (size_t)(pbLineEnd - pbLineBegin);
   16,551 ( 0.00%)      return (char *)pbLineBegin;
   33,108 ( 0.00%)  }
        .           
        .           static int STORMLIB_CDECL CompareFileNodes(const void * p1, const void * p2)
        .           {
        .               char * szFileName1 = *(char **)p1;
        .               char * szFileName2 = *(char **)p2;
        .           
        .               return _stricmp(szFileName1, szFileName2);
        .           }
-- line 309 ----------------------------------------
-- line 402 ----------------------------------------
        .           
        .           //-----------------------------------------------------------------------------
        .           // Local functions (listfile nodes)
        .           
        .           // Adds a name into the list of all names. For each locale in the MPQ,
        .           // one entry will be created
        .           // If the file name is already there, does nothing.
        .           static DWORD SListFileCreateNodeForAllLocales(TMPQArchive * ha, const char * szFileName)
   82,800 ( 0.00%)  {
        .               TFileEntry * pFileEntry;
        .               TMPQHash * pFirstHash;
        .               TMPQHash * pHashEnd;
        .               TMPQHash * pHash;
        .               DWORD dwName1;
        .               DWORD dwName2;
        .           
        .               // If we have HET table, use that one
   66,240 ( 0.00%)      if(ha->pHetTable != NULL)
        .               {
        .                   pFileEntry = GetFileEntryLocale(ha, szFileName, 0);
        .                   if(pFileEntry != NULL)
        .                   {
        .                       // Allocate file name for the file entry
        .                       AllocateFileName(ha, pFileEntry, szFileName);
        .                   }
        .           
        .                   return ERROR_SUCCESS;
        .               }
        .           
        .               // If we have hash table, we use it
   66,240 ( 0.00%)      if(ha->pHashTable != NULL)
        .               {
        .                   // Get the end of the hash table and both names
  149,040 ( 0.00%)          pHashEnd = ha->pHashTable + ha->pHeader->dwHashTableSize;
  115,920 ( 0.00%)          dwName1 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_A);
18,370,245 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (16,560x)
  115,920 ( 0.00%)          dwName2 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_B);
18,370,245 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (16,560x)
        .           
        .                   // Some protectors set very high hash table size (0x00400000 items or more)
        .                   // in order to make this process very slow. We will ignore items
        .                   // in the hash table that would be beyond the end of the file.
        .                   // Example MPQ: MPQ_2022_v1_Sniper.scx
   82,800 ( 0.00%)          if(ha->dwFlags & MPQ_FLAG_HASH_TABLE_CUT)
        .                       pHashEnd = ha->pHashTable + (ha->dwRealHashTableSize / sizeof(TMPQHash));
        .           
        .                   // Go through the hash table and put the name in each item that has the same name pair
        .                   // for(pHash = ha->pHashTable; pHash < pHashEnd; pHash++)
        .                   // {
        .                   //     if(pHash->dwName1 == dwName1 && pHash->dwName2 == dwName2 && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
        .                   //     {
        .                   //         // Allocate file name for the file entry
        .                   //         AllocateFileName(ha, ha->pFileTable + MPQ_BLOCK_INDEX(pHash), szFileName);
        .                   //     }
        .                   // }
        .           
        .                   // Go while we found something
  132,480 ( 0.00%)          pFirstHash = pHash = GetFirstHashEntry(ha, szFileName);
56,419,512 ( 0.05%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetFirstHashEntry(_TMPQArchive*, char const*) (16,560x)
   82,794 ( 0.00%)          while(pHash != NULL)
        .                   {
        .                      // Allocate file name for the file entry
  215,241 ( 0.00%)             AllocateFileName(ha, ha->pFileTable + MPQ_BLOCK_INDEX(pHash), szFileName);
5,065,673 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseFileTable.cpp:AllocateFileName(_TMPQArchive*, _TFileEntry*, char const*) (16,557x)
        .           
        .                      // Now find the next language version of the file
  115,899 ( 0.00%)             pHash = GetNextHashEntry(ha, pFirstHash, pHash);
1,719,495 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetNextHashEntry(_TMPQArchive*, _TMPQHash*, _TMPQHash*) (16,557x)
        .                   }
        .           
   33,120 ( 0.00%)          return ERROR_SUCCESS;
        .               }
        .           
        .               return ERROR_CAN_NOT_COMPLETE;
   33,120 ( 0.00%)  }
        .           
        .           // Saves the whole listfile to the MPQ
        .           DWORD SListFileSaveToMpq(TMPQArchive * ha)
        .           {
        .               TMPQFile * hf = NULL;
        .               LPBYTE pbListFile;
        .               DWORD cbListFile = 0;
        .               DWORD dwErrCode = ERROR_SUCCESS;
-- line 479 ----------------------------------------
-- line 529 ----------------------------------------
        .               return dwErrCode;
        .           }
        .           
        .           static DWORD SFileAddArbitraryListFile(
        .               TMPQArchive * ha,
        .               HANDLE hMpq,
        .               const TCHAR * szListFile,
        .               DWORD dwMaxSize)
       21 ( 0.00%)  {
        3 ( 0.00%)      TListFileCache * pCache = NULL;
        .           
        .               // Create the listfile cache for that file
       33 ( 0.00%)      pCache = CreateListFileCache(hMpq, szListFile, NULL, dwMaxSize, ha->dwFlags);
5,153,733 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:CreateListFileCache(void*, char const*, char const*, unsigned int, unsigned int) (3x)
        6 ( 0.00%)      if(pCache != NULL)
        .               {
        .                   char * szFileName;
        3 ( 0.00%)          size_t nLength = 0;
        .           
        .                   // Get the next line
  165,543 ( 0.00%)          while((szFileName = ReadListFileLine(pCache, &nLength)) != NULL)
12,893,262 ( 0.01%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:ReadListFileLine(TListFileCache*, unsigned long*) (16,554x)
        .                   {
        .                       // Add the line to the MPQ
   49,653 ( 0.00%)              if(nLength != 0)
   82,755 ( 0.00%)                  SListFileCreateNodeForAllLocales(ha, szFileName);
101,216,541 ( 0.08%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) (16,551x)
        .                   }
        .           
        .                   // Delete the cache
        9 ( 0.00%)          FreeListFileCache(pCache);
      372 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:FreeListFileCache(TListFileCache*) (3x)
        .               }
        .           
       12 ( 0.00%)      return (pCache != NULL) ? ERROR_SUCCESS : ERROR_FILE_CORRUPT;
        6 ( 0.00%)  }
        .           
        .           static DWORD SFileAddArbitraryListFile(
        .               TMPQArchive * ha,
        .               const char ** listFileEntries,
        .               DWORD dwEntryCount)
        .           {
        .               if(listFileEntries != NULL && dwEntryCount > 0)
        .               {
-- line 568 ----------------------------------------
-- line 578 ----------------------------------------
        .               }
        .           
        .               return (listFileEntries != NULL && dwEntryCount > 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
        .           }
        .           
        .           static DWORD SFileAddInternalListFile(
        .               TMPQArchive * ha,
        .               HANDLE hMpq)
       15 ( 0.00%)  {
        .               TMPQHash * pFirstHash;
        .               TMPQHash * pHash;
        6 ( 0.00%)      LCID lcSaveLocale = g_lcFileLocale;
        3 ( 0.00%)      DWORD dwMaxSize = MAX_LISTFILE_SIZE;
        3 ( 0.00%)      DWORD dwErrCode = ERROR_SUCCESS;
        .           
        .               // If there is hash table, we need to support multiple listfiles
        .               // with different locales (BrooDat.mpq)
       12 ( 0.00%)      if(ha->pHashTable != NULL)
        .               {
        .                   // If the archive is a malformed map, ignore too large listfiles
       15 ( 0.00%)          if(STORMLIB_TEST_FLAGS(ha->dwFlags, MPQ_FLAG_MALFORMED | MPQ_FLAG_PATCH, MPQ_FLAG_MALFORMED))
        .                       dwMaxSize = 0x40000;
        .           
       21 ( 0.00%)          pFirstHash = pHash = GetFirstHashEntry(ha, LISTFILE_NAME);
    3,339 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetFirstHashEntry(_TMPQArchive*, char const*) (3x)
       27 ( 0.00%)          while(dwErrCode == ERROR_SUCCESS && pHash != NULL)
        .                   {
        .                       // Set the prefered locale to that from list file
       30 ( 0.00%)              SFileSetLocale(SFILE_MAKE_LCID(pHash->Locale, pHash->Platform));
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenArchive.cpp:SFileSetLocale (3x)
        .           
        .                       // Add that listfile
       24 ( 0.00%)              dwErrCode = SFileAddArbitraryListFile(ha, hMpq, NULL, dwMaxSize);
119,561,952 ( 0.10%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SFileAddArbitraryListFile(_TMPQArchive*, void*, char const*, unsigned int) (3x)
        .           
        .                       // Move to the next hash
       21 ( 0.00%)              pHash = GetNextHashEntry(ha, pFirstHash, pHash);
      264 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetNextHashEntry(_TMPQArchive*, _TMPQHash*, _TMPQHash*) (3x)
        .                   }
        .           
        .                   // Restore the original locale
       12 ( 0.00%)          SFileSetLocale(lcSaveLocale);
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenArchive.cpp:SFileSetLocale (3x)
        .               }
        .               else
        .               {
        .                   // Add the single listfile
        .                   dwErrCode = SFileAddArbitraryListFile(ha, hMpq, NULL, dwMaxSize);
        .               }
        .           
        .               // Return the result of the operation
        3 ( 0.00%)      return dwErrCode;
        6 ( 0.00%)  }
        .           
        .           static bool DoListFileSearch(TListFileCache * pCache, SFILE_FIND_DATA * lpFindFileData)
        .           {
        .               // Check for the valid search handle
        .               if(pCache != NULL)
        .               {
        .                   char * szFileName;
        .                   size_t nLength = 0;
-- line 633 ----------------------------------------
-- line 654 ----------------------------------------
        .               return false;
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // File functions
        .           
        .           // Adds a listfile into the MPQ archive.
        .           DWORD WINAPI SFileAddListFile(HANDLE hMpq, const TCHAR * szListFile)
       15 ( 0.00%)  {
        6 ( 0.00%)      TMPQArchive * ha = (TMPQArchive *)hMpq;
        3 ( 0.00%)      DWORD dwErrCode = ERROR_SUCCESS;
        .           
        .               // Add the listfile for each MPQ in the patch chain
       15 ( 0.00%)      while(ha != NULL)
        .               {
        6 ( 0.00%)          if(szListFile != NULL)
        .                       dwErrCode = SFileAddArbitraryListFile(ha, NULL, szListFile, MAX_LISTFILE_SIZE);
        .                   else
       18 ( 0.00%)              dwErrCode = SFileAddInternalListFile(ha, hMpq);
119,565,801 ( 0.10%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SFileAddInternalListFile(_TMPQArchive*, void*) (3x)
        .           
        .                   // Also, add three special files to the listfile:
        .                   // (listfile) itself, (attributes) and (signature)
       12 ( 0.00%)          SListFileCreateNodeForAllLocales(ha, LISTFILE_NAME);
    6,198 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) (3x)
       12 ( 0.00%)          SListFileCreateNodeForAllLocales(ha, SIGNATURE_NAME);
    6,033 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) (3x)
       12 ( 0.00%)          SListFileCreateNodeForAllLocales(ha, ATTRIBUTES_NAME);
    8,012 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) (3x)
        .           
        .                   // Move to the next archive in the chain
        9 ( 0.00%)          ha = ha->haPatch;
        .               }
        .           
        3 ( 0.00%)      return dwErrCode;
        6 ( 0.00%)  }
        .           
        .           DWORD WINAPI SFileAddListFileEntries(HANDLE hMpq, const char ** listFileEntries, DWORD dwEntryCount)
        .           {
        .               TMPQArchive * ha = (TMPQArchive *)hMpq;
        .               DWORD dwErrCode = ERROR_SUCCESS;
        .           
        .               // Add the listfile for each MPQ in the patch chain
        .               while(ha != NULL)
-- line 693 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/std_mutex.h
--------------------------------------------------------------------------------
Ir                 

-- line 59 ----------------------------------------
        .             class __mutex_base
        .             {
        .             protected:
        .               typedef __gthread_mutex_t			__native_type;
        .           
        .           #ifdef __GTHREAD_MUTEX_INIT
        .               __native_type  _M_mutex = __GTHREAD_MUTEX_INIT;
        .           
       90 ( 0.00%)      constexpr __mutex_base() noexcept = default;
        .           #else
        .               __native_type  _M_mutex;
        .           
        .               __mutex_base() noexcept
        .               {
        .                 // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
        .                 __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
        .               }
-- line 75 ----------------------------------------
-- line 96 ----------------------------------------
        .             class mutex : private __mutex_base
        .             {
        .             public:
        .               typedef __native_type* 			native_handle_type;
        .           
        .           #ifdef __GTHREAD_MUTEX_INIT
        .               constexpr
        .           #endif
       30 ( 0.00%)      mutex() noexcept = default;
       72 ( 0.00%)  => /usr/include/c++/14/bits/std_mutex.h:std::__mutex_base::__mutex_base() (3x)
        .               ~mutex() = default;
        .           
        .               mutex(const mutex&) = delete;
        .               mutex& operator=(const mutex&) = delete;
        .           
        .               void
  596,288 ( 0.00%)      lock()
        .               {
  604,172 ( 0.00%)        int __e = __gthread_mutex_lock(&_M_mutex);
8,497,104 ( 0.01%)  => /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_mutex_lock(pthread_mutex_t*) (149,072x)
        .           
        .                 // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
  323,770 ( 0.00%)        if (__e)
        .           	__throw_system_error(__e);
  447,216 ( 0.00%)      }
        .           
        .               _GLIBCXX_NODISCARD
        .               bool
        .               try_lock() noexcept
        .               {
        .                 // XXX EINVAL, EAGAIN, EBUSY
        .                 return !__gthread_mutex_trylock(&_M_mutex);
        .               }
        .           
        .               void
  596,208 ( 0.00%)      unlock()
        .               {
        .                 // XXX EINVAL, EAGAIN, EPERM
  447,156 ( 0.00%)        __gthread_mutex_unlock(&_M_mutex);
7,905,036 ( 0.01%)  => /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_mutex_unlock(pthread_mutex_t*) (149,052x)
  447,156 ( 0.00%)      }
        .           
        .               native_handle_type
        .               native_handle() noexcept
        .               { return &_M_mutex; }
        .             };
        .           
        .             /// @cond undocumented
        .           
-- line 141 ----------------------------------------
-- line 241 ----------------------------------------
        .              */
        .             template<typename _Mutex>
        .               class lock_guard
        .               {
        .               public:
        .                 typedef _Mutex mutex_type;
        .           
        .                 [[__nodiscard__]]
1,179,456 ( 0.00%)        explicit lock_guard(mutex_type& __m) : _M_device(__m)
1,032,024 ( 0.00%)        { _M_device.lock(); }
10,320,240 ( 0.01%)  => /usr/include/c++/14/bits/std_mutex.h:std::mutex::lock() (147,432x)
        .           
        .                 [[__nodiscard__]]
        .                 lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m)
        .                 { } // calling thread owns mutex
        .           
  589,728 ( 0.00%)        ~lock_guard()
1,032,024 ( 0.00%)        { _M_device.unlock(); }
9,288,216 ( 0.01%)  => /usr/include/c++/14/bits/std_mutex.h:std::mutex::unlock() (147,432x)
        .           
        .                 lock_guard(const lock_guard&) = delete;
        .                 lock_guard& operator=(const lock_guard&) = delete;
        .           
        .               private:
        .                 mutex_type&  _M_device;
        .               };
        .           
-- line 265 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_map.h
--------------------------------------------------------------------------------
Ir                 

-- line 189 ----------------------------------------
        .                 // (get_allocator() is also listed in this section)
        .           
        .                 /**
        .                  *  @brief  Default constructor creates no elements.
        .                  */
        .           #if __cplusplus < 201103L
        .                 map() : _M_t() { }
        .           #else
    7,380 ( 0.00%)        map() = default;
      128 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ImGuiKey, std::pair<ImGuiKey const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::_Select1st<std::pair<ImGuiKey const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::less<ImGuiKey>, std::allocator<std::pair<ImGuiKey const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::_Rb_tree() (2x)
        .           #endif
        .           
        .                 /**
        .                  *  @brief  Creates a %map with no elements.
        .                  *  @param  __comp  A comparison object.
        .                  *  @param  __a  An allocator object.
        .                  */
        .                 explicit
-- line 205 ----------------------------------------
-- line 211 ----------------------------------------
        .                  *  @brief  %Map copy constructor.
        .                  *
        .                  *  Whether the allocator is copied depends on the allocator traits.
        .                  */
        .           #if __cplusplus < 201103L
        .                 map(const map& __x)
        .                 : _M_t(__x._M_t) { }
        .           #else
    1,482 ( 0.00%)        map(const map&) = default;
  809,160 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Rb_tree(std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&) (34x)
        .           
        .                 /**
        .                  *  @brief  %Map move constructor.
        .                  *
        .                  *  The newly-created %map contains the exact contents of the moved
        .                  *  instance. The moved instance is a valid, but unspecified, %map.
        .                  */
        .                 map(map&&) = default;
-- line 227 ----------------------------------------
-- line 306 ----------------------------------------
        .           	{ _M_t._M_insert_range_unique(__first, __last); }
        .           
        .           #if __cplusplus >= 201103L
        .                 /**
        .                  *  The dtor only erases the elements, and note that if the elements
        .                  *  themselves are pointers, the pointed-to memory is not touched in any
        .                  *  way.  Managing the pointer is the user's responsibility.
        .                  */
    8,150 ( 0.00%)        ~map() = default;
  203,625 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::~_Rb_tree() (811x)
        .           #endif
        .           
        .                 /**
        .                  *  @brief  %Map assignment operator.
        .                  *
        .                  *  Whether the allocator is copied depends on the allocator traits.
        .                  */
        .           #if __cplusplus < 201103L
-- line 322 ----------------------------------------
-- line 360 ----------------------------------------
        .           
        .                 // iterators
        .                 /**
        .                  *  Returns a read/write iterator that points to the first pair in the
        .                  *  %map.
        .                  *  Iteration is done in ascending order according to the keys.
        .                  */
        .                 iterator
   14,768 ( 0.00%)        begin() _GLIBCXX_NOEXCEPT
   18,460 ( 0.00%)        { return _M_t.begin(); }
   37,076 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ImGuiKey, std::pair<ImGuiKey const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::_Select1st<std::pair<ImGuiKey const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::less<ImGuiKey>, std::allocator<std::pair<ImGuiKey const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::begin() (1,612x)
        .           
        .                 /**
        .                  *  Returns a read-only (constant) iterator that points to the first pair
        .                  *  in the %map.  Iteration is done in ascending order according to the
        .                  *  keys.
        .                  */
        .                 const_iterator
        .                 begin() const _GLIBCXX_NOEXCEPT
-- line 377 ----------------------------------------
-- line 378 ----------------------------------------
        .                 { return _M_t.begin(); }
        .           
        .                 /**
        .                  *  Returns a read/write iterator that points one past the last
        .                  *  pair in the %map.  Iteration is done in ascending order
        .                  *  according to the keys.
        .                  */
        .                 iterator
2,667,840 ( 0.00%)        end() _GLIBCXX_NOEXCEPT
3,334,800 ( 0.00%)        { return _M_t.end(); }
      920 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::end() (40x)
        .           
        .                 /**
        .                  *  Returns a read-only (constant) iterator that points one past the last
        .                  *  pair in the %map.  Iteration is done in ascending order according to
        .                  *  the keys.
        .                  */
        .                 const_iterator
        .                 end() const _GLIBCXX_NOEXCEPT
-- line 395 ----------------------------------------
-- line 433 ----------------------------------------
        .           
        .           #if __cplusplus >= 201103L
        .                 /**
        .                  *  Returns a read-only (constant) iterator that points to the first pair
        .                  *  in the %map.  Iteration is done in ascending order according to the
        .                  *  keys.
        .                  */
        .                 const_iterator
    1,160 ( 0.00%)        cbegin() const noexcept
    1,450 ( 0.00%)        { return _M_t.begin(); }
    6,670 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::begin() const (290x)
        .           
        .                 /**
        .                  *  Returns a read-only (constant) iterator that points one past the last
        .                  *  pair in the %map.  Iteration is done in ascending order according to
        .                  *  the keys.
        .                  */
        .                 const_iterator
    2,320 ( 0.00%)        cend() const noexcept
    2,900 ( 0.00%)        { return _M_t.end(); }
   13,340 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() const (580x)
        .           
        .                 /**
        .                  *  Returns a read-only (constant) reverse iterator that points to the
        .                  *  last pair in the %map.  Iteration is done in descending order
        .                  *  according to the keys.
        .                  */
        .                 const_reverse_iterator
        .                 crbegin() const noexcept
-- line 459 ----------------------------------------
-- line 469 ----------------------------------------
        .                 { return _M_t.rend(); }
        .           #endif
        .           
        .                 // capacity
        .                 /** Returns true if the %map is empty.  (Thus begin() would equal
        .                  *  end().)
        .                 */
        .                 _GLIBCXX_NODISCARD bool
    1,392 ( 0.00%)        empty() const _GLIBCXX_NOEXCEPT
    1,740 ( 0.00%)        { return _M_t.empty(); }
    3,132 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::empty() const (348x)
        .           
        .                 /** Returns the size of the %map.  */
        .                 size_type
    7,924 ( 0.00%)        size() const _GLIBCXX_NOEXCEPT
    9,905 ( 0.00%)        { return _M_t.size(); }
   13,867 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::size() const (1,981x)
        .           
        .                 /** Returns the maximum size of the %map.  */
        .                 size_type
        .                 max_size() const _GLIBCXX_NOEXCEPT
        .                 { return _M_t.max_size(); }
        .           
        .                 // [23.3.1.2] element access
        .                 /**
-- line 491 ----------------------------------------
-- line 496 ----------------------------------------
        .                  *  Allows for easy lookup with the subscript ( @c [] )
        .                  *  operator.  Returns data associated with the key specified in
        .                  *  subscript.  If the key does not exist, a pair with that key
        .                  *  is created using default values, which is then returned.
        .                  *
        .                  *  Lookup requires logarithmic time.
        .                  */
        .                 mapped_type&
    3,912 ( 0.00%)        operator[](const key_type& __k)
        .                 {
        .           	// concept requirements
        .           	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)
        .           
    3,912 ( 0.00%)  	iterator __i = lower_bound(__k);
    3,390 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Ship::CommandEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > >::lower_bound(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (6x)
        .           	// __i->first is greater than or equivalent to __k.
   15,206 ( 0.00%)  	if (__i == end() || key_comp()(__k, (*__i).first))
      920 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (5x)
      175 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >::operator*() const (5x)
      192 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Ship::CommandEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > >::end() (6x)
       80 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Ship::CommandEntry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > >::key_comp() const (5x)
       72 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > const&, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > const&) (6x)
        .           #if __cplusplus >= 201103L
    3,840 ( 0.00%)  	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
   12,321 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > >::_M_emplace_hint_unique<std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>, std::tuple<> >(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >, std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>&&, std::tuple<>&&) (6x)
       66 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >::_Rb_tree_const_iterator(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > const&) (6x)
    1,200 ( 0.00%)  					    std::tuple<const key_type&>(__k),
      216 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::tuple(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (6x)
        .           					    std::tuple<>());
        .           #else
        .           	  __i = insert(__i, value_type(__k, mapped_type()));
        .           #endif
    2,608 ( 0.00%)  	return (*__i).second;
      210 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >::operator*() const (6x)
    1,956 ( 0.00%)        }
        .           
        .           #if __cplusplus >= 201103L
        .                 mapped_type&
      414 ( 0.00%)        operator[](key_type&& __k)
        .                 {
        .           	// concept requirements
        .           	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)
        .           
      414 ( 0.00%)  	iterator __i = lower_bound(__k);
   23,923 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<Ship::ShipDeviceIndex, bool, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::lower_bound(Ship::ShipDeviceIndex const&) (41x)
        .           	// __i->first is greater than or equivalent to __k.
    1,385 ( 0.00%)  	if (__i == end() || key_comp()(__k, (*__i).first))
    1,312 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<Ship::ShipDeviceIndex, bool, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::end() (41x)
      492 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<Ship::ShipDeviceIndex const, bool> > const&, std::_Rb_tree_iterator<std::pair<Ship::ShipDeviceIndex const, bool> > const&) (41x)
    1,104 ( 0.00%)  	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
   53,698 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<Ship::ShipDeviceIndex const, bool> > std::_Rb_tree<Ship::ShipDeviceIndex, std::pair<Ship::ShipDeviceIndex const, bool>, std::_Select1st<std::pair<Ship::ShipDeviceIndex const, bool> >, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::_M_emplace_hint_unique<std::piecewise_construct_t const&, std::tuple<Ship::ShipDeviceIndex&&>, std::tuple<> >(std::_Rb_tree_const_iterator<std::pair<Ship::ShipDeviceIndex const, bool> >, std::piecewise_construct_t const&, std::tuple<Ship::ShipDeviceIndex&&>&&, std::tuple<>&&) (41x)
      451 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<Ship::ShipDeviceIndex const, bool> >::_Rb_tree_const_iterator(std::_Rb_tree_iterator<std::pair<Ship::ShipDeviceIndex const, bool> > const&) (41x)
      552 ( 0.00%)  					std::forward_as_tuple(std::move(__k)),
    3,567 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<Ship::ShipDeviceIndex&&> std::forward_as_tuple<Ship::ShipDeviceIndex>(Ship::ShipDeviceIndex&&) (41x)
      246 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<Ship::ShipDeviceIndex&>::type&& std::move<Ship::ShipDeviceIndex&>(Ship::ShipDeviceIndex&) (41x)
        .           					std::tuple<>());
      276 ( 0.00%)  	return (*__i).second;
    1,435 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<Ship::ShipDeviceIndex const, bool> >::operator*() const (41x)
      207 ( 0.00%)        }
        .           #endif
        .           
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // DR 464. Suggestion for new member functions in standard containers.
        .                 /**
        .                  *  @brief  Access to %map data.
        .                  *  @param  __k  The key for which data should be retrieved.
        .                  *  @return  A reference to the data whose key is equivalent to @a __k, if
-- line 544 ----------------------------------------
-- line 580 ----------------------------------------
        .                  *  the %map.
        .                  *  A %map relies on unique keys and thus a %pair is only inserted if its
        .                  *  first element (the key) is not already present in the %map.
        .                  *
        .                  *  Insertion requires logarithmic time.
        .                  */
        .                 template<typename... _Args>
        .           	std::pair<iterator, bool>
   85,792 ( 0.00%)  	emplace(_Args&&... __args)
        .           	{
        .           #if __cplusplus >= 201703L
        .           	  if constexpr (sizeof...(_Args) == 2)
        .           	    if constexpr (is_same_v<allocator_type, allocator<value_type>>)
        .           	      {
  171,584 ( 0.00%)  		auto&& [__a, __v] = pair<_Args&...>(__args...);
  353,892 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::tuple_element<1ul, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&> >::type&& std::get<1ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&>&&) (10,724x)
  353,892 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::tuple_element<0ul, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&> >::type&& std::get<0ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&>&&) (10,724x)
  150,136 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&>::pair(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, decltype(nullptr)&) (10,724x)
        .           		if constexpr (__usable_key<decltype(__a)>)
        .           		  {
   21,448 ( 0.00%)  		    const key_type& __k = __a;
   64,344 ( 0.00%)  		    iterator __i = lower_bound(__k);
7,635,414 ( 0.01%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::lower_bound(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (10,724x)
  262,975 ( 0.00%)  		    if (__i == end() || key_comp()(__k, (*__i).first))
1,956,702 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#1}))<((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#2}))) std::less<void>::operator()<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (7,855x)
  343,168 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() (10,724x)
  274,925 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::operator*() const (7,855x)
  128,688 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (10,724x)
  125,680 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::key_comp() const (7,855x)
        .           		      {
   57,380 ( 0.00%)  			__i = emplace_hint(__i, std::forward<_Args>(__args)...);
5,639,214 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::emplace_hint<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, decltype(nullptr)>(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, decltype(nullptr)&&) (2,869x)
   31,559 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_const_iterator(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (2,869x)
   17,214 ( 0.00%)  => /usr/include/c++/14/bits/move.h:decltype(nullptr)&& std::forward<decltype(nullptr)>(std::remove_reference<decltype(nullptr)>::type&) (2,869x)
   17,214 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::type&) (2,869x)
   28,690 ( 0.00%)  			return {__i, true};
   94,677 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, bool>::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&, bool>(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&, bool&&) (2,869x)
        .           		      }
   70,695 ( 0.00%)  		    return {__i, false};
  259,215 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, bool>::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&, bool>(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&, bool&&) (7,855x)
        .           		  }
        .           	      }
        .           #endif
        .           	  return _M_t._M_emplace_unique(std::forward<_Args>(__args)...);
   53,620 ( 0.00%)  	}
        .           
        .                 /**
        .                  *  @brief Attempts to build and insert a std::pair into the %map.
        .                  *
        .                  *  @param  __pos  An iterator that serves as a hint as to where the pair
        .                  *                should be inserted.
        .                  *  @param  __args  Arguments used to generate a new pair instance (see
        .                  *	         std::piecewise_contruct for passing arguments to each
-- line 617 ----------------------------------------
-- line 630 ----------------------------------------
        .                  *  See
        .                  *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
        .                  *  for more on @a hinting.
        .                  *
        .                  *  Insertion requires logarithmic time (if the hint is not taken).
        .                  */
        .                 template<typename... _Args>
        .           	iterator
   25,961 ( 0.00%)  	emplace_hint(const_iterator __pos, _Args&&... __args)
        .           	{
   40,346 ( 0.00%)  	  return _M_t._M_emplace_hint_unique(__pos,
   21,206 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_M_emplace_hint_unique<std::pair<ColorCombinerKey, ColorCombiner> >(std::_Rb_tree_const_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >, std::pair<ColorCombinerKey, ColorCombiner>&&) (20x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<ColorCombinerKey, ColorCombiner>&& std::forward<std::pair<ColorCombinerKey, ColorCombiner> >(std::remove_reference<std::pair<ColorCombinerKey, ColorCombiner> >::type&) (20x)
        .           					     std::forward<_Args>(__args)...);
   14,405 ( 0.00%)  	}
        .           #endif
        .           
        .           #if __cplusplus > 201402L
        .                 /// Extract a node.
        .                 node_type
        .                 extract(const_iterator __pos)
        .                 {
        .           	__glibcxx_assert(__pos != end());
-- line 650 ----------------------------------------
-- line 839 ----------------------------------------
        .                 // 2354. Unnecessary copying when inserting into maps with braced-init
        .                 std::pair<iterator, bool>
        .                 insert(value_type&& __x)
        .                 { return _M_t._M_insert_unique(std::move(__x)); }
        .           
        .                 template<typename _Pair>
        .           	__enable_if_t<is_constructible<value_type, _Pair>::value,
        .           		      pair<iterator, bool>>
      120 ( 0.00%)  	insert(_Pair&& __x)
        .           	{
        .           #if __cplusplus >= 201703L
        .           	  using _P2 = remove_reference_t<_Pair>;
        .           	  if constexpr (__is_pair<remove_const_t<_P2>>)
        .           	    if constexpr (is_same_v<allocator_type, allocator<value_type>>)
        .           	      if constexpr (__usable_key<typename _P2::first_type>)
        .           		{
       40 ( 0.00%)  		  const key_type& __k = __x.first;
      120 ( 0.00%)  		  iterator __i = lower_bound(__k);
   10,319 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::lower_bound(ColorCombinerKey const&) (20x)
      496 ( 0.00%)  		  if (__i == end() || key_comp()(__k, (*__i).first))
      776 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<ColorCombinerKey>::operator()(ColorCombinerKey const&, ColorCombinerKey const&) const (14x)
      640 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::end() (20x)
      490 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::operator*() const (14x)
      240 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&, std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&) (20x)
      224 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::key_comp() const (14x)
        .           		    {
      320 ( 0.00%)  		      __i = emplace_hint(__i, std::forward<_Pair>(__x));
   21,706 ( 0.00%)  => /usr/include/c++/14/bits/stl_map.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > std::map<ColorCombinerKey, ColorCombiner, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::emplace_hint<std::pair<ColorCombinerKey, ColorCombiner> >(std::_Rb_tree_const_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >, std::pair<ColorCombinerKey, ColorCombiner>&&) (20x)
      220 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::_Rb_tree_const_iterator(std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> > const&) (20x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<ColorCombinerKey, ColorCombiner>&& std::forward<std::pair<ColorCombinerKey, ColorCombiner> >(std::remove_reference<std::pair<ColorCombinerKey, ColorCombiner> >::type&) (20x)
      200 ( 0.00%)  		      return {__i, true};
      660 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >, bool>::pair<std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >&, bool>(std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >&, bool&&) (20x)
        .           		    }
        .           		  return {__i, false};
        .           		}
        .           #endif
        .           	  return _M_t._M_emplace_unique(std::forward<_Pair>(__x));
       60 ( 0.00%)  	}
        .           #endif
        .                 /// @}
        .           
        .           #if __cplusplus >= 201103L
        .                 /**
        .                  *  @brief Attempts to insert a list of std::pairs into the %map.
        .                  *  @param  __list  A std::initializer_list<value_type> of pairs to be
        .                  *                  inserted.
-- line 874 ----------------------------------------
-- line 1109 ----------------------------------------
        .                  *
        .                  *  This function erases all the elements located by the given key from
        .                  *  a %map.
        .                  *  Note that this function only erases the element, and that if
        .                  *  the element is itself a pointer, the pointed-to memory is not touched
        .                  *  in any way.  Managing the pointer is the user's responsibility.
        .                  */
        .                 size_type
       70 ( 0.00%)        erase(const key_type& __x)
       98 ( 0.00%)        { return _M_t.erase(__x); }
   50,683 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (14x)
        .           
        .           #if __cplusplus >= 201103L
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // DR 130. Associative erase should return an iterator.
        .                 /**
        .                  *  @brief Erases a [first,last) range of elements from a %map.
        .                  *  @param  __first  Iterator pointing to the start of the range to be
        .                  *                   erased.
-- line 1126 ----------------------------------------
-- line 1174 ----------------------------------------
        .           
        .                 /**
        .                  *  Erases all elements in a %map.  Note that this function only
        .                  *  erases the elements, and that if the elements themselves are
        .                  *  pointers, the pointed-to memory is not touched in any way.
        .                  *  Managing the pointer is the user's responsibility.
        .                  */
        .                 void
    3,012 ( 0.00%)        clear() _GLIBCXX_NOEXCEPT
    4,518 ( 0.00%)        { _M_t.clear(); }
       63 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<Ship::ShipDeviceIndex, std::pair<Ship::ShipDeviceIndex const, bool>, std::_Select1st<std::pair<Ship::ShipDeviceIndex const, bool> >, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::clear() (1x)
        .           
        .                 // observers
        .                 /**
        .                  *  Returns the key comparison object out of which the %map was
        .                  *  constructed.
        .                  */
        .                 key_compare
   33,244 ( 0.00%)        key_comp() const
   49,866 ( 0.00%)        { return _M_t.key_comp(); }
   47,130 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::key_comp() const (7,855x)
        .           
        .                 /**
        .                  *  Returns a value comparison object, built from the key comparison
        .                  *  object out of which the %map was constructed.
        .                  */
        .                 value_compare
        .                 value_comp() const
        .                 { return value_compare(_M_t.key_comp()); }
-- line 1200 ----------------------------------------
-- line 1210 ----------------------------------------
        .                  *
        .                  *  This function takes a key and tries to locate the element with which
        .                  *  the key matches.  If successful the function returns an iterator
        .                  *  pointing to the sought after %pair.  If unsuccessful it returns the
        .                  *  past-the-end ( @c end() ) iterator.
        .                  */
        .           
        .                 iterator
  435,890 ( 0.00%)        find(const key_type& __x)
  610,246 ( 0.00%)        { return _M_t.find(__x); }
17,885,997 ( 0.01%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::find(ColorCombinerKey const&) (21,608x)
        .           
        .           #if __cplusplus > 201103L
        .                 template<typename _Kt>
        .           	auto
      250 ( 0.00%)  	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
      350 ( 0.00%)  	{ return _M_t._M_find_tr(__x); }
   49,312 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_find_tr<char [5], void>(char const (&) [5]) (50x)
        .           #endif
        .                 ///@}
        .           
        .                 ///@{
        .                 /**
        .                  *  @brief Tries to locate an element in a %map.
        .                  *  @param  __x  Key of (key, value) %pair to be located.
        .                  *  @return  Read-only (constant) iterator pointing to sought-after
-- line 1233 ----------------------------------------
-- line 1275 ----------------------------------------
        .           #if __cplusplus > 201703L
        .                 ///@{
        .                 /**
        .                  *  @brief  Finds whether an element with the given key exists.
        .                  *  @param  __x  Key of (key, value) pairs to be located.
        .                  *  @return  True if there is an element with the specified key.
        .                  */
        .                 bool
    2,155 ( 0.00%)        contains(const key_type& __x) const
    7,758 ( 0.00%)        { return _M_t.find(__x) != _M_t.end(); }
  607,663 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::find(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (431x)
    9,913 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::end() const (431x)
    5,172 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const&, std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const&) (431x)
        .           
        .                 template<typename _Kt>
        .           	auto
        .           	contains(const _Kt& __x) const
        .           	-> decltype(_M_t._M_find_tr(__x), void(), true)
        .           	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
        .                 ///@}
        .           #endif
-- line 1292 ----------------------------------------
-- line 1299 ----------------------------------------
        .                  *           than key, or end().
        .                  *
        .                  *  This function returns the first element of a subsequence of elements
        .                  *  that matches the given key.  If unsuccessful it returns an iterator
        .                  *  pointing to the first element that has a greater value than given key
        .                  *  or end() if no such element exists.
        .                  */
        .                 iterator
   57,325 ( 0.00%)        lower_bound(const key_type& __x)
   80,255 ( 0.00%)        { return _M_t.lower_bound(__x); }
   10,111 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::lower_bound(std::pair<unsigned long, unsigned int> const&) (18x)
        .           
        .           #if __cplusplus > 201103L
        .                 template<typename _Kt>
        .           	auto
        .           	lower_bound(const _Kt& __x)
        .           	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
        .           	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
        .           #endif
-- line 1316 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir                   

-- line 104 ----------------------------------------
          .                 { using type = const _Tp; };
          .           
          .               template<typename _Pair>
          .                 struct __1st_type<_Pair&>
          .                 { using type = typename __1st_type<_Pair>::type&; };
          .           
          .               template<typename _Tp>
          .                 typename __1st_type<_Tp>::type&&
 60,526,245 ( 0.05%)        operator()(_Tp&& __x) const noexcept
 60,526,245 ( 0.05%)        { return std::forward<_Tp>(__x).first; }
    319,236 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > const& std::forward<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > const&>(std::remove_reference<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > const&>::type&) (53,206x)
          .             };
          .           
          .             template<typename _ExKey, typename _Value>
          .               struct _ConvertToValueType;
          .           
          .             template<typename _Value>
          .               struct _ConvertToValueType<_Identity, _Value>
          .               {
-- line 121 ----------------------------------------
-- line 128 ----------------------------------------
          .             template<typename _Value>
          .               struct _ConvertToValueType<_Select1st, _Value>
          .               {
          .                 constexpr _Value&&
          .                 operator()(_Value&& __x) const noexcept
          .                 { return std::move(__x); }
          .           
          .                 constexpr const _Value&
        212 ( 0.00%)        operator()(const _Value& __x) const noexcept
        159 ( 0.00%)        { return __x; }
          .           
          .                 template<typename _Kt, typename _Val>
          .           	constexpr std::pair<_Kt, _Val>&&
          .           	operator()(std::pair<_Kt, _Val>&& __x) const noexcept
          .           	{ return std::move(__x); }
          .           
          .                 template<typename _Kt, typename _Val>
          .           	constexpr const std::pair<_Kt, _Val>&
-- line 145 ----------------------------------------
-- line 150 ----------------------------------------
          .             template<typename _ExKey>
          .               struct _NodeBuilder;
          .           
          .             template<>
          .               struct _NodeBuilder<_Select1st>
          .               {
          .                 template<typename _Kt, typename _Arg, typename _NodeGenerator>
          .           	static auto
        357 ( 0.00%)  	_S_build(_Kt&& __k, _Arg&& __arg, const _NodeGenerator& __node_gen)
          .           	-> typename _NodeGenerator::__node_ptr
          .           	{
        459 ( 0.00%)  	  return __node_gen(std::forward<_Kt>(__k),
      8,337 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false>* std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false> > >::operator()<Attribute const&, std::any const&>(Attribute const&, std::any const&) const (14x)
         84 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Attribute const& std::forward<Attribute const&>(std::remove_reference<Attribute const&>::type&) (14x)
        204 ( 0.00%)  			    std::forward<_Arg>(__arg).second);
         84 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<Attribute const, std::any> const& std::forward<std::pair<Attribute const, std::any> const&>(std::remove_reference<std::pair<Attribute const, std::any> const&>::type&) (14x)
        153 ( 0.00%)  	}
          .               };
          .           
          .             template<>
          .               struct _NodeBuilder<_Identity>
          .               {
          .                 template<typename _Kt, typename _Arg, typename _NodeGenerator>
          .           	static auto
          .           	_S_build(_Kt&& __k, _Arg&&, const _NodeGenerator& __node_gen)
-- line 171 ----------------------------------------
-- line 198 ----------------------------------------
          .                 using __node_alloc_type = _NodeAlloc;
          .                 using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
          .                 using __node_alloc_traits =
          .           	typename __hashtable_alloc::__node_alloc_traits;
          .           
          .               public:
          .                 using __node_ptr = typename __hashtable_alloc::__node_ptr;
          .           
          5 ( 0.00%)        _ReuseOrAllocNode(__node_ptr __nodes, __hashtable_alloc& __h)
          9 ( 0.00%)        : _M_nodes(__nodes), _M_h(__h) { }
          .                 _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;
          .           
          4 ( 0.00%)        ~_ReuseOrAllocNode()
         10 ( 0.00%)        { _M_h._M_deallocate_nodes(_M_nodes); }
         12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<unsigned int, false> > >::_M_deallocate_nodes(std::__detail::_Hash_node<unsigned int, false>*) (1x)
          .           
          .                 template<typename... _Args>
          .           	__node_ptr
          .           	operator()(_Args&&... __args) const
          .           	{
          .           	  if (!_M_nodes)
          .           	    return _M_h._M_allocate_node(std::forward<_Args>(__args)...);
          .           
-- line 219 ----------------------------------------
-- line 240 ----------------------------------------
          .               struct _AllocNode
          .               {
          .               private:
          .                 using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
          .           
          .               public:
          .                 using __node_ptr = typename __hashtable_alloc::__node_ptr;
          .           
    117,384 ( 0.00%)        _AllocNode(__hashtable_alloc& __h)
    176,076 ( 0.00%)        : _M_h(__h) { }
          .           
          .                 template<typename... _Args>
          .           	__node_ptr
    142,176 ( 0.00%)  	operator()(_Args&&... __args) const
    260,826 ( 0.00%)  	{ return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
      2,700 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>* std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >::_M_allocate_node<Ship::Stick const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(Ship::Stick const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::Stick const& std::forward<Ship::Stick const&>(std::remove_reference<Ship::Stick const&>::type&) (2x)
         12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type&) (2x)
          .           
          .               private:
          .                 __hashtable_alloc& _M_h;
          .               };
          .           
          .             // Auxiliary types used for all instantiations of _Hashtable nodes
          .             // and iterators.
          .           
-- line 262 ----------------------------------------
-- line 295 ----------------------------------------
          .              *
          .              *  Important traits for hash tables depending on associated hasher.
          .              *
          .              */
          .             template<typename _Hash>
          .               struct _Hashtable_hash_traits
          .               {
          .                 static constexpr std::size_t
 23,764,572 ( 0.02%)        __small_size_threshold() noexcept
 35,646,858 ( 0.03%)        { return std::__is_fast_hash<_Hash>::value ? 0 : 20; }
          .               };
          .           
          .             /**
          .              *  struct _Hash_node_base
          .              *
          .              *  Nodes, used to wrap elements stored in the hash table.  A policy
          .              *  template parameter of class template _Hashtable controls whether
          .              *  nodes also store a hash code. In some cases (e.g. strings) this
          .              *  may be a performance win.
          .              */
          .             struct _Hash_node_base
          .             {
          .               _Hash_node_base* _M_nxt;
          .           
    835,986 ( 0.00%)      _Hash_node_base() noexcept : _M_nxt() { }
          .           
          3 ( 0.00%)      _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
          .             };
          .           
          .             /**
          .              *  struct _Hash_node_value_base
          .              *
          .              *  Node type with the value to store.
          .              */
          .             template<typename _Value>
-- line 329 ----------------------------------------
-- line 331 ----------------------------------------
          .               {
          .                 typedef _Value value_type;
          .           
          .                 __gnu_cxx::__aligned_buffer<_Value> _M_storage;
          .           
          .                 [[__gnu__::__always_inline__]]
          .                 _Value*
          .                 _M_valptr() noexcept
 25,981,051 ( 0.02%)        { return _M_storage._M_ptr(); }
      6,165 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >::_M_ptr() (411x)
          .           
          .                 [[__gnu__::__always_inline__]]
          .                 const _Value*
          .                 _M_valptr() const noexcept
 60,523,980 ( 0.05%)        { return _M_storage._M_ptr(); }
    605,370 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > >::_M_ptr() const (40,358x)
          .           
          .                 [[__gnu__::__always_inline__]]
          .                 _Value&
          .                 _M_v() noexcept
    154,551 ( 0.00%)        { return *_M_valptr(); }
          .           
          .                 [[__gnu__::__always_inline__]]
          .                 const _Value&
          .                 _M_v() const noexcept
 12,104,796 ( 0.01%)        { return *_M_valptr(); }
          .               };
          .           
          .             /**
          .              *  Primary template struct _Hash_node_code_cache.
          .              */
          .             template<bool _Cache_hash_code>
          .               struct _Hash_node_code_cache
          .               { };
-- line 362 ----------------------------------------
-- line 373 ----------------------------------------
          .               : _Hash_node_value_base<_Value>
          .               , _Hash_node_code_cache<_Cache_hash_code>
          .               { };
          .           
          .             /**
          .              *  Primary template struct _Hash_node.
          .              */
          .             template<typename _Value, bool _Cache_hash_code>
    746,190 ( 0.00%)      struct _Hash_node
        400 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node_base::_Hash_node_base() (50x)
          .               : _Hash_node_base
          .               , _Hash_node_value<_Value, _Cache_hash_code>
          .               {
          .                 _Hash_node*
  1,446,114 ( 0.00%)        _M_next() const noexcept
  1,928,155 ( 0.00%)        { return static_cast<_Hash_node*>(this->_M_nxt); }
          .               };
          .           
          .             /// Base class for node iterators.
          .             template<typename _Value, bool _Cache_hash_code>
          .               struct _Node_iterator_base
          .               {
          .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
          .           
          .                 __node_type* _M_cur;
          .           
          .                 _Node_iterator_base() : _M_cur(nullptr) { }
 72,759,544 ( 0.06%)        _Node_iterator_base(__node_type* __p) noexcept
109,139,316 ( 0.09%)        : _M_cur(__p) { }
          .           
          .                 void
    317,008 ( 0.00%)        _M_incr() noexcept
    713,268 ( 0.00%)        { _M_cur = _M_cur->_M_next(); }
      4,816 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_next() const (688x)
          .           
          .                 friend bool
 25,114,756 ( 0.02%)        operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
          .                 noexcept
 50,229,512 ( 0.04%)        { return __x._M_cur == __y._M_cur; }
          .           
          .           #if __cpp_impl_three_way_comparison < 201907L
          .                 friend bool
          .                 operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
          .                 noexcept
          .                 { return __x._M_cur != __y._M_cur; }
          .           #endif
          .               };
-- line 417 ----------------------------------------
-- line 434 ----------------------------------------
          .           				      const value_type*, value_type*>;
          .           
          .                 using reference = __conditional_t<__constant_iterators,
          .           					const value_type&, value_type&>;
          .           
          .                 _Node_iterator() = default;
          .           
          .                 explicit
  2,992,740 ( 0.00%)        _Node_iterator(__node_type* __p) noexcept
  4,788,384 ( 0.00%)        : __base_type(__p) { }
    165,510 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator_base<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> >, false>::_Node_iterator_base(std::__detail::_Hash_node<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> >, false>*) (16,551x)
          .           
          .                 reference
    450,724 ( 0.00%)        operator*() const noexcept
    901,448 ( 0.00%)        { return this->_M_cur->_M_v(); }
          .           
          .                 pointer
  1,054,576 ( 0.00%)        operator->() const noexcept
  1,581,864 ( 0.00%)        { return this->_M_cur->_M_valptr(); }
          .           
          .                 _Node_iterator&
    317,008 ( 0.00%)        operator++() noexcept
          .                 {
    237,756 ( 0.00%)  	this->_M_incr();
     13,760 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator_base<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>::_M_incr() (688x)
     79,252 ( 0.00%)  	return *this;
    158,504 ( 0.00%)        }
          .           
          .                 _Node_iterator
          .                 operator++(int) noexcept
          .                 {
          .           	_Node_iterator __tmp(*this);
          .           	this->_M_incr();
          .           	return __tmp;
          .                 }
-- line 466 ----------------------------------------
-- line 481 ----------------------------------------
          .                 typedef std::forward_iterator_tag			iterator_category;
          .           
          .                 typedef const value_type*				pointer;
          .                 typedef const value_type&				reference;
          .           
          .                 _Node_const_iterator() = default;
          .           
          .                 explicit
 87,956,690 ( 0.07%)        _Node_const_iterator(__node_type* __p) noexcept
140,730,704 ( 0.12%)        : __base_type(__p) { }
172,152,180 ( 0.14%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator_base<std::pair<Attribute const, std::any>, false>::_Node_iterator_base(std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false>*) (17,215,218x)
          .           
          .                 _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
          .           			   __cache>& __x) noexcept
          .                 : __base_type(__x._M_cur) { }
          .           
          .                 reference
          .                 operator*() const noexcept
          .                 { return this->_M_cur->_M_v(); }
          .           
          .                 pointer
 23,489,388 ( 0.02%)        operator->() const noexcept
 35,234,082 ( 0.03%)        { return this->_M_cur->_M_valptr(); }
          .           
          .                 _Node_const_iterator&
          .                 operator++() noexcept
          .                 {
          .           	this->_M_incr();
          .           	return *this;
          .                 }
          .           
-- line 510 ----------------------------------------
-- line 524 ----------------------------------------
          .             /// into the range [0, N).
          .             struct _Mod_range_hashing
          .             {
          .               typedef std::size_t first_argument_type;
          .               typedef std::size_t second_argument_type;
          .               typedef std::size_t result_type;
          .           
          .               result_type
 60,835,850 ( 0.05%)      operator()(first_argument_type __num,
          .           	       second_argument_type __den) const noexcept
 73,003,040 ( 0.06%)      { return __num % __den; }
          .             };
          .           
          .             /// Default ranged hash function H.  In principle it should be a
          .             /// function object composed from objects of type H1 and H2 such that
          .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
          .             /// h1 and h2.  So instead we'll just use a tag to tell class template
          .             /// hashtable to do that composition.
          .             struct _Default_ranged_hash { };
          .           
          .             /// Default value for rehash policy.  Bucket size is (usually) the
          .             /// smallest prime that keeps the load factor small enough.
          .             struct _Prime_rehash_policy
          .             {
          .               using __has_load_factor = true_type;
          .           
      2,148 ( 0.00%)      _Prime_rehash_policy(float __z = 1.0) noexcept
      4,312 ( 0.00%)      : _M_max_load_factor(__z), _M_next_resize(0) { }
          .           
          .               float
          .               max_load_factor() const noexcept
          .               { return _M_max_load_factor; }
          .           
          .               // Return a bucket size no smaller than n.
          .               std::size_t
          .               _M_next_bkt(std::size_t __n) const;
-- line 559 ----------------------------------------
-- line 569 ----------------------------------------
          .               // is the new bucket count.  If not, return make_pair(false, 0).
          .               std::pair<bool, std::size_t>
          .               _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
          .           		   std::size_t __n_ins) const;
          .           
          .               typedef std::size_t _State;
          .           
          .               _State
    152,976 ( 0.00%)      _M_state() const
    203,970 ( 0.00%)      { return _M_next_resize; }
          .           
          .               void
          .               _M_reset() noexcept
          3 ( 0.00%)      { _M_next_resize = 0; }
          .           
          .               void
          .               _M_reset(_State __state)
          .               { _M_next_resize = __state; }
          .           
          .               static const std::size_t _S_growth_factor = 2;
          .           
          .               float		_M_max_load_factor;
-- line 590 ----------------------------------------
-- line 722 ----------------------------------------
          .             };
          .           
          .             template<typename _RehashPolicy>
          .               struct _RehashStateGuard
          .               {
          .                 _RehashPolicy* _M_guarded_obj;
          .                 typename _RehashPolicy::_State _M_prev_state;
          .           
    254,960 ( 0.00%)        _RehashStateGuard(_RehashPolicy& __policy)
    254,960 ( 0.00%)        : _M_guarded_obj(std::__addressof(__policy))
    305,952 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::_Prime_rehash_policy* std::__addressof<std::__detail::_Prime_rehash_policy>(std::__detail::_Prime_rehash_policy&) (50,992x)
    254,960 ( 0.00%)        , _M_prev_state(__policy._M_state())
    356,944 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Prime_rehash_policy::_M_state() const (50,992x)
    152,976 ( 0.00%)        { }
          .                 _RehashStateGuard(const _RehashStateGuard&) = delete;
          .           
    203,968 ( 0.00%)        ~_RehashStateGuard()
          .                 {
    203,968 ( 0.00%)  	if (_M_guarded_obj)
          .           	  _M_guarded_obj->_M_reset(_M_prev_state);
    152,976 ( 0.00%)        }
          .               };
          .           
          .             // Base classes for std::_Hashtable.  We define these base classes
          .             // because in some cases we want to do different things depending on
          .             // the value of a policy class.  In some cases the policy class
          .             // affects which member functions and nested typedefs are defined;
          .             // we handle that by specializing base class templates.  Several of
          .             // the base class templates need to access other members of class
-- line 748 ----------------------------------------
-- line 811 ----------------------------------------
          .                 {
          .           	auto __ite = static_cast<__hashtable*>(this)->find(__k);
          .           	if (!__ite._M_cur)
          .           	  __throw_out_of_range(__N("unordered_map::at"));
          .           	return __ite->second;
          .                 }
          .           
          .                 const mapped_type&
 28,692,030 ( 0.02%)        at(const key_type& __k) const
          .                 {
 34,430,436 ( 0.03%)  	auto __ite = static_cast<const __hashtable*>(this)->find(__k);
2,002,703,694 ( 1.66%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const (5,738,406x)
 17,215,218 ( 0.01%)  	if (!__ite._M_cur)
          .           	  __throw_out_of_range(__N("unordered_map::at"));
 22,953,624 ( 0.02%)  	return __ite->second;
166,413,774 ( 0.14%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_const_iterator<std::pair<Attribute const, std::any>, false, false>::operator->() const (5,738,406x)
 11,476,812 ( 0.01%)        }
          .               };
          .           
          .             template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
    307,556 ( 0.00%)      _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
          .               operator[](const key_type& __k)
          .               -> mapped_type&
          .               {
    102,512 ( 0.00%)        __hashtable* __h = static_cast<__hashtable*>(this);
    307,536 ( 0.00%)        __hash_code __code = __h->_M_hash_code(__k);
    629,052 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(unsigned long const&) const (16,554x)
    307,536 ( 0.00%)        std::size_t __bkt = __h->_M_bucket_index(__code);
    645,606 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_bucket_index(unsigned long) const (16,554x)
    461,306 ( 0.00%)        if (auto __node = __h->_M_find_node(__bkt, __k, __code))
  4,127,331 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_node(unsigned long, unsigned long const&, unsigned long) const (16,554x)
    122,017 ( 0.00%)  	return __node->_M_v().second;
          .           
    338,250 ( 0.00%)        typename __hashtable::_Scoped_node __node {
 13,537,369 ( 0.01%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Scoped_node::_Scoped_node<std::piecewise_construct_t const&, std::tuple<unsigned long const&>, std::tuple<> >(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >*, std::piecewise_construct_t const&, std::tuple<unsigned long const&>&&, std::tuple<>&&) (16,551x)
          .           	__h,
          .           	std::piecewise_construct,
    169,125 ( 0.00%)  	std::tuple<const key_type&>(__k),
    595,836 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<unsigned long const&>::tuple(unsigned long const&) (16,551x)
          .           	std::tuple<>()
          .                 };
          .                 auto __pos
    270,606 ( 0.00%)  	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
  8,084,944 ( 0.01%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*, unsigned long) (16,551x)
     33,825 ( 0.00%)        __node._M_node = nullptr;
    135,302 ( 0.00%)        return __pos->second;
    479,979 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false, false>::operator->() const (16,551x)
    357,771 ( 0.00%)      }
    182,061 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Scoped_node::~_Scoped_node() (16,551x)
          .           
          .             template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               auto
    102,756 ( 0.00%)      _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
          .               operator[](key_type&& __k)
          .               -> mapped_type&
          .               {
     34,252 ( 0.00%)        __hashtable* __h = static_cast<__hashtable*>(this);
    102,756 ( 0.00%)        __hash_code __code = __h->_M_hash_code(__k);
     83,640 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::__detail::_Select1st, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>::_M_hash_code(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (498x)
    102,756 ( 0.00%)        std::size_t __bkt = __h->_M_bucket_index(__code);
     19,422 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_bucket_index(unsigned long) const (498x)
    154,134 ( 0.00%)        if (auto __node = __h->_M_find_node(__bkt, __k, __code))
    139,900 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_find_node(unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long) const (498x)
      2,877 ( 0.00%)  	return __node->_M_v().second;
          .           
    167,150 ( 0.00%)        typename __hashtable::_Scoped_node __node {
     85,935 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_Scoped_node::_Scoped_node<std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>, std::tuple<> >(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> > >*, std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>&&, std::tuple<>&&) (87x)
          .           	__h,
          .           	std::piecewise_construct,
    133,720 ( 0.00%)  	std::forward_as_tuple(std::move(__k)),
      7,569 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&> std::forward_as_tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (87x)
        522 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&& std::move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (87x)
          .           	std::tuple<>()
          .                 };
          .                 auto __pos
    133,726 ( 0.00%)  	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
     32,250 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>*, unsigned long) (87x)
     16,715 ( 0.00%)        __node._M_node = nullptr;
     66,861 ( 0.00%)        return __pos->second;
      2,523 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, false, true>::operator->() const (87x)
    135,775 ( 0.00%)      }
        957 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_Scoped_node::~_Scoped_node() (87x)
          .           
          .             // Partial specialization for unordered_map<const T, U>, see PR 104174.
          .             template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits, bool __uniq>
          .               struct _Map_base<const _Key, pair<const _Key, _Val>,
          .           		     _Alloc, _Select1st, _Equal, _Hash,
          .           		     _RangeHash, _Unused, _RehashPolicy, _Traits, __uniq>
-- line 888 ----------------------------------------
-- line 920 ----------------------------------------
          .                 using value_type = typename __hashtable_base::value_type;
          .                 using size_type = typename __hashtable_base::size_type;
          .           
          .                 using __unique_keys = typename _Traits::__unique_keys;
          .                 using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;
          .                 using __node_gen_type = _AllocNode<__node_alloc_type>;
          .           
          .                 __hashtable&
         30 ( 0.00%)        _M_conjure_hashtable()
         30 ( 0.00%)        { return *(static_cast<__hashtable*>(this)); }
          .           
          .                 template<typename _InputIterator, typename _NodeGetter>
          .           	void
          .           	_M_insert_range(_InputIterator __first, _InputIterator __last,
          .           			const _NodeGetter&, true_type __uks);
          .           
          .                 template<typename _InputIterator, typename _NodeGetter>
          .           	void
-- line 937 ----------------------------------------
-- line 989 ----------------------------------------
          .           	}
          .           
          .                 void
          .                 insert(initializer_list<value_type> __l)
          .                 { this->insert(__l.begin(), __l.end()); }
          .           
          .                 template<typename _InputIterator>
          .           	void
         30 ( 0.00%)  	insert(_InputIterator __first, _InputIterator __last)
          .           	{
         20 ( 0.00%)  	  __hashtable& __h = _M_conjure_hashtable();
          6 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Insert_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_conjure_hashtable() (1x)
         25 ( 0.00%)  	  __node_gen_type __node_gen(__h);
         10 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> > >::_AllocNode(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> > >&) (1x)
         35 ( 0.00%)  	  return _M_insert_range(__first, __last, __node_gen, __unique_keys{});
    107,218 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:void std::__detail::_Insert_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_insert_range<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const*, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> > > >(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const*, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const*, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> > > const&, std::integral_constant<bool, true>) (1x)
         10 ( 0.00%)  	}
          .               };
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _InputIterator, typename _NodeGetter>
          .                 void
         35 ( 0.00%)        _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          .           		   _Hash, _RangeHash, _Unused,
          .           		   _RehashPolicy, _Traits>::
          .                 _M_insert_range(_InputIterator __first, _InputIterator __last,
          .           		      const _NodeGetter& __node_gen, true_type __uks)
          .                 {
         20 ( 0.00%)  	__hashtable& __h = _M_conjure_hashtable();
         12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Insert_base<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_conjure_hashtable() (2x)
        232 ( 0.00%)  	for (; __first != __last; ++__first)
        318 ( 0.00%)  	  __h._M_insert(*__first, __node_gen, __uks);
     20,200 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::pair<std::__detail::_Node_iterator<std::pair<Attribute const, std::any>, false, false>, bool> std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert<std::pair<Attribute const, std::any> const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false> > > >(std::pair<Attribute const, std::any> const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<Attribute const, std::any>, false> > > const&, std::integral_constant<bool, true>) (14x)
         20 ( 0.00%)        }
          .           
          .             template<typename _Key, typename _Value, typename _Alloc,
          .           	   typename _ExtractKey, typename _Equal,
          .           	   typename _Hash, typename _RangeHash, typename _Unused,
          .           	   typename _RehashPolicy, typename _Traits>
          .               template<typename _InputIterator, typename _NodeGetter>
          .                 void
          .                 _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 1028 ----------------------------------------
-- line 1232 ----------------------------------------
          .              *  final) and when it is worth it (the type is empty.)
          .              */
          .             template<int _Nm, typename _Tp,
          .           	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
          .               struct _Hashtable_ebo_helper;
          .           
          .             /// Specialization using EBO.
          .             template<int _Nm, typename _Tp>
    238,016 ( 0.00%)      struct _Hashtable_ebo_helper<_Nm, _Tp, true>
          .               : private _Tp
          .               {
     11,704 ( 0.00%)        _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
          .           
          .                 template<typename _OtherTp>
    146,780 ( 0.00%)  	_Hashtable_ebo_helper(_OtherTp&& __tp)
    293,490 ( 0.00%)  	: _Tp(std::forward<_OtherTp>(__tp))
      7,662 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> >&& std::forward<std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> > >(std::remove_reference<std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> > >::type&) (1,277x)
     88,068 ( 0.00%)  	{ }
          .           
144,185,040 ( 0.12%)        const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
    821,928 ( 0.00%)        _Tp& _M_get() { return static_cast<_Tp&>(*this); }
          .               };
          .           
          .             /// Specialization not using EBO.
          .             template<int _Nm, typename _Tp>
          .               struct _Hashtable_ebo_helper<_Nm, _Tp, false>
          .               {
          .                 _Hashtable_ebo_helper() = default;
          .           
-- line 1259 ----------------------------------------
-- line 1318 ----------------------------------------
          .                 hash_function() const
          .                 { return _M_hash(); }
          .           
          .               protected:
          .                 typedef std::size_t 				__hash_code;
          .           
          .                 // We need the default constructor for the local iterators and _Hashtable
          .                 // default constructor.
      5,320 ( 0.00%)        _Hash_code_base() = default;
         12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<1, std::hash<unsigned int>, true>::_Hashtable_ebo_helper() (2x)
          .           
         65 ( 0.00%)        _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
         17 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<1, std::hash<Ship::Stick>, true>::_Hashtable_ebo_helper<std::hash<Ship::Stick> const&>(std::hash<Ship::Stick> const&) (1x)
          .           
          .                 __hash_code
 60,481,185 ( 0.05%)        _M_hash_code(const _Key& __k) const
          .                 {
          .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
          .           	    "hash function must be invocable with an argument of key type");
108,657,123 ( 0.09%)  	return _M_hash()(__k);
        399 ( 0.00%)  => /usr/include/c++/14/bits/functional_hash.h:std::__hash_enum<Ship::Stick, true>::operator()(Ship::Stick) const (21x)
        315 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<Ship::Stick, std::pair<Ship::Stick const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::hash<Ship::Stick>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash() const (21x)
 24,192,474 ( 0.02%)        }
          .           
          .                 template<typename _Kt>
          .           	__hash_code
        260 ( 0.00%)  	_M_hash_code_tr(const _Kt& __k) const
          .           	{
          .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
          .           	    "hash function must be invocable with an argument of key type");
        436 ( 0.00%)  	  return _M_hash()(__k);
      5,357 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__str_hash_base<char, std::allocator<char>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (32x)
        480 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>::_M_hash() const (32x)
        104 ( 0.00%)  	}
          .           
          .                 __hash_code
          .                 _M_hash_code(const _Hash_node_value<_Value, false>& __n) const
          .                 { return _M_hash_code(_ExtractKey{}(__n._M_v())); }
          .           
          .                 __hash_code
          .                 _M_hash_code(const _Hash_node_value<_Value, true>& __n) const
          .                 { return __n._M_hash_code; }
          .           
          .                 std::size_t
 71,380,818 ( 0.06%)        _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
 95,174,424 ( 0.08%)        { return _RangeHash{}(__c, __bkt_count); }
        253 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Mod_range_hashing::operator()(unsigned long, unsigned long) const (23x)
          .           
          .                 std::size_t
  1,197,516 ( 0.00%)        _M_bucket_index(const _Hash_node_value<_Value, false>& __n,
          .           		      std::size_t __bkt_count) const
          .           	noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))
          .           		  && noexcept(declval<const _RangeHash&>()((__hash_code)0,
          .           							   (std::size_t)0)) )
          .                 {
  3,792,134 ( 0.00%)  	return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
  1,533,604 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<unsigned long, std::pair<unsigned long const, std::shared_ptr<Ship::Archive> >, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(unsigned long const&) const (40,358x)
    645,728 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > const&>::type&& std::__detail::_Select1st::operator()<std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > const&>(std::pair<unsigned long const, std::shared_ptr<Ship::Archive> > const&) const (40,358x)
    443,938 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Mod_range_hashing::operator()(unsigned long, unsigned long) const (40,358x)
          .           			    __bkt_count);
    399,172 ( 0.00%)        }
          .           
          .                 std::size_t
    424,686 ( 0.00%)        _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
          .           		      std::size_t __bkt_count) const
          .           	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
          .           							(std::size_t)0)) )
    637,029 ( 0.00%)        { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
     49,126 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Mod_range_hashing::operator()(unsigned long, unsigned long) const (4,466x)
          .           
          .                 void
    250,820 ( 0.00%)        _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
    150,492 ( 0.00%)        { }
          .           
          .                 void
     89,410 ( 0.00%)        _M_copy_code(_Hash_node_code_cache<false>&,
          .           		   const _Hash_node_code_cache<false>&) const
     53,646 ( 0.00%)        { }
          .           
          .                 void
      4,135 ( 0.00%)        _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
      4,964 ( 0.00%)        { __n._M_hash_code = __c; }
          .           
          .                 void
     28,730 ( 0.00%)        _M_copy_code(_Hash_node_code_cache<true>& __to,
          .           		   const _Hash_node_code_cache<true>& __from) const
     40,222 ( 0.00%)        { __to._M_hash_code = __from._M_hash_code; }
          .           
          .                 void
          .                 _M_swap(_Hash_code_base& __x)
          .                 { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }
          .           
          .                 const _Hash&
108,866,601 ( 0.09%)        _M_hash() const { return __ebo_hash::_M_cget(); }
         90 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<1, std::hash<Ship::Direction>, true>::_M_cget() const (15x)
          .               };
          .           
          .             /// Partial specialization used when nodes contain a cached hash code.
          .             template<typename _Key, typename _Value, typename _ExtractKey,
          .           	   typename _Hash, typename _RangeHash, typename _Unused>
          .               struct _Local_iterator_base<_Key, _Value, _ExtractKey,
          .           				_Hash, _RangeHash, _Unused, true>
          .               : public _Node_iterator_base<_Value, true>
-- line 1408 ----------------------------------------
-- line 1700 ----------------------------------------
          .           					       __hash_cached::value>;
          .           
          .                 using __hash_code = typename __hash_code_base::__hash_code;
          .           
          .               private:
          .                 using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
          .           
          .                 static bool
 47,028,124 ( 0.04%)        _S_equals(__hash_code, const _Hash_node_code_cache<false>&)
 35,271,093 ( 0.03%)        { return true; }
          .           
          .                 static bool
          .                 _S_node_equals(const _Hash_node_code_cache<false>&,
          .           		     const _Hash_node_code_cache<false>&)
          .                 { return true; }
          .           
          .                 static bool
    842,448 ( 0.00%)        _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
  1,263,674 ( 0.00%)        { return __c == __n._M_hash_code; }
          .           
          .                 static bool
          .                 _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
          .           		     const _Hash_node_code_cache<true>& __rhn)
          .                 { return __lhn._M_hash_code == __rhn._M_hash_code; }
          .           
          .               protected:
      6,916 ( 0.00%)        _Hashtable_base() = default;
         16 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::__detail::_Select1st, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>::_Hash_code_base() (1x)
          6 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true>::_Hashtable_ebo_helper() (1x)
          .           
         30 ( 0.00%)        _Hashtable_base(const _Hash& __hash, const _Equal& __eq)
         50 ( 0.00%)        : __hash_code_base(__hash), _EqualEBO(__eq)
         30 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_code_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>::_Hash_code_base(std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) (1x)
         17 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true>::_Hashtable_ebo_helper<std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) (1x)
         15 ( 0.00%)        { }
          .           
          .                 bool
 83,334,902 ( 0.07%)        _M_key_equals(const _Key& __k,
          .           		    const _Hash_node_value<_Value,
          .           					   __hash_cached::value>& __n) const
          .                 {
          .           	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
          .           	  "key equality predicate must be invocable with two arguments of "
          .           	  "key type");
202,384,762 ( 0.17%)  	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
  3,379,568 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>::type&& std::__detail::_Select1st::operator()<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) const (211,223x)
  3,168,345 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true> >::_M_eq() const (211,223x)
  2,745,899 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::equal_to<unsigned long>::operator()(unsigned long const&, unsigned long const&) const (211,223x)
 35,714,958 ( 0.03%)        }
          .           
          .                 template<typename _Kt>
          .           	bool
      1,568 ( 0.00%)  	_M_key_equals_tr(const _Kt& __k,
          .           			 const _Hash_node_value<_Value,
          .           					     __hash_cached::value>& __n) const
          .           	{
          .           	  static_assert(
          .           	    __is_invocable<const _Equal&, const _Kt&, const _Key&>{},
          .           	    "key equality predicate must be invocable with two arguments of "
          .           	    "key type");
      3,808 ( 0.00%)  	  return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
     14,762 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (224x)
      3,584 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Select1st::__1st_type<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const&>::type&& std::__detail::_Select1st::operator()<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const&) const (224x)
      3,360 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_eq() const (224x)
        672 ( 0.00%)  	}
          .           
          .                 bool
 83,773,375 ( 0.07%)        _M_equals(const _Key& __k, __hash_code __c,
          .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
226,928,013 ( 0.19%)        { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
 32,583,533 ( 0.03%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_key_equals(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true> const&) const (144,943x)
  1,809,610 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_S_equals(unsigned long, std::__detail::_Hash_node_code_cache<true> const&) (180,961x)
          .           
          .                 template<typename _Kt>
          .           	bool
        126 ( 0.00%)  	_M_equals_tr(const _Kt& __k, __hash_code __c,
          .           		     const _Hash_node_value<_Value,
          .           					    __hash_cached::value>& __n) const
        207 ( 0.00%)  	{ return _S_equals(__c, __n) && _M_key_equals_tr(__k, __n); }
        225 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:bool std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_M_key_equals_tr<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__detail::_Hash_node_value<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, true> const&) const (1x)
        180 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >::_S_equals(unsigned long, std::__detail::_Hash_node_code_cache<true> const&) (18x)
          .           
          .                 bool
          .                 _M_node_equals(
          .           	const _Hash_node_value<_Value, __hash_cached::value>& __lhn,
          .           	const _Hash_node_value<_Value, __hash_cached::value>& __rhn) const
          .                 {
          .           	return _S_node_equals(__lhn, __rhn)
          .           	  && _M_key_equals(_ExtractKey{}(__lhn._M_v()), __rhn);
-- line 1774 ----------------------------------------
-- line 1777 ----------------------------------------
          .                 void
          .                 _M_swap(_Hashtable_base& __x)
          .                 {
          .           	__hash_code_base::_M_swap(__x);
          .           	std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
          .                 }
          .           
          .                 const _Equal&
107,146,890 ( 0.09%)        _M_eq() const { return _EqualEBO::_M_cget(); }
      2,394 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true>::_M_cget() const (399x)
          .               };
          .           
          .             /**
          .              *  Primary class template  _Equality.
          .              *
          .              *  This is for implementing equality comparison for unordered
          .              *  containers, per N3068, by John Lakos and Pablo Halpern.
          .              *  Algorithmically, we follow closely the reference implementations
-- line 1793 ----------------------------------------
-- line 1932 ----------------------------------------
          .                 return true;
          .               }
          .           
          .             /**
          .              * This type deals with all allocation and keeps an allocator instance
          .              * through inheritance to benefit from EBO when possible.
          .              */
          .             template<typename _NodeAlloc>
    297,520 ( 0.00%)      struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
          9 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<std::pair<float, float> const, unsigned short>, true> >, true>::~_Hashtable_ebo_helper() (1x)
          .               {
          .               private:
          .                 using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
          .           
          .                 template<typename>
          .           	struct __get_value_type;
          .                 template<typename _Val, bool _Cache_hash_code>
          .           	struct __get_value_type<_Hash_node<_Val, _Cache_hash_code>>
-- line 1948 ----------------------------------------
-- line 1960 ----------------------------------------
          .                 using __node_ptr = __node_type*;
          .                 using __node_base = _Hash_node_base;
          .                 using __node_base_ptr = __node_base*;
          .                 using __buckets_alloc_type =
          .           	__alloc_rebind<__node_alloc_type, __node_base_ptr>;
          .                 using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;
          .                 using __buckets_ptr = __node_base_ptr*;
          .           
      5,320 ( 0.00%)        _Hashtable_alloc() = default;
         12 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<std::pair<float, float> const, unsigned short>, true> >, true>::_Hashtable_ebo_helper() (1x)
          .                 _Hashtable_alloc(const _Hashtable_alloc&) = default;
          .                 _Hashtable_alloc(_Hashtable_alloc&&) = default;
          .           
          .                 template<typename _Alloc>
    146,730 ( 0.00%)  	_Hashtable_alloc(_Alloc&& __a)
    234,768 ( 0.00%)  	: __ebo_node_alloc(std::forward<_Alloc>(__a))
        104 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerRumbleMapping> >, true> >, true>::_Hashtable_ebo_helper<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerRumbleMapping> >, true> > >(std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerRumbleMapping> >, true> >&&) (4x)
         24 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerRumbleMapping> >, true> >&& std::forward<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerRumbleMapping> >, true> > >(std::remove_reference<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerRumbleMapping> >, true> > >::type&) (4x)
     88,038 ( 0.00%)  	{ }
          .           
          .                 __node_alloc_type&
    547,952 ( 0.00%)        _M_node_allocator()
    684,940 ( 0.00%)        { return __ebo_node_alloc::_M_get(); }
    337,536 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<unsigned short const, std::shared_ptr<Ship::ControllerButton> >, false> >, true>::_M_get() (56,256x)
          .           
          .                 const __node_alloc_type&
    117,364 ( 0.00%)        _M_node_allocator() const
    146,705 ( 0.00%)        { return __ebo_node_alloc::_M_cget(); }
     61,104 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true> >, true>::_M_cget() const (10,184x)
          .           
          .                 // Allocate a node and construct an element within it.
          .                 template<typename... _Args>
          .           	__node_ptr
          .           	_M_allocate_node(_Args&&... __args);
          .           
          .                 // Destroy the element within a node and deallocate the node.
          .                 void
-- line 1991 ----------------------------------------
-- line 2007 ----------------------------------------
          .                 _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);
          .               };
          .           
          .             // Definitions of class template _Hashtable_alloc's out-of-line member
          .             // functions.
          .             template<typename _NodeAlloc>
          .               template<typename... _Args>
          .                 auto
    649,976 ( 0.00%)        _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
          .                 -> __node_ptr
          .                 {
    820,809 ( 0.00%)  	auto& __alloc = _M_node_allocator();
    248,310 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >::_M_node_allocator() (16,554x)
     74,619 ( 0.00%)  	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
    298,476 ( 0.00%)  	__node_ptr __n = std::__to_address(__nptr);
     99,324 ( 0.00%)  => /usr/include/c++/14/bits/ptr_traits.h:std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>* std::__to_address<std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> >(std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*) (16,554x)
          .           	__try
          .           	  {
    447,714 ( 0.00%)  	    ::new ((void*)__n) __node_type;
    297,972 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>::_Hash_node() (16,554x)
    115,878 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (16,554x)
    926,857 ( 0.00%)  	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
     99,324 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::piecewise_construct_t const& std::forward<std::piecewise_construct_t const&>(std::remove_reference<std::piecewise_construct_t const&>::type&) (16,554x)
     99,324 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<>&& std::forward<std::tuple<> >(std::remove_reference<std::tuple<> >::type&) (16,554x)
     99,324 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<unsigned long&&>&& std::forward<std::tuple<unsigned long&&> >(std::remove_reference<std::tuple<unsigned long&&> >::type&) (16,554x)
          .           					   std::forward<_Args>(__args)...);
    130,960 ( 0.00%)  	    return __n;
          .           	  }
          .           	__catch(...)
          .           	  {
          .           	    __n->~__node_type();
          .           	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
          .           	    __throw_exception_again;
          .           	  }
    375,579 ( 0.00%)        }
          .           
          .             template<typename _NodeAlloc>
          .               void
    144,480 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
          .               {
    192,640 ( 0.00%)        __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
         15 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> > >::_M_node_allocator() (1x)
    120,400 ( 0.00%)        _M_deallocate_node_ptr(__n);
        183 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true> > >::_M_deallocate_node_ptr(std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, true>*) (1x)
     96,320 ( 0.00%)      }
          .           
          .             template<typename _NodeAlloc>
          .               void
    120,400 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
          .               {
          .                 typedef typename __node_alloc_traits::pointer _Ptr;
     96,320 ( 0.00%)        auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      9,600 ( 0.00%)  => /usr/include/c++/14/bits/ptr_traits.h:std::__ptr_traits_ptr_to<std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>*, std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>, false>::pointer_to(std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false>&) (400x)
          .                 __n->~__node_type();
    313,040 ( 0.00%)        __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
      6,000 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false> > >::_M_node_allocator() (400x)
     72,240 ( 0.00%)      }
          .           
          .             template<typename _NodeAlloc>
          .               void
    150,880 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
          .               {
    138,707 ( 0.00%)        while (__n)
          .           	{
     48,158 ( 0.00%)  	  __node_ptr __tmp = __n;
     96,316 ( 0.00%)  	  __n = __n->_M_next();
         28 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>::_M_next() const (4x)
    120,395 ( 0.00%)  	  _M_deallocate_node(__tmp);
      1,596 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false> > >::_M_deallocate_node(std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*) (4x)
          .           	}
    120,704 ( 0.00%)      }
          .           
          .             template<typename _NodeAlloc>
          .               auto
     35,620 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
          .               -> __buckets_ptr
          .               {
     42,744 ( 0.00%)        __buckets_alloc_type __alloc(_M_node_allocator());
     19,260 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true> > >::_M_node_allocator() (1,284x)
          .           
      7,124 ( 0.00%)        auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
     28,496 ( 0.00%)        __buckets_ptr __p = std::__to_address(__ptr);
      7,704 ( 0.00%)  => /usr/include/c++/14/bits/ptr_traits.h:std::__detail::_Hash_node_base** std::__to_address<std::__detail::_Hash_node_base*>(std::__detail::_Hash_node_base**) (1,284x)
     49,877 ( 0.00%)        __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
     24,396 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1,284x)
     14,248 ( 0.00%)        return __p;
     14,248 ( 0.00%)      }
          .           
          .             template<typename _NodeAlloc>
          .               void
     42,510 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::
          .               _M_deallocate_buckets(__buckets_ptr __bkts,
          .           			  std::size_t __bkt_count)
          .               {
          .                 typedef typename __buckets_alloc_traits::pointer _Ptr;
     28,340 ( 0.00%)        auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
        144 ( 0.00%)  => /usr/include/c++/14/bits/ptr_traits.h:std::__ptr_traits_ptr_to<std::__detail::_Hash_node_base**, std::__detail::_Hash_node_base*, false>::pointer_to(std::__detail::_Hash_node_base*&) (6x)
     42,510 ( 0.00%)        __buckets_alloc_type __alloc(_M_node_allocator());
         90 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<TextureCacheKey const, TextureCacheValue>, false> > >::_M_node_allocator() (6x)
          .                 __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
     21,255 ( 0.00%)      }
          .           
          .            ///@} hashtable-detail
          .           } // namespace __detail
          .           /// @endcond
          .           _GLIBCXX_END_NAMESPACE_VERSION
          .           } // namespace std
          .           
          .           #endif // _HASHTABLE_POLICY_H
-- line 2097 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/fmt/core.h
--------------------------------------------------------------------------------
Ir                 

-- line 325 ----------------------------------------
        .           // https://github.com/fmtlib/fmt/issues/3247
        .           #if FMT_CPLUSPLUS >= 202002L && defined(_GLIBCXX_RELEASE) && \
        .               _GLIBCXX_RELEASE >= 12 &&                                \
        .               (FMT_CLANG_VERSION >= 1400 && FMT_CLANG_VERSION < 1500)
        .             ignore_unused(default_value);
        .             return __builtin_is_constant_evaluated();
        .           #elif defined(__cpp_lib_is_constant_evaluated)
        .             ignore_unused(default_value);
    3,938 ( 0.00%)    return std::is_constant_evaluated();
        5 ( 0.00%)  => /usr/include/c++/14/type_traits:std::is_constant_evaluated() (1x)
        .           #else
        .             return default_value;
        .           #endif
        .           }
        .           
        .           // Suppresses "conditional expression is constant" warnings.
        .           template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
        .             return value;
-- line 341 ----------------------------------------
-- line 416 ----------------------------------------
        .            private:
        .             const Char* data_;
        .             size_t size_;
        .           
        .            public:
        .             using value_type = Char;
        .             using iterator = const Char*;
        .           
    5,917 ( 0.00%)    constexpr basic_string_view() noexcept : data_(nullptr), size_(0) {}
        .           
        .             /** Constructs a string reference object from a C string and a size. */
        .             constexpr basic_string_view(const Char* s, size_t count) noexcept
    5,901 ( 0.00%)        : data_(s), size_(count) {}
        .           
        .             /**
        .               \rst
        .               Constructs a string reference object from a C string computing
        .               the size with ``std::char_traits<Char>::length``.
        .               \endrst
        .              */
        .             FMT_CONSTEXPR_CHAR_TRAITS
        .             FMT_INLINE
        .             basic_string_view(const Char* s)
      114 ( 0.00%)        : data_(s),
       57 ( 0.00%)          size_(detail::const_check(std::is_same<Char, char>::value &&
        .                                             !detail::is_constant_evaluated(true))
       12 ( 0.00%)                    ? std::strlen(reinterpret_cast<const char*>(s))
        3 ( 0.00%)                    : std::char_traits<Char>::length(s)) {}
        .           
        .             /** Constructs a string reference from a ``std::basic_string`` object. */
        .             template <typename Traits, typename Alloc>
   22,950 ( 0.00%)    FMT_CONSTEXPR basic_string_view(
        .                 const std::basic_string<Char, Traits, Alloc>& s) noexcept
   45,900 ( 0.00%)        : data_(s.data()), size_(s.size()) {}
   73,440 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::data() const (4,590x)
   32,130 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (4,590x)
        .           
        .             template <typename S, FMT_ENABLE_IF(std::is_same<
        .                                                 S, detail::std_string_view<Char>>::value)>
        .             FMT_CONSTEXPR basic_string_view(S s) noexcept
        .                 : data_(s.data()), size_(s.size()) {}
        .           
        .             /** Returns a pointer to the string data. */
    5,254 ( 0.00%)    constexpr auto data() const noexcept -> const Char* { return data_; }
        .           
        .             /** Returns the string size. */
   11,166 ( 0.00%)    constexpr auto size() const noexcept -> size_t { return size_; }
        .           
        .             constexpr auto begin() const noexcept -> iterator { return data_; }
    9,850 ( 0.00%)    constexpr auto end() const noexcept -> iterator { return data_ + size_; }
        .           
        .             constexpr auto operator[](size_t pos) const noexcept -> const Char& {
        .               return data_[pos];
        .             }
        .           
        .             FMT_CONSTEXPR void remove_prefix(size_t n) noexcept {
        .               data_ += n;
        .               size_ -= n;
-- line 471 ----------------------------------------
-- line 530 ----------------------------------------
        .           template <typename S>
        .           struct is_compile_string : std::is_base_of<compile_string, S> {};
        .           
        .           template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
        .           FMT_INLINE auto to_string_view(const Char* s) -> basic_string_view<Char> {
        .             return s;
        .           }
        .           template <typename Char, typename Traits, typename Alloc>
    5,240 ( 0.00%)  inline auto to_string_view(const std::basic_string<Char, Traits, Alloc>& s)
        .               -> basic_string_view<Char> {
    5,240 ( 0.00%)    return s;
   99,560 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::basic_string_view<char>::basic_string_view<std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (2,620x)
   10,480 ( 0.00%)  }
        .           template <typename Char>
        .           constexpr auto to_string_view(basic_string_view<Char> s)
        .               -> basic_string_view<Char> {
        .             return s;
        .           }
        .           template <typename Char,
        .                     FMT_ENABLE_IF(!std::is_empty<std_string_view<Char>>::value)>
        .           inline auto to_string_view(std_string_view<Char> s) -> basic_string_view<Char> {
-- line 549 ----------------------------------------
-- line 786 ----------------------------------------
        .             struct accessor : base {
        .               accessor(base b) : base(b) {}
        .               using base::container;
        .             };
        .             return *accessor(it).container;
        .           }
        .           
        .           template <typename Char, typename InputIt, typename OutputIt>
   19,670 ( 0.00%)  FMT_CONSTEXPR auto copy_str(InputIt begin, InputIt end, OutputIt out)
        .               -> OutputIt {
2,965,617 ( 0.00%)    while (begin != end) *out++ = static_cast<Char>(*begin++);
8,861,445 ( 0.01%)  => /usr/include/c++/14/bits/stl_iterator.h:std::back_insert_iterator<fmt::v10::detail::buffer<char> >::operator=(char&&) (196,921x)
1,181,526 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:std::back_insert_iterator<fmt::v10::detail::buffer<char> >::operator*() (196,921x)
  393,842 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::appender::operator++(int) (196,921x)
        .             return out;
   19,670 ( 0.00%)  }
        .           
        .           template <typename Char, typename T, typename U,
        .                     FMT_ENABLE_IF(
        .                         std::is_same<remove_const_t<T>, U>::value&& is_char<U>::value)>
        .           FMT_CONSTEXPR auto copy_str(T* begin, T* end, U* out) -> U* {
        .             if (is_constant_evaluated()) return copy_str<Char, T*, U*>(begin, end, out);
        .             auto size = to_unsigned(end - begin);
    7,884 ( 0.00%)    if (size > 0) memcpy(out, begin, size * sizeof(U));
        .             return out + size;
        .           }
        .           
        .           /**
        .             \rst
        .             A contiguous memory buffer with an optional growing ability. It is an internal
        .             class and shouldn't be used directly, only via `~fmt::basic_memory_buffer`.
        .             \endrst
-- line 814 ----------------------------------------
-- line 820 ----------------------------------------
        .             size_t capacity_;
        .           
        .            protected:
        .             // Don't initialize ptr_ since it is not accessed to save a few cycles.
        .             FMT_MSC_WARNING(suppress : 26495)
        .             FMT_CONSTEXPR buffer(size_t sz) noexcept : size_(sz), capacity_(sz) {}
        .           
        .             FMT_CONSTEXPR20 buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) noexcept
   51,503 ( 0.00%)        : ptr_(p), size_(sz), capacity_(cap) {}
        .           
        .             FMT_CONSTEXPR20 ~buffer() = default;
        .             buffer(buffer&&) = default;
        .           
        .             /** Sets the buffer data and capacity. */
        .             FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
    9,183 ( 0.00%)      ptr_ = buf_data;
    7,213 ( 0.00%)      capacity_ = buf_capacity;
    1,967 ( 0.00%)    }
        .           
        .             /** Increases the buffer capacity to hold at least *capacity* elements. */
        .             // DEPRECATED!
        .             virtual FMT_CONSTEXPR20 void grow(size_t capacity) = 0;
        .           
        .            public:
        .             using value_type = T;
        .             using const_reference = const T&;
-- line 845 ----------------------------------------
-- line 849 ----------------------------------------
        .           
        .             FMT_INLINE auto begin() noexcept -> T* { return ptr_; }
        .             FMT_INLINE auto end() noexcept -> T* { return ptr_ + size_; }
        .           
        .             FMT_INLINE auto begin() const noexcept -> const T* { return ptr_; }
        .             FMT_INLINE auto end() const noexcept -> const T* { return ptr_ + size_; }
        .           
        .             /** Returns the size of this buffer. */
   21,626 ( 0.00%)    constexpr auto size() const noexcept -> size_t { return size_; }
        .           
        .             /** Returns the capacity of this buffer. */
    3,942 ( 0.00%)    constexpr auto capacity() const noexcept -> size_t { return capacity_; }
        .           
        .             /** Returns a pointer to the buffer data (not null-terminated). */
  161,187 ( 0.00%)    FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
    1,970 ( 0.00%)    FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
        .           
        .             /** Clears this buffer. */
    7,868 ( 0.00%)    void clear() { size_ = 0; }
        .           
        .             // Tries resizing the buffer to contain *count* elements. If T is a POD type
        .             // the new elements may not be initialized.
        .             FMT_CONSTEXPR20 void try_resize(size_t count) {
        .               try_reserve(count);
   11,826 ( 0.00%)      size_ = count <= capacity_ ? count : capacity_;
        .             }
        .           
        .             // Tries increasing the buffer capacity to *new_capacity*. It can increase the
        .             // capacity by a smaller amount than requested but guarantees there is space
        .             // for at least one additional element either by increasing the capacity or by
        .             // flushing the buffer if it is full.
        .             FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  774,662 ( 0.00%)      if (new_capacity > capacity_) grow(new_capacity);
  196,921 ( 0.00%)    }
        .           
1,591,365 ( 0.00%)    FMT_CONSTEXPR20 void push_back(const T& value) {
  701,083 ( 0.00%)      try_reserve(size_ + 1);
  590,763 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::try_reserve(unsigned long) (196,921x)
1,347,006 ( 0.00%)      ptr_[size_++] = value;
1,228,964 ( 0.00%)    }
        .           
        .             /** Appends data to the end of the buffer. */
        .             template <typename U> void append(const U* begin, const U* end);
        .           
        .             template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
        .               return ptr_[index];
        .             }
        .             template <typename Idx>
-- line 895 ----------------------------------------
-- line 896 ----------------------------------------
        .             FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
        .               return ptr_[index];
        .             }
        .           };
        .           
        .           struct buffer_traits {
        .             explicit buffer_traits(size_t) {}
        .             auto count() const -> size_t { return 0; }
    7,868 ( 0.00%)    auto limit(size_t size) -> size_t { return size; }
        .           };
        .           
        .           class fixed_buffer_traits {
        .            private:
        .             size_t count_ = 0;
        .             size_t limit_;
        .           
        .            public:
-- line 912 ----------------------------------------
-- line 927 ----------------------------------------
        .             enum { buffer_size = 256 };
        .             T data_[buffer_size];
        .           
        .            protected:
        .             FMT_CONSTEXPR20 void grow(size_t) override {
        .               if (this->size() == buffer_size) flush();
        .             }
        .           
   15,736 ( 0.00%)    void flush() {
    7,868 ( 0.00%)      auto size = this->size();
    7,868 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::size() const (3,934x)
    7,868 ( 0.00%)      this->clear();
    7,868 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::clear() (3,934x)
   35,406 ( 0.00%)      out_ = copy_str<T>(data_, data_ + this->limit(size), out_);
13,441,770 ( 0.01%)  => /usr/include/fmt/core.h:fmt::v10::appender fmt::v10::detail::copy_str<char, char*, fmt::v10::appender>(char*, char*, fmt::v10::appender) (3,934x)
    7,868 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer_traits::limit(unsigned long) (3,934x)
   15,736 ( 0.00%)    }
        .           
        .            public:
    9,835 ( 0.00%)    explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
   23,604 ( 0.00%)        : Traits(n), buffer<T>(data_, 0, buffer_size), out_(out) {}
   13,769 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::buffer(char*, unsigned long, unsigned long) (1,967x)
        .             iterator_buffer(iterator_buffer&& other)
        .                 : Traits(other), buffer<T>(data_, 0, buffer_size), out_(other.out_) {}
   13,769 ( 0.00%)    ~iterator_buffer() { flush(); }
   78,680 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::iterator_buffer<fmt::v10::appender, char, fmt::v10::detail::buffer_traits>::flush() (1,967x)
        .           
    3,934 ( 0.00%)    auto out() -> OutputIt {
    1,967 ( 0.00%)      flush();
13,469,308 ( 0.01%)  => /usr/include/fmt/core.h:fmt::v10::detail::iterator_buffer<fmt::v10::appender, char, fmt::v10::detail::buffer_traits>::flush() (1,967x)
    1,967 ( 0.00%)      return out_;
    3,934 ( 0.00%)    }
        .             auto count() const -> size_t { return Traits::count() + this->size(); }
        .           };
        .           
        .           template <typename T>
        .           class iterator_buffer<T*, T, fixed_buffer_traits> final
        .               : public fixed_buffer_traits,
        .                 public buffer<T> {
        .            private:
-- line 959 ----------------------------------------
-- line 1096 ----------------------------------------
        .               std::is_constructible<typename Context::template formatter_type<T>>;
        .           
        .           // An output iterator that appends to a buffer.
        .           // It is used to reduce symbol sizes for the common case.
        .           class appender : public std::back_insert_iterator<detail::buffer<char>> {
        .             using base = std::back_insert_iterator<detail::buffer<char>>;
        .           
        .            public:
   25,571 ( 0.00%)    using std::back_insert_iterator<detail::buffer<char>>::back_insert_iterator;
   37,373 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:std::back_insert_iterator<fmt::v10::detail::buffer<char> >::back_insert_iterator(fmt::v10::detail::buffer<char>&) (1,967x)
        .             appender(base it) noexcept : base(it) {}
        .             FMT_UNCHECKED_ITERATOR(appender);
        .           
        .             auto operator++() noexcept -> appender& { return *this; }
  393,842 ( 0.00%)    auto operator++(int) noexcept -> appender { return *this; }
        .           };
        .           
        .           namespace detail {
        .           
        .           template <typename Context, typename T>
        .           constexpr auto has_const_formatter_impl(T*)
        .               -> decltype(typename Context::template formatter_type<T>().format(
        .                               std::declval<const T&>(), std::declval<Context&>()),
-- line 1117 ----------------------------------------
-- line 1128 ----------------------------------------
        .           }
        .           
        .           template <typename T>
        .           using buffer_appender = conditional_t<std::is_same<T, char>::value, appender,
        .                                                 std::back_insert_iterator<buffer<T>>>;
        .           
        .           // Maps an output iterator to a buffer.
        .           template <typename T, typename OutputIt>
    3,934 ( 0.00%)  auto get_buffer(OutputIt out) -> iterator_buffer<OutputIt, T> {
    3,934 ( 0.00%)    return iterator_buffer<OutputIt, T>(out);
   47,208 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::iterator_buffer<fmt::v10::appender, char, fmt::v10::detail::buffer_traits>::iterator_buffer(fmt::v10::appender, unsigned long) (1,967x)
    5,901 ( 0.00%)  }
        .           template <typename T, typename Buf,
        .                     FMT_ENABLE_IF(std::is_base_of<buffer<char>, Buf>::value)>
        .           auto get_buffer(std::back_insert_iterator<Buf> out) -> buffer<char>& {
        .             return get_container(out);
        .           }
        .           
        .           template <typename Buf, typename OutputIt>
        .           FMT_INLINE auto get_iterator(Buf& buf, OutputIt) -> decltype(buf.out()) {
    7,868 ( 0.00%)    return buf.out();
13,481,110 ( 0.01%)  => /usr/include/fmt/core.h:fmt::v10::detail::iterator_buffer<fmt::v10::appender, char, fmt::v10::detail::buffer_traits>::out() (1,967x)
        .           }
        .           template <typename T, typename OutputIt>
        .           auto get_iterator(buffer<T>&, OutputIt out) -> OutputIt {
        .             return out;
        .           }
        .           
        .           struct view {};
        .           
-- line 1155 ----------------------------------------
-- line 1179 ----------------------------------------
        .           };
        .           
        .           template <typename T, typename Char, size_t NUM_ARGS>
        .           struct arg_data<T, Char, NUM_ARGS, 0> {
        .             // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
        .             T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];
        .           
        .             template <typename... U>
    3,922 ( 0.00%)    FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
    1,967 ( 0.00%)    FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
        .             FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
        .               return nullptr;
        .             }
        .           };
        .           
        .           template <typename Char>
        .           inline void init_named_args(named_arg_info<Char>*, int, int) {}
        .           
-- line 1196 ----------------------------------------
-- line 1274 ----------------------------------------
        .               const void* pointer;
        .               string_value<char_type> string;
        .               custom_value<Context> custom;
        .               named_arg_value<char_type> named_args;
        .             };
        .           
        .             constexpr FMT_INLINE value() : no_value() {}
        .             constexpr FMT_INLINE value(int val) : int_value(val) {}
    4,571 ( 0.00%)    constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
        .             constexpr FMT_INLINE value(long long val) : long_long_value(val) {}
        .             constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
        .             FMT_INLINE value(int128_opt val) : int128_value(val) {}
        .             FMT_INLINE value(uint128_opt val) : uint128_value(val) {}
        .             constexpr FMT_INLINE value(float val) : float_value(val) {}
        .             constexpr FMT_INLINE value(double val) : double_value(val) {}
        .             FMT_INLINE value(long double val) : long_double_value(val) {}
        .             constexpr FMT_INLINE value(bool val) : bool_value(val) {}
        .             constexpr FMT_INLINE value(char_type val) : char_value(val) {}
        .             FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
        2 ( 0.00%)      string.data = val;
        2 ( 0.00%)      if (is_constant_evaluated()) string.size = {};
        .             }
        .             FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
    7,861 ( 0.00%)      string.data = val.data();
    1,310 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::basic_string_view<char>::data() const (655x)
    7,206 ( 0.00%)      string.size = val.size();
    1,310 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::basic_string_view<char>::size() const (655x)
        .             }
        .             FMT_INLINE value(const void* val) : pointer(val) {}
        .             FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
        .                 : named_args{args, size} {}
        .           
        .             template <typename T> FMT_CONSTEXPR20 FMT_INLINE value(T& val) {
        .               using value_type = remove_const_t<T>;
        .               custom.value = const_cast<value_type*>(std::addressof(val));
-- line 1306 ----------------------------------------
-- line 1411 ----------------------------------------
        .             FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
        .               return val;
        .             }
        .             template <typename T,
        .                       FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
        .                                     std::is_same<char_type, char_t<T>>::value)>
        .             FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
        .                 -> basic_string_view<char_type> {
    8,513 ( 0.00%)      return to_string_view(val);
   30,130 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::basic_string_view<char> fmt::v10::detail::to_string_view<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (655x)
        .             }
        .             template <typename T,
        .                       FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
        .                                     !std::is_same<char_type, char_t<T>>::value)>
        .             FMT_CONSTEXPR FMT_INLINE auto map(const T&) -> unformattable_char {
        .               return {};
        .             }
        .           
-- line 1427 ----------------------------------------
-- line 1834 ----------------------------------------
        .           
        .            public:
        .             template <typename... T>
        .             FMT_CONSTEXPR FMT_INLINE format_arg_store(T&... args)
        .                 :
        .           #if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
        .                   basic_format_args<Context>(*this),
        .           #endif
        2 ( 0.00%)          data_{detail::make_arg<is_packed, Context>(args)...} {
        .               if (detail::const_check(num_named_args != 0))
        .                 detail::init_named_args(data_.named_args(), 0, 0, args...);
        .             }
        .           };
        .           
        .           /**
        .             \rst
        .             Constructs a `~fmt::format_arg_store` object that contains references to
        .             arguments and can be implicitly converted to `~fmt::format_args`. `Context`
        .             can be omitted in which case it defaults to `~fmt::format_context`.
        .             See `~fmt::arg` for lifetime considerations.
        .             \endrst
        .            */
        .           // Arguments are taken by lvalue references to avoid some lifetime issues.
        .           template <typename Context = format_context, typename... T>
   11,138 ( 0.00%)  constexpr auto make_format_args(T&... args)
        .               -> format_arg_store<Context, remove_cvref_t<T>...> {
        .             return {args...};
   14,423 ( 0.00%)  }
        .           
        .           /**
        .             \rst
        .             Returns a named argument to be used in a formatting function.
        .             It should only be used in a call to a formatting function or
        .             `dynamic_format_arg_store::push_back`.
        .           
        .             **Example**::
-- line 1869 ----------------------------------------
-- line 1919 ----------------------------------------
        .             FMT_CONSTEXPR auto type(int index) const -> detail::type {
        .               int shift = index * detail::packed_arg_bits;
        .               unsigned int mask = (1 << detail::packed_arg_bits) - 1;
        .               return static_cast<detail::type>((desc_ >> shift) & mask);
        .             }
        .           
        .             constexpr FMT_INLINE basic_format_args(unsigned long long desc,
        .                                                    const detail::value<Context>* values)
    3,934 ( 0.00%)        : desc_(desc), values_(values) {}
        .             constexpr basic_format_args(unsigned long long desc, const format_arg* args)
        .                 : desc_(desc), args_(args) {}
        .           
        .            public:
        .             constexpr basic_format_args() : desc_(0), args_(nullptr) {}
        .           
        .             /**
        .              \rst
        .              Constructs a `basic_format_args` object from `~fmt::format_arg_store`.
        .              \endrst
        .              */
        .             template <typename... Args>
        .             constexpr FMT_INLINE basic_format_args(
        .                 const format_arg_store<Context, Args...>& store)
        .                 : basic_format_args(format_arg_store<Context, Args...>::desc,
    1,967 ( 0.00%)                            store.data_.args()) {}
        .           
        .             /**
        .              \rst
        .              Constructs a `basic_format_args` object from
        .              `~fmt::dynamic_format_arg_store`.
        .              \endrst
        .              */
        .             constexpr FMT_INLINE basic_format_args(
-- line 1951 ----------------------------------------
-- line 2788 ----------------------------------------
        .                 detail::parse_format_string<true>(sv, checker(sv));
        .               }
        .           #else
        .               detail::check_format_string<Args...>(s);
        .           #endif
        .             }
        .             basic_format_string(runtime_format_string<Char> fmt) : str_(fmt.str) {}
        .           
    3,934 ( 0.00%)    FMT_INLINE operator basic_string_view<Char>() const { return str_; }
        .             FMT_INLINE auto get() const -> basic_string_view<Char> { return str_; }
        .           };
        .           
        .           #if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
        .           // Workaround broken conversion on older gcc.
        .           template <typename...> using format_string = string_view;
        .           inline auto runtime(string_view s) -> string_view { return s; }
        .           #else
-- line 2804 ----------------------------------------
-- line 2834 ----------------------------------------
        .           FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
        .               -> std::string {
        .             return vformat(fmt, fmt::make_format_args(args...));
        .           }
        .           
        .           /** Formats a string and writes the output to ``out``. */
        .           template <typename OutputIt,
        .                     FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
   19,670 ( 0.00%)  auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {
    5,901 ( 0.00%)    auto&& buf = detail::get_buffer<char>(out);
   60,977 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::iterator_buffer<fmt::v10::appender, char, fmt::v10::detail::buffer_traits> fmt::v10::detail::get_buffer<char, fmt::v10::appender>(fmt::v10::appender) (1,967x)
   15,740 ( 0.00%)    detail::vformat_to(buf, fmt, args, {});
1,278,224 ( 0.00%)  => /usr/src/debug/fmt-10.2.1-5.fc40.x86_64/include/fmt/format.h:void fmt::v10::detail::vformat_to<char>(fmt::v10::detail::buffer<char>&, fmt::v10::basic_string_view<char>, fmt::v10::detail::vformat_args<char>::type, fmt::v10::detail::locale_ref) (1,967x)
    1,796 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .             return detail::get_iterator(buf, out);
   19,670 ( 0.00%)  }
   92,449 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::iterator_buffer<fmt::v10::appender, char, fmt::v10::detail::buffer_traits>::~iterator_buffer() (1,967x)
        .           
        .           /**
        .            \rst
        .            Formats ``args`` according to specifications in ``fmt``, writes the result to
        .            the output iterator ``out`` and returns the iterator past the end of the output
        .            range. `format_to` does not append a terminating null character.
        .           
        .            **Example**::
-- line 2854 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/fmt/format.h
--------------------------------------------------------------------------------
Ir               

-- line 828 ----------------------------------------
      .           using is_double_double = bool_constant<std::numeric_limits<T>::digits == 106>;
      .           
      .           #ifndef FMT_USE_FULL_CACHE_DRAGONBOX
      .           #  define FMT_USE_FULL_CACHE_DRAGONBOX 0
      .           #endif
      .           
      .           template <typename T>
      .           template <typename U>
803,760 ( 0.00%)  void buffer<T>::append(const U* begin, const U* end) {
267,920 ( 0.00%)    while (begin != end) {
133,960 ( 0.00%)      auto count = to_unsigned(end - begin);
200,940 ( 0.00%)      try_reserve(size_ + count);
 66,980 ( 0.00%)      auto free_cap = capacity_ - size_;
133,960 ( 0.00%)      if (free_cap < count) count = free_cap;
 66,980 ( 0.00%)      std::uninitialized_copy_n(begin, count, ptr_ + size_);
200,940 ( 0.00%)      size_ += count;
      .               begin += count;
      .             }
535,840 ( 0.00%)  }
      .           
      .           template <typename T, typename Enable = void>
      .           struct is_locale : std::false_type {};
      .           template <typename T>
      .           struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
      .           }  // namespace detail
      .           
      .           FMT_BEGIN_EXPORT
-- line 854 ----------------------------------------
-- line 883 ----------------------------------------
      .           class basic_memory_buffer final : public detail::buffer<T> {
      .            private:
      .             T store_[SIZE];
      .           
      .             // Don't inherit from Allocator to avoid generating type_info for it.
      .             FMT_NO_UNIQUE_ADDRESS Allocator alloc_;
      .           
      .             // Deallocate memory allocated by the buffer.
  9,835 ( 0.00%)    FMT_CONSTEXPR20 void deallocate() {
  7,868 ( 0.00%)      T* data = this->data();
  3,934 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::data() (1,967x)
 65,960 ( 0.00%)      if (data != store_) alloc_.deallocate(data, this->capacity());
  7,868 ( 0.00%)    }
      .           
      .            protected:
      .             FMT_CONSTEXPR20 void grow(size_t size) override {
      .               detail::abort_fuzzing_if(size > 5000);
      .               const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
      .               size_t old_capacity = this->capacity();
  5,216 ( 0.00%)      size_t new_capacity = old_capacity + old_capacity / 2;
  2,608 ( 0.00%)      if (size > new_capacity)
      .                 new_capacity = size;
  2,608 ( 0.00%)      else if (new_capacity > max_size)
      .                 new_capacity = size > max_size ? size : max_size;
      .               T* old_data = this->data();
      .               T* new_data =
      .                   std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
      .               // Suppress a bogus -Wstringop-overflow in gcc 13.1 (#3481).
      .               detail::assume(this->size() <= new_capacity);
      .               // The following code doesn't throw, so the raw pointer above doesn't leak.
      .               std::uninitialized_copy_n(old_data, this->size(), new_data);
      .               this->set(new_data, new_capacity);
      .               // deallocate must not throw according to the standard, but even if it does,
      .               // the buffer already uses the new storage and will deallocate it in
      .               // destructor.
  5,216 ( 0.00%)      if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
      .             }
      .           
      .            public:
      .             using value_type = T;
      .             using const_reference = const T&;
      .           
  9,835 ( 0.00%)    FMT_CONSTEXPR20 explicit basic_memory_buffer(
      .                 const Allocator& alloc = Allocator())
 59,399 ( 0.00%)        : alloc_(alloc) {
 13,769 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::buffer(char*, unsigned long, unsigned long) (1,967x)
 36,070 ( 0.00%)      this->set(store_, SIZE);
  5,901 ( 0.00%)  => /usr/include/fmt/core.h:fmt::v10::detail::buffer<char>::set(char*, unsigned long) (1,967x)
  3,934 ( 0.00%)      if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  5,901 ( 0.00%)    }
 49,525 ( 0.00%)    FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
 37,373 ( 0.00%)  => /usr/include/fmt/format.h:fmt::v10::basic_memory_buffer<char, 250ul, std::allocator<char> >::deallocate() (1,967x)
      .           
      .            private:
      .             // Move data from other to this buffer.
      .             FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
      .               alloc_ = std::move(other.alloc_);
      .               T* data = other.data();
      .               size_t size = other.size(), capacity = other.capacity();
 11,826 ( 0.00%)      if (data == other.store_) {
      .                 this->set(store_, capacity);
      .                 detail::copy_str<T>(other.store_, other.store_ + size, store_);
      .               } else {
      .                 this->set(data, capacity);
      .                 // Set pointer to the inline array so that delete is not called
      .                 // when deallocating.
      .                 other.set(other.store_, 0);
      .                 other.clear();
-- line 946 ----------------------------------------
-- line 1300 ----------------------------------------
      .             Iterator begin;
      .             Iterator end;
      .           };
      .           
      .           // Formats a decimal unsigned integer value writing into out pointing to a
      .           // buffer of specified size. The caller must ensure that the buffer is large
      .           // enough.
      .           template <typename Char, typename UInt>
  7,880 ( 0.00%)  FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
      .               -> format_decimal_result<Char*> {
      .             FMT_ASSERT(size >= count_digits(value), "invalid digit count");
 15,760 ( 0.00%)    out += size;
      .             Char* end = out;
 36,784 ( 0.00%)    while (value >= 100) {
      .               // Integer division is slow so do it for a group of two digits instead
      .               // of for every digit. The idea comes from the talk by Alexandrescu
      .               // "Three Optimization Tips for C++". See speed-test for a comparison.
  5,256 ( 0.00%)      out -= 2;
 31,536 ( 0.00%)      copy2(out, digits2(static_cast<size_t>(value % 100)));
  5,256 ( 0.00%)      value /= 100;
      .             }
 15,760 ( 0.00%)    if (value < 10) {
  3,948 ( 0.00%)      *--out = static_cast<Char>('0' + value);
  7,880 ( 0.00%)      return {out, end};
      .             }
  6,564 ( 0.00%)    out -= 2;
  6,564 ( 0.00%)    copy2(out, digits2(static_cast<size_t>(value)));
      .             return {out, end};
  7,880 ( 0.00%)  }
      .           
      .           template <typename Char, typename UInt, typename Iterator,
      .                     FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
      .           FMT_CONSTEXPR inline auto format_decimal(Iterator out, UInt value, int size)
      .               -> format_decimal_result<Iterator> {
      .             // Buffer is large enough to hold all digits (digits10 + 1).
      .             Char buffer[digits10<UInt>() + 1] = {};
      .             auto end = format_decimal(buffer, value, size).end;
-- line 1336 ----------------------------------------
-- line 3972 ----------------------------------------
      .             // Buffer should be large enough to hold all digits (digits10 + 1),
      .             // a sign and a null character.
      .             enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
      .             mutable char buffer_[buffer_size];
      .             char* str_;
      .           
      .             template <typename UInt> auto format_unsigned(UInt value) -> char* {
      .               auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
 31,520 ( 0.00%)      return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
 72,268 ( 0.00%)  => /usr/include/fmt/format.h:fmt::v10::detail::format_decimal_result<char*> fmt::v10::detail::format_decimal<char, unsigned int>(char*, unsigned int, int) [clone .constprop.0] (3,940x)
      .             }
      .           
      .             template <typename Int> auto format_signed(Int value) -> char* {
      .               auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
      .               bool negative = value < 0;
 23,640 ( 0.00%)      if (negative) abs_value = 0 - abs_value;
      .               auto begin = format_unsigned(abs_value);
 15,760 ( 0.00%)      if (negative) *--begin = '-';
      .               return begin;
      .             }
      .           
      .            public:
  7,880 ( 0.00%)    explicit format_int(int value) : str_(format_signed(value)) {}
      .             explicit format_int(long value) : str_(format_signed(value)) {}
      .             explicit format_int(long long value) : str_(format_signed(value)) {}
      .             explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
      .             explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
      .             explicit format_int(unsigned long long value)
      .                 : str_(format_unsigned(value)) {}
      .           
      .             /** Returns the number of characters written to the output buffer. */
-- line 4001 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_iterator_base_funcs.h
--------------------------------------------------------------------------------
Ir                 

-- line 98 ----------------------------------------
        .               inline _GLIBCXX14_CONSTEXPR
        .               typename iterator_traits<_RandomAccessIterator>::difference_type
        .               __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
        .                          random_access_iterator_tag)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_RandomAccessIteratorConcept<
        .           				  _RandomAccessIterator>)
1,145,792 ( 0.00%)        return __last - __first;
   27,008 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::difference_type __gnu_cxx::operator-<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, __gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&) (844x)
        .               }
        .           
        .           #if _GLIBCXX_USE_CXX11_ABI
        .             // Forward declaration because of the qualified call in distance.
        .             template<typename _Tp>
        .               ptrdiff_t
        .               __distance(_GLIBCXX_STD_C::_List_iterator<_Tp>,
        .           	       _GLIBCXX_STD_C::_List_iterator<_Tp>,
-- line 114 ----------------------------------------
-- line 143 ----------------------------------------
        .             */
        .             template<typename _InputIterator>
        .               _GLIBCXX_NODISCARD __attribute__((__always_inline__))
        .               inline _GLIBCXX17_CONSTEXPR
        .               typename iterator_traits<_InputIterator>::difference_type
        .               distance(_InputIterator __first, _InputIterator __last)
        .               {
        .                 // concept requirements -- taken care of in __distance
2,265,620 ( 0.00%)        return std::__distance(__first, __last,
  568,554 ( 0.00%)  			     std::__iterator_category(__first));
        .               }
        .           
        .             template<typename _InputIterator, typename _Distance>
        .               inline _GLIBCXX14_CONSTEXPR void
        .               __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        .                 __glibcxx_assert(__n >= 0);
        .                 while (__n--)
        .           	++__i;
        .               }
        .           
        .             template<typename _BidirectionalIterator, typename _Distance>
        .               inline _GLIBCXX14_CONSTEXPR void
    2,005 ( 0.00%)      __advance(_BidirectionalIterator& __i, _Distance __n,
        .           	      bidirectional_iterator_tag)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_BidirectionalIteratorConcept<
        .           				  _BidirectionalIterator>)
      802 ( 0.00%)        if (__n > 0)
    6,015 ( 0.00%)          while (__n--)
    1,203 ( 0.00%)  	  ++__i;
    2,965 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::operator++() (111x)
        .                 else
        .                   while (__n++)
        .           	  --__i;
    1,604 ( 0.00%)      }
        .           
        .             template<typename _RandomAccessIterator, typename _Distance>
        .               inline _GLIBCXX14_CONSTEXPR void
        .               __advance(_RandomAccessIterator& __i, _Distance __n,
        .                         random_access_iterator_tag)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_RandomAccessIteratorConcept<
-- line 188 ----------------------------------------
-- line 215 ----------------------------------------
        .              *  and are constant time.  For other %iterator classes they are linear time.
        .             */
        .             template<typename _InputIterator, typename _Distance>
        .               __attribute__((__always_inline__))
        .               inline _GLIBCXX17_CONSTEXPR void
        .               advance(_InputIterator& __i, _Distance __n)
        .               {
        .                 // concept requirements -- taken care of in __advance
    1,715 ( 0.00%)        typename iterator_traits<_InputIterator>::difference_type __d = __n;
    2,005 ( 0.00%)        std::__advance(__i, __d, std::__iterator_category(__i));
      590 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator_base_funcs.h:void std::__advance<std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, long>(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&, long, std::bidirectional_iterator_tag) (10x)
      401 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201103L
        .           
        .             template<typename _InputIterator>
        .               _GLIBCXX_NODISCARD [[__gnu__::__always_inline__]]
        .               inline _GLIBCXX17_CONSTEXPR _InputIterator
        .               next(_InputIterator __x, typename
        .           	 iterator_traits<_InputIterator>::difference_type __n = 1)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        .                 std::advance(__x, __n);
      290 ( 0.00%)        return __x;
        .               }
        .           
        .             template<typename _BidirectionalIterator>
        .               _GLIBCXX_NODISCARD [[__gnu__::__always_inline__]]
        .               inline _GLIBCXX17_CONSTEXPR _BidirectionalIterator
        .               prev(_BidirectionalIterator __x, typename
        .           	 iterator_traits<_BidirectionalIterator>::difference_type __n = 1) 
        .               {
-- line 246 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imgui.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 1196 ----------------------------------------
        .           #ifndef GImGui
        .           ImGuiContext*   GImGui = NULL;
        .           #endif
        .           
        .           // Memory Allocator functions. Use SetAllocatorFunctions() to change them.
        .           // - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
        .           // - DLL users: read comments above.
        .           #ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
   50,886 ( 0.00%)  static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
  970,661 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (4,626x)
   54,612 ( 0.00%)  static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
  626,275 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (4,551x)
        .           #else
        .           static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
        .           static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
        .           #endif
        .           static ImGuiMemAllocFunc    GImAllocatorAllocFunc = MallocWrapper;
        .           static ImGuiMemFreeFunc     GImAllocatorFreeFunc = FreeWrapper;
        .           static void*                GImAllocatorUserData = NULL;
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
        .           //-----------------------------------------------------------------------------
        .           
       71 ( 0.00%)  ImGuiStyle::ImGuiStyle()
      180 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (15x)
       71 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .           {
        3 ( 0.00%)      Alpha                       = 1.0f;             // Global alpha applies to everything in Dear ImGui.
        3 ( 0.00%)      DisabledAlpha               = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
        9 ( 0.00%)      WindowPadding               = ImVec2(8,8);      // Padding within a window
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      WindowRounding              = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        3 ( 0.00%)      WindowBorderSize            = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        9 ( 0.00%)      WindowMinSize               = ImVec2(32,32);    // Minimum window size
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      WindowTitleAlign            = ImVec2(0.0f,0.5f);// Alignment for title bar text
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        2 ( 0.00%)      WindowMenuButtonPosition    = ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
        3 ( 0.00%)      ChildRounding               = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
        3 ( 0.00%)      ChildBorderSize             = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        3 ( 0.00%)      PopupRounding               = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
        3 ( 0.00%)      PopupBorderSize             = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        9 ( 0.00%)      FramePadding                = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      FrameRounding               = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
        3 ( 0.00%)      FrameBorderSize             = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
        9 ( 0.00%)      ItemSpacing                 = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      ItemInnerSpacing            = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      CellPadding                 = ImVec2(4,2);      // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      TouchExtraPadding           = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      IndentSpacing               = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
        3 ( 0.00%)      ColumnsMinSpacing           = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
        3 ( 0.00%)      ScrollbarSize               = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
        3 ( 0.00%)      ScrollbarRounding           = 9.0f;             // Radius of grab corners rounding for scrollbar
        3 ( 0.00%)      GrabMinSize                 = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
        3 ( 0.00%)      GrabRounding                = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        3 ( 0.00%)      LogSliderDeadzone           = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
        3 ( 0.00%)      TabRounding                 = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        3 ( 0.00%)      TabBorderSize               = 0.0f;             // Thickness of border around tabs.
        3 ( 0.00%)      TabMinWidthForCloseButton   = 0.0f;             // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
        3 ( 0.00%)      TabBarBorderSize            = 1.0f;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        3 ( 0.00%)      TableAngledHeadersAngle     = 35.0f * (IM_PI / 180.0f); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        9 ( 0.00%)      TableAngledHeadersTextAlign = ImVec2(0.5f,0.0f);// Alignment of angled headers within the cell
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        2 ( 0.00%)      ColorButtonPosition         = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
        9 ( 0.00%)      ButtonTextAlign             = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      SelectableTextAlign         = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      SeparatorTextBorderSize     = 3.0f;             // Thickkness of border in SeparatorText()
        9 ( 0.00%)      SeparatorTextAlign          = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      SeparatorTextPadding        = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      DisplayWindowPadding        = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      DisplaySafeAreaPadding      = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      DockingSeparatorSize        = 2.0f;             // Thickness of resizing border between docked windows
        3 ( 0.00%)      MouseCursorScale            = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
        2 ( 0.00%)      AntiAliasedLines            = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
        2 ( 0.00%)      AntiAliasedLinesUseTex      = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
        2 ( 0.00%)      AntiAliasedFill             = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
        3 ( 0.00%)      CurveTessellationTol        = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
        3 ( 0.00%)      CircleTessellationMaxError  = 0.30f;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
        .           
        .               // Behaviors
        3 ( 0.00%)      HoverStationaryDelay        = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
        3 ( 0.00%)      HoverDelayShort             = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
        3 ( 0.00%)      HoverDelayNormal            = 0.40f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
        2 ( 0.00%)      HoverFlagsForTooltipMouse   = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled;    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
        2 ( 0.00%)      HoverFlagsForTooltipNav     = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
        .           
        .               // Default theme
        3 ( 0.00%)      ImGui::StyleColorsDark(this);
    2,231 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImGui::StyleColorsDark(ImGuiStyle*) (1x)
        3 ( 0.00%)  }
        .           
        .           // To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
        .           // Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
        .           void ImGuiStyle::ScaleAllSizes(float scale_factor)
        .           {
        .               WindowPadding = ImTrunc(WindowPadding * scale_factor);
        .               WindowRounding = ImTrunc(WindowRounding * scale_factor);
        .               WindowMinSize = ImTrunc(WindowMinSize * scale_factor);
-- line 1285 ----------------------------------------
-- line 1302 ----------------------------------------
        .               TabMinWidthForCloseButton = (TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(TabMinWidthForCloseButton * scale_factor) : FLT_MAX;
        .               SeparatorTextPadding = ImTrunc(SeparatorTextPadding * scale_factor);
        .               DockingSeparatorSize = ImTrunc(DockingSeparatorSize * scale_factor);
        .               DisplayWindowPadding = ImTrunc(DisplayWindowPadding * scale_factor);
        .               DisplaySafeAreaPadding = ImTrunc(DisplaySafeAreaPadding * scale_factor);
        .               MouseCursorScale = ImTrunc(MouseCursorScale * scale_factor);
        .           }
        .           
       38 ( 0.00%)  ImGuiIO::ImGuiIO()
       60 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (5x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::ImVector() (1x)
        .           {
        .               // Most fields are initialized with zero
        6 ( 0.00%)      memset(this, 0, sizeof(*this));
   14,633 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .               IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
        .           
        .               // Settings
        2 ( 0.00%)      ConfigFlags = ImGuiConfigFlags_None;
        2 ( 0.00%)      BackendFlags = ImGuiBackendFlags_None;
        9 ( 0.00%)      DisplaySize = ImVec2(-1.0f, -1.0f);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        3 ( 0.00%)      DeltaTime = 1.0f / 60.0f;
        3 ( 0.00%)      IniSavingRate = 5.0f;
        2 ( 0.00%)      IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
        2 ( 0.00%)      LogFilename = "imgui_log.txt";
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    2,002 ( 0.00%)      for (int i = 0; i < ImGuiKey_COUNT; i++)
    3,330 ( 0.00%)          KeyMap[i] = -1;
        .           #endif
        2 ( 0.00%)      UserData = NULL;
        .           
        2 ( 0.00%)      Fonts = NULL;
        3 ( 0.00%)      FontGlobalScale = 1.0f;
        2 ( 0.00%)      FontDefault = NULL;
        2 ( 0.00%)      FontAllowUserScaling = false;
        9 ( 0.00%)      DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        .           
        .               // Docking options (when ImGuiConfigFlags_DockingEnable is set)
        2 ( 0.00%)      ConfigDockingNoSplit = false;
        2 ( 0.00%)      ConfigDockingWithShift = false;
        2 ( 0.00%)      ConfigDockingAlwaysTabBar = false;
        2 ( 0.00%)      ConfigDockingTransparentPayload = false;
        .           
        .               // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
        2 ( 0.00%)      ConfigViewportsNoAutoMerge = false;
        2 ( 0.00%)      ConfigViewportsNoTaskBarIcon = false;
        2 ( 0.00%)      ConfigViewportsNoDecoration = true;
        2 ( 0.00%)      ConfigViewportsNoDefaultParent = false;
        .           
        .               // Miscellaneous options
        2 ( 0.00%)      MouseDrawCursor = false;
        .           #ifdef __APPLE__
        .               ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
        .           #else
        2 ( 0.00%)      ConfigMacOSXBehaviors = false;
        .           #endif
        2 ( 0.00%)      ConfigInputTrickleEventQueue = true;
        2 ( 0.00%)      ConfigInputTextCursorBlink = true;
        2 ( 0.00%)      ConfigInputTextEnterKeepActive = false;
        2 ( 0.00%)      ConfigDragClickToInputText = false;
        2 ( 0.00%)      ConfigWindowsResizeFromEdges = true;
        2 ( 0.00%)      ConfigWindowsMoveFromTitleBarOnly = false;
        3 ( 0.00%)      ConfigMemoryCompactTimer = 60.0f;
        2 ( 0.00%)      ConfigDebugBeginReturnValueOnce = false;
        2 ( 0.00%)      ConfigDebugBeginReturnValueLoop = false;
        .           
        .               // Inputs Behaviors
        3 ( 0.00%)      MouseDoubleClickTime = 0.30f;
        3 ( 0.00%)      MouseDoubleClickMaxDist = 6.0f;
        3 ( 0.00%)      MouseDragThreshold = 6.0f;
        3 ( 0.00%)      KeyRepeatDelay = 0.275f;
        3 ( 0.00%)      KeyRepeatRate = 0.050f;
        .           
        .               // Platform Functions
        .               // Note: Initialize() will setup default clipboard/ime handlers.
        6 ( 0.00%)      BackendPlatformName = BackendRendererName = NULL;
       10 ( 0.00%)      BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
        2 ( 0.00%)      PlatformLocaleDecimalPoint = '.';
        .           
        .               // Input (NB: we already have memset zero the entire structure!)
        9 ( 0.00%)      MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        9 ( 0.00%)      MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        2 ( 0.00%)      MouseSource = ImGuiMouseSource_Mouse;
       99 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
   18,652 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
        2 ( 0.00%)      AppAcceptingEvents = true;
        2 ( 0.00%)      BackendUsingLegacyKeyArrays = (ImS8)-1;
        2 ( 0.00%)      BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
        4 ( 0.00%)  }
        .           
        .           // Pass in translated ASCII characters for text input.
        .           // - with glfw you can get those from the callback set in glfwSetCharCallback()
        .           // - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
        .           // FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
        .           void ImGuiIO::AddInputCharacter(unsigned int c)
    1,570 ( 0.00%)  {
    1,256 ( 0.00%)      IM_ASSERT(Ctx != NULL);
      942 ( 0.00%)      ImGuiContext& g = *Ctx;
    2,198 ( 0.00%)      if (c == 0 || !AppAcceptingEvents)
        .                   return;
        .           
      942 ( 0.00%)      ImGuiInputEvent e;
    7,536 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiInputEvent::ImGuiInputEvent() (314x)
      314 ( 0.00%)      e.Type = ImGuiInputEventType_Text;
      314 ( 0.00%)      e.Source = ImGuiInputSource_Keyboard;
    1,884 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
      628 ( 0.00%)      e.Text.Char = c;
    2,198 ( 0.00%)      g.InputEventsQueue.push_back(e);
   37,941 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (314x)
      628 ( 0.00%)  }
        .           
        .           // UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
        .           // we should save the high surrogate.
        .           void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)
        .           {
        .               if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
        .                   return;
        .           
-- line 1414 ----------------------------------------
-- line 1437 ----------------------------------------
        .                   }
        .           
        .                   InputQueueSurrogate = 0;
        .               }
        .               AddInputCharacter((unsigned)cp);
        .           }
        .           
        .           void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
    1,570 ( 0.00%)  {
    1,570 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
    3,140 ( 0.00%)      while (*utf8_chars != 0)
        .               {
      314 ( 0.00%)          unsigned int c = 0;
    2,512 ( 0.00%)          utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
   45,216 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImTextCharFromUtf8(unsigned int*, char const*, char const*) (314x)
    1,570 ( 0.00%)          AddInputCharacter(c);
   58,351 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiIO::AddInputCharacter(unsigned int) (314x)
        .               }
      628 ( 0.00%)  }
        .           
        .           // Clear all incoming events.
        .           void ImGuiIO::ClearEventsQueue()
        .           {
        .               IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
        .               g.InputEventsQueue.clear();
        .           }
        .           
        .           // Clear current keyboard/mouse/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
        .           void ImGuiIO::ClearInputKeys()
        8 ( 0.00%)  {
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
       14 ( 0.00%)      memset(KeysDown, 0, sizeof(KeysDown));
      114 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2x)
        .           #endif
    4,004 ( 0.00%)      for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
        .               {
    9,324 ( 0.00%)          KeysData[n].Down             = false;
   11,988 ( 0.00%)          KeysData[n].DownDuration     = -1.0f;
   11,988 ( 0.00%)          KeysData[n].DownDurationPrev = -1.0f;
        .               }
       28 ( 0.00%)      KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
        4 ( 0.00%)      KeyMods = ImGuiMod_None;
       18 ( 0.00%)      MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2x)
       38 ( 0.00%)      for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
        .               {
       40 ( 0.00%)          MouseDown[n] = false;
      160 ( 0.00%)          MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
        .               }
       14 ( 0.00%)      MouseWheel = MouseWheelH = 0.0f;
       10 ( 0.00%)      InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
       30 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int) (2x)
        6 ( 0.00%)  }
        .           
        .           // Removed this as it is ambiguous/misleading and generally incorrect to use with the existence of a higher-level input queue.
        .           // Current frame character buffer is now also cleared by ClearInputKeys().
        .           #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        .           void ImGuiIO::ClearInputCharacters()
        .           {
        .               InputQueueCharacters.resize(0);
        .           }
        .           #endif
        .           
        .           static ImGuiInputEvent* FindLatestInputEvent(ImGuiContext* ctx, ImGuiInputEventType type, int arg = -1)
   19,962 ( 0.00%)  {
    6,654 ( 0.00%)      ImGuiContext& g = *ctx;
1,828,284 ( 0.00%)      for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
        .               {
4,219,705 ( 0.00%)          ImGuiInputEvent* e = &g.InputEventsQueue[n];
13,261,930 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::operator[](int) (602,815x)
2,411,260 ( 0.00%)          if (e->Type != type)
1,203,330 ( 0.00%)              continue;
    2,300 ( 0.00%)          if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
        .                       continue;
    2,304 ( 0.00%)          if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
        .                       continue;
    2,300 ( 0.00%)          return e;
        .               }
    2,177 ( 0.00%)      return NULL;
    6,654 ( 0.00%)  }
        .           
        .           // Queue a new key down/up event.
        .           // - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
        .           // - bool down:          Is the key down? use false to signify a key release.
        .           // - float analog_value: 0.0f..1.0f
        .           // IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
        .           // WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULLFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
        .           void ImGuiIO::AddKeyAnalogEvent(ImGuiKey key, bool down, float analog_value)
   12,720 ( 0.00%)  {
        .               //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
    6,360 ( 0.00%)      IM_ASSERT(Ctx != NULL);
   11,130 ( 0.00%)      if (key == ImGuiKey_None || !AppAcceptingEvents)
        .                   return;
    4,770 ( 0.00%)      ImGuiContext& g = *Ctx;
    7,950 ( 0.00%)      IM_ASSERT(ImGui::IsNamedKeyOrModKey(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
   23,850 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsNamedKeyOrModKey(ImGuiKey) (1,590x)
    9,540 ( 0.00%)      IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
   15,264 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsAliasKey(ImGuiKey) (1,590x)
    3,180 ( 0.00%)      IM_ASSERT(key != ImGuiMod_Shortcut); // We could easily support the translation here but it seems saner to not accept it (TestEngine perform a translation itself)
        .           
        .               // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
   12,716 ( 0.00%)      IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
    6,360 ( 0.00%)      if (BackendUsingLegacyKeyArrays == -1)
      466 ( 0.00%)          for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
    1,078 ( 0.00%)              IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
    3,180 ( 0.00%)      BackendUsingLegacyKeyArrays = 0;
        .           #endif
    7,950 ( 0.00%)      if (ImGui::IsGamepadKey(key))
   15,264 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsGamepadKey(ImGuiKey) (1,590x)
        .                   BackendUsingLegacyNavInputArray = false;
        .           
        .               // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
    9,540 ( 0.00%)      const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);
22,567,180 ( 0.02%)  => build/_deps/imgui-src/imgui.cpp:FindLatestInputEvent(ImGuiContext*, ImGuiInputEventType, int) (1,590x)
    9,540 ( 0.00%)      const ImGuiKeyData* key_data = ImGui::GetKeyData(&g, key);
   95,082 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetKeyData(ImGuiContext*, ImGuiKey) (1,590x)
    7,950 ( 0.00%)      const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
    7,950 ( 0.00%)      const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
   14,262 ( 0.00%)      if (latest_key_down == down && latest_key_analog == analog_value)
    1,582 ( 0.00%)          return;
        .           
        .               // Add event
       24 ( 0.00%)      ImGuiInputEvent e;
      192 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiInputEvent::ImGuiInputEvent() (8x)
        8 ( 0.00%)      e.Type = ImGuiInputEventType_Key;
       56 ( 0.00%)      e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
       64 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsGamepadKey(ImGuiKey) (8x)
       48 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
       16 ( 0.00%)      e.Key.Key = key;
       16 ( 0.00%)      e.Key.Down = down;
       16 ( 0.00%)      e.Key.AnalogValue = analog_value;
       56 ( 0.00%)      g.InputEventsQueue.push_back(e);
      368 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (8x)
    3,180 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddKeyEvent(ImGuiKey key, bool down)
   11,130 ( 0.00%)  {
    7,950 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
   16,214 ( 0.00%)      AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
22,858,908 ( 0.02%)  => build/_deps/imgui-src/imgui.cpp:ImGuiIO::AddKeyAnalogEvent(ImGuiKey, bool, float) (1,590x)
    3,180 ( 0.00%)  }
        .           
        .           // [Optional] Call after AddKeyEvent().
        .           // Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
        .           // If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
        .           void ImGuiIO::SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index)
    2,544 ( 0.00%)  {
      636 ( 0.00%)      if (key == ImGuiKey_None)
        .                   return;
    1,590 ( 0.00%)      IM_ASSERT(ImGui::IsNamedKey(key)); // >= 512
    3,498 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsNamedKey(ImGuiKey) (318x)
    2,226 ( 0.00%)      IM_ASSERT(native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)); // >= 0 && <= 511
    3,498 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsLegacyKey(ImGuiKey) (318x)
        .               IM_UNUSED(native_keycode);  // Yet unused
        .               IM_UNUSED(native_scancode); // Yet unused
        .           
        .               // Build native->imgui map so old user code can still call key functions with native 0..511 values.
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    1,590 ( 0.00%)      const int legacy_key = (native_legacy_index != -1) ? native_legacy_index : native_keycode;
    1,908 ( 0.00%)      if (!ImGui::IsLegacyKey((ImGuiKey)legacy_key))
    3,498 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsLegacyKey(ImGuiKey) (318x)
        .                   return;
    1,908 ( 0.00%)      KeyMap[legacy_key] = key;
    2,226 ( 0.00%)      KeyMap[key] = legacy_key;
        .           #else
        .               IM_UNUSED(key);
        .               IM_UNUSED(native_legacy_index);
        .           #endif
      636 ( 0.00%)  }
        .           
        .           // Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
        .           void ImGuiIO::SetAppAcceptingEvents(bool accepting_events)
        .           {
        .               AppAcceptingEvents = accepting_events;
        .           }
        .           
        .           // Queue a mouse move event
        .           void ImGuiIO::AddMousePosEvent(float x, float y)
    9,275 ( 0.00%)  {
    5,300 ( 0.00%)      IM_ASSERT(Ctx != NULL);
    3,975 ( 0.00%)      ImGuiContext& g = *Ctx;
    6,625 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
        .           
        .               // Apply same flooring as UpdateMouseInputs()
   27,809 ( 0.00%)      ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);
   18,550 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1,325x)
   34,398 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,646x)
        .           
        .               // Filter duplicate
    7,950 ( 0.00%)      const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);
   98,178 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FindLatestInputEvent(ImGuiContext*, ImGuiInputEventType, int) (1,325x)
   14,647 ( 0.00%)      const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
   16,044 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1,146x)
   11,118 ( 0.00%)      if (latest_pos.x == pos.x && latest_pos.y == pos.y)
      188 ( 0.00%)          return;
        .           
    3,411 ( 0.00%)      ImGuiInputEvent e;
   27,288 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiInputEvent::ImGuiInputEvent() (1,137x)
    1,137 ( 0.00%)      e.Type = ImGuiInputEventType_MousePos;
    1,137 ( 0.00%)      e.Source = ImGuiInputSource_Mouse;
    6,822 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
    2,274 ( 0.00%)      e.MousePos.PosX = pos.x;
    2,274 ( 0.00%)      e.MousePos.PosY = pos.y;
    3,411 ( 0.00%)      e.MousePos.MouseSource = g.InputEventsNextMouseSource;
    7,959 ( 0.00%)      g.InputEventsQueue.push_back(e);
  247,558 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (1,137x)
    3,975 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddMouseButtonEvent(int mouse_button, bool down)
       28 ( 0.00%)  {
       16 ( 0.00%)      IM_ASSERT(Ctx != NULL);
       12 ( 0.00%)      ImGuiContext& g = *Ctx;
       16 ( 0.00%)      IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
       20 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
        .           
        .               // Filter duplicate
       24 ( 0.00%)      const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);
    1,748 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FindLatestInputEvent(ImGuiContext*, ImGuiInputEventType, int) (4x)
       36 ( 0.00%)      const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
       12 ( 0.00%)      if (latest_button_down == down)
        .                   return;
        .           
       12 ( 0.00%)      ImGuiInputEvent e;
       96 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiInputEvent::ImGuiInputEvent() (4x)
        4 ( 0.00%)      e.Type = ImGuiInputEventType_MouseButton;
        4 ( 0.00%)      e.Source = ImGuiInputSource_Mouse;
       24 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
        8 ( 0.00%)      e.MouseButton.Button = mouse_button;
        8 ( 0.00%)      e.MouseButton.Down = down;
       12 ( 0.00%)      e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
       28 ( 0.00%)      g.InputEventsQueue.push_back(e);
      184 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (4x)
        8 ( 0.00%)  }
        .           
        .           // Queue a mouse wheel event (some mouse/API may only have a Y component)
        .           void ImGuiIO::AddMouseWheelEvent(float wheel_x, float wheel_y)
        .           {
        .               IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
        .           
        .               // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
-- line 1656 ----------------------------------------
-- line 1665 ----------------------------------------
        .               e.MouseWheel.WheelY = wheel_y;
        .               e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
        .               g.InputEventsQueue.push_back(e);
        .           }
        .           
        .           // This is not a real event, the data is latched in order to be stored in actual Mouse events.
        .           // This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
        .           void ImGuiIO::AddMouseSourceEvent(ImGuiMouseSource source)
    5,660 ( 0.00%)  {
    4,528 ( 0.00%)      IM_ASSERT(Ctx != NULL);
    3,396 ( 0.00%)      ImGuiContext& g = *Ctx;
    3,396 ( 0.00%)      g.InputEventsNextMouseSource = source;
    3,396 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddMouseViewportEvent(ImGuiID viewport_id)
    2,015 ( 0.00%)  {
    1,612 ( 0.00%)      IM_ASSERT(Ctx != NULL);
    1,209 ( 0.00%)      ImGuiContext& g = *Ctx;
        .               //IM_ASSERT(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport);
    2,015 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
        .           
        .               // Filter duplicate
    2,418 ( 0.00%)      const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseViewport);
  298,030 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FindLatestInputEvent(ImGuiContext*, ImGuiInputEventType, int) (403x)
    2,418 ( 0.00%)      const ImGuiID latest_viewport_id = latest_event ? latest_event->MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport;
    1,209 ( 0.00%)      if (latest_viewport_id == viewport_id)
      399 ( 0.00%)          return;
        .           
       12 ( 0.00%)      ImGuiInputEvent e;
       96 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiInputEvent::ImGuiInputEvent() (4x)
        4 ( 0.00%)      e.Type = ImGuiInputEventType_MouseViewport;
        4 ( 0.00%)      e.Source = ImGuiInputSource_Mouse;
        8 ( 0.00%)      e.MouseViewport.HoveredViewportID = viewport_id;
       28 ( 0.00%)      g.InputEventsQueue.push_back(e);
      184 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (4x)
      806 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddFocusEvent(bool focused)
       30 ( 0.00%)  {
       20 ( 0.00%)      IM_ASSERT(Ctx != NULL);
       15 ( 0.00%)      ImGuiContext& g = *Ctx;
        .           
        .               // Filter duplicate
       30 ( 0.00%)      const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);
    1,724 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FindLatestInputEvent(ImGuiContext*, ImGuiInputEventType, int) (5x)
       30 ( 0.00%)      const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
       23 ( 0.00%)      if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
        3 ( 0.00%)          return;
        .           
        6 ( 0.00%)      ImGuiInputEvent e;
       48 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiInputEvent::ImGuiInputEvent() (2x)
        2 ( 0.00%)      e.Type = ImGuiInputEventType_Focus;
       12 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
        4 ( 0.00%)      e.AppFocused.Focused = focused;
       14 ( 0.00%)      g.InputEventsQueue.push_back(e);
       92 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (2x)
       10 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
        .           //-----------------------------------------------------------------------------
        .           
        .           ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)
        .           {
        .               IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
-- line 1724 ----------------------------------------
-- line 1859 ----------------------------------------
        .               if (count < 1)
        .                   return;
        .               if (count > 1)
        .                   strncpy(dst, src, count - 1);
        .               dst[count - 1] = 0;
        .           }
        .           
        .           char* ImStrdup(const char* str)
       24 ( 0.00%)  {
       30 ( 0.00%)      size_t len = strlen(str);
       84 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (6x)
       30 ( 0.00%)      void* buf = IM_ALLOC(len + 1);
      708 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (6x)
       48 ( 0.00%)      return (char*)memcpy(buf, (const void*)str, len + 1);
       74 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (6x)
       12 ( 0.00%)  }
        .           
        .           char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
        .           {
        .               size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
        .               size_t src_size = strlen(src) + 1;
        .               if (dst_buf_size < src_size)
        .               {
        .                   IM_FREE(dst);
-- line 1879 ----------------------------------------
-- line 1880 ----------------------------------------
        .                   dst = (char*)IM_ALLOC(src_size);
        .                   if (p_dst_size)
        .                       *p_dst_size = src_size;
        .               }
        .               return (char*)memcpy(dst, (const void*)src, src_size);
        .           }
        .           
        .           const char* ImStrchrRange(const char* str, const char* str_end, char c)
       70 ( 0.00%)  {
      100 ( 0.00%)      const char* p = (const char*)memchr(str, (int)c, str_end - str);
      190 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2 (10x)
       10 ( 0.00%)      return p;
       20 ( 0.00%)  }
        .           
        .           int ImStrlenW(const ImWchar* str)
        .           {
        .               //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
        .               int n = 0;
        .               while (*str++) n++;
        .               return n;
        .           }
-- line 1899 ----------------------------------------
-- line 1946 ----------------------------------------
        .               while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        .                   p--;
        .               if (p_start != buf)                     // Copy memory if we had leading blanks
        .                   memmove(buf, p_start, p - p_start);
        .               buf[p - p_start] = 0;                   // Zero terminate
        .           }
        .           
        .           const char* ImStrSkipBlank(const char* str)
        9 ( 0.00%)  {
       31 ( 0.00%)      while (str[0] == ' ' || str[0] == '\t')
        1 ( 0.00%)          str++;
        3 ( 0.00%)      return str;
        6 ( 0.00%)  }
        .           
        .           // A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
        .           // Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
        .           // B) When buf==NULL vsnprintf() will return the output size.
        .           #ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        .           
        .           // We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
        .           // You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
-- line 1966 ----------------------------------------
-- line 1977 ----------------------------------------
        .           #endif
        .           #endif // #ifdef IMGUI_USE_STB_SPRINTF
        .           
        .           #if defined(_MSC_VER) && !defined(vsnprintf)
        .           #define vsnprintf _vsnprintf
        .           #endif
        .           
        .           int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
    4,455 ( 0.00%)  {
        .               va_list args;
    2,430 ( 0.00%)      va_start(args, fmt);
        .           #ifdef IMGUI_USE_STB_SPRINTF
        .               int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
        .           #else
    3,244 ( 0.00%)      int w = vsnprintf(buf, buf_size, fmt, args);
  300,501 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/vsnprintf.c:vsnprintf (405x)
    1,199 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           #endif
        .               va_end(args);
      810 ( 0.00%)      if (buf == NULL)
        .                   return w;
    2,025 ( 0.00%)      if (w == -1 || w >= (int)buf_size)
        .                   w = (int)buf_size - 1;
    2,025 ( 0.00%)      buf[w] = 0;
      405 ( 0.00%)      return w;
      810 ( 0.00%)  }
        .           
        .           int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
        .           {
        .           #ifdef IMGUI_USE_STB_SPRINTF
        .               int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
        .           #else
        .               int w = vsnprintf(buf, buf_size, fmt, args);
        .           #endif
-- line 2008 ----------------------------------------
-- line 2092 ----------------------------------------
        .           
        .           // Zero-terminated string hash, with support for ### to reset back to seed value
        .           // We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
        .           // Because this syntax is rarely used we are optimizing for the common case.
        .           // - If we reach ### in the string we discard the hash so far and reset to the seed.
        .           // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
        .           // FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
        .           ImGuiID ImHashStr(const char* data_p, size_t data_size, ImGuiID seed)
   58,635 ( 0.00%)  {
   11,727 ( 0.00%)      seed = ~seed;
   23,454 ( 0.00%)      ImU32 crc = seed;
   23,454 ( 0.00%)      const unsigned char* data = (const unsigned char*)data_p;
   11,727 ( 0.00%)      const ImU32* crc32_lut = GCrc32LookupTable;
   23,454 ( 0.00%)      if (data_size != 0)
        .               {
      421 ( 0.00%)          while (data_size-- != 0)
        .                   {
      275 ( 0.00%)              unsigned char c = *data++;
      127 ( 0.00%)              if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
        .                           crc = seed;
      770 ( 0.00%)              crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        .                   }
        .               }
        .               else
        .               {
  834,687 ( 0.00%)          while (unsigned char c = *data++)
        .                   {
  236,087 ( 0.00%)              if (c == '#' && data[0] == '#' && data[1] == '#')
      806 ( 0.00%)                  crc = seed;
1,505,252 ( 0.00%)              crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
  107,518 ( 0.00%)          }
        .               }
   23,454 ( 0.00%)      return ~crc;
   23,454 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MISC HELPERS/UTILITIES (File functions)
        .           //-----------------------------------------------------------------------------
        .           
        .           // Default file functions
        .           #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        .           
        .           ImFileHandle ImFileOpen(const char* filename, const char* mode)
        5 ( 0.00%)  {
        .           #if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(__CYGWIN__) && !defined(__GNUC__)
        .               // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.
        .               // Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!
        .               const int filename_wsize = ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);
        .               const int mode_wsize = ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, NULL, 0);
        .           
        .               // Use stack buffer if possible, otherwise heap buffer. Sizes include zero terminator.
        .               // We don't rely on current ImGuiContext as this is implied to be a helper function which doesn't depend on it (see #7314).
-- line 2143 ----------------------------------------
-- line 2146 ----------------------------------------
        .               if (filename_wsize + mode_wsize > IM_ARRAYSIZE(local_temp_stack))
        .                   local_temp_heap.resize(filename_wsize + mode_wsize);
        .               wchar_t* filename_wbuf = local_temp_heap.Data ? local_temp_heap.Data : local_temp_stack;
        .               wchar_t* mode_wbuf = filename_wbuf + filename_wsize;
        .               ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_wbuf, filename_wsize);
        .               ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, mode_wbuf, mode_wsize);
        .               return ::_wfopen(filename_wbuf, mode_wbuf);
        .           #else
       10 ( 0.00%)      return fopen(filename, mode);
    1,246 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      554 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofopen.c:fopen@@GLIBC_2.2.5 (1x)
        .           #endif
        2 ( 0.00%)  }
        .           
        .           // We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
       16 ( 0.00%)  bool    ImFileClose(ImFileHandle f)     { return fclose(f) == 0; }
    1,249 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      640 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofclose.c:fclose@@GLIBC_2.2.5 (1x)
       49 ( 0.00%)  ImU64   ImFileGetSize(ImFileHandle f)   { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1; }
   28,773 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/fseek.c:fseek (2x)
    2,468 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (2x)
      249 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/ioftell.c:ftell (2x)
       20 ( 0.00%)  ImU64   ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f)           { return fread(data, (size_t)sz, (size_t)count, f); }
    1,167 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      181 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofread.c:fread (1x)
        .           ImU64   ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f)    { return fwrite(data, (size_t)sz, (size_t)count, f); }
        .           #endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        .           
        .           // Helper: Load file content into memory
        .           // Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
        .           // This can't really be used with "rt" because fseek size won't match read size.
        .           void*   ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)
        7 ( 0.00%)  {
        4 ( 0.00%)      IM_ASSERT(filename && mode);
        2 ( 0.00%)      if (out_file_size)
        2 ( 0.00%)          *out_file_size = 0;
        .           
        .               ImFileHandle f;
       10 ( 0.00%)      if ((f = ImFileOpen(filename, mode)) == NULL)
    1,817 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFileOpen(char const*, char const*) (1x)
        .                   return NULL;
        .           
        4 ( 0.00%)      size_t file_size = (size_t)ImFileGetSize(f);
   31,539 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFileGetSize(_IO_FILE*) (1x)
        2 ( 0.00%)      if (file_size == (size_t)-1)
        .               {
        .                   ImFileClose(f);
        .                   return NULL;
        .               }
        .           
        7 ( 0.00%)      void* file_data = IM_ALLOC(file_size + padding_bytes);
      118 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        2 ( 0.00%)      if (file_data == NULL)
        .               {
        .                   ImFileClose(f);
        .                   return NULL;
        .               }
       10 ( 0.00%)      if (ImFileRead(file_data, 1, file_size, f) != file_size)
    1,368 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFileRead(void*, unsigned long long, unsigned long long, _IO_FILE*) (1x)
        .               {
        .                   ImFileClose(f);
        .                   IM_FREE(file_data);
        .                   return NULL;
        .               }
        2 ( 0.00%)      if (padding_bytes > 0)
        .                   memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);
        .           
        3 ( 0.00%)      ImFileClose(f);
    1,905 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFileClose(_IO_FILE*) (1x)
        2 ( 0.00%)      if (out_file_size)
        3 ( 0.00%)          *out_file_size = file_size;
        .           
        1 ( 0.00%)      return file_data;
        2 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
        .           //-----------------------------------------------------------------------------
        .           
        .           IM_MSVC_RUNTIME_CHECKS_OFF
        .           
        .           // Convert UTF-8 to 32-bit character, process single character input.
        .           // A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
        .           // We handle UTF-8 decoding error by skipping forward.
        .           int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
    1,884 ( 0.00%)  {
        .               static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
        .               static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
        .               static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
        .               static const int shiftc[] = { 0, 18, 12, 6, 0 };
        .               static const int shifte[] = { 0, 6, 4, 2, 0 };
    2,512 ( 0.00%)      int len = lengths[*(const unsigned char*)in_text >> 3];
    1,884 ( 0.00%)      int wanted = len + (len ? 0 : 1);
        .           
      628 ( 0.00%)      if (in_text_end == NULL)
    1,570 ( 0.00%)          in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
        .           
        .               // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
        .               // so it is fast even with excessive branching.
        .               unsigned char s[4];
    2,198 ( 0.00%)      s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
    1,884 ( 0.00%)      s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
    1,884 ( 0.00%)      s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
    1,884 ( 0.00%)      s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
        .           
        .               // Assume a four-byte character and load four bytes. Unused bits are shifted out.
    3,140 ( 0.00%)      *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
    2,826 ( 0.00%)      *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
    2,826 ( 0.00%)      *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
    2,512 ( 0.00%)      *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
    2,512 ( 0.00%)      *out_char >>= shiftc[len];
        .           
        .               // Accumulate the various error conditions.
      314 ( 0.00%)      int e = 0;
    2,826 ( 0.00%)      e  = (*out_char < mins[len]) << 6; // non-canonical encoding
    2,198 ( 0.00%)      e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
    1,884 ( 0.00%)      e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
    1,570 ( 0.00%)      e |= (s[1] & 0xc0) >> 2;
    1,570 ( 0.00%)      e |= (s[2] & 0xc0) >> 4;
    1,256 ( 0.00%)      e |= (s[3]       ) >> 6;
      314 ( 0.00%)      e ^= 0x2a; // top two bits of each tail byte correct?
    1,570 ( 0.00%)      e >>= shifte[len];
        .           
      628 ( 0.00%)      if (e)
        .               {
        .                   // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
        .                   // One byte is consumed in case of invalid first byte of in_text.
        .                   // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
        .                   // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
        .                   wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
        .                   *out_char = IM_UNICODE_CODEPOINT_INVALID;
        .               }
        .           
      314 ( 0.00%)      return wanted;
      628 ( 0.00%)  }
        .           
        .           int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
        .           {
        .               ImWchar* buf_out = buf;
        .               ImWchar* buf_end = buf + buf_size;
        .               while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
        .               {
        .                   unsigned int c;
-- line 2274 ----------------------------------------
-- line 2429 ----------------------------------------
        .               return ImVec4(
        .                   ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        .                   ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        .                   ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        .                   ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
        .           }
        .           
        .           ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
   35,504 ( 0.00%)  {
        .               ImU32 out;
   88,760 ( 0.00%)      out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  115,388 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImSaturate(float) (8,876x)
   97,636 ( 0.00%)      out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  115,388 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImSaturate(float) (8,876x)
   97,636 ( 0.00%)      out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  115,388 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImSaturate(float) (8,876x)
   97,636 ( 0.00%)      out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  115,388 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImSaturate(float) (8,876x)
    8,876 ( 0.00%)      return out;
   17,752 ( 0.00%)  }
        .           
        .           // Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
        .           // Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
        .           void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
        .           {
        .               float K = 0.f;
        .               if (g < b)
        .               {
-- line 2452 ----------------------------------------
-- line 2496 ----------------------------------------
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImGuiStorage
        .           // Helper: Key->value storage
        .           //-----------------------------------------------------------------------------
        .           
        .           // std::lower_bound but without the bullshit
        .           static ImGuiStorage::ImGuiStoragePair* LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key)
   11,356 ( 0.00%)  {
    8,517 ( 0.00%)      ImGuiStorage::ImGuiStoragePair* first = data.Data;
   22,712 ( 0.00%)      ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
   11,356 ( 0.00%)      size_t count = (size_t)(last - first);
   22,235 ( 0.00%)      while (count > 0)
        .               {
   20,577 ( 0.00%)          size_t count2 = count >> 1;
   41,154 ( 0.00%)          ImGuiStorage::ImGuiStoragePair* mid = first + count2;
   27,436 ( 0.00%)          if (mid->key < key)
        .                   {
    6,060 ( 0.00%)              first = ++mid;
   10,100 ( 0.00%)              count -= count2 + 1;
        .                   }
        .                   else
        .                   {
    9,678 ( 0.00%)              count = count2;
        .                   }
        .               }
    2,839 ( 0.00%)      return first;
    5,678 ( 0.00%)  }
        .           
        .           // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
        .           void ImGuiStorage::BuildSortByKey()
        .           {
        .               struct StaticFunc
        .               {
        .                   static int IMGUI_CDECL PairComparerByID(const void* lhs, const void* rhs)
        .                   {
-- line 2531 ----------------------------------------
-- line 2534 ----------------------------------------
        .                       if (((const ImGuiStoragePair*)lhs)->key < ((const ImGuiStoragePair*)rhs)->key) return -1;
        .                       return 0;
        .                   }
        .               };
        .               ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), StaticFunc::PairComparerByID);
        .           }
        .           
        .           int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
       12 ( 0.00%)  {
       12 ( 0.00%)      ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
       84 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>&, unsigned int) (2x)
       24 ( 0.00%)      if (it == Data.end() || it->key != key)
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::end() const (2x)
        .                   return default_val;
        4 ( 0.00%)      return it->val_i;
        4 ( 0.00%)  }
        .           
        .           bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
        .           {
        .               return GetInt(key, default_val ? 1 : 0) != 0;
        .           }
        .           
        .           float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
        .           {
        .               ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
        .               if (it == Data.end() || it->key != key)
        .                   return default_val;
        .               return it->val_f;
        .           }
        .           
        .           void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
   14,145 ( 0.00%)  {
   16,974 ( 0.00%)      ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
  199,214 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>&, unsigned int) (2,829x)
   33,928 ( 0.00%)      if (it == Data.end() || it->key != key)
   33,948 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::end() const (2,829x)
       24 ( 0.00%)          return NULL;
    5,634 ( 0.00%)      return it->val_p;
    5,658 ( 0.00%)  }
        .           
        .           // References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
        .           int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
        7 ( 0.00%)  {
        6 ( 0.00%)      ImGuiStoragePair* it = LowerBound(Data, key);
       25 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>&, unsigned int) (1x)
        9 ( 0.00%)      if (it == Data.end() || it->key != key)
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::end() (1x)
       13 ( 0.00%)          it = Data.insert(it, ImGuiStoragePair(key, default_val));
       59 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::insert(ImGuiStorage::ImGuiStoragePair const*, ImGuiStorage::ImGuiStoragePair const&) (1x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiStorage::ImGuiStoragePair::ImGuiStoragePair(unsigned int, int) (1x)
        2 ( 0.00%)      return &it->val_i;
        3 ( 0.00%)  }
        .           
        .           bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
        .           {
        .               return (bool*)GetIntRef(key, default_val ? 1 : 0);
        .           }
        .           
        .           float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
        .           {
-- line 2585 ----------------------------------------
-- line 2617 ----------------------------------------
        .               ImGuiStoragePair* it = LowerBound(Data, key);
        .               if (it == Data.end() || it->key != key)
        .                   Data.insert(it, ImGuiStoragePair(key, val));
        .               else
        .                   it->val_f = val;
        .           }
        .           
        .           void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
       49 ( 0.00%)  {
       42 ( 0.00%)      ImGuiStoragePair* it = LowerBound(Data, key);
      375 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>&, unsigned int) (7x)
       79 ( 0.00%)      if (it == Data.end() || it->key != key)
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::end() (7x)
       84 ( 0.00%)          Data.insert(it, ImGuiStoragePair(key, val));
      893 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::insert(ImGuiStorage::ImGuiStoragePair const*, ImGuiStorage::ImGuiStoragePair const&) (7x)
       98 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiStorage::ImGuiStoragePair::ImGuiStoragePair(unsigned int, void*) (7x)
        .               else
        .                   it->val_p = val;
       35 ( 0.00%)  }
        .           
        .           void ImGuiStorage::SetAllInt(int v)
        .           {
        .               for (int i = 0; i < Data.Size; i++)
        .                   Data[i].val_i = v;
        .           }
        .           
        .           //-----------------------------------------------------------------------------
-- line 2639 ----------------------------------------
-- line 3104 ----------------------------------------
        .               return ret;
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] STYLING
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiStyle& ImGui::GetStyle()
        2 ( 0.00%)  {
        3 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
        2 ( 0.00%)      return GImGui->Style;
        2 ( 0.00%)  }
        .           
        .           ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
   32,290 ( 0.00%)  {
   19,374 ( 0.00%)      ImGuiStyle& style = GImGui->Style;
   64,580 ( 0.00%)      ImVec4 c = style.Colors[idx];
   38,748 ( 0.00%)      c.w *= style.Alpha * alpha_mul;
   19,374 ( 0.00%)      return ColorConvertFloat4ToU32(c);
  658,716 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ColorConvertFloat4ToU32(ImVec4 const&) (6,458x)
   12,916 ( 0.00%)  }
        .           
        .           ImU32 ImGui::GetColorU32(const ImVec4& col)
        .           {
        .               ImGuiStyle& style = GImGui->Style;
        .               ImVec4 c = col;
        .               c.w *= style.Alpha;
        .               return ColorConvertFloat4ToU32(c);
        .           }
-- line 3131 ----------------------------------------
-- line 3155 ----------------------------------------
        .               backup.Col = idx;
        .               backup.BackupValue = g.Style.Colors[idx];
        .               g.ColorStack.push_back(backup);
        .               if (g.DebugFlashStyleColorIdx != idx)
        .                   g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
        .           }
        .           
        .           void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
   56,420 ( 0.00%)  {
   22,568 ( 0.00%)      ImGuiContext& g = *GImGui;
   33,852 ( 0.00%)      ImGuiColorMod backup;
  327,236 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiColorMod::ImGuiColorMod() (11,284x)
   22,568 ( 0.00%)      backup.Col = idx;
  112,840 ( 0.00%)      backup.BackupValue = g.Style.Colors[idx];
   67,704 ( 0.00%)      g.ColorStack.push_back(backup);
  519,242 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiColorMod>::push_back(ImGuiColorMod const&) (11,284x)
   45,136 ( 0.00%)      if (g.DebugFlashStyleColorIdx != idx)
  124,124 ( 0.00%)          g.Style.Colors[idx] = col;
   33,852 ( 0.00%)  }
        .           
        .           void ImGui::PopStyleColor(int count)
   12,896 ( 0.00%)  {
    6,448 ( 0.00%)      ImGuiContext& g = *GImGui;
   12,896 ( 0.00%)      if (g.ColorStack.Size < count)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times!");
        .                   count = g.ColorStack.Size;
        .               }
   29,016 ( 0.00%)      while (count > 0)
        .               {
   56,420 ( 0.00%)          ImGuiColorMod& backup = g.ColorStack.back();
  236,964 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiColorMod>::back() (11,284x)
  135,408 ( 0.00%)          g.Style.Colors[backup.Col] = backup.BackupValue;
   45,136 ( 0.00%)          g.ColorStack.pop_back();
  180,544 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiColorMod>::pop_back() (11,284x)
   11,284 ( 0.00%)          count--;
        .               }
   12,896 ( 0.00%)  }
        .           
        .           static const ImGuiCol GWindowDockStyleColors[ImGuiWindowDockStyleCol_COUNT] =
        .           {
        .               ImGuiCol_Text, ImGuiCol_Tab, ImGuiCol_TabHovered, ImGuiCol_TabActive, ImGuiCol_TabUnfocused, ImGuiCol_TabUnfocusedActive
        .           };
        .           
        .           static const ImGuiDataVarInfo GStyleVarInfo[] =
        .           {
-- line 3196 ----------------------------------------
-- line 3225 ----------------------------------------
        .               { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SelectableTextAlign) },       // ImGuiStyleVar_SelectableTextAlign
        .               { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, SeparatorTextBorderSize)},    // ImGuiStyleVar_SeparatorTextBorderSize
        .               { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextAlign) },        // ImGuiStyleVar_SeparatorTextAlign
        .               { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextPadding) },      // ImGuiStyleVar_SeparatorTextPadding
        .               { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, DockingSeparatorSize) },      // ImGuiStyleVar_DockingSeparatorSize
        .           };
        .           
        .           const ImGuiDataVarInfo* ImGui::GetStyleVarInfo(ImGuiStyleVar idx)
   80,600 ( 0.00%)  {
   80,600 ( 0.00%)      IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
        .               IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
  141,050 ( 0.00%)      return &GStyleVarInfo[idx];
   40,300 ( 0.00%)  }
        .           
        .           void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
   26,598 ( 0.00%)  {
    8,866 ( 0.00%)      ImGuiContext& g = *GImGui;
   17,732 ( 0.00%)      const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
   75,361 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetStyleVarInfo(int) (4,433x)
   35,464 ( 0.00%)      if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
        .               {
   31,031 ( 0.00%)          float* pvar = (float*)var_info->GetVarPtr(&g.Style);
   48,763 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDataVarInfo::GetVarPtr(void*) const (4,433x)
   62,062 ( 0.00%)          g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
  212,784 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStyleMod>::push_back(ImGuiStyleMod const&) (4,433x)
   62,062 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiStyleMod::ImGuiStyleMod(int, float) (4,433x)
   13,299 ( 0.00%)          *pvar = val;
    4,433 ( 0.00%)          return;
        .               }
        .               IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
   13,299 ( 0.00%)  }
        .           
        .           void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
   33,852 ( 0.00%)  {
   11,284 ( 0.00%)      ImGuiContext& g = *GImGui;
   22,568 ( 0.00%)      const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
   95,914 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetStyleVarInfo(int) (5,642x)
   45,136 ( 0.00%)      if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
        .               {
   39,494 ( 0.00%)          ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
   62,062 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDataVarInfo::GetVarPtr(void*) const (5,642x)
   78,988 ( 0.00%)          g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
  270,994 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStyleMod>::push_back(ImGuiStyleMod const&) (5,642x)
   95,914 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiStyleMod::ImGuiStyleMod(int, ImVec2) (5,642x)
   22,568 ( 0.00%)          *pvar = val;
    5,642 ( 0.00%)          return;
        .               }
        .               IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
   16,926 ( 0.00%)  }
        .           
        .           void ImGui::PopStyleVar(int count)
   24,180 ( 0.00%)  {
   12,090 ( 0.00%)      ImGuiContext& g = *GImGui;
   24,180 ( 0.00%)      if (g.StyleVarStack.Size < count)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times!");
        .                   count = g.StyleVarStack.Size;
        .               }
   32,240 ( 0.00%)      while (count > 0)
        .               {
        .                   // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
   50,375 ( 0.00%)          ImGuiStyleMod& backup = g.StyleVarStack.back();
  211,575 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStyleMod>::back() (10,075x)
   50,375 ( 0.00%)          const ImGuiDataVarInfo* info = GetStyleVarInfo(backup.VarIdx);
  171,275 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetStyleVarInfo(int) (10,075x)
   70,525 ( 0.00%)          void* data = info->GetVarPtr(&g.Style);
  110,825 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDataVarInfo::GetVarPtr(void*) const (10,075x)
  102,765 ( 0.00%)          if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
   95,914 ( 0.00%)          else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
   40,300 ( 0.00%)          g.StyleVarStack.pop_back();
  161,200 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStyleMod>::pop_back() (10,075x)
   10,075 ( 0.00%)          count--;
        .               }
   24,180 ( 0.00%)  }
        .           
        .           const char* ImGui::GetStyleColorName(ImGuiCol idx)
        .           {
        .               // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
        .               switch (idx)
        .               {
        .               case ImGuiCol_Text: return "Text";
        .               case ImGuiCol_TextDisabled: return "TextDisabled";
-- line 3294 ----------------------------------------
-- line 3354 ----------------------------------------
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] RENDER HELPERS
        .           // Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
        .           // we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
        .           // Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
        .           //-----------------------------------------------------------------------------
        .           
        .           const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
   41,920 ( 0.00%)  {
   20,960 ( 0.00%)      const char* text_display_end = text;
   20,960 ( 0.00%)      if (!text_end)
   10,480 ( 0.00%)          text_end = (const char*)-1;
        .           
  596,918 ( 0.00%)      while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
   45,984 ( 0.00%)          text_display_end++;
   10,480 ( 0.00%)      return text_display_end;
   20,960 ( 0.00%)  }
        .           
        .           // Internal ImGui functions to render text
        .           // RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
        .           void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
   21,762 ( 0.00%)  {
    4,836 ( 0.00%)      ImGuiContext& g = *GImGui;
    7,254 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
        .               // Hide anything after a '##' string
        .               const char* text_display_end;
    4,836 ( 0.00%)      if (hide_text_after_hash)
        .               {
   16,926 ( 0.00%)          text_display_end = FindRenderedTextEnd(text, text_end);
  299,832 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindRenderedTextEnd(char const*, char const*) (2,418x)
        .               }
        .               else
        .               {
        .                   if (!text_end)
        .                       text_end = text + strlen(text); // FIXME-OPT
        .                   text_display_end = text_end;
        .               }
        .           
    7,254 ( 0.00%)      if (text != text_display_end)
        .               {
   58,032 ( 0.00%)          window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
5,776,475 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddText(ImFont const*, float, ImVec2 const&, unsigned int, char const*, char const*, float, ImVec4 const*) (2,418x)
  316,758 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (2,418x)
    9,672 ( 0.00%)          if (g.LogEnabled)
        .                       LogRenderedText(&pos, text, text_display_end);
        .               }
    9,672 ( 0.00%)  }
        .           
        .           void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .           
        .               if (!text_end)
        .                   text_end = text + strlen(text); // FIXME-OPT
-- line 3406 ----------------------------------------
-- line 3414 ----------------------------------------
        .           }
        .           
        .           // Default clip_rect uses (pos_min,pos_max)
        .           // Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
        .           // FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.
        .           // Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
        .           // better advantage of the render function taking size into account for coarse clipping.
        .           void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
    4,040 ( 0.00%)  {
        .               // Perform CPU side clipping for single clipped element to avoid using scissor state
    1,212 ( 0.00%)      ImVec2 pos = pos_min;
    2,424 ( 0.00%)      const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
        .           
    2,020 ( 0.00%)      const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    2,424 ( 0.00%)      const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    6,458 ( 0.00%)      bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
      808 ( 0.00%)      if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
    6,464 ( 0.00%)          need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
        .           
        .               // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    2,020 ( 0.00%)      if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    8,888 ( 0.00%)      if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
    4,040 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (404x)
        .           
        .               // Render
      808 ( 0.00%)      if (need_clipping)
        .               {
       15 ( 0.00%)          ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
       22 ( 0.00%)          draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    3,558 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddText(ImFont const*, float, ImVec2 const&, unsigned int, char const*, char const*, float, ImVec4 const*) (1x)
      131 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (1x)
        .               }
        .               else
        .               {
    8,866 ( 0.00%)          draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
  617,003 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddText(ImFont const*, float, ImVec2 const&, unsigned int, char const*, char const*, float, ImVec4 const*) (403x)
   52,793 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (403x)
        .               }
    1,617 ( 0.00%)  }
        .           
        .           void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
   25,398 ( 0.00%)  {
        .               // Hide anything after a '##' string
   16,932 ( 0.00%)      const char* text_display_end = FindRenderedTextEnd(text, text_end);
   84,499 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindRenderedTextEnd(char const*, char const*) (2,822x)
    8,466 ( 0.00%)      const int text_len = (int)(text_display_end - text);
    5,644 ( 0.00%)      if (text_len == 0)
    2,418 ( 0.00%)          return;
        .           
      808 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,212 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    5,656 ( 0.00%)      RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
  725,633 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderTextClippedEx(ImDrawList*, ImVec2 const&, ImVec2 const&, char const*, char const*, ImVec2 const*, ImVec2 const&, ImRect const*) (404x)
    1,616 ( 0.00%)      if (g.LogEnabled)
        .                   LogRenderedText(&pos_min, text, text_display_end);
    5,644 ( 0.00%)  }
        .           
        .           // Another overly complex function until we reorganize everything into a nice all-in-one helper.
        .           // This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
        .           // This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
        .           void ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (text_end_full == NULL)
-- line 3470 ----------------------------------------
-- line 3606 ----------------------------------------
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] INITIALIZATION, SHUTDOWN
        .           //-----------------------------------------------------------------------------
        .           
        .           // Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
        .           // Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
        .           ImGuiContext* ImGui::GetCurrentContext()
    8,456 ( 0.00%)  {
    4,228 ( 0.00%)      return GImGui;
    8,456 ( 0.00%)  }
        .           
        .           void ImGui::SetCurrentContext(ImGuiContext* ctx)
        6 ( 0.00%)  {
        .           #ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
        .               IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
        .           #else
        4 ( 0.00%)      GImGui = ctx;
        .           #endif
        6 ( 0.00%)  }
        .           
        .           void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)
        .           {
        .               GImAllocatorAllocFunc = alloc_func;
        .               GImAllocatorFreeFunc = free_func;
        .               GImAllocatorUserData = user_data;
        .           }
        .           
-- line 3633 ----------------------------------------
-- line 3635 ----------------------------------------
        .           void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)
        .           {
        .               *p_alloc_func = GImAllocatorAllocFunc;
        .               *p_free_func = GImAllocatorFreeFunc;
        .               *p_user_data = GImAllocatorUserData;
        .           }
        .           
        .           ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
        8 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext* prev_ctx = GetCurrentContext();
        5 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetCurrentContext() (1x)
       13 ( 0.00%)      ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
   63,046 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiContext::ImGuiContext(ImFontAtlas*) (1x)
      790 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        3 ( 0.00%)      SetCurrentContext(ctx);
        8 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetCurrentContext(ImGuiContext*) (1x)
        1 ( 0.00%)      Initialize();
   49,695 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Initialize() (1x)
        2 ( 0.00%)      if (prev_ctx != NULL)
        .                   SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
        2 ( 0.00%)      return ctx;
        7 ( 0.00%)  }
        .           
        .           void ImGui::DestroyContext(ImGuiContext* ctx)
        .           {
        .               ImGuiContext* prev_ctx = GetCurrentContext();
        .               if (ctx == NULL) //-V1051
        .                   ctx = prev_ctx;
        .               SetCurrentContext(ctx);
        .               Shutdown();
-- line 3659 ----------------------------------------
-- line 3673 ----------------------------------------
        .               { ImGuiLocKey_WindowingPopup,       "(Popup)"                               },
        .               { ImGuiLocKey_WindowingUntitled,    "(Untitled)"                            },
        .               { ImGuiLocKey_DockingHideTabBar,    "Hide tab bar###HideTabBar"             },
        .               { ImGuiLocKey_DockingHoldShiftToDock,       "Hold SHIFT to enable Docking window."  },
        .               { ImGuiLocKey_DockingDragToUndockOrMoveNode,"Click and drag to move or undock whole node."    },
        .           };
        .           
        .           void ImGui::Initialize()
        7 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
       10 ( 0.00%)      IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
        .           
        .               // Add .ini handle for ImGuiWindow and ImGuiTable types
        .               {
        3 ( 0.00%)          ImGuiSettingsHandler ini_handler;
       32 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiSettingsHandler::ImGuiSettingsHandler() (1x)
        1 ( 0.00%)          ini_handler.TypeName = "Window";
        5 ( 0.00%)          ini_handler.TypeHash = ImHashStr("Window");
      168 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (1x)
        1 ( 0.00%)          ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
        1 ( 0.00%)          ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
        1 ( 0.00%)          ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
        1 ( 0.00%)          ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
        1 ( 0.00%)          ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
        3 ( 0.00%)          AddSettingsHandler(&ini_handler);
      476 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::AddSettingsHandler(ImGuiSettingsHandler const*) (1x)
        .               }
        1 ( 0.00%)      TableSettingsAddSettingsHandler();
      483 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_tables.cpp:ImGui::TableSettingsAddSettingsHandler() (1x)
        .           
        .               // Setup default localization table
        3 ( 0.00%)      LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
      257 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LocalizeRegisterEntries(ImGuiLocEntry const*, int) (1x)
        .           
        .               // Setup default platform clipboard/IME handlers.
        2 ( 0.00%)      g.IO.GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations
        2 ( 0.00%)      g.IO.SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
        3 ( 0.00%)      g.IO.ClipboardUserData = (void*)&g;                          // Default implementation use the ImGuiContext as user data (ideally those would be arguments to the function)
        2 ( 0.00%)      g.IO.SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;
        .           
        .               // Create default viewport
       11 ( 0.00%)      ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
      509 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::ImGuiViewportP() (1x)
      425 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        2 ( 0.00%)      viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
        2 ( 0.00%)      viewport->Idx = 0;
        2 ( 0.00%)      viewport->PlatformWindowCreated = true;
        2 ( 0.00%)      viewport->Flags = ImGuiViewportFlags_OwnedByApp;
        6 ( 0.00%)      g.Viewports.push_back(viewport);
      353 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::push_back(ImGuiViewportP* const&) (1x)
        8 ( 0.00%)      g.TempBuffer.resize(1024 * 3 + 1, 0);
   37,331 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<char>::resize(int, char const&) (1x)
        5 ( 0.00%)      g.ViewportCreatedCount++;
       13 ( 0.00%)      g.PlatformIO.Viewports.push_back(g.Viewports[0]);
      457 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewport*>::push_back(ImGuiViewport* const&) (1x)
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (1x)
        .           
        .               // Build KeysMayBeCharInput[] lookup table (1 bool per named key)
      466 ( 0.00%)      for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
    1,440 ( 0.00%)          if ((key >= ImGuiKey_0 && key <= ImGuiKey_9) || (key >= ImGuiKey_A && key <= ImGuiKey_Z) || (key >= ImGuiKey_Keypad0 && key <= ImGuiKey_Keypad9)
    1,266 ( 0.00%)              || key == ImGuiKey_Tab || key == ImGuiKey_Space || key == ImGuiKey_Apostrophe || key == ImGuiKey_Comma || key == ImGuiKey_Minus || key == ImGuiKey_Period
    1,194 ( 0.00%)              || key == ImGuiKey_Slash || key == ImGuiKey_Semicolon || key == ImGuiKey_Equal || key == ImGuiKey_LeftBracket || key == ImGuiKey_RightBracket || key == ImGuiKey_GraveAccent
    1,122 ( 0.00%)              || key == ImGuiKey_KeypadDecimal || key == ImGuiKey_KeypadDivide || key == ImGuiKey_KeypadMultiply || key == ImGuiKey_KeypadSubtract || key == ImGuiKey_KeypadAdd || key == ImGuiKey_KeypadEqual)
      384 ( 0.00%)              g.KeysMayBeCharInput.SetBit(key);
    2,880 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitArray<154, -512>::SetBit(int) (64x)
        .           
        .           #ifdef IMGUI_HAS_DOCK
        .               // Initialize Docking
        3 ( 0.00%)      DockContextInitialize(&g);
      313 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextInitialize(ImGuiContext*) (1x)
        .           #endif
        .           
        2 ( 0.00%)      g.Initialized = true;
        8 ( 0.00%)  }
        .           
        .           // This function is merely here to free heap allocations.
        .           void ImGui::Shutdown()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == NULL, "Forgot to shutdown Platform backend?");
        .               IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == NULL, "Forgot to shutdown Renderer backend?");
        .           
-- line 3741 ----------------------------------------
-- line 3839 ----------------------------------------
        .               for (ImGuiContextHook& hook : g.Hooks)
        .                   if (hook.HookId == hook_id)
        .                       hook.Type = ImGuiContextHookType_PendingRemoval_;
        .           }
        .           
        .           // Call context hooks (used by e.g. test engine)
        .           // We assume a small number of hooks so all stored in same array
        .           void ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)
   12,090 ( 0.00%)  {
    4,836 ( 0.00%)      ImGuiContext& g = *ctx;
   36,270 ( 0.00%)      for (ImGuiContextHook& hook : g.Hooks)
   29,016 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiContextHook>::end() (2,418x)
   16,926 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiContextHook>::begin() (2,418x)
        .                   if (hook.Type == hook_type)
        .                       hook.Callback(&g, &hook);
    9,672 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
        .           //-----------------------------------------------------------------------------
        .           
        .           // ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
      864 ( 0.00%)  ImGuiWindow::ImGuiWindow(ImGuiContext* ctx, const char* name) : DrawListInst(NULL)
    2,304 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect() (48x)
    1,626 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindowTempData::ImGuiWindowTempData() (6x)
    1,368 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::ImDrawList(ImDrawListSharedData*) (6x)
    1,152 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (96x)
      174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiWindowClass::ImGuiWindowClass() (6x)
      144 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiStorage::ImGuiStorage() (6x)
      120 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImVec2ih::ImVec2ih() (12x)
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::ImVector() (6x)
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiOldColumns>::ImVector() (6x)
        .           {
       36 ( 0.00%)      memset(this, 0, sizeof(*this));
      496 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6x)
       18 ( 0.00%)      Ctx = ctx;
       30 ( 0.00%)      Name = ImStrdup(name);
    1,010 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImStrdup(char const*) (6x)
       42 ( 0.00%)      NameBufLen = (int)strlen(name) + 1;
       84 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (6x)
       42 ( 0.00%)      ID = ImHashStr(name);
    2,461 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (6x)
       42 ( 0.00%)      IDStack.push_back(ID);
    1,317 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::push_back(unsigned int const&) (6x)
       12 ( 0.00%)      ViewportAllowPlatformMonitorExtend = -1;
       54 ( 0.00%)      ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       42 ( 0.00%)      MoveId = GetID("#MOVE");
    1,182 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (6x)
       42 ( 0.00%)      TabId = GetID("#TAB");
    1,038 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (6x)
       54 ( 0.00%)      ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       54 ( 0.00%)      ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       36 ( 0.00%)      AutoFitFramesX = AutoFitFramesY = -1;
       12 ( 0.00%)      AutoPosLastDirection = ImGuiDir_None;
       72 ( 0.00%)      SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = 0;
       84 ( 0.00%)      SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       12 ( 0.00%)      LastFrameActive = -1;
       12 ( 0.00%)      LastFrameJustFocused = -1;
       18 ( 0.00%)      LastTimeActive = -1.0f;
       42 ( 0.00%)      FontWindowScale = FontDpiScale = 1.0f;
       12 ( 0.00%)      SettingsOffset = -1;
       12 ( 0.00%)      DockOrder = -1;
       24 ( 0.00%)      DrawList = &DrawListInst;
       36 ( 0.00%)      DrawList->_Data = &Ctx->DrawListSharedData;
       30 ( 0.00%)      DrawList->_OwnerName = Name;
       84 ( 0.00%)      NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       42 ( 0.00%)      IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
      174 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiWindowClass::ImGuiWindowClass() (6x)
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (6x)
       36 ( 0.00%)  }
        .           
        .           ImGuiWindow::~ImGuiWindow()
        .           {
        .               IM_ASSERT(DrawList == &DrawListInst);
        .               IM_DELETE(Name);
        .               ColumnsStorage.clear_destruct();
        .           }
        .           
        .           static void SetCurrentWindow(ImGuiWindow* window)
   16,128 ( 0.00%)  {
    8,064 ( 0.00%)      ImGuiContext& g = *GImGui;
   12,096 ( 0.00%)      g.CurrentWindow = window;
   34,676 ( 0.00%)      g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
    8,064 ( 0.00%)      if (window)
        .               {
   36,290 ( 0.00%)          g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
   87,092 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::CalcFontSize() const (3,629x)
    3,629 ( 0.00%)          ImGui::NavUpdateCurrentWindowIsScrollPushableX();
   79,838 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateCurrentWindowIsScrollPushableX() (3,629x)
        .               }
   12,096 ( 0.00%)  }
        .           
        .           void ImGui::GcCompactTransientMiscBuffers()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.ItemFlagsStack.clear();
        .               g.GroupStack.clear();
        .               TableGcCompactSettings();
        .           }
        .           
        .           // Free up/compact internal window buffers, we can use this when a window becomes unused.
        .           // Not freed:
        .           // - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
        .           // This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
        .           void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)
        4 ( 0.00%)  {
        2 ( 0.00%)      window->MemoryCompacted = true;
        5 ( 0.00%)      window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
        5 ( 0.00%)      window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
        4 ( 0.00%)      window->IDStack.clear();
      248 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::clear() (1x)
        4 ( 0.00%)      window->DrawList->_ClearFreeMemory();
    1,438 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_ClearFreeMemory() (1x)
        4 ( 0.00%)      window->DC.ChildWindows.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::clear() (1x)
        4 ( 0.00%)      window->DC.ItemWidthStack.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::clear() (1x)
        4 ( 0.00%)      window->DC.TextWrapPosStack.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::clear() (1x)
        3 ( 0.00%)  }
        .           
        .           void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)
        .           {
        .               // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
        .               // The other buffers tends to amortize much faster.
        .               window->MemoryCompacted = false;
        .               window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
        .               window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
        .               window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
        .           }
        .           
        .           void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
       20 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Clear previous active id
       16 ( 0.00%)      if (g.ActiveId != 0)
        .               {
        .                   // While most behaved code would make an effort to not steal active id during window move/drag operations,
        .                   // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
        .                   // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
        8 ( 0.00%)          if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
        .                   {
        .                       IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
        .                       g.MovingWindow = NULL;
        .                   }
        .           
        .                   // This could be written in a more general way (e.g associate a hook to ActiveId),
        .                   // but since this is currently quite an exception we'll leave it as is.
        .                   // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveId()
       12 ( 0.00%)          if (g.InputTextState.ID == g.ActiveId)
        .                       InputTextDeactivateHook(g.ActiveId);
        .               }
        .           
        .               // Set active id
       24 ( 0.00%)      g.ActiveIdIsJustActivated = (g.ActiveId != id);
       16 ( 0.00%)      if (g.ActiveIdIsJustActivated)
        .               {
       20 ( 0.00%)          IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
       12 ( 0.00%)          g.ActiveIdTimer = 0.0f;
        8 ( 0.00%)          g.ActiveIdHasBeenPressedBefore = false;
        8 ( 0.00%)          g.ActiveIdHasBeenEditedBefore = false;
        8 ( 0.00%)          g.ActiveIdMouseButton = -1;
        8 ( 0.00%)          if (id != 0)
        .                   {
        6 ( 0.00%)              g.LastActiveId = id;
        6 ( 0.00%)              g.LastActiveIdTimer = 0.0f;
        .                   }
        .               }
       12 ( 0.00%)      g.ActiveId = id;
        8 ( 0.00%)      g.ActiveIdAllowOverlap = false;
        8 ( 0.00%)      g.ActiveIdNoClearOnFocusLoss = false;
       12 ( 0.00%)      g.ActiveIdWindow = window;
        8 ( 0.00%)      g.ActiveIdHasBeenEditedThisFrame = false;
        8 ( 0.00%)      g.ActiveIdFromShortcut = false;
        8 ( 0.00%)      if (id)
        .               {
        6 ( 0.00%)          g.ActiveIdIsAlive = id;
       22 ( 0.00%)          g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
        8 ( 0.00%)          IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);
        .               }
        .           
        .               // Clear declaration of inputs claimed by the widget
        .               // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
        8 ( 0.00%)      g.ActiveIdUsingNavDirMask = 0x00;
        8 ( 0.00%)      g.ActiveIdUsingAllKeyboardKeys = false;
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        8 ( 0.00%)      g.ActiveIdUsingNavInputMask = 0x00;
        .           #endif
       12 ( 0.00%)  }
        .           
        .           void ImGui::ClearActiveID()
        4 ( 0.00%)  {
        6 ( 0.00%)      SetActiveID(0, NULL); // g.ActiveId = 0;
      144 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetActiveID(unsigned int, ImGuiWindow*) (2x)
        6 ( 0.00%)  }
        .           
        .           void ImGui::SetHoveredID(ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.HoveredId = id;
        .               g.HoveredIdAllowOverlap = false;
        .               if (id != 0 && g.HoveredIdPreviousFrame != id)
        .                   g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
-- line 4015 ----------------------------------------
-- line 4186 ----------------------------------------
        .           
        .           // Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
        .           // (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
        .           // FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
        .           // If you used this in your legacy/custom widgets code:
        .           // - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.InFlags'.
        .           // - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
        .           bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id, ImGuiItemFlags item_flags)
   16,938 ( 0.00%)  {
    5,646 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,469 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
   11,292 ( 0.00%)      if (g.HoveredWindow != window)
    5,646 ( 0.00%)          return false;
        .               if (!IsMouseHoveringRect(bb.Min, bb.Max))
        .                   return false;
        .           
        .               if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        .                   return false;
        .               if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        .                   if (!g.ActiveIdFromShortcut)
        .                       return false;
-- line 4206 ----------------------------------------
-- line 4255 ----------------------------------------
        .                       IM_DEBUG_BREAK();
        .               }
        .           #endif
        .           
        .               if (g.NavDisableMouseHover)
        .                   return false;
        .           
        .               return true;
    5,646 ( 0.00%)  }
        .           
        .           // FIXME: This is inlined/duplicated in ItemAdd()
        .           // FIXME: The id != 0 path is not used by our codebase, may get rid of it?
        .           bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               if (!bb.Overlaps(window->ClipRect))
-- line 4271 ----------------------------------------
-- line 4273 ----------------------------------------
        .                       if (!g.LogEnabled)
        .                           return true;
        .               return false;
        .           }
        .           
        .           // This is also inlined in ItemAdd()
        .           // Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
        .           void ImGui::SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)
   12,096 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,048 ( 0.00%)      g.LastItemData.ID = item_id;
    6,048 ( 0.00%)      g.LastItemData.InFlags = in_flags;
    6,048 ( 0.00%)      g.LastItemData.StatusFlags = item_flags;
   26,208 ( 0.00%)      g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
    6,048 ( 0.00%)  }
        .           
        .           float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
        .           {
        .               if (wrap_pos_x < 0.0f)
        .                   return 0.0f;
        .           
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
-- line 4295 ----------------------------------------
-- line 4307 ----------------------------------------
        .                   wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space
        .               }
        .           
        .               return ImMax(wrap_pos_x - pos.x, 1.0f);
        .           }
        .           
        .           // IM_ALLOC() == ImGui::MemAlloc()
        .           void* ImGui::MemAlloc(size_t size)
   18,504 ( 0.00%)  {
   32,382 ( 0.00%)      void* ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
1,021,547 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:MallocWrapper(unsigned long, void*) (4,626x)
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
   18,504 ( 0.00%)      if (ImGuiContext* ctx = GImGui)
   36,992 ( 0.00%)          DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
  166,844 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DebugAllocHook(ImGuiDebugAllocInfo*, int, void*, unsigned long) (4,624x)
        .           #endif
    4,626 ( 0.00%)      return ptr;
    9,252 ( 0.00%)  }
        .           
        .           // IM_FREE() == ImGui::MemFree()
        .           void ImGui::MemFree(void* ptr)
   18,204 ( 0.00%)  {
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    9,102 ( 0.00%)      if (ptr != NULL)
   18,152 ( 0.00%)          if (ImGuiContext* ctx = GImGui)
   36,304 ( 0.00%)              DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
  158,906 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DebugAllocHook(ImGuiDebugAllocInfo*, int, void*, unsigned long) (4,538x)
        .           #endif
   31,857 ( 0.00%)      return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
  680,887 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FreeWrapper(void*, void*) (4,551x)
    9,102 ( 0.00%)  }
        .           
        .           // We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
        .           void ImGui::DebugAllocHook(ImGuiDebugAllocInfo* info, int frame_count, void* ptr, size_t size)
   54,972 ( 0.00%)  {
   82,458 ( 0.00%)      ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[info->LastEntriesIdx];
        .               IM_UNUSED(ptr);
   36,648 ( 0.00%)      if (entry->FrameCount != frame_count)
        .               {
      240 ( 0.00%)          info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);
      108 ( 0.00%)          entry = &info->LastEntriesBuf[info->LastEntriesIdx];
       36 ( 0.00%)          entry->FrameCount = frame_count;
       72 ( 0.00%)          entry->AllocCount = entry->FreeCount = 0;
        .               }
   18,324 ( 0.00%)      if (size != (size_t)-1)
        .               {
   27,744 ( 0.00%)          entry->AllocCount++;
   23,120 ( 0.00%)          info->TotalAllocCount++;
        .                   //printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
        .               }
        .               else
        .               {
   27,228 ( 0.00%)          entry->FreeCount++;
   22,690 ( 0.00%)          info->TotalFreeCount++;
        .                   //printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
        .               }
   32,110 ( 0.00%)  }
        .           
        .           const char* ImGui::GetClipboardText()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData) : "";
        .           }
        .           
        .           void ImGui::SetClipboardText(const char* text)
-- line 4367 ----------------------------------------
-- line 4372 ----------------------------------------
        .           }
        .           
        .           const char* ImGui::GetVersion()
        .           {
        .               return IMGUI_VERSION;
        .           }
        .           
        .           ImGuiIO& ImGui::GetIO()
   31,246 ( 0.00%)  {
   46,869 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
   31,246 ( 0.00%)      return GImGui->IO;
   31,246 ( 0.00%)  }
        .           
        .           ImGuiPlatformIO& ImGui::GetPlatformIO()
      812 ( 0.00%)  {
    1,218 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
      812 ( 0.00%)      return GImGui->PlatformIO;
      812 ( 0.00%)  }
        .           
        .           // Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
        .           ImDrawData* ImGui::GetDrawData()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,821 ( 0.00%)      ImGuiViewportP* viewport = g.Viewports[0];
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (403x)
    2,821 ( 0.00%)      return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
      806 ( 0.00%)  }
        .           
        .           double ImGui::GetTime()
        .           {
        .               return GImGui->Time;
        .           }
        .           
        .           int ImGui::GetFrameCount()
       10 ( 0.00%)  {
       10 ( 0.00%)      return GImGui->FrameCount;
       10 ( 0.00%)  }
        .           
        .           static ImDrawList* GetViewportBgFgDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)
        .           {
        .               // Create the draw list on demand, because they are not frequently used for all viewports
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport->BgFgDrawLists));
        .               ImDrawList* draw_list = viewport->BgFgDrawLists[drawlist_no];
        .               if (draw_list == NULL)
-- line 4415 ----------------------------------------
-- line 4453 ----------------------------------------
        .           }
        .           
        .           ImDrawListSharedData* ImGui::GetDrawListSharedData()
        .           {
        .               return &GImGui->DrawListSharedData;
        .           }
        .           
        .           void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
       10 ( 0.00%)  {
        .               // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
        .               // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
        .               // This is because we want ActiveId to be set even when the window is not permitted to move.
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
        8 ( 0.00%)      FocusWindow(window);
      658 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FocusWindow(ImGuiWindow*, int) (2x)
       12 ( 0.00%)      SetActiveID(window->MoveId, window);
      172 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetActiveID(unsigned int, ImGuiWindow*) (2x)
        4 ( 0.00%)      g.NavDisableHighlight = true;
       22 ( 0.00%)      g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (2x)
        4 ( 0.00%)      g.ActiveIdNoClearOnFocusLoss = true;
        2 ( 0.00%)      SetActiveIdUsingAllKeyboardKeys();
      110 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetActiveIdUsingAllKeyboardKeys() (2x)
        .           
        2 ( 0.00%)      bool can_move_window = true;
       10 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
        2 ( 0.00%)          can_move_window = false;
       10 ( 0.00%)      if (ImGuiDockNode* node = window->DockNodeAsHost)
        .                   if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
        .                       can_move_window = false;
        4 ( 0.00%)      if (can_move_window)
        .                   g.MovingWindow = window;
        8 ( 0.00%)  }
        .           
        .           // We use 'undock == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
        .           void ImGui::StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undock)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               bool can_undock_node = false;
        .               if (undock && node != NULL && node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove) == 0 && (node->MergedFlags & ImGuiDockNodeFlags_NoUndocking) == 0)
        .               {
-- line 4489 ----------------------------------------
-- line 4504 ----------------------------------------
        .           }
        .           
        .           // Handle mouse moving window
        .           // Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
        .           // FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
        .           // This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
        .           // but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
        .           void ImGui::UpdateMouseMovingWindowNewFrame()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,612 ( 0.00%)      if (g.MovingWindow != NULL)
        .               {
        .                   // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        .                   // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        .                   KeepAliveID(g.ActiveId);
        .                   IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
        .                   ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
        .           
        .                   // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
-- line 4522 ----------------------------------------
-- line 4555 ----------------------------------------
        .           
        .                       g.MovingWindow = NULL;
        .                       ClearActiveID();
        .                   }
        .               }
        .               else
        .               {
        .                   // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
    1,647 ( 0.00%)          if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        .                   {
       20 ( 0.00%)              KeepAliveID(g.ActiveId);
      105 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::KeepAliveID(unsigned int) (5x)
       25 ( 0.00%)              if (!g.IO.MouseDown[0])
        2 ( 0.00%)                  ClearActiveID();
      160 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ClearActiveID() (2x)
        .                   }
        .               }
    1,209 ( 0.00%)  }
        .           
        .           // Initiate moving window when clicking on empty space or title bar.
        .           // Handle left-click and right-click focus.
        .           void ImGui::UpdateMouseMovingWindowEndFrame()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,212 ( 0.00%)      if (g.ActiveId != 0 || g.HoveredId != 0)
        6 ( 0.00%)          return;
        .           
        .               // Unless we just made a window/popup appear
    3,600 ( 0.00%)      if (g.NavWindow && g.NavWindow->Appearing)
        1 ( 0.00%)          return;
        .           
        .               // Click on empty space to focus window and start moving
        .               // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
    1,596 ( 0.00%)      if (g.IO.MouseClicked[0])
        .               {
        .                   // Handle the edge case of a popup being closed while clicking in its empty space.
        .                   // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
       18 ( 0.00%)          ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
       18 ( 0.00%)          const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
        .           
       12 ( 0.00%)          if (root_window != NULL && !is_closed_popup)
        .                   {
        8 ( 0.00%)              StartMouseMovingWindow(g.HoveredWindow); //-V595
    1,120 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::StartMouseMovingWindow(ImGuiWindow*) (2x)
        .           
        .                       // Cancel moving if clicked outside of title bar
        8 ( 0.00%)              if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
        .                           if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
        .                               if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
        .                                   g.MovingWindow = NULL;
        .           
        .                       // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
        8 ( 0.00%)              if (g.HoveredIdDisabled)
        .                           g.MovingWindow = NULL;
        .                   }
        .                   else if (root_window == NULL && g.NavWindow != NULL)
        .                   {
        .                       // Clicking on void disable focus
        .                       FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);
        .                   }
        .               }
        .           
        .               // With right mouse button we close popups without changing focus based on where the mouse is aimed
        .               // Instead, focus will be restored to the window under the bottom-most closed popup.
        .               // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
    1,596 ( 0.00%)      if (g.IO.MouseClicked[1])
        .               {
        .                   // Find the top-most window between HoveredWindow and the top-most Modal Window.
        .                   // This is where we can trim the popup stack.
        .                   ImGuiWindow* modal = GetTopMostPopupModal();
        .                   bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
        .                   ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
        .               }
      806 ( 0.00%)  }
        .           
        .           // This is called during NewFrame()->UpdateViewportsNewFrame() only.
        .           // Need to keep in sync with SetWindowPos()
        .           static void TranslateWindow(ImGuiWindow* window, const ImVec2& delta)
       25 ( 0.00%)  {
       30 ( 0.00%)      window->Pos += delta;
      105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (5x)
       30 ( 0.00%)      window->ClipRect.Translate(delta);
      175 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Translate(ImVec2 const&) (5x)
       30 ( 0.00%)      window->OuterRectClipped.Translate(delta);
      175 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Translate(ImVec2 const&) (5x)
       30 ( 0.00%)      window->InnerRect.Translate(delta);
      175 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Translate(ImVec2 const&) (5x)
       30 ( 0.00%)      window->DC.CursorPos += delta;
      105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (5x)
       30 ( 0.00%)      window->DC.CursorStartPos += delta;
      105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (5x)
       30 ( 0.00%)      window->DC.CursorMaxPos += delta;
      105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (5x)
       30 ( 0.00%)      window->DC.IdealMaxPos += delta;
      105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (5x)
       15 ( 0.00%)  }
        .           
        .           static void ScaleWindow(ImGuiWindow* window, float scale)
        .           {
        .               ImVec2 origin = window->Viewport->Pos;
        .               window->Pos = ImFloor((window->Pos - origin) * scale + origin);
        .               window->Size = ImTrunc(window->Size * scale);
        .               window->SizeFull = ImTrunc(window->SizeFull * scale);
        .               window->ContentSize = ImTrunc(window->ContentSize * scale);
        .           }
        .           
        .           static bool IsWindowActiveAndVisible(ImGuiWindow* window)
    9,684 ( 0.00%)  {
   30,661 ( 0.00%)      return (window->Active) && (!window->Hidden);
    6,456 ( 0.00%)  }
        .           
        .           // The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
        .           void ImGui::UpdateHoveredWindowAndCaptureFlags()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
    6,045 ( 0.00%)      g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
   17,732 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImMax(ImVec2 const&, ImVec2 const&) (403x)
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (403x)
        .           
        .               // Find the window hovered by mouse:
        .               // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
        .               // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
        .               // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
      403 ( 0.00%)      bool clear_hovered_windows = false;
      403 ( 0.00%)      FindHoveredWindow();
  159,855 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FindHoveredWindow() (403x)
    3,796 ( 0.00%)      IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
        .           
        .               // Modal windows prevents mouse from hovering behind them.
      806 ( 0.00%)      ImGuiWindow* modal_window = GetTopMostPopupModal();
    5,642 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetTopMostPopupModal() (403x)
    2,015 ( 0.00%)      if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
        .                   clear_hovered_windows = true;
        .           
        .               // Disabled mouse?
    2,015 ( 0.00%)      if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
        .                   clear_hovered_windows = true;
        .           
        .               // We track click ownership. When clicked outside of a window the click is owned by the application and
        .               // won't report hovering nor request capture even while dragging over our windows afterward.
    2,015 ( 0.00%)      const bool has_open_popup = (g.OpenPopupStack.Size > 0);
    1,209 ( 0.00%)      const bool has_open_modal = (modal_window != NULL);
      403 ( 0.00%)      int mouse_earliest_down = -1;
      403 ( 0.00%)      bool mouse_any_down = false;
    7,657 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
        .               {
   12,090 ( 0.00%)          if (io.MouseClicked[i])
        .                   {
       20 ( 0.00%)              io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
       20 ( 0.00%)              io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
        .                   }
   18,135 ( 0.00%)          mouse_any_down |= io.MouseDown[i];
   12,090 ( 0.00%)          if (io.MouseDown[i])
       10 ( 0.00%)              if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
       10 ( 0.00%)                  mouse_earliest_down = i;
        .               }
    2,045 ( 0.00%)      const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
    2,045 ( 0.00%)      const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
        .           
        .               // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
        .               // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    2,418 ( 0.00%)      const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    1,612 ( 0.00%)      if (!mouse_avail && !mouse_dragging_extern_payload)
        .                   clear_hovered_windows = true;
        .           
      806 ( 0.00%)      if (clear_hovered_windows)
        .                   g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
        .           
        .               // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
        .               // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
    1,612 ( 0.00%)      if (g.WantCaptureMouseNextFrame != -1)
        .               {
        .                   io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
        .               }
        .               else
        .               {
    4,735 ( 0.00%)          io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
    4,735 ( 0.00%)          io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
        .               }
        .           
        .               // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
    3,622 ( 0.00%)      io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    1,612 ( 0.00%)      if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        .                   io.WantCaptureKeyboard = true;
    1,612 ( 0.00%)      if (g.WantCaptureKeyboardNextFrame != -1) // Manual override
        .                   io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
        .           
        .               // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    2,821 ( 0.00%)      io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
    1,612 ( 0.00%)  }
        .           
        .           // Calling SetupDrawListSharedData() is followed by SetCurrentFont() which sets up the remaining data.
        .           static void SetupDrawListSharedData()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,224 ( 0.00%)      ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    8,880 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (403x)
    4,860 ( 0.00%)          virtual_space.Add(viewport->GetMainRect());
   34,830 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (405x)
   19,013 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Add(ImRect const&) (405x)
    3,224 ( 0.00%)      g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
   19,344 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ToVec4() const (403x)
    1,612 ( 0.00%)      g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
    2,821 ( 0.00%)      g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
   15,161 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSharedData::SetCircleTessellationMaxError(float) (403x)
      806 ( 0.00%)      g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
    1,612 ( 0.00%)      if (g.Style.AntiAliasedLines)
    2,418 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
    4,030 ( 0.00%)      if (g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts->Flags & ImFontAtlasFlags_NoBakedLines))
    2,418 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
    1,612 ( 0.00%)      if (g.Style.AntiAliasedFill)
    2,418 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
    2,015 ( 0.00%)      if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
    2,418 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
    1,612 ( 0.00%)  }
        .           
        .           void ImGui::NewFrame()
    1,612 ( 0.00%)  {
    1,209 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Remove pending delete hooks before frame start.
        .               // This deferred removal avoid issues of removal while iterating the hook vector
    2,821 ( 0.00%)      for (int n = g.Hooks.Size - 1; n >= 0; n--)
        .                   if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
        .                       g.Hooks.erase(&g.Hooks[n]);
        .           
    1,612 ( 0.00%)      CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
   18,135 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CallContextHooks(ImGuiContext*, ImGuiContextHookType) (403x)
        .           
        .               // Check and assert for various common IO and Configuration mistakes
    1,612 ( 0.00%)      g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
      403 ( 0.00%)      ErrorCheckNewFrameSanityChecks();
1,320,639 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ErrorCheckNewFrameSanityChecks() (403x)
    1,612 ( 0.00%)      g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
        .           
        .               // Load settings on first frame, save settings when modified (after a delay)
      403 ( 0.00%)      UpdateSettings();
  109,035 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateSettings() (403x)
        .           
    3,224 ( 0.00%)      g.Time += g.IO.DeltaTime;
      806 ( 0.00%)      g.WithinFrameScope = true;
    2,015 ( 0.00%)      g.FrameCount += 1;
      806 ( 0.00%)      g.TooltipOverrideCount = 0;
      806 ( 0.00%)      g.WindowsActiveCount = 0;
    2,015 ( 0.00%)      g.MenusIdSubmittedThisFrame.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::resize(int) (403x)
        .           
        .               // Calculate frame-rate for the user, as a purely luxurious feature
    5,642 ( 0.00%)      g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    3,224 ( 0.00%)      g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    6,448 ( 0.00%)      g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    3,224 ( 0.00%)      g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
    4,089 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:int ImMin<int>(int, int) (403x)
    6,448 ( 0.00%)      g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
        .           
        .               // Process input queue (trickle as many events as possible), turn events into writes to IO structure
    2,015 ( 0.00%)      g.InputEventsTrail.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::resize(int) (403x)
    2,015 ( 0.00%)      UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
  452,916 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateInputEvents(bool) (403x)
        .           
        .               // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
      403 ( 0.00%)      UpdateViewportsNewFrame();
  726,912 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateViewportsNewFrame() (403x)
        .           
        .               // Setup current font and draw list shared data
        .               // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
    1,209 ( 0.00%)      g.IO.Fonts->Locked = true;
      403 ( 0.00%)      SetupDrawListSharedData();
  144,403 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetupDrawListSharedData() (403x)
    1,209 ( 0.00%)      SetCurrentFont(GetDefaultFont());
   35,061 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetCurrentFont(ImFont*) (403x)
   14,911 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetDefaultFont() (403x)
    2,418 ( 0.00%)      IM_ASSERT(g.Font->IsLoaded());
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFont::IsLoaded() const (403x)
        .           
        .               // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    8,880 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (403x)
        .               {
      810 ( 0.00%)          viewport->DrawData = NULL;
      810 ( 0.00%)          viewport->DrawDataP.Valid = false;
        .               }
        .           
        .               // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    1,612 ( 0.00%)      if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        .                   KeepAliveID(g.DragDropPayload.SourceId);
        .           
        .               // Update HoveredId data
    1,612 ( 0.00%)      if (!g.HoveredIdPreviousFrame)
    1,209 ( 0.00%)          g.HoveredIdTimer = 0.0f;
    1,612 ( 0.00%)      if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
    1,209 ( 0.00%)          g.HoveredIdNotActiveTimer = 0.0f;
    1,612 ( 0.00%)      if (g.HoveredId)
        .                   g.HoveredIdTimer += g.IO.DeltaTime;
    1,612 ( 0.00%)      if (g.HoveredId && g.ActiveId != g.HoveredId)
        .                   g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    1,612 ( 0.00%)      g.HoveredIdPreviousFrame = g.HoveredId;
      806 ( 0.00%)      g.HoveredId = 0;
      806 ( 0.00%)      g.HoveredIdAllowOverlap = false;
      806 ( 0.00%)      g.HoveredIdDisabled = false;
        .           
        .               // Clear ActiveID if the item is not alive anymore.
        .               // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
        .               // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
    1,642 ( 0.00%)      if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
        .               {
        .                   IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
        .                   ClearActiveID();
        .               }
        .           
        .               // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
    1,612 ( 0.00%)      if (g.ActiveId)
       35 ( 0.00%)          g.ActiveIdTimer += g.IO.DeltaTime;
    2,821 ( 0.00%)      g.LastActiveIdTimer += g.IO.DeltaTime;
    1,612 ( 0.00%)      g.ActiveIdPreviousFrame = g.ActiveId;
    1,612 ( 0.00%)      g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    1,612 ( 0.00%)      g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
      806 ( 0.00%)      g.ActiveIdIsAlive = 0;
      806 ( 0.00%)      g.ActiveIdHasBeenEditedThisFrame = false;
      806 ( 0.00%)      g.ActiveIdPreviousFrameIsAlive = false;
      806 ( 0.00%)      g.ActiveIdIsJustActivated = false;
    1,612 ( 0.00%)      if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
        .                   g.TempInputId = 0;
    1,612 ( 0.00%)      if (g.ActiveId == 0)
        .               {
      796 ( 0.00%)          g.ActiveIdUsingNavDirMask = 0x00;
      796 ( 0.00%)          g.ActiveIdUsingAllKeyboardKeys = false;
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
      796 ( 0.00%)          g.ActiveIdUsingNavInputMask = 0x00;
        .           #endif
        .               }
        .           
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    1,612 ( 0.00%)      if (g.ActiveId == 0)
    1,194 ( 0.00%)          g.ActiveIdUsingNavInputMask = 0;
       20 ( 0.00%)      else if (g.ActiveIdUsingNavInputMask != 0)
        .               {
        .                   // If your custom widget code used:                 { g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel); }
        .                   // Since IMGUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(ImGuiKey_Escape, g.ActiveId); SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId); }
        .                   if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
        .                       SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
        .                   if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
        .                       IM_ASSERT(0); // Other values unsupported
        .               }
        .           #endif
        .           
        .               // Record when we have been stationary as this state is preserved while over same item.
        .               // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
        .               // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
    1,612 ( 0.00%)      if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
        .                   g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
    1,612 ( 0.00%)      else if (g.HoverItemDelayId == 0)
      806 ( 0.00%)          g.HoverItemUnlockedStationaryId = 0;
    2,614 ( 0.00%)      if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
      894 ( 0.00%)          g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
    1,016 ( 0.00%)      else if (g.HoveredWindow == NULL)
      472 ( 0.00%)          g.HoverWindowUnlockedStationaryId = 0;
        .           
        .               // Update hover delay for IsItemHovered() with delays and tooltips
    1,612 ( 0.00%)      g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
    1,612 ( 0.00%)      if (g.HoverItemDelayId != 0)
        .               {
        .                   g.HoverItemDelayTimer += g.IO.DeltaTime;
        .                   g.HoverItemDelayClearTimer = 0.0f;
        .                   g.HoverItemDelayId = 0;
        .               }
    2,015 ( 0.00%)      else if (g.HoverItemDelayTimer > 0.0f)
        .               {
        .                   // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
        .                   // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
        .                   g.HoverItemDelayClearTimer += g.IO.DeltaTime;
        .                   if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate
        .                       g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
        .               }
        .           
        .               // Drag and drop
    1,612 ( 0.00%)      g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
      806 ( 0.00%)      g.DragDropAcceptIdCurr = 0;
    1,209 ( 0.00%)      g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
      806 ( 0.00%)      g.DragDropWithinSource = false;
      806 ( 0.00%)      g.DragDropWithinTarget = false;
      806 ( 0.00%)      g.DragDropHoldJustPressedId = 0;
        .           
        .               // Close popups on focus lost (currently wip/opt-in)
        .               //if (g.IO.AppFocusLost)
        .               //    ClosePopupsExceptModals();
        .           
        .               // Update keyboard input state
      403 ( 0.00%)      UpdateKeyboardInputs();
15,818,964 ( 0.01%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateKeyboardInputs() (403x)
        .           
        .               //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
        .               //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
        .               //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
        .               //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
        .           
        .               // Update gamepad/keyboard navigation
      403 ( 0.00%)      NavUpdate();
  837,506 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdate() (403x)
        .           
        .               // Update mouse input state
      403 ( 0.00%)      UpdateMouseInputs();
  275,592 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseInputs() (403x)
        .           
        .               // Undocking
        .               // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
    1,209 ( 0.00%)      DockContextNewFrameUpdateUndocking(&g);
   23,777 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextNewFrameUpdateUndocking(ImGuiContext*) (403x)
        .           
        .               // Find hovered window
        .               // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
      403 ( 0.00%)      UpdateHoveredWindowAndCaptureFlags();
  293,330 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateHoveredWindowAndCaptureFlags() (403x)
        .           
        .               // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
      403 ( 0.00%)      UpdateMouseMovingWindowNewFrame();
    6,795 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseMovingWindowNewFrame() (403x)
        .           
        .               // Background darkening/whitening
    4,030 ( 0.00%)      if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
    5,642 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetTopMostPopupModal() (403x)
        .                   g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
        .               else
    5,642 ( 0.00%)          g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (403x)
        .           
      806 ( 0.00%)      g.MouseCursor = ImGuiMouseCursor_Arrow;
    4,030 ( 0.00%)      g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
        .           
        .               // Platform IME data: reset for the frame
    2,418 ( 0.00%)      g.PlatformImeDataPrev = g.PlatformImeData;
      806 ( 0.00%)      g.PlatformImeData.WantVisible = false;
        .           
        .               // Mouse wheel scrolling, scale
      403 ( 0.00%)      UpdateMouseWheel();
  111,436 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseWheel() (403x)
        .           
        .               // Mark all windows as not visible and compact unused memory.
    2,418 ( 0.00%)      IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
    8,463 ( 0.00%)      const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
   22,929 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (403x)
        .               {
    9,648 ( 0.00%)          window->WasActive = window->Active;
    4,824 ( 0.00%)          window->Active = false;
    4,824 ( 0.00%)          window->WriteAccessed = false;
    9,648 ( 0.00%)          window->BeginCountPreviousFrame = window->BeginCount;
    4,824 ( 0.00%)          window->BeginCount = 0;
        .           
        .                   // Garbage collect transient buffers of recently unused windows
   18,915 ( 0.00%)          if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
        3 ( 0.00%)              GcCompactTransientWindowBuffers(window);
    1,758 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GcCompactTransientWindowBuffers(ImGuiWindow*) (1x)
        .               }
        .           
        .               // Garbage collect transient buffers of recently unused tables
    2,418 ( 0.00%)      for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
        .                   if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
        .                       TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
    6,045 ( 0.00%)      for (ImGuiTableTempData& table_temp_data : g.TablesTempData)
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiTableTempData>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiTableTempData>::begin() (403x)
        .                   if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)
        .                       TableGcCompactTransientBuffers(&table_temp_data);
    1,612 ( 0.00%)      if (g.GcCompactAll)
        .                   GcCompactTransientMiscBuffers();
      806 ( 0.00%)      g.GcCompactAll = false;
        .           
        .               // Closing the focused window restore focus to the first active root window in descending z-order
    4,024 ( 0.00%)      if (g.NavWindow && !g.NavWindow->WasActive)
        .                   FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);
        .           
        .               // No window should be open at the beginning of the frame.
        .               // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    2,015 ( 0.00%)      g.CurrentWindowStack.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::resize(int) (403x)
    2,015 ( 0.00%)      g.BeginPopupStack.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPopupData>::resize(int) (403x)
    2,015 ( 0.00%)      g.ItemFlagsStack.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::resize(int) (403x)
    2,821 ( 0.00%)      g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
   11,900 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<int>::push_back(int const&) (403x)
    2,015 ( 0.00%)      g.GroupStack.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiGroupData>::resize(int) (403x)
        .           
        .               // Docking
    1,209 ( 0.00%)      DockContextNewFrameUpdateDocking(&g);
   57,725 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextNewFrameUpdateDocking(ImGuiContext*) (403x)
        .           
        .               // [DEBUG] Update debug features
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
      403 ( 0.00%)      UpdateDebugToolItemPicker();
    7,254 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateDebugToolItemPicker() (403x)
      403 ( 0.00%)      UpdateDebugToolStackQueries();
    8,475 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateDebugToolStackQueries() (403x)
      403 ( 0.00%)      UpdateDebugToolFlashStyleColor();
    8,060 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateDebugToolFlashStyleColor() (403x)
    2,821 ( 0.00%)      if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
        .               {
        .                   g.DebugLocateId = 0;
        .                   g.DebugBreakInLocateId = false;
        .               }
    2,821 ( 0.00%)      if (g.DebugLogAutoDisableFrames > 0 && --g.DebugLogAutoDisableFrames == 0)
        .               {
        .                   DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n");
        .                   g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;
        .                   g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
        .               }
        .           #endif
        .           
        .               // Create implicit/fallback window - which we will only render it if the user has added something to it.
        .               // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
        .               // This fallback is particularly important as it prevents ImGui:: calls from crashing.
      806 ( 0.00%)      g.WithinFrameScopeWithImplicitWindow = true;
    4,030 ( 0.00%)      SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
   18,941 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNextWindowSize(ImVec2 const&, int) (403x)
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (403x)
    1,612 ( 0.00%)      Begin("Debug##Default");
7,233,900 ( 0.01%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Begin(char const*, bool*, int) (403x)
    2,015 ( 0.00%)      IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
        .           
        .               // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
        .               // allowing to validate correct Begin/End behavior in user code.
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    1,612 ( 0.00%)      if (g.IO.ConfigDebugBeginReturnValueLoop)
        .                   g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
        .               else
      806 ( 0.00%)          g.DebugBeginReturnValueCullDepth = -1;
        .           #endif
        .           
    1,612 ( 0.00%)      CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
   18,135 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CallContextHooks(ImGuiContext*, ImGuiContextHookType) (403x)
    1,612 ( 0.00%)  }
        .           
        .           // FIXME: Add a more explicit sort order in the window structure.
        .           static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
        .           {
        .               const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
        .               const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
        .               if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        .                   return d;
        .               if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        .                   return d;
        .               return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
        .           }
        .           
        .           static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
   12,090 ( 0.00%)  {
   12,090 ( 0.00%)      out_sorted_windows->push_back(window);
   46,748 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::push_back(ImGuiWindow* const&) (1,612x)
    9,672 ( 0.00%)      if (window->Active)
        .               {
    4,839 ( 0.00%)          int count = window->DC.ChildWindows.Size;
   12,904 ( 0.00%)          ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
    9,684 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImQsort(void*, unsigned long, unsigned long, int (*)(void const*, void const*)) (807x)
   11,289 ( 0.00%)          for (int i = 0; i < count; i++)
        .                   {
    6,448 ( 0.00%)              ImGuiWindow* child = window->DC.ChildWindows[i];
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (403x)
    3,224 ( 0.00%)              if (child->Active)
    4,030 ( 0.00%)                  AddWindowToSortBuffer(out_sorted_windows, child);
   75,764 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToSortBuffer(ImVector<ImGuiWindow*>*, ImGuiWindow*)'2 (403x)
        .                   }
        .               }
    7,254 ( 0.00%)  }
        .           
        .           static void AddWindowToDrawData(ImGuiWindow* window, int layer)
    8,055 ( 0.00%)  {
    3,222 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,833 ( 0.00%)      ImGuiViewportP* viewport = window->Viewport;
    3,222 ( 0.00%)      IM_ASSERT(viewport != NULL);
    8,055 ( 0.00%)      g.IO.MetricsRenderWindows++;
    8,055 ( 0.00%)      if (window->DrawList->_Splitter._Count > 1)
    1,612 ( 0.00%)          window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
  269,117 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::ChannelsMerge() (403x)
   19,332 ( 0.00%)      ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);
   78,357 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImGui::AddDrawListToDrawDataEx(ImDrawData*, ImVector<ImDrawList*>*, ImDrawList*) (806x)
   29,807 ( 0.00%)      for (ImGuiWindow* child : window->DC.ChildWindows)
    9,672 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (806x)
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (806x)
    4,030 ( 0.00%)          if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
    6,448 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:IsWindowActiveAndVisible(ImGuiWindow*) (403x)
    4,025 ( 0.00%)              AddWindowToDrawData(child, layer);
  405,642 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToDrawData(ImGuiWindow*, int)'2 (403x)
    6,444 ( 0.00%)  }
        .           
        .           static inline int GetWindowDisplayLayer(ImGuiWindow* window)
    2,418 ( 0.00%)  {
    3,224 ( 0.00%)      return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
    1,612 ( 0.00%)  }
        .           
        .           // Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
        .           static inline void AddRootWindowToDrawData(ImGuiWindow* window)
    3,224 ( 0.00%)  {
    6,448 ( 0.00%)      AddWindowToDrawData(window, GetWindowDisplayLayer(window));
  555,330 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToDrawData(ImGuiWindow*, int) (806x)
    7,254 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:GetWindowDisplayLayer(ImGuiWindow*) (806x)
    2,418 ( 0.00%)  }
        .           
        .           static void FlattenDrawDataIntoSingleLayer(ImDrawDataBuilder* builder)
    1,624 ( 0.00%)  {
    1,624 ( 0.00%)      int n = builder->Layers[0]->Size;
      812 ( 0.00%)      int full_size = n;
    2,842 ( 0.00%)      for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)
    2,436 ( 0.00%)          full_size += builder->Layers[i]->Size;
    2,436 ( 0.00%)      builder->Layers[0]->resize(full_size);
    6,090 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::resize(int) (406x)
    2,842 ( 0.00%)      for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++)
        .               {
    2,030 ( 0.00%)          ImVector<ImDrawList*>* layer = builder->Layers[layer_n];
    2,030 ( 0.00%)          if (layer->empty())
    3,654 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::empty() const (406x)
      406 ( 0.00%)              continue;
        .                   memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList*));
        .                   n += layer->Size;
        .                   layer->resize(0);
        .               }
    1,624 ( 0.00%)  }
        .           
        .           static void InitViewportDrawData(ImGuiViewportP* viewport)
    1,624 ( 0.00%)  {
      812 ( 0.00%)      ImGuiIO& io = ImGui::GetIO();
    3,654 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetIO() (406x)
    1,218 ( 0.00%)      ImDrawData* draw_data = &viewport->DrawDataP;
        .           
    1,218 ( 0.00%)      viewport->DrawData = draw_data; // Make publicly accessible
    1,624 ( 0.00%)      viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
    1,624 ( 0.00%)      viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
    2,030 ( 0.00%)      viewport->DrawDataBuilder.Layers[0]->resize(0);
    6,090 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::resize(int) (406x)
    2,030 ( 0.00%)      viewport->DrawDataBuilder.Layers[1]->resize(0);
    6,090 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::resize(int) (406x)
        .           
        .               // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
        .               // and to allow applications/backends to easily skip rendering.
        .               // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
        .               // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
        .               // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
    2,436 ( 0.00%)      const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0;
        .           
      812 ( 0.00%)      draw_data->Valid = true;
      812 ( 0.00%)      draw_data->CmdListsCount = 0;
    2,436 ( 0.00%)      draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    1,624 ( 0.00%)      draw_data->DisplayPos = viewport->Pos;
    3,248 ( 0.00%)      draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
    1,624 ( 0.00%)      draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
    1,218 ( 0.00%)      draw_data->OwnerViewport = viewport;
    1,218 ( 0.00%)  }
        .           
        .           // Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
        .           // - When using this function it is sane to ensure that float are perfectly rounded to integer values,
        .           //   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
        .           // - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
        .           //   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
        .           //   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
        .           void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
   28,224 ( 0.00%)  {
    8,064 ( 0.00%)      ImGuiWindow* window = GetCurrentWindow();
   48,384 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetCurrentWindow() (4,032x)
   28,224 ( 0.00%)      window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
  858,339 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PushClipRect(ImVec2 const&, ImVec2 const&, bool) (4,032x)
   60,480 ( 0.00%)      window->ClipRect = window->DrawList->_ClipRectStack.back();
  221,760 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec4 const&) (4,032x)
   72,576 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec4>::back() (4,032x)
   12,096 ( 0.00%)  }
        .           
        .           void ImGui::PopClipRect()
    6,048 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiWindow* window = GetCurrentWindow();
   24,192 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetCurrentWindow() (2,016x)
    8,064 ( 0.00%)      window->DrawList->PopClipRect();
  275,401 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PopClipRect() (2,016x)
   30,240 ( 0.00%)      window->ClipRect = window->DrawList->_ClipRectStack.back();
  110,880 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec4 const&) (2,016x)
   36,288 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImVec4>::back() (2,016x)
    6,048 ( 0.00%)  }
        .           
        .           static ImGuiWindow* FindFrontMostVisibleChildWindow(ImGuiWindow* window)
        .           {
        .               for (int n = window->DC.ChildWindows.Size - 1; n >= 0; n--)
        .                   if (IsWindowActiveAndVisible(window->DC.ChildWindows[n]))
        .                       return FindFrontMostVisibleChildWindow(window->DC.ChildWindows[n]);
        .               return window;
        .           }
-- line 5158 ----------------------------------------
-- line 5211 ----------------------------------------
        .                       bottom_most_visible_window = window;
        .               }
        .               return bottom_most_visible_window;
        .           }
        .           
        .           // Important: AddWindowToDrawData() has not been called yet, meaning DockNodeHost windows needs a DrawList->ChannelsMerge() before usage.
        .           // We call ChannelsMerge() lazily here at it is faster that doing a full iteration of g.Windows[] prior to calling RenderDimmedBackgrounds().
        .           static void ImGui::RenderDimmedBackgrounds()
    2,015 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
      806 ( 0.00%)      ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
    6,045 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetTopMostAndVisiblePopupModal() (403x)
    4,030 ( 0.00%)      if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
      806 ( 0.00%)          return;
        .               const bool dim_bg_for_modal = (modal_window != NULL);
        .               const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
        .               if (!dim_bg_for_modal && !dim_bg_for_window_list)
        .                   return;
        .           
        .               ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
        .               if (dim_bg_for_modal)
        .               {
-- line 5231 ----------------------------------------
-- line 5265 ----------------------------------------
        .                   if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])
        .                       continue;
        .                   if (modal_window && viewport->Window && IsWindowAbove(viewport->Window, modal_window))
        .                       continue;
        .                   ImDrawList* draw_list = GetForegroundDrawList(viewport);
        .                   const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
        .                   draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
        .               }
    2,015 ( 0.00%)  }
        .           
        .           // This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
        .           void ImGui::EndFrame()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,612 ( 0.00%)      IM_ASSERT(g.Initialized);
        .           
        .               // Don't process EndFrame() multiple times.
    2,418 ( 0.00%)      if (g.FrameCountEnded == g.FrameCount)
        .                   return;
    1,612 ( 0.00%)      IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
        .           
    1,612 ( 0.00%)      CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
   18,135 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CallContextHooks(ImGuiContext*, ImGuiContextHookType) (403x)
        .           
      403 ( 0.00%)      ErrorCheckEndFrameSanityChecks();
  186,589 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ErrorCheckEndFrameSanityChecks() (403x)
        .           
        .               // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    1,209 ( 0.00%)      ImGuiPlatformImeData* ime_data = &g.PlatformImeData;
    5,642 ( 0.00%)      if (g.IO.SetPlatformImeDataFn && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
    7,657 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (403x)
        .               {
        .                   ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
        .                   IMGUI_DEBUG_LOG_IO("[io] Calling io.SetPlatformImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
        .                   if (viewport == NULL)
        .                       viewport = GetMainViewport();
        .                   g.IO.SetPlatformImeDataFn(viewport, ime_data);
        .               }
        .           
        .               // Hide implicit/fallback "Debug" window if it hasn't been used
      806 ( 0.00%)      g.WithinFrameScopeWithImplicitWindow = false;
    4,030 ( 0.00%)      if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
    1,209 ( 0.00%)          g.CurrentWindow->Active = false;
      403 ( 0.00%)      End();
  233,337 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::End() (403x)
        .           
        .               // Update navigation: CTRL+Tab, wrap-around requests
      403 ( 0.00%)      NavEndFrame();
   13,299 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavEndFrame() (403x)
        .           
        .               // Update docking
    1,209 ( 0.00%)      DockContextEndFrame(&g);
   37,882 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextEndFrame(ImGuiContext*) (403x)
        .           
    1,209 ( 0.00%)      SetCurrentViewport(NULL, NULL);
   10,881 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetCurrentViewport(ImGuiWindow*, ImGuiViewportP*) (403x)
        .           
        .               // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    1,612 ( 0.00%)      if (g.DragDropActive)
        .               {
        .                   bool is_delivered = g.DragDropPayload.Delivery;
        .                   bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        .                   if (is_delivered || is_elapsed)
        .                       ClearDragDrop();
        .               }
        .           
        .               // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    1,612 ( 0.00%)      if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        .               {
        .                   g.DragDropWithinSource = true;
        .                   SetTooltip("...");
        .                   g.DragDropWithinSource = false;
        .               }
        .           
        .               // End frame
      806 ( 0.00%)      g.WithinFrameScope = false;
    1,612 ( 0.00%)      g.FrameCountEnded = g.FrameCount;
        .           
        .               // Initiate moving window + handle left-click and right-click focus
      403 ( 0.00%)      UpdateMouseMovingWindowEndFrame();
   14,024 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseMovingWindowEndFrame() (403x)
        .           
        .               // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
      403 ( 0.00%)      UpdateViewportsEndFrame();
   71,103 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateViewportsEndFrame() (403x)
        .           
        .               // Sort the window list so that all child windows are after their parent
        .               // We cannot do that on FocusWindow() because children may not exist yet
    2,015 ( 0.00%)      g.WindowsTempSortBuffer.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::resize(int) (403x)
    2,821 ( 0.00%)      g.WindowsTempSortBuffer.reserve(g.Windows.Size);
    4,970 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::reserve(int) (403x)
   22,971 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (403x)
        .               {
   17,737 ( 0.00%)          if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
      806 ( 0.00%)              continue;
   11,284 ( 0.00%)          AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
  188,632 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToSortBuffer(ImVector<ImGuiWindow*>*, ImGuiWindow*) (1,612x)
        .               }
        .           
        .               // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    2,418 ( 0.00%)      IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
    2,821 ( 0.00%)      g.Windows.swap(g.WindowsTempSortBuffer);
   14,911 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::swap(ImVector<ImGuiWindow*>&) (403x)
    1,612 ( 0.00%)      g.IO.MetricsActiveWindows = g.WindowsActiveCount;
        .           
        .               // Unlock font atlas
    1,209 ( 0.00%)      g.IO.Fonts->Locked = false;
        .           
        .               // Clear Input data for next frame
    1,612 ( 0.00%)      g.IO.MousePosPrev = g.IO.MousePos;
      806 ( 0.00%)      g.IO.AppFocusLost = false;
    2,821 ( 0.00%)      g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    2,015 ( 0.00%)      g.IO.InputQueueCharacters.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::resize(int) (403x)
        .           
    2,015 ( 0.00%)      CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
   18,135 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CallContextHooks(ImGuiContext*, ImGuiContextHookType) (403x)
      806 ( 0.00%)  }
        .           
        .           // Prepare the data for rendering so you can call GetDrawData()
        .           // (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
        .           // it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
        .           void ImGui::Render()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,612 ( 0.00%)      IM_ASSERT(g.Initialized);
        .           
    2,418 ( 0.00%)      if (g.FrameCountEnded != g.FrameCount)
      403 ( 0.00%)          EndFrame();
  947,311 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::EndFrame() (403x)
    2,418 ( 0.00%)      if (g.FrameCountRendered == g.FrameCount)
        .                   return;
    1,612 ( 0.00%)      g.FrameCountRendered = g.FrameCount;
        .           
      806 ( 0.00%)      g.IO.MetricsRenderWindows = 0;
    1,612 ( 0.00%)      CallContextHooks(&g, ImGuiContextHookType_RenderPre);
   18,135 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CallContextHooks(ImGuiContext*, ImGuiContextHookType) (403x)
        .           
        .               // Add background ImDrawList (for each active viewport)
    8,887 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (403x)
        .               {
    1,218 ( 0.00%)          InitViewportDrawData(viewport);
   43,442 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:InitViewportDrawData(ImGuiViewportP*) (406x)
    1,624 ( 0.00%)          if (viewport->BgFgDrawLists[0] != NULL)
        .                       AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
        .               }
        .           
        .               // Draw modal/window whitening backgrounds
      403 ( 0.00%)      RenderDimmedBackgrounds();
   16,523 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderDimmedBackgrounds() (403x)
        .           
        .               // Add ImDrawList to render
        .               ImGuiWindow* windows_to_render_top_most[2];
    2,418 ( 0.00%)      windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
    2,418 ( 0.00%)      windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
   22,971 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (403x)
        .               {
        .                   IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
   33,041 ( 0.00%)          if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
   33,856 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:IsWindowActiveAndVisible(ImGuiWindow*) (2,418x)
    2,418 ( 0.00%)              AddRootWindowToDrawData(window);
  574,674 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddRootWindowToDrawData(ImGuiWindow*) (806x)
        .               }
    4,030 ( 0.00%)      for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
    6,448 ( 0.00%)          if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
        .                       AddRootWindowToDrawData(windows_to_render_top_most[n]);
        .           
        .               // Draw software mouse cursor if requested by io.MouseDrawCursor flag
    1,612 ( 0.00%)      if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
        .                   RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
        .           
        .               // Setup ImDrawData structures for end-user
    2,418 ( 0.00%)      g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
    8,887 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (403x)
        .               {
    1,624 ( 0.00%)          FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);
   30,450 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FlattenDrawDataIntoSingleLayer(ImDrawDataBuilder*) (406x)
        .           
        .                   // Add foreground ImDrawList (for each active viewport)
    1,624 ( 0.00%)          if (viewport->BgFgDrawLists[1] != NULL)
        .                       AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
        .           
        .                   // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
    1,218 ( 0.00%)          ImDrawData* draw_data = &viewport->DrawDataP;
    2,436 ( 0.00%)          IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
    8,918 ( 0.00%)          for (ImDrawList* draw_list : draw_data->CmdLists)
    4,872 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::end() (406x)
    2,842 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::begin() (406x)
    1,212 ( 0.00%)              draw_list->_PopUnusedDrawCmd();
   28,641 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_PopUnusedDrawCmd() (404x)
        .           
    2,842 ( 0.00%)          g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
    2,842 ( 0.00%)          g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
        .               }
        .           
    2,015 ( 0.00%)      CallContextHooks(&g, ImGuiContextHookType_RenderPost);
   18,135 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CallContextHooks(ImGuiContext*, ImGuiContextHookType) (403x)
      806 ( 0.00%)  }
        .           
        .           // Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
        .           // CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
        .           ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
   41,920 ( 0.00%)  {
   10,480 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               const char* text_display_end;
   10,480 ( 0.00%)      if (hide_text_after_double_hash)
   36,680 ( 0.00%)          text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
  384,331 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindRenderedTextEnd(char const*, char const*) (5,240x)
        .               else
        .                   text_display_end = text_end;
        .           
   15,720 ( 0.00%)      ImFont* font = g.Font;
   15,720 ( 0.00%)      const float font_size = g.FontSize;
   15,720 ( 0.00%)      if (text == text_display_end)
   21,762 ( 0.00%)          return ImVec2(0.0f, font_size);
   33,852 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,418x)
   36,686 ( 0.00%)      ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
1,123,696 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImFont::CalcTextSizeA(float, float, float, char const*, char const*, char const**) const (2,822x)
        .           
        .               // Round
        .               // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
        .               // FIXME: Investigate using ceilf or e.g.
        .               // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
        .               // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
   16,932 ( 0.00%)      text_size.x = IM_TRUNC(text_size.x + 0.99999f);
        .           
    2,822 ( 0.00%)      return text_size;
   15,720 ( 0.00%)  }
        .           
        .           // Find window given position, search front-to-back
        .           // FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
        .           // with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
        .           // called, aka before the next Begin(). Moving window isn't affected.
        .           static void FindHoveredWindow()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
    2,418 ( 0.00%)      ImGuiViewportP* moving_window_viewport = g.MovingWindow ? g.MovingWindow->Viewport : NULL;
    1,612 ( 0.00%)      if (g.MovingWindow)
        .                   g.MovingWindow->Viewport = g.MouseViewport;
        .           
      403 ( 0.00%)      ImGuiWindow* hovered_window = NULL;
      403 ( 0.00%)      ImGuiWindow* hovered_window_ignoring_moving_window = NULL;
    1,612 ( 0.00%)      if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        .                   hovered_window = g.MovingWindow;
        .           
    1,209 ( 0.00%)      ImVec2 padding_regular = g.Style.TouchExtraPadding;
    3,627 ( 0.00%)      ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
    8,783 ( 0.00%)      for (int i = g.Windows.Size - 1; i >= 0; i--)
        .               {
   16,616 ( 0.00%)          ImGuiWindow* window = g.Windows[i];
   39,463 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (2,077x)
        .                   IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
   15,481 ( 0.00%)          if (!window->Active || window->Hidden)
    1,610 ( 0.00%)              continue;
    6,360 ( 0.00%)          if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
      804 ( 0.00%)              continue;
    3,480 ( 0.00%)          IM_ASSERT(window->Viewport);
    5,220 ( 0.00%)          if (window->Viewport != g.MouseViewport)
        .                       continue;
        .           
        .                   // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
    7,830 ( 0.00%)          ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
    9,570 ( 0.00%)          if (!window->OuterRectClipped.ContainsWithPad(g.IO.MousePos, hit_padding))
   21,168 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ContainsWithPad(ImVec2 const&, ImVec2 const&) const (870x)
    1,404 ( 0.00%)              continue;
        .           
        .                   // Support for one rectangular hole in any given window
        .                   // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
      672 ( 0.00%)          if (window->HitTestHoleSize.x != 0)
        .                   {
        .                       ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
        .                       ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
        .                       if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
        .                           continue;
        .                   }
        .           
      336 ( 0.00%)          if (hovered_window == NULL)
      336 ( 0.00%)              hovered_window = window;
        .                   IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
    1,008 ( 0.00%)          if (hovered_window_ignoring_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
      336 ( 0.00%)              hovered_window_ignoring_moving_window = window;
      672 ( 0.00%)          if (hovered_window && hovered_window_ignoring_moving_window)
      168 ( 0.00%)              break;
        .               }
        .           
    1,209 ( 0.00%)      g.HoveredWindow = hovered_window;
    1,209 ( 0.00%)      g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
        .           
    1,612 ( 0.00%)      if (g.MovingWindow)
        .                   g.MovingWindow->Viewport = moving_window_viewport;
    1,209 ( 0.00%)  }
        .           
        .           bool ImGui::IsItemActive()
      808 ( 0.00%)  {
      808 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,616 ( 0.00%)      if (g.ActiveId)
       21 ( 0.00%)          return g.ActiveId == g.LastItemData.ID;
      401 ( 0.00%)      return false;
      808 ( 0.00%)  }
        .           
        .           bool ImGui::IsItemActivated()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.ActiveId)
        .                   if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)
        .                       return true;
        .               return false;
-- line 5544 ----------------------------------------
-- line 5646 ----------------------------------------
        .                   g.HoveredIdAllowOverlap = true;
        .               if (g.ActiveId == id) // Before we made this obsolete, most calls to SetItemAllowOverlap() used to avoid this path by testing g.ActiveId != id.
        .                   g.ActiveIdAllowOverlap = true;
        .           }
        .           #endif
        .           
        .           // FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version for the two users of this function.
        .           void ImGui::SetActiveIdUsingAllKeyboardKeys()
        6 ( 0.00%)  {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
        8 ( 0.00%)      IM_ASSERT(g.ActiveId != 0);
        4 ( 0.00%)      g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
        4 ( 0.00%)      g.ActiveIdUsingAllKeyboardKeys = true;
        2 ( 0.00%)      NavMoveRequestCancel();
       76 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavMoveRequestCancel() (2x)
        6 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::GetItemID()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return g.LastItemData.ID;
        .           }
        .           
        .           ImVec2 ImGui::GetItemRectMin()
-- line 5668 ----------------------------------------
-- line 5840 ----------------------------------------
        .                   if (g.HoveredWindow == child_window)
        .                       g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
        .               }
        .               g.WithinEndChild = false;
        .               g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
        .           }
        .           
        .           static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
       96 ( 0.00%)  {
      144 ( 0.00%)      window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
      144 ( 0.00%)      window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
      144 ( 0.00%)      window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
      144 ( 0.00%)      window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
       48 ( 0.00%)  }
        .           
        .           ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
    8,084 ( 0.00%)  {
    4,042 ( 0.00%)      ImGuiContext& g = *GImGui;
   12,126 ( 0.00%)      return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
  244,097 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::GetVoidPtr(unsigned int) const (2,021x)
    4,042 ( 0.00%)  }
        .           
        .           ImGuiWindow* ImGui::FindWindowByName(const char* name)
    8,068 ( 0.00%)  {
   12,102 ( 0.00%)      ImGuiID id = ImHashStr(name);
  780,020 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (2,017x)
    6,051 ( 0.00%)      return FindWindowByID(id);
  272,091 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowByID(unsigned int) (2,017x)
    4,034 ( 0.00%)  }
        .           
        .           static void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
       24 ( 0.00%)  {
        8 ( 0.00%)      const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
      128 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetMainViewport() (4x)
       16 ( 0.00%)      window->ViewportPos = main_viewport->Pos;
       16 ( 0.00%)      if (settings->ViewportId)
        .               {
        .                   window->ViewportId = settings->ViewportId;
        .                   window->ViewportPos = ImVec2(settings->ViewportPos.x, settings->ViewportPos.y);
        .               }
      104 ( 0.00%)      window->Pos = ImTrunc(ImVec2(settings->Pos.x + window->ViewportPos.x, settings->Pos.y + window->ViewportPos.y));
      144 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(ImVec2 const&) (4x)
       56 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (4x)
       32 ( 0.00%)      if (settings->Size.x > 0 && settings->Size.y > 0)
      100 ( 0.00%)          window->Size = window->SizeFull = ImTrunc(ImVec2(settings->Size.x, settings->Size.y));
      144 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(ImVec2 const&) (4x)
       56 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (4x)
       16 ( 0.00%)      window->Collapsed = settings->Collapsed;
       16 ( 0.00%)      window->DockId = settings->DockId;
       16 ( 0.00%)      window->DockOrder = settings->DockOrder;
       16 ( 0.00%)  }
        .           
        .           static void UpdateWindowInFocusOrderList(ImGuiWindow* window, bool just_created, ImGuiWindowFlags new_flags)
   14,112 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
   14,111 ( 0.00%)      const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
   10,080 ( 0.00%)      const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
    8,076 ( 0.00%)      if ((just_created || child_flag_changed) && !new_is_explicit_child)
        .               {
       45 ( 0.00%)          IM_ASSERT(!g.WindowsFocusOrder.contains(window));
      240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::contains(ImGuiWindow* const&) const (5x)
       30 ( 0.00%)          g.WindowsFocusOrder.push_back(window);
      320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::push_back(ImGuiWindow* const&) (5x)
       30 ( 0.00%)          window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
        .               }
   12,064 ( 0.00%)      else if (!just_created && child_flag_changed && new_is_explicit_child)
        .               {
        .                   IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
        .                   for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
        .                       g.WindowsFocusOrder[n]->FocusOrder--;
        .                   g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
        .                   window->FocusOrder = -1;
        .               }
    6,048 ( 0.00%)      window->IsExplicitChild = new_is_explicit_child;
    6,048 ( 0.00%)  }
        .           
        .           static void InitOrLoadWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
       36 ( 0.00%)  {
        .               // Initial window state with e.g. default/arbitrary window position
        .               // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
       12 ( 0.00%)      const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
      192 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetMainViewport() (6x)
       90 ( 0.00%)      window->Pos = main_viewport->Pos + ImVec2(60, 60);
      234 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (6x)
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       84 ( 0.00%)      window->Size = window->SizeFull = ImVec2(0, 0);
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
       24 ( 0.00%)      window->ViewportPos = main_viewport->Pos;
       72 ( 0.00%)      window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = window->SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
        .           
       12 ( 0.00%)      if (settings != NULL)
        .               {
       20 ( 0.00%)          SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
      180 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetWindowConditionAllowFlags(ImGuiWindow*, int, bool) (4x)
       20 ( 0.00%)          ApplyWindowSettings(window, settings);
      892 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ApplyWindowSettings(ImGuiWindow*, ImGuiWindowSettings*) (4x)
        .               }
       84 ( 0.00%)      window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
        .           
       30 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
        .               {
        .                   window->AutoFitFramesX = window->AutoFitFramesY = 2;
        .                   window->AutoFitOnlyGrows = false;
        .               }
        .               else
        .               {
       30 ( 0.00%)          if (window->Size.x <= 0.0f)
        4 ( 0.00%)              window->AutoFitFramesX = 2;
       30 ( 0.00%)          if (window->Size.y <= 0.0f)
        4 ( 0.00%)              window->AutoFitFramesY = 2;
       60 ( 0.00%)          window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
        .               }
       24 ( 0.00%)  }
        .           
        .           static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)
       54 ( 0.00%)  {
        .               // Create window the first time
        .               //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
       12 ( 0.00%)      ImGuiContext& g = *GImGui;
       84 ( 0.00%)      ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
   17,176 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::ImGuiWindow(ImGuiContext*, char const*) (6x)
    6,481 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (6x)
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (6x)
       18 ( 0.00%)      window->Flags = flags;
       48 ( 0.00%)      g.WindowsById.SetVoidPtr(window->ID, window);
    1,415 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::SetVoidPtr(unsigned int, void*) (6x)
        .           
        6 ( 0.00%)      ImGuiWindowSettings* settings = NULL;
       24 ( 0.00%)      if (!(flags & ImGuiWindowFlags_NoSavedSettings))
       32 ( 0.00%)          if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
      886 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByWindow(ImGuiWindow*) (4x)
       32 ( 0.00%)              window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
      192 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::offset_from_ptr(ImGuiWindowSettings const*) (4x)
        .           
       30 ( 0.00%)      InitOrLoadWindowSettings(window, settings);
    2,302 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:InitOrLoadWindowSettings(ImGuiWindow*, ImGuiWindowSettings*) (6x)
        .           
       24 ( 0.00%)      if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        7 ( 0.00%)          g.Windows.push_front(window); // Quite slow but rare and only once
      110 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::push_front(ImGuiWindow* const&) (1x)
        .               else
       30 ( 0.00%)          g.Windows.push_back(window);
      320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::push_back(ImGuiWindow* const&) (5x)
        .           
       12 ( 0.00%)      return window;
       42 ( 0.00%)  }
        .           
        .           static ImGuiWindow* GetWindowForTitleDisplay(ImGuiWindow* window)
        .           {
        .               return window->DockNodeAsHost ? window->DockNodeAsHost->VisibleWindow : window;
        .           }
        .           
        .           static ImGuiWindow* GetWindowForTitleAndMenuHeight(ImGuiWindow* window)
   18,144 ( 0.00%)  {
   39,879 ( 0.00%)      return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
   12,096 ( 0.00%)  }
        .           
        .           static inline ImVec2 CalcWindowMinSize(ImGuiWindow* window)
   24,192 ( 0.00%)  {
        .               // We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
        .               // FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
        .               // Perhaps should tend further a neater test for this.
   12,096 ( 0.00%)      ImGuiContext& g = *GImGui;
   24,192 ( 0.00%)      ImVec2 size_min;
   42,330 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))
        .               {
   16,926 ( 0.00%)          size_min.x = (window->ChildFlags & ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0f;
   19,344 ( 0.00%)          size_min.y = (window->ChildFlags & ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0f;
        .               }
        .               else
        .               {
   32,670 ( 0.00%)          size_min.x = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0f;
   32,670 ( 0.00%)          size_min.y = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0f;
        .               }
        .           
        .               // Reduce artifacts with very small windows
   24,192 ( 0.00%)      ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
   70,119 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:GetWindowForTitleAndMenuHeight(ImGuiWindow*) (6,048x)
  145,152 ( 0.00%)      size_min.y = ImMax(size_min.y, window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f));
  133,056 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (12,096x)
  130,617 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::MenuBarHeight() const (6,048x)
  127,080 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::TitleBarHeight() const (6,048x)
    6,048 ( 0.00%)      return size_min;
   18,144 ( 0.00%)  }
        .           
        .           static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)
   20,160 ( 0.00%)  {
    8,064 ( 0.00%)      ImGuiContext& g = *GImGui;
   12,096 ( 0.00%)      ImVec2 new_size = size_desired;
   20,160 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
        .               {
        .                   // See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
        .                   ImRect cr = g.NextWindowData.SizeConstraintRect;
        .                   new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        .                   new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        .                   if (g.NextWindowData.SizeCallback)
        .                   {
        .                       ImGuiSizeCallbackData data;
-- line 6009 ----------------------------------------
-- line 6014 ----------------------------------------
        .                       g.NextWindowData.SizeCallback(&data);
        .                       new_size = data.DesiredSize;
        .                   }
        .                   new_size.x = IM_TRUNC(new_size.x);
        .                   new_size.y = IM_TRUNC(new_size.y);
        .               }
        .           
        .               // Minimum size
   20,160 ( 0.00%)      ImVec2 size_min = CalcWindowMinSize(window);
  572,552 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowMinSize(ImGuiWindow*) (4,032x)
   24,192 ( 0.00%)      return ImMax(new_size, size_min);
  185,472 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImMax(ImVec2 const&, ImVec2 const&) (4,032x)
   12,096 ( 0.00%)  }
        .           
        .           static void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)
   12,096 ( 0.00%)  {
    2,016 ( 0.00%)      bool preserve_old_content_sizes = false;
    8,064 ( 0.00%)      if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        .                   preserve_old_content_sizes = true;
    8,072 ( 0.00%)      else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
        .                   preserve_old_content_sizes = true;
    4,032 ( 0.00%)      if (preserve_old_content_sizes)
        .               {
        .                   *content_size_current = window->ContentSize;
        .                   *content_size_ideal = window->ContentSizeIdeal;
        .                   return;
        .               }
        .           
   34,272 ( 0.00%)      content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
   34,272 ( 0.00%)      content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
   48,384 ( 0.00%)      content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   48,384 ( 0.00%)      content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
    4,032 ( 0.00%)  }
        .           
        .           static ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)
   10,080 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,048 ( 0.00%)      ImGuiStyle& style = g.Style;
   18,144 ( 0.00%)      const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
   18,144 ( 0.00%)      const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
   16,128 ( 0.00%)      ImVec2 size_pad = window->WindowPadding * 2.0f;
   68,544 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (2,016x)
   42,336 ( 0.00%)      ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
  157,248 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (4,032x)
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   10,080 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_Tooltip)
        .               {
        .                   // Tooltip always resize
        .                   return size_desired;
        .               }
        .               else
        .               {
        .                   // Maximum window size is determined by the viewport size or monitor size
   10,080 ( 0.00%)          ImVec2 size_min = CalcWindowMinSize(window);
  286,276 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowMinSize(ImGuiWindow*) (2,016x)
   47,162 ( 0.00%)          ImVec2 size_max = (window->ViewportOwned || ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))) ? ImVec2(FLT_MAX, FLT_MAX) : ImGui::GetMainViewport()->WorkSize - style.DisplaySafeAreaPadding * 2.0f;
   41,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (1,209x)
   47,151 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (1,209x)
   11,298 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (807x)
   38,688 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetMainViewport() (1,209x)
    6,048 ( 0.00%)          const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
   11,295 ( 0.00%)          if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0)
   16,947 ( 0.00%)              size_max = g.PlatformIO.Monitors[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0f;
   27,438 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (807x)
   31,473 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (807x)
   17,754 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::operator[](int) (807x)
   28,224 ( 0.00%)          ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, size_max));
   99,584 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImClamp(ImVec2 const&, ImVec2 const&, ImVec2) (2,016x)
   88,704 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImMax(ImVec2 const&, ImVec2 const&) (2,016x)
        .           
        .                   // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        .                   // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
   14,112 ( 0.00%)          ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
  437,476 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowSizeAfterConstraint(ImGuiWindow*, ImVec2 const&) (2,016x)
   34,260 ( 0.00%)          bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x  && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
   30,642 ( 0.00%)          bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
    4,032 ( 0.00%)          if (will_have_scrollbar_x)
        .                       size_auto_fit.y += style.ScrollbarSize;
    4,032 ( 0.00%)          if (will_have_scrollbar_y)
    2,010 ( 0.00%)              size_auto_fit.x += style.ScrollbarSize;
    2,016 ( 0.00%)          return size_auto_fit;
        .               }
    6,048 ( 0.00%)  }
        .           
        .           ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)
        .           {
        .               ImVec2 size_contents_current;
        .               ImVec2 size_contents_ideal;
        .               CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
        .               ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
        .               ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
        .               return size_final;
        .           }
        .           
        .           static ImGuiCol GetWindowBgColorIdx(ImGuiWindow* window)
    1,212 ( 0.00%)  {
    2,020 ( 0.00%)      if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        .                   return ImGuiCol_PopupBg;
    2,020 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
        .                   return ImGuiCol_ChildBg;
      404 ( 0.00%)      return ImGuiCol_WindowBg;
      808 ( 0.00%)  }
        .           
        .           static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
        .           {
        .               ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
        .               ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
        .               ImVec2 size_expected = pos_max - pos_min;
        .               ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
        .               *out_pos = pos_min;
-- line 6107 ----------------------------------------
-- line 6174 ----------------------------------------
        .               id = ImHashStr("#RESIZE", 0, id);
        .               id = ImHashData(&n, sizeof(int), id);
        .               return id;
        .           }
        .           
        .           // Handle resize for: Resize Grips, Borders, Gamepad
        .           // Return true when using auto-fit (double-click on resize grip)
        .           static int ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_hovered, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)
   16,130 ( 0.00%)  {
    3,226 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,839 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
        .           
   11,300 ( 0.00%)      if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
    2,418 ( 0.00%)          return false;
    2,020 ( 0.00%)      if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
      808 ( 0.00%)          return false;
        .           
        .               int ret_auto_fit_mask = 0x00;
        .               const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
        .               const float grip_hover_inner_size = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75f) : 0.0f;
        .               const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
        .           
        .               ImRect clamp_rect = visibility_rect;
        .               const bool window_move_from_title_bar = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar);
-- line 6197 ----------------------------------------
-- line 6392 ----------------------------------------
        .               if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y || curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)
        .                   MarkIniSettingsDirty(window);
        .           
        .               // Recalculate next expected border expected coordinates
        .               if (*border_held != -1)
        .                   g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
        .           
        .               return ret_auto_fit_mask;
    4,839 ( 0.00%)  }
        .           
        .           static inline void ClampWindowPos(ImGuiWindow* window, const ImRect& visibility_rect)
    2,424 ( 0.00%)  {
      808 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,212 ( 0.00%)      ImVec2 size_for_clamping = window->Size;
    1,616 ( 0.00%)      if (g.IO.ConfigWindowsMoveFromTitleBarOnly && (!(window->Flags & ImGuiWindowFlags_NoTitleBar) || window->DockNodeAsHost))
        .                   size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
    7,676 ( 0.00%)      window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
   22,220 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImClamp(ImVec2 const&, ImVec2 const&, ImVec2) (404x)
   15,756 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (404x)
    1,616 ( 0.00%)  }
        .           
        .           static void RenderWindowOuterSingleBorder(ImGuiWindow* window, int border_n, ImU32 border_col, float border_size)
        .           {
        .               const ImGuiResizeBorderDef& def = resize_border_def[border_n];
        .               const float rounding = window->WindowRounding;
        .               const ImRect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);
        .               window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
        .               window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
        .               window->DrawList->PathStroke(border_col, ImDrawFlags_None, border_size);
        .           }
        .           
        .           static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)
    9,684 ( 0.00%)  {
    3,228 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,842 ( 0.00%)      const float border_size = window->WindowBorderSize;
    8,070 ( 0.00%)      const ImU32 border_col = GetColorU32(ImGuiCol_Border);
  211,434 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (1,614x)
   10,491 ( 0.00%)      if (border_size > 0.0f && (window->Flags & ImGuiWindowFlags_NoBackground) == 0)
   11,312 ( 0.00%)          window->DrawList->AddRect(window->Pos, window->Pos + window->Size, border_col, window->WindowRounding, 0, window->WindowBorderSize);
  829,195 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRect(ImVec2 const&, ImVec2 const&, unsigned int, float, int, float) (404x)
   15,756 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (404x)
    4,840 ( 0.00%)      else if (border_size > 0.0f)
        .               {
    2,015 ( 0.00%)          if (window->ChildFlags & ImGuiChildFlags_ResizeX) // Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
        .                       RenderWindowOuterSingleBorder(window, 1, border_col, border_size);
    2,015 ( 0.00%)          if (window->ChildFlags & ImGuiChildFlags_ResizeY)
        .                       RenderWindowOuterSingleBorder(window, 3, border_col, border_size);
        .               }
   12,912 ( 0.00%)      if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1)
        .               {
        .                   const int border_n = (window->ResizeBorderHeld != -1) ? window->ResizeBorderHeld : window->ResizeBorderHovered;
        .                   const ImU32 border_col_resizing = GetColorU32((window->ResizeBorderHeld != -1) ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
        .                   RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0f, window->WindowBorderSize)); // Thicker than usual
        .               }
    8,070 ( 0.00%)      if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
        .               {
        .                   float y = window->Pos.y + window->TitleBarHeight() - 1;
        .                   window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), border_col, g.Style.FrameBorderSize);
        .               }
   11,298 ( 0.00%)  }
        .           
        .           // Draw background and borders
        .           // Draw and handle scrollbars
        .           void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)
   28,210 ( 0.00%)  {
    4,030 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,045 ( 0.00%)      ImGuiStyle& style = g.Style;
    6,045 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
        .           
        .               // Ensure that ScrollBar doesn't read last frame's SkipItems
    8,060 ( 0.00%)      IM_ASSERT(window->BeginCount == 0);
    4,030 ( 0.00%)      window->SkipItems = false;
        .           
        .               // Draw window + handle manual resize
        .               // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
    6,045 ( 0.00%)      const float window_rounding = window->WindowRounding;
    6,045 ( 0.00%)      const float window_border_size = window->WindowBorderSize;
    8,060 ( 0.00%)      if (window->Collapsed)
        .               {
        .                   // Title bar only
        .                   const float backup_border_size = style.FrameBorderSize;
        .                   g.Style.FrameBorderSize = window->WindowBorderSize;
        .                   ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
        .                   if (window->ViewportOwned)
        .                       title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
        .                   RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
        .                   g.Style.FrameBorderSize = backup_border_size;
        .               }
        .               else
        .               {
        .                   // Window background
    8,060 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoBackground))
        .                   {
      404 ( 0.00%)              bool is_docking_transparent_payload = false;
    1,616 ( 0.00%)              if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
        .                           if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
        .                               is_docking_transparent_payload = true;
        .           
    3,636 ( 0.00%)              ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
   52,924 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (404x)
    6,464 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:GetWindowBgColorIdx(ImGuiWindow*) (404x)
    1,616 ( 0.00%)              if (window->ViewportOwned)
        .                       {
        1 ( 0.00%)                  bg_col |= IM_COL32_A_MASK; // No alpha
        2 ( 0.00%)                  if (is_docking_transparent_payload)
        .                               window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
        .                       }
        .                       else
        .                       {
        .                           // Adjust alpha. For docking
      403 ( 0.00%)                  bool override_alpha = false;
      806 ( 0.00%)                  float alpha = 1.0f;
    2,015 ( 0.00%)                  if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
        .                           {
        .                               alpha = g.NextWindowData.BgAlphaVal;
        .                               override_alpha = true;
        .                           }
      806 ( 0.00%)                  if (is_docking_transparent_payload)
        .                           {
        .                               alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
        .                               override_alpha = true;
        .                           }
      806 ( 0.00%)                  if (override_alpha)
        .                               bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
        .                       }
        .           
        .                       // Render, for docked windows and host windows we ensure bg goes before decorations
    2,020 ( 0.00%)              if (window->DockIsActive)
        .                           window->DockNode->LastBgColor = bg_col;
    3,232 ( 0.00%)              ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
    3,636 ( 0.00%)              if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
        .                           bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
   16,968 ( 0.00%)              bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
  122,706 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (404x)
   31,512 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (808x)
   18,180 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::TitleBarHeight() const (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
    3,636 ( 0.00%)              if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
        .                           bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
        .                   }
   10,075 ( 0.00%)          if (window->DockIsActive)
    2,010 ( 0.00%)              window->DockNode->IsBgDrawnThisFrame = true;
        .           
        .                   // Title bar
        .                   // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
        .                   // in order for their pos/size to be matching their undocking state.)
   10,484 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
        .                   {
    3,234 ( 0.00%)              ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
   52,924 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (404x)
    1,616 ( 0.00%)              if (window->ViewportOwned)
        1 ( 0.00%)                  title_bar_col |= IM_COL32_A_MASK; // No alpha
    5,252 ( 0.00%)              window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
  122,744 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (404x)
        .                   }
        .           
        .                   // Menu bar
    8,060 ( 0.00%)          if (flags & ImGuiWindowFlags_MenuBar)
        .                   {
    2,821 ( 0.00%)              ImRect menu_bar_rect = window->MenuBarRect();
   63,271 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::MenuBarRect() const (403x)
    4,836 ( 0.00%)              menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
   47,957 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ClipWith(ImRect const&) (403x)
   34,658 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::Rect() const (403x)
   19,344 ( 0.00%)              window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
  122,055 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (403x)
   52,793 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (403x)
   15,717 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (403x)
   11,284 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (806x)
   15,717 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (403x)
    2,015 ( 0.00%)              if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
        .                           window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
        .                   }
        .           
        .                   // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
    6,045 ( 0.00%)          ImGuiDockNode* node = window->DockNode;
   18,130 ( 0.00%)          if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
    4,020 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsHiddenTabBar() const (402x)
        .                   {
        .                       float unhide_sz_draw = ImTrunc(g.FontSize * 0.70f);
        .                       float unhide_sz_hit = ImTrunc(g.FontSize * 0.55f);
        .                       ImVec2 p = node->Pos;
        .                       ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
        .                       ImGuiID unhide_id = window->GetID("#UNHIDE");
        .                       KeepAliveID(unhide_id);
        .                       bool hovered, held;
-- line 6555 ----------------------------------------
-- line 6559 ----------------------------------------
        .                           StartMouseMovingWindowOrNode(window, node, true); // Undock from tab-bar triangle = same as window/collapse menu button
        .           
        .                       // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
        .                       ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
        .                       window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
        .                   }
        .           
        .                   // Scrollbars
    8,060 ( 0.00%)          if (window->ScrollbarX)
        .                       Scrollbar(ImGuiAxis_X);
    8,060 ( 0.00%)          if (window->ScrollbarY)
        .                       Scrollbar(ImGuiAxis_Y);
        .           
        .                   // Render resize grips (after their input handling so we don't have a frame of latency)
   10,482 ( 0.00%)          if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
        .                   {
    5,252 ( 0.00%)              for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
        .                       {
    5,656 ( 0.00%)                  const ImU32 col = resize_grip_col[resize_grip_n];
    1,616 ( 0.00%)                  if ((col & IM_COL32_A_MASK) == 0)
      808 ( 0.00%)                      continue;
        .                           const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
        .                           const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
        .                           window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
        .                           window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
        .                           window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
        .                           window->DrawList->PathFillConvex(col);
        .                       }
        .                   }
        .           
        .                   // Borders (for dock node host they will be rendered over after the tab bar)
   10,482 ( 0.00%)          if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
    3,633 ( 0.00%)              RenderWindowOuterBorders(window);
1,074,637 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowOuterBorders(ImGuiWindow*) (1,211x)
        .               }
   14,105 ( 0.00%)  }
        .           
        .           // When inside a dock node, this is handled in DockNodeCalcTabBarLayout() instead.
        .           // Render title text, collapse button, close button
        .           void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)
    2,828 ( 0.00%)  {
      808 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,212 ( 0.00%)      ImGuiStyle& style = g.Style;
    1,212 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
        .           
    1,212 ( 0.00%)      const bool has_close_button = (p_open != NULL);
    4,444 ( 0.00%)      const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
        .           
        .               // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
        .               // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
    1,212 ( 0.00%)      const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
    2,424 ( 0.00%)      g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
      808 ( 0.00%)      window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
        .           
        .               // Layout buttons
        .               // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
    1,212 ( 0.00%)      float pad_l = style.FramePadding.x;
    1,212 ( 0.00%)      float pad_r = style.FramePadding.x;
    1,212 ( 0.00%)      float button_sz = g.FontSize;
    1,616 ( 0.00%)      ImVec2 close_button_pos;
    1,616 ( 0.00%)      ImVec2 collapse_button_pos;
      808 ( 0.00%)      if (has_close_button)
        .               {
       16 ( 0.00%)          close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
        6 ( 0.00%)          pad_r += button_sz + style.ItemInnerSpacing.x;
        .               }
    2,424 ( 0.00%)      if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
        .               {
        .                   collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
        .                   pad_r += button_sz + style.ItemInnerSpacing.x;
        .               }
    2,424 ( 0.00%)      if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
        .               {
    6,060 ( 0.00%)          collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
    2,424 ( 0.00%)          pad_l += button_sz + style.ItemInnerSpacing.x;
        .               }
        .           
        .               // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
      808 ( 0.00%)      if (has_collapse_button)
    5,252 ( 0.00%)          if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
1,071,080 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGui::CollapseButton(unsigned int, ImVec2 const&, ImGuiDockNode*) (404x)
  118,372 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (404x)
        .                       window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
        .           
        .               // Close button
      808 ( 0.00%)      if (has_close_button)
       12 ( 0.00%)          if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
      221 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (1x)
    5,271 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGui::CloseButton(unsigned int, ImVec2 const&) (1x)
        .                       *p_open = false;
        .           
      808 ( 0.00%)      window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    1,212 ( 0.00%)      g.CurrentItemFlags = item_flags_backup;
        .           
        .               // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
        .               // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
    2,424 ( 0.00%)      const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
    8,888 ( 0.00%)      const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
  164,879 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CalcTextSize(char const*, char const*, bool, float) (404x)
   15,756 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (404x)
    5,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (404x)
        .           
        .               // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
        .               // while uncentered title text will still reach edges correctly.
    2,020 ( 0.00%)      if (pad_l > style.FramePadding.x)
    2,020 ( 0.00%)          pad_l += g.Style.ItemInnerSpacing.x;
    2,020 ( 0.00%)      if (pad_r > style.FramePadding.x)
        5 ( 0.00%)          pad_r += g.Style.ItemInnerSpacing.x;
    2,020 ( 0.00%)      if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
        .               {
        .                   float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
        .                   float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
        .                   pad_l = ImMax(pad_l, pad_extend * centerness);
        .                   pad_r = ImMax(pad_r, pad_extend * centerness);
        .               }
        .           
    6,060 ( 0.00%)      ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
   21,816 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(float, float, float, float) (404x)
    8,888 ( 0.00%)      ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
   21,816 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(float, float, float, float) (404x)
    4,041 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (404x)
    1,616 ( 0.00%)      if (flags & ImGuiWindowFlags_UnsavedDocument)
        .               {
        .                   ImVec2 marker_pos;
        .                   marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
        .                   marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
        .                   if (marker_pos.x > layout_r.Min.x)
        .                   {
        .                       RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
        .                       clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
        .                   }
        .               }
        .               //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
        .               //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
    6,464 ( 0.00%)      RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
  779,952 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderTextClipped(ImVec2 const&, ImVec2 const&, char const*, char const*, ImVec2 const*, ImVec2 const&, ImRect const*) (404x)
    1,212 ( 0.00%)  }
        .           
        .           void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
   12,102 ( 0.00%)  {
    6,051 ( 0.00%)      window->ParentWindow = parent_window;
   38,323 ( 0.00%)      window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
   10,490 ( 0.00%)      if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        .               {
    3,228 ( 0.00%)          window->RootWindowDockTree = parent_window->RootWindowDockTree;
    6,862 ( 0.00%)          if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
    1,612 ( 0.00%)              window->RootWindow = parent_window->RootWindow;
        .               }
    7,262 ( 0.00%)      if (parent_window && (flags & ImGuiWindowFlags_Popup))
        .                   window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
   10,490 ( 0.00%)      if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
    3,228 ( 0.00%)          window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
   12,909 ( 0.00%)      while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
        .               {
        .                   IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
        .                   window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
        .               }
    8,068 ( 0.00%)  }
        .           
        .           // [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
        .           // This is designed as a toy/test-bed for
        .           void ImGui::UpdateWindowSkipRefresh(ImGuiWindow* window)
    6,048 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,032 ( 0.00%)      window->SkipRefresh = false;
   10,080 ( 0.00%)      if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0)
    4,032 ( 0.00%)          return;
        .               if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh)
        .               {
        .                   // FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
        .                   if (window->Appearing) // If currently appearing
        .                       return;
        .                   if (window->Hidden) // If was hidden (previous frame)
        .                       return;
        .                   if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow && window->RootWindow == g.HoveredWindow->RootWindow)
        .                       return;
        .                   if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow && window->RootWindow == g.NavWindow->RootWindow)
        .                       return;
        .                   window->DrawList = NULL;
        .                   window->SkipRefresh = true;
        .               }
    4,032 ( 0.00%)  }
        .           
        .           // When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
        .           // should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
        .           // In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
        .           // - WindowA            // FindBlockingModal() returns Modal1
        .           //   - WindowB          //                  .. returns Modal1
        .           //   - Modal1           //                  .. returns Modal2
        .           //      - WindowC       //                  .. returns Modal2
        .           //          - WindowD   //                  .. returns Modal2
        .           //          - Modal2    //                  .. returns Modal2
        .           //            - WindowE //                  .. returns NULL
        .           // Notes:
        .           // - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
        .           //   Only difference is here we check for ->Active/WasActive but it may be unecessary.
        .           ImGuiWindow* ImGui::FindBlockingModal(ImGuiWindow* window)
       20 ( 0.00%)  {
       10 ( 0.00%)      ImGuiContext& g = *GImGui;
       20 ( 0.00%)      if (g.OpenPopupStack.Size <= 0)
       10 ( 0.00%)          return NULL;
        .           
        .               // Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
        .               for (ImGuiPopupData& popup_data : g.OpenPopupStack)
        .               {
        .                   ImGuiWindow* popup_window = popup_data.Window;
        .                   if (popup_window == NULL || !(popup_window->Flags & ImGuiWindowFlags_Modal))
        .                       continue;
        .                   if (!popup_window->Active && !popup_window->WasActive)      // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
-- line 6755 ----------------------------------------
-- line 6756 ----------------------------------------
        .                       continue;
        .                   if (window == NULL)                                         // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
        .                       return popup_window;
        .                   if (IsWindowWithinBeginStackOf(window, popup_window))       // Window may be over modal
        .                       continue;
        .                   return popup_window;                                        // Place window right below first block modal
        .               }
        .               return NULL;
       10 ( 0.00%)  }
        .           
        .           // Push a new Dear ImGui window to add widgets to.
        .           // - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
        .           // - Begin/End can be called multiple times during the frame with the same window name to append content.
        .           // - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
        .           //   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
        .           // - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
        .           // - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
        .           bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
   18,144 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,048 ( 0.00%)      const ImGuiStyle& style = g.Style;
   12,096 ( 0.00%)      IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
    8,064 ( 0.00%)      IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
   12,096 ( 0.00%)      IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
        .           
        .               // Find or create
    8,064 ( 0.00%)      ImGuiWindow* window = FindWindowByName(name);
1,081,783 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowByName(char const*) (2,016x)
    8,064 ( 0.00%)      const bool window_just_created = (window == NULL);
    4,032 ( 0.00%)      if (window_just_created)
       36 ( 0.00%)          window = CreateNewWindow(name, flags);
   29,379 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CreateNewWindow(char const*, int) (6x)
        .           
        .               // [DEBUG] Debug break requested by user
   12,096 ( 0.00%)      if (g.DebugBreakInWindow == window->ID)
        .                   IM_DEBUG_BREAK();
        .           
        .               // Automatically disable manual moving/resizing when NoInputs is set
    8,064 ( 0.00%)      if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
      403 ( 0.00%)          flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
        .           
    8,064 ( 0.00%)      if (flags & ImGuiWindowFlags_NavFlattened)
        .                   IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
        .           
    6,048 ( 0.00%)      const int current_frame = g.FrameCount;
   10,080 ( 0.00%)      const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
   16,127 ( 0.00%)      window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
        .           
        .               // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
   14,112 ( 0.00%)      bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    8,064 ( 0.00%)      if (flags & ImGuiWindowFlags_Popup)
        .               {
        .                   ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        .                   window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        .                   window_just_activated_by_user |= (window != popup_ref.Window);
        .               }
        .           
        .               // Update Flags, LastFrameActive, BeginOrderXXX fields
    6,048 ( 0.00%)      const bool window_was_appearing = window->Appearing;
    4,032 ( 0.00%)      if (first_begin_of_the_frame)
        .               {
   12,096 ( 0.00%)          UpdateWindowInFocusOrderList(window, window_just_created, flags);
   75,236 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:UpdateWindowInFocusOrderList(ImGuiWindow*, bool, int) (2,016x)
    6,048 ( 0.00%)          window->Appearing = window_just_activated_by_user;
    8,064 ( 0.00%)          if (window->Appearing)
       30 ( 0.00%)              SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
      270 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetWindowConditionAllowFlags(ImGuiWindow*, int, bool) (6x)
    8,064 ( 0.00%)          window->FlagsPreviousFrame = window->Flags;
    6,048 ( 0.00%)          window->Flags = (ImGuiWindowFlags)flags;
   16,128 ( 0.00%)          window->ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0;
    6,048 ( 0.00%)          window->LastFrameActive = current_frame;
   10,080 ( 0.00%)          window->LastTimeActive = (float)g.Time;
    4,032 ( 0.00%)          window->BeginOrderWithinParent = 0;
   16,128 ( 0.00%)          window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
        .               }
        .               else
        .               {
        .                   flags = window->Flags;
        .               }
        .           
        .               // Docking
        .               // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
    9,672 ( 0.00%)      IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
        .                   SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
    4,032 ( 0.00%)      if (first_begin_of_the_frame)
        .               {
   18,951 ( 0.00%)          bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
   20,161 ( 0.00%)          bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
   25,808 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetWindowAlwaysWantOwnTabBar(ImGuiWindow*) (1,613x)
   10,080 ( 0.00%)          bool dock_node_was_visible = window->DockNodeIsVisible;
   10,080 ( 0.00%)          bool dock_tab_was_visible = window->DockTabIsVisible;
    7,258 ( 0.00%)          if (has_dock_node || new_auto_dock_node)
        .                   {
    2,015 ( 0.00%)              BeginDocked(window, p_open);
  564,152 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BeginDocked(ImGuiWindow*, bool*) (403x)
    1,209 ( 0.00%)              flags = window->Flags;
    2,015 ( 0.00%)              if (window->DockIsActive)
        .                       {
    1,612 ( 0.00%)                  IM_ASSERT(window->DockNode != NULL);
    2,418 ( 0.00%)                  g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
        .                       }
        .           
        .                       // Amend the Appearing flag
    4,440 ( 0.00%)              if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
        .                       {
        .                           window->Appearing = true;
        .                           SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
        .                       }
        .                   }
        .                   else
        .                   {
   40,325 ( 0.00%)              window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
        .                   }
        .               }
        .           
        .               // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
   32,257 ( 0.00%)      ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
   27,830 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::back() (1,210x)
   14,517 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::empty() const (1,613x)
   18,144 ( 0.00%)      ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    8,872 ( 0.00%)      IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
        .           
        .               // We allow window memory to be compacted so recreate the base stack when needed.
    8,064 ( 0.00%)      if (window->IDStack.Size == 0)
        .                   window->IDStack.push_back(window->ID);
        .           
        .               // Add to stack
    6,048 ( 0.00%)      g.CurrentWindow = window;
    6,048 ( 0.00%)      ImGuiWindowStackData window_stack_data;
  562,464 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindowStackData::ImGuiWindowStackData() (2,016x)
    4,032 ( 0.00%)      window_stack_data.Window = window;
   18,144 ( 0.00%)      window_stack_data.ParentLastItemDataBackup = g.LastItemData;
   12,096 ( 0.00%)      window_stack_data.StackSizesOnBegin.SetToContextState(&g);
  112,896 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStackSizes::SetToContextState(ImGuiContext*) (2,016x)
   12,096 ( 0.00%)      g.CurrentWindowStack.push_back(window_stack_data);
  119,124 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::push_back(ImGuiWindowStackData const&) (2,016x)
    8,064 ( 0.00%)      if (flags & ImGuiWindowFlags_ChildMenu)
        .                   g.BeginMenuDepth++;
        .           
        .               // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
    4,032 ( 0.00%)      if (first_begin_of_the_frame)
        .               {
   12,096 ( 0.00%)          UpdateWindowParentAndRootLinks(window, flags, parent_window);
  120,541 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow*, int, ImGuiWindow*) (2,016x)
    6,048 ( 0.00%)          window->ParentWindowInBeginStack = parent_window_in_stack;
        .           
        .                   // Focus route
        .                   // There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
        .                   // Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
   16,531 ( 0.00%)          window->ParentWindowForFocusRoute = (window->RootWindow != window) ? parent_window_in_stack : NULL;
   14,516 ( 0.00%)          if (window->ParentWindowForFocusRoute == NULL && window->DockNode != NULL)
    2,418 ( 0.00%)              if (window->DockNode->MergedFlags & ImGuiDockNodeFlags_DockedWindowsInFocusRoute)
        .                           window->ParentWindowForFocusRoute = window->DockNode->HostWindow;
        .           
        .                   // Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
    8,064 ( 0.00%)          if (window->WindowClass.FocusRouteParentWindowId != 0)
        .                   {
        .                       window->ParentWindowForFocusRoute = FindWindowByID(window->WindowClass.FocusRouteParentWindowId);
        .                       IM_ASSERT(window->ParentWindowForFocusRoute != 0); // Invalid value for FocusRouteParentWindowId.
        .                   }
        .               }
        .           
        .               // Add to focus scope stack
   16,128 ( 0.00%)      PushFocusScope((flags & ImGuiWindowFlags_NavFlattened) ? g.CurrentFocusScopeId : window->ID);
  107,023 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushFocusScope(unsigned int) (2,016x)
    8,064 ( 0.00%)      window->NavRootFocusScopeId = g.CurrentFocusScopeId;
        .           
        .               // Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
    8,064 ( 0.00%)      if (flags & ImGuiWindowFlags_Popup)
        .               {
        .                   ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        .                   popup_ref.Window = window;
        .                   popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
        .                   g.BeginPopupStack.push_back(popup_ref);
        .                   window->PopupId = popup_ref.PopupId;
        .               }
        .           
        .               // Process SetNextWindow***() calls
        .               // (FIXME: Consider splitting the HasXXX flags into X/Y components
    2,016 ( 0.00%)      bool window_pos_set_by_api = false;
    4,032 ( 0.00%)      bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
        .               {
   14,508 ( 0.00%)          window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
   20,956 ( 0.00%)          if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
   25,792 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLengthSqr(ImVec2 const&) (1,612x)
        .                   {
        .                       // May be processed on the next frame if this is our first frame and we are measuring size
        .                       // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
        .                       window->SetWindowPosVal = g.NextWindowData.PosVal;
        .                       window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
        .                       window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        .                   }
        .                   else
        .                   {
   12,896 ( 0.00%)              SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
  282,334 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetWindowPos(ImGuiWindow*, ImVec2 const&, int) (1,612x)
        .                   }
        .               }
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
        .               {
   29,822 ( 0.00%)          window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
   29,822 ( 0.00%)          window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
   10,075 ( 0.00%)          if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0) // Axis-specific conditions for BeginChild()
        .                       g.NextWindowData.SizeVal.x = window->SizeFull.x;
   10,075 ( 0.00%)          if ((window->ChildFlags & ImGuiChildFlags_ResizeY) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0)
        .                       g.NextWindowData.SizeVal.y = window->SizeFull.y;
   16,120 ( 0.00%)          SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
  182,591 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetWindowSize(ImGuiWindow*, ImVec2 const&, int) (2,015x)
        .               }
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
        .               {
        .                   if (g.NextWindowData.ScrollVal.x >= 0.0f)
        .                   {
        .                       window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
        .                       window->ScrollTargetCenterRatio.x = 0.0f;
        .                   }
        .                   if (g.NextWindowData.ScrollVal.y >= 0.0f)
        .                   {
        .                       window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
        .                       window->ScrollTargetCenterRatio.y = 0.0f;
        .                   }
        .               }
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
        .                   window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
    4,032 ( 0.00%)      else if (first_begin_of_the_frame)
   18,144 ( 0.00%)          window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
        .                   window->WindowClass = g.NextWindowData.WindowClass;
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
        .                   SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
        .                   FocusWindow(window);
    8,064 ( 0.00%)      if (window->Appearing)
       30 ( 0.00%)          SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
      270 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetWindowConditionAllowFlags(ImGuiWindow*, int, bool) (6x)
        .           
        .               // [EXPERIMENTAL] Skip Refresh mode
    6,048 ( 0.00%)      UpdateWindowSkipRefresh(window);
   32,256 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowSkipRefresh(ImGuiWindow*) (2,016x)
        .           
        .               // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    4,032 ( 0.00%)      g.CurrentWindow = NULL;
        .           
        .               // When reusing window again multiple times a frame, just append content (don't need to setup again)
   14,112 ( 0.00%)      if (first_begin_of_the_frame && !window->SkipRefresh)
        .               {
        .                   // Initialize
   15,320 ( 0.00%)          const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
   10,080 ( 0.00%)          const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
    4,032 ( 0.00%)          window->Active = true;
    8,064 ( 0.00%)          window->HasCloseButton = (p_open != NULL);
   36,288 ( 0.00%)          window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
  110,880 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec4 const&) (2,016x)
   44,352 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (2,016x)
   10,080 ( 0.00%)          window->IDStack.resize(1);
   30,240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::resize(int) (2,016x)
    8,064 ( 0.00%)          window->DrawList->_ResetForNewFrame();
  566,886 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_ResetForNewFrame() (2,016x)
    4,032 ( 0.00%)          window->DC.CurrentTableIdx = -1;
    8,064 ( 0.00%)          if (flags & ImGuiWindowFlags_DockNodeHost)
        .                   {
    2,015 ( 0.00%)              window->DrawList->ChannelsSplit(2);
   73,665 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::ChannelsSplit(int) (403x)
    2,015 ( 0.00%)              window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
   96,250 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::ChannelsSetCurrent(int) (403x)
        .                   }
        .           
        .                   // Restore buffer capacity when woken from a compacted state, to avoid
    8,064 ( 0.00%)          if (window->MemoryCompacted)
        .                       GcAwakeTransientWindowBuffers(window);
        .           
        .                   // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        .                   // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
    2,016 ( 0.00%)          bool window_title_visible_elsewhere = false;
   30,204 ( 0.00%)          if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
      806 ( 0.00%)              window_title_visible_elsewhere = true;
    6,452 ( 0.00%)          else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
        .                       window_title_visible_elsewhere = true;
    9,262 ( 0.00%)          if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
    8,040 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 (402x)
        .                   {
        .                       size_t buf_len = (size_t)window->NameBufLen;
        .                       window->Name = ImStrdupcpy(window->Name, &buf_len, name);
        .                       window->NameBufLen = (int)buf_len;
        .                   }
        .           
        .                   // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
        .           
        .                   // Update contents size from last frame for auto-fitting (or use explicit size)
   16,128 ( 0.00%)          CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
  247,976 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowContentSizes(ImGuiWindow*, ImVec2*, ImVec2*) (2,016x)
        .           
        .                   // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
        .                   // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
        .                   // it has a single usage before this code block and may be set below before it is finally checked.
    8,064 ( 0.00%)          if (window->HiddenFramesCanSkipItems > 0)
        .                       window->HiddenFramesCanSkipItems--;
    8,064 ( 0.00%)          if (window->HiddenFramesCannotSkipItems > 0)
        8 ( 0.00%)              window->HiddenFramesCannotSkipItems--;
    8,064 ( 0.00%)          if (window->HiddenFramesForRenderOnly > 0)
        .                       window->HiddenFramesForRenderOnly--;
        .           
        .                   // Hide new windows for one frame until they calculate their size
    4,072 ( 0.00%)          if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
        4 ( 0.00%)              window->HiddenFramesCannotSkipItems = 1;
        .           
        .                   // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        .                   // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
    4,056 ( 0.00%)          if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        .                   {
        .                       window->HiddenFramesCannotSkipItems = 1;
        .                       if (flags & ImGuiWindowFlags_AlwaysAutoResize)
        .                       {
        .                           if (!window_size_x_set_by_api)
        .                               window->Size.x = window->SizeFull.x = 0.f;
        .                           if (!window_size_y_set_by_api)
        .                               window->Size.y = window->SizeFull.y = 0.f;
        .                           window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
        .                       }
        .                   }
        .           
        .                   // SELECT VIEWPORT
        .                   // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
        .           
    6,048 ( 0.00%)          WindowSelectViewport(window);
  335,263 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::WindowSelectViewport(ImGuiWindow*) (2,016x)
   12,096 ( 0.00%)          SetCurrentViewport(window, window->Viewport);
   47,188 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetCurrentViewport(ImGuiWindow*, ImGuiViewportP*) (2,016x)
   16,128 ( 0.00%)          window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
    6,048 ( 0.00%)          SetCurrentWindow(window);
  162,084 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetCurrentWindow(ImGuiWindow*) (2,016x)
    6,048 ( 0.00%)          flags = window->Flags;
        .           
        .                   // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
        .                   // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
        .           
   18,548 ( 0.00%)          if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow))
    2,015 ( 0.00%)              window->WindowBorderSize = style.ChildBorderSize;
        .                   else
   12,904 ( 0.00%)              window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
    8,064 ( 0.00%)          window->WindowPadding = style.WindowPadding;
   25,399 ( 0.00%)          if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !(window->ChildFlags & ImGuiChildFlags_AlwaysUseWindowPadding) && window->WindowBorderSize == 0.0f)
    5,642 ( 0.00%)              window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (403x)
        .           
        .                   // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
   34,272 ( 0.00%)          window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
   43,143 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (4,032x)
    8,064 ( 0.00%)          window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
        .           
        .                   // Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
        .                   // Those flags will be altered further down in the function depending on more conditions.
    4,032 ( 0.00%)          bool use_current_size_for_scrollbar_x = window_just_created;
    4,032 ( 0.00%)          bool use_current_size_for_scrollbar_y = window_just_created;
   16,928 ( 0.00%)          if (window_size_x_set_by_api && window->ContentSizeExplicit.x != 0.0f)
        .                       use_current_size_for_scrollbar_x = true;
   16,928 ( 0.00%)          if (window_size_y_set_by_api && window->ContentSizeExplicit.y != 0.0f) // #7252
        .                       use_current_size_for_scrollbar_y = true;
        .           
        .                   // Collapse window by double-clicking on title bar
        .                   // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
   12,104 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
        .                   {
        .                       // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
    2,828 ( 0.00%)              ImRect title_bar_rect = window->TitleBarRect();
   44,844 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::TitleBarRect() const (404x)
    3,232 ( 0.00%)              if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max))
        .                           if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey_MouseLeft) == ImGuiKeyOwner_None)
        .                               window->WantCollapseToggle = true;
    1,616 ( 0.00%)              if (window->WantCollapseToggle)
        .                       {
        .                           window->Collapsed = !window->Collapsed;
        .                           if (!window->Collapsed)
        .                               use_current_size_for_scrollbar_y = true;
        .                           MarkIniSettingsDirty(window);
        .                       }
      404 ( 0.00%)          }
        .                   else
        .                   {
    4,836 ( 0.00%)              window->Collapsed = false;
        .                   }
    4,032 ( 0.00%)          window->WantCollapseToggle = false;
        .           
        .                   // SIZE
        .           
        .                   // Outer Decoration Sizes
        .                   // (we need to clear ScrollbarSize immediatly as CalcWindowAutoFitSize() needs it and can be called from other locations).
    6,048 ( 0.00%)          const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
    6,048 ( 0.00%)          window->DecoOuterSizeX1 = 0.0f;
    6,048 ( 0.00%)          window->DecoOuterSizeX2 = 0.0f;
   20,160 ( 0.00%)          window->DecoOuterSizeY1 = window->TitleBarHeight() + window->MenuBarHeight();
   42,360 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::TitleBarHeight() const (2,016x)
   43,539 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::MenuBarHeight() const (2,016x)
    6,048 ( 0.00%)          window->DecoOuterSizeY2 = 0.0f;
   18,144 ( 0.00%)          window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
        .           
        .                   // Calculate auto-fit size, handle automatic resize
   16,128 ( 0.00%)          const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
1,722,864 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowAutoFitSize(ImGuiWindow*, ImVec2 const&) (2,016x)
    8,064 ( 0.00%)          if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        .                   {
        .                       // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
        .                       if (!window_size_x_set_by_api)
        .                       {
        .                           window->SizeFull.x = size_auto_fit.x;
        .                           use_current_size_for_scrollbar_x = true;
        .                       }
        .                       if (!window_size_y_set_by_api)
        .                       {
        .                           window->SizeFull.y = size_auto_fit.y;
        .                           use_current_size_for_scrollbar_y = true;
        .                       }
        .                   }
   16,128 ( 0.00%)          else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        .                   {
        .                       // Auto-fit may only grow window during the first few frames
        .                       // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
        .                       if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
        .                       {
        .                           window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
        .                           use_current_size_for_scrollbar_x = true;
        .                       }
-- line 7144 ----------------------------------------
-- line 7147 ----------------------------------------
        .                           window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
        .                           use_current_size_for_scrollbar_y = true;
        .                       }
        .                       if (!window->Collapsed)
        .                           MarkIniSettingsDirty(window);
        .                   }
        .           
        .                   // Apply minimum/maximum window size constraints and final size
   18,144 ( 0.00%)          window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
  437,476 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowSizeAfterConstraint(ImGuiWindow*, ImVec2 const&) (2,016x)
   20,160 ( 0.00%)          window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
        .           
        .                   // POSITION
        .           
        .                   // Popup latch its initial position, will position itself when it appears next frame
    4,032 ( 0.00%)          if (window_just_activated_by_user)
        .                   {
       12 ( 0.00%)              window->AutoPosLastDirection = ImGuiDir_None;
       24 ( 0.00%)              if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
        .                           window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        .                   }
        .           
        .                   // Position child window
    8,064 ( 0.00%)          if (flags & ImGuiWindowFlags_ChildWindow)
        .                   {
    4,836 ( 0.00%)              IM_ASSERT(parent_window && parent_window->Active);
    3,224 ( 0.00%)              window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
    4,836 ( 0.00%)              parent_window->DC.ChildWindows.push_back(window);
   23,870 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::push_back(ImGuiWindow* const&) (806x)
    6,448 ( 0.00%)              if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
        .                           window->Pos = parent_window->DC.CursorPos;
        .                   }
        .           
   16,128 ( 0.00%)          const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
    4,032 ( 0.00%)          if (window_pos_with_pivot)
        .                       SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
    8,064 ( 0.00%)          else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
        .                       window->Pos = FindBestWindowPosForPopup(window);
    8,064 ( 0.00%)          else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
        .                       window->Pos = FindBestWindowPosForPopup(window);
    8,064 ( 0.00%)          else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
        .                       window->Pos = FindBestWindowPosForPopup(window);
        .           
        .                   // Late create viewport if we don't fit within our current host viewport.
   16,935 ( 0.00%)          if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_IsMinimized))
   18,538 ( 0.00%)              if (!window->Viewport->GetMainRect().Contains(window->Rect()))
   69,316 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (806x)
   69,316 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::Rect() const (806x)
   25,792 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Contains(ImRect const&) const (806x)
        .                       {
        .                           // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
        .                           //ImGuiViewport* old_viewport = window->Viewport;
        .                           window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
        .           
        .                           // FIXME-DPI
        .                           //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
        .                           SetCurrentViewport(window, window->Viewport);
        .                           window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
        .                           SetCurrentWindow(window);
        .                       }
        .           
    8,064 ( 0.00%)          if (window->ViewportOwned)
        5 ( 0.00%)              WindowSyncOwnedViewport(window, parent_window_in_stack);
      303 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::WindowSyncOwnedViewport(ImGuiWindow*, ImGuiWindow*) (1x)
        .           
        .                   // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
        .                   // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
   16,128 ( 0.00%)          ImRect viewport_rect(window->Viewport->GetMainRect());
  173,376 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (2,016x)
   16,128 ( 0.00%)          ImRect viewport_work_rect(window->Viewport->GetWorkRect());
  173,376 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetWorkRect() const (2,016x)
   18,144 ( 0.00%)          ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
   92,736 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImMax(ImVec2 const&, ImVec2 const&) (2,016x)
   42,336 ( 0.00%)          ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
   78,624 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2,016x)
   78,624 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (2,016x)
   32,256 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (2,016x)
        .           
        .                   // Clamp position/size so window stays visible within its viewport or monitor
        .                   // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        .                   // FIXME: Similar to code in GetWindowAllowedExtentRect()
    9,680 ( 0.00%)          if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
        .                   {
   10,083 ( 0.00%)              if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetWidth() const (403x)
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetHeight() const (403x)
        .                       {
    2,418 ( 0.00%)                  ClampWindowPos(window, visibility_rect);
   53,196 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ClampWindowPos(ImGuiWindow*, ImRect const&) (403x)
        .                       }
        8 ( 0.00%)              else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
        .                       {
        4 ( 0.00%)                  if (g.MovingWindow != NULL && window->RootWindowDockTree == g.MovingWindow->RootWindowDockTree)
        .                           {
        .                               // While moving windows we allow them to straddle monitors (#7299, #3071)
        .                               visibility_rect = g.PlatformMonitorsFullWorkRect;
        .                           }
        .                           else
        .                           {
        .                               // When not moving ensure visible in its monitor
        .                               // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
        5 ( 0.00%)                      const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
       49 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetViewportPlatformMonitor(ImGuiViewport*) (1x)
       20 ( 0.00%)                      visibility_rect = ImRect(monitor->WorkPos, monitor->WorkPos + monitor->WorkSize);
       39 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (1x)
       16 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (1x)
        .                           }
       10 ( 0.00%)                  visibility_rect.Expand(-visibility_padding);
       36 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&) (1x)
       35 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Expand(ImVec2 const&) (1x)
        5 ( 0.00%)                  ClampWindowPos(window, visibility_rect);
      132 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ClampWindowPos(ImGuiWindow*, ImRect const&) (1x)
        .                       }
        .                   }
   14,112 ( 0.00%)          window->Pos = ImTrunc(window->Pos);
   72,576 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(ImVec2 const&) (2,016x)
        .           
        .                   // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        .                   // Large values tend to lead to variety of artifacts and are not recommended.
   18,139 ( 0.00%)          if (window->ViewportOwned || window->DockIsActive)
    1,616 ( 0.00%)              window->WindowRounding = 0.0f;
        .                   else
   18,135 ( 0.00%)              window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
        .           
        .                   // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
        .                   //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
        .                   //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
        .           
        .                   // Apply window focus (new and reactivated windows are moved to front)
    2,016 ( 0.00%)          bool want_focus = false;
    4,056 ( 0.00%)          if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
        .                   {
       24 ( 0.00%)              if (flags & ImGuiWindowFlags_Popup)
        .                           want_focus = true;
       70 ( 0.00%)              else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
        5 ( 0.00%)                  want_focus = true;
        .                   }
        .           
        .                   // [Test Engine] Register whole window in the item system (before submitting further decorations)
        .           #ifdef IMGUI_ENABLE_TEST_ENGINE
        .                   if (g.TestEngineHookItems)
        .                   {
        .                       IM_ASSERT(window->IDStack.Size == 1);
        .                       window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
        .                       IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
        .                       IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
        .                       window->IDStack.Size = 1;
        .                   }
        .           #endif
        .           
        .                   // Decide if we are going to handle borders and resize grips
   23,393 ( 0.00%)          const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
        .           
        .                   // Handle manual resize: Resize Grips, Borders, Gamepad
    4,032 ( 0.00%)          int border_hovered = -1, border_held = -1;
    4,032 ( 0.00%)          ImU32 resize_grip_col[4] = {};
   21,370 ( 0.00%)          const int resize_grip_count = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
   40,320 ( 0.00%)          const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   12,097 ( 0.00%)          if (handle_borders_and_resize_grips && !window->Collapsed)
   24,195 ( 0.00%)              if (int auto_fit_mask = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
   45,580 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowManualResize(ImGuiWindow*, ImVec2 const&, int*, int*, int, unsigned int*, ImRect const&) (1,613x)
        .                       {
        .                           if (auto_fit_mask & (1 << ImGuiAxis_X))
        .                               use_current_size_for_scrollbar_x = true;
        .                           if (auto_fit_mask & (1 << ImGuiAxis_Y))
        .                               use_current_size_for_scrollbar_y = true;
        .                       }
    6,048 ( 0.00%)          window->ResizeBorderHovered = (signed char)border_hovered;
    6,048 ( 0.00%)          window->ResizeBorderHeld = (signed char)border_held;
        .           
        .                   // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
    8,064 ( 0.00%)          if (window->ViewportOwned)
        .                   {
        6 ( 0.00%)              if (!window->Viewport->PlatformRequestMove)
        5 ( 0.00%)                  window->Viewport->Pos = window->Pos;
        6 ( 0.00%)              if (!window->Viewport->PlatformRequestResize)
        5 ( 0.00%)                  window->Viewport->Size = window->Size;
        4 ( 0.00%)              window->Viewport->UpdateWorkRect();
      145 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::UpdateWorkRect() (1x)
        8 ( 0.00%)              viewport_rect = window->Viewport->GetMainRect();
       86 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (1x)
        .                   }
        .           
        .                   // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
   10,080 ( 0.00%)          window->ViewportPos = window->Viewport->Pos;
        .           
        .                   // SCROLLBAR VISIBILITY
        .           
        .                   // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
   10,080 ( 0.00%)          if (!window->Collapsed)
        .                   {
        .                       // When reading the current size we need to read it after size constraints have been applied.
        .                       // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
        .                       // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
   30,240 ( 0.00%)              ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   26,208 ( 0.00%)              ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
   78,624 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2,016x)
   76,608 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetSize() const (2,016x)
   36,234 ( 0.00%)              ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
   78,390 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2,010x)
       84 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (6x)
   68,340 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator*(ImVec2 const&, float) (2,010x)
    8,070 ( 0.00%)              float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
    8,070 ( 0.00%)              float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
        .                       //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
   20,160 ( 0.00%)              window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
   34,272 ( 0.00%)              window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
    8,064 ( 0.00%)              if (window->ScrollbarX && !window->ScrollbarY)
        .                           window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
   36,288 ( 0.00%)              window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
        .           
        .                       // Amend the partially filled window->DecorationXXX values.
   14,112 ( 0.00%)              window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
   14,112 ( 0.00%)              window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
        .                   }
        .           
        .                   // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
        .                   // Update various regions. Variables they depend on should be set above in this function.
        .                   // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
        .           
        .                   // Outer rectangle
        .                   // Not affected by window border size. Used by:
        .                   // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
        .                   // - Begin() initial clipping rect for drawing window background and borders.
        .                   // - Begin() clipping whole child
   26,204 ( 0.00%)          const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
   14,112 ( 0.00%)          const ImRect outer_rect = window->Rect();
  173,376 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::Rect() const (2,016x)
   14,112 ( 0.00%)          const ImRect title_bar_rect = window->TitleBarRect();
  175,416 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::TitleBarRect() const (2,016x)
   10,080 ( 0.00%)          window->OuterRectClipped = outer_rect;
   10,080 ( 0.00%)          if (window->DockIsActive)
    3,224 ( 0.00%)              window->OuterRectClipped.Min.y += window->TitleBarHeight();
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::TitleBarHeight() const (403x)
   12,096 ( 0.00%)          window->OuterRectClipped.ClipWith(host_rect);
  238,694 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ClipWith(ImRect const&) (2,016x)
        .           
        .                   // Inner rectangle
        .                   // Not affected by window border size. Used by:
        .                   // - InnerClipRect
        .                   // - ScrollToRectEx()
        .                   // - NavUpdatePageUpPageDown()
        .                   // - Scrollbar()
   14,112 ( 0.00%)          window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
   14,112 ( 0.00%)          window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
   20,160 ( 0.00%)          window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
   20,160 ( 0.00%)          window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
        .           
        .                   // Inner clipping rectangle.
        .                   // - Extend a outside of normal work region up to borders.
        .                   // - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
        .                   // - It also makes clipped items be more noticeable.
        .                   // - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
        .                   // - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        .                   // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        .                   // Affected by window/frame border size. Used by:
        .                   // - Begin() initial clip rect
   21,371 ( 0.00%)          float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
   26,208 ( 0.00%)          window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + window->WindowBorderSize);
   26,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,016x)
   22,176 ( 0.00%)          window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
   26,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,016x)
   26,208 ( 0.00%)          window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - window->WindowBorderSize);
   26,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,016x)
   26,208 ( 0.00%)          window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
   26,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(float) (2,016x)
   12,096 ( 0.00%)          window->InnerClipRect.ClipWithFull(host_rect);
  288,288 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ClipWithFull(ImRect const&) (2,016x)
        .           
        .                   // Default item width. Make it proportional to window size if window manually resizes
   26,208 ( 0.00%)          if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
   22,176 ( 0.00%)              window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);
   16,128 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(float) (2,016x)
        .                   else
        .                       window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);
        .           
        .                   // SCROLLING
        .           
        .                   // Lock down maximum scrolling
        .                   // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
        .                   // for right/bottom aligned items without creating a scrollbar.
   40,320 ( 0.00%)          window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   20,160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetWidth() const (2,016x)
   40,320 ( 0.00%)          window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   20,160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetHeight() const (2,016x)
        .           
        .                   // Apply scrolling
   12,096 ( 0.00%)          window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
  836,640 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow*) (2,016x)
   18,144 ( 0.00%)          window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   12,096 ( 0.00%)          window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
        .           
        .                   // DRAWING
        .           
        .                   // Setup draw list and outer clipping rectangle
   26,208 ( 0.00%)          IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
   44,352 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::operator[](int) (2,016x)
   18,144 ( 0.00%)          window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
  182,807 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PushTextureID(void*) (2,016x)
   14,112 ( 0.00%)          PushClipRect(host_rect.Min, host_rect.Max, false);
  587,706 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushClipRect(ImVec2 const&, ImVec2 const&, bool) (2,016x)
        .           
        .                   // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
        .                   // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
        .                   // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
   20,561 ( 0.00%)          const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
    4,032 ( 0.00%)          if (is_undocked_or_docked_visible)
        .                   {
    2,015 ( 0.00%)              bool render_decorations_in_parent = false;
   14,500 ( 0.00%)              if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
        .                       {
        .                           // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
        .                           // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
    4,830 ( 0.00%)                  ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
    3,220 ( 0.00%)                  bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
    4,830 ( 0.00%)                  bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
   13,285 ( 0.00%)                  if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)
   16,905 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::back() (805x)
      403 ( 0.00%)                      render_decorations_in_parent = true;
        .                       }
    4,030 ( 0.00%)              if (render_decorations_in_parent)
    1,612 ( 0.00%)                  window->DrawList = parent_window->DrawList;
        .           
        .                       // Handle title bar, scrollbar, resize grips and resize borders
   14,105 ( 0.00%)              const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
   28,791 ( 0.00%)              const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
   20,150 ( 0.00%)              RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
2,143,529 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowDecorations(ImGuiWindow*, ImRect const&, bool, bool, int, unsigned int const*, float) (2,015x)
        .           
    4,030 ( 0.00%)              if (render_decorations_in_parent)
    1,612 ( 0.00%)                  window->DrawList = &window->DrawListInst;
        .                   }
        .           
        .                   // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
        .           
        .                   // Work rectangle.
        .                   // Affected by window padding and border size. Used by:
        .                   // - Columns() for right-most edge
        .                   // - TreeNode(), CollapsingHeader() for right-most edge
        .                   // - BeginTabBar() for right-most edge
   16,936 ( 0.00%)          const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
   10,080 ( 0.00%)          const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
   56,448 ( 0.00%)          const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
   20,160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   58,868 ( 0.00%)          const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
   20,563 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   40,320 ( 0.00%)          window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   16,128 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(float) (2,016x)
   40,320 ( 0.00%)          window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
   22,176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,016x)
   16,128 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(float) (2,016x)
   10,080 ( 0.00%)          window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
   10,080 ( 0.00%)          window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
   12,096 ( 0.00%)          window->ParentWorkRect = window->WorkRect;
        .           
        .                   // [LEGACY] Content Region
        .                   // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        .                   // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
        .                   // Used by:
        .                   // - Mouse wheel scrolling + many other things
   26,208 ( 0.00%)          window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
   26,208 ( 0.00%)          window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
   50,400 ( 0.00%)          window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
   50,400 ( 0.00%)          window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
        .           
        .                   // Setup drawing context
        .                   // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
   20,160 ( 0.00%)          window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
    6,048 ( 0.00%)          window->DC.GroupOffset.x = 0.0f;
    6,048 ( 0.00%)          window->DC.ColumnsOffset.x = 0.0f;
        .           
        .                   // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
        .                   // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
   40,320 ( 0.00%)          double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
   32,256 ( 0.00%)          double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
   22,176 ( 0.00%)          window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   42,336 ( 0.00%)          window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
    8,064 ( 0.00%)          window->DC.CursorPos = window->DC.CursorStartPos;
    8,064 ( 0.00%)          window->DC.CursorPosPrevLine = window->DC.CursorPos;
    8,064 ( 0.00%)          window->DC.CursorMaxPos = window->DC.CursorStartPos;
    8,064 ( 0.00%)          window->DC.IdealMaxPos = window->DC.CursorStartPos;
   28,224 ( 0.00%)          window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   12,096 ( 0.00%)          window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
   10,080 ( 0.00%)          window->DC.IsSameLine = window->DC.IsSetPos = false;
        .           
    4,032 ( 0.00%)          window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    8,064 ( 0.00%)          window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
    4,032 ( 0.00%)          window->DC.NavLayersActiveMaskNext = 0x00;
    4,032 ( 0.00%)          window->DC.NavIsScrollPushableX = true;
    4,032 ( 0.00%)          window->DC.NavHideHighlightOneFrame = false;
   14,112 ( 0.00%)          window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);
        .           
    4,032 ( 0.00%)          window->DC.MenuBarAppending = false;
   18,144 ( 0.00%)          window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
  371,064 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGuiMenuColumns::Update(float, bool) (2,016x)
    4,032 ( 0.00%)          window->DC.TreeDepth = 0;
    4,032 ( 0.00%)          window->DC.TreeJumpToParentOnPopMask = 0x00;
   10,080 ( 0.00%)          window->DC.ChildWindows.resize(0);
   30,240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::resize(int) (2,016x)
    8,064 ( 0.00%)          window->DC.StateStorage = &window->StateStorage;
    4,032 ( 0.00%)          window->DC.CurrentColumns = NULL;
    4,032 ( 0.00%)          window->DC.LayoutType = ImGuiLayoutType_Vertical;
   11,692 ( 0.00%)          window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        .           
    8,064 ( 0.00%)          window->DC.ItemWidth = window->ItemWidthDefault;
    6,048 ( 0.00%)          window->DC.TextWrapPos = -1.0f; // disabled
   10,080 ( 0.00%)          window->DC.ItemWidthStack.resize(0);
   30,240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::resize(int) (2,016x)
   10,080 ( 0.00%)          window->DC.TextWrapPosStack.resize(0);
   30,240 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<float>::resize(int) (2,016x)
    8,064 ( 0.00%)          if (flags & ImGuiWindowFlags_Modal)
        .                       window->DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_ModalWindowDimBg));
        .           
    8,064 ( 0.00%)          if (window->AutoFitFramesX > 0)
        .                       window->AutoFitFramesX--;
    8,064 ( 0.00%)          if (window->AutoFitFramesY > 0)
        .                       window->AutoFitFramesY--;
        .           
        .                   // Clear SetNextWindowXXX data (can aim to move this higher in the function)
    8,064 ( 0.00%)          g.NextWindowData.ClearFlags();
   16,128 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiNextWindowData::ClearFlags() (2,016x)
        .           
        .                   // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        .                   // We ImGuiFocusRequestFlags_UnlessBelowModal to:
        .                   // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
        .                   // - Position window behind the modal that is not a begin-parent of this window.
    4,032 ( 0.00%)          if (want_focus)
       20 ( 0.00%)              FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
    2,322 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FocusWindow(ImGuiWindow*, int) (5x)
    4,057 ( 0.00%)          if (want_focus && window == g.NavWindow)
       20 ( 0.00%)              NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
    1,668 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavInitWindow(ImGuiWindow*, bool) (5x)
        .           
        .                   // Close requested by platform window (apply to all windows in this viewport)
   10,085 ( 0.00%)          if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
        .                   {
        .                       IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window->Name);
        .                       *p_open = false;
        .                       g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
        .                   }
        .           
        .                   // Title bar
   10,488 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
    8,888 ( 0.00%)              RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
2,304,257 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowTitleBarContents(ImGuiWindow*, ImRect const&, char const*, bool*) (404x)
   21,816 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(float, float, float, float) (404x)
        .           
        .                   // Clear hit test shape every frame
   10,080 ( 0.00%)          window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
        .           
        .                   // Pressing CTRL+C while holding on a window copy its content to the clipboard
        .                   // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        .                   // Maybe we can support CTRL+C on every element?
        .                   /*
        .                   //if (g.NavWindow == window && g.ActiveId == 0)
        .                   if (g.ActiveId == window->MoveId)
        .                       if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
        .                           LogToClipboard();
        .                   */
        .           
   10,080 ( 0.00%)          if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
        .                   {
        .                       // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
        .                       // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
   10,080 ( 0.00%)              if (g.MovingWindow == window && (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
        .                           BeginDockableDragDropSource(window);
        .           
        .                       // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
    8,064 ( 0.00%)              if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
        .                           if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
        .                               if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
        .                                   BeginDockableDragDropTarget(window);
        .                   }
        .           
        .                   // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        .                   // This is useful to allow creating context menus on title bar only, etc.
   10,080 ( 0.00%)          SetLastItemDataForWindow(window, title_bar_rect);
  255,575 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetLastItemDataForWindow(ImGuiWindow*, ImRect const&) (2,016x)
        .           
        .                   // [DEBUG]
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    8,064 ( 0.00%)          if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
        .                       DebugLocateItemResolveWithLastItem();
        .           #endif
        .           
        .                   // [Test Engine] Register title bar / tab with MoveId.
        .           #ifdef IMGUI_ENABLE_TEST_ENGINE
        .                   if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
        .                       IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
        .           #endif
    2,016 ( 0.00%)      }
        .               else
        .               {
        .                   // Skip refresh always mark active
        .                   if (window->SkipRefresh)
        .                       window->Active = true;
        .           
        .                   // Append
        .                   SetCurrentViewport(window, window->Viewport);
        .                   SetCurrentWindow(window);
        .                   g.NextWindowData.ClearFlags();
        .                   SetLastItemDataForWindow(window, window->TitleBarRect());
        .               }
        .           
   16,129 ( 0.00%)      if (!(flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)
   12,904 ( 0.00%)          PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
  620,272 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushClipRect(ImVec2 const&, ImVec2 const&, bool) (1,613x)
        .           
        .               // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    4,032 ( 0.00%)      window->WriteAccessed = false;
    8,064 ( 0.00%)      window->BeginCount++;
        .           
        .               // Update visibility
   14,112 ( 0.00%)      if (first_begin_of_the_frame && !window->SkipRefresh)
        .               {
        .                   // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
        .                   // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
        .                   // This is analogous to regular windows being hidden from one frame.
        .                   // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
   12,901 ( 0.00%)          if (window->DockIsActive && !window->DockTabIsVisible)
        .                   {
        6 ( 0.00%)              if (window->LastFrameJustFocused == g.FrameCount)
        3 ( 0.00%)                  window->HiddenFramesCannotSkipItems = 1;
        .                       else
        .                           window->HiddenFramesCanSkipItems = 1;
        .                   }
        .           
   11,288 ( 0.00%)          if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_ChildMenu))
        .                   {
        .                       // Child window can be out of sight and have "negative" clip windows.
        .                       // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
    3,224 ( 0.00%)              IM_ASSERT((flags& ImGuiWindowFlags_NoTitleBar) != 0 || window->DockIsActive);
    4,836 ( 0.00%)              const bool nav_request = (flags & ImGuiWindowFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
    7,254 ( 0.00%)              if (!g.LogEnabled && !nav_request)
    9,672 ( 0.00%)                  if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
        .                           {
        .                               if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        .                                   window->HiddenFramesCannotSkipItems = 1;
        .                               else
        .                                   window->HiddenFramesCanSkipItems = 1;
        .                           }
        .           
        .                       // Hide along with parent or if parent is collapsed
    8,060 ( 0.00%)              if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
        .                           window->HiddenFramesCanSkipItems = 1;
    8,060 ( 0.00%)              if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
        .                           window->HiddenFramesCannotSkipItems = 1;
        .                   }
        .           
        .                   // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
   10,080 ( 0.00%)          if (style.Alpha <= 0.0f)
        .                       window->HiddenFramesCanSkipItems = 1;
        .           
        .                   // Update the Hidden flag
   20,163 ( 0.00%)          bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
   18,135 ( 0.00%)          window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
        .           
        .                   // Disable inputs for requested number of frames
    8,064 ( 0.00%)          if (window->DisableInputsFrames > 0)
        .                   {
        .                       window->DisableInputsFrames--;
        .                       window->Flags |= ImGuiWindowFlags_NoInputs;
        .                   }
        .           
        .                   // Update the SkipItems flag, used to early out of all items functions (no layout required)
    2,016 ( 0.00%)          bool skip_items = false;
   22,176 ( 0.00%)          if (window->Collapsed || !window->Active || hidden_regular)
       36 ( 0.00%)              if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
        .                           skip_items = true;
    6,048 ( 0.00%)          window->SkipItems = skip_items;
        .           
        .                   // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
    8,064 ( 0.00%)          if (window->SkipItems)
        .                       window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
        .           
        .                   // Sanity check: there are two spots which can set Appearing = true
        .                   // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
        .                   // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
    8,064 ( 0.00%)          if (window->SkipItems && !window->Appearing)
        .                       IM_ASSERT(window->Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
    2,016 ( 0.00%)      }
        .               else if (first_begin_of_the_frame)
        .               {
        .                   // Skip refresh mode
        .                   window->SkipItems = true;
        .               }
        .           
        .               // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
        .               // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
   10,080 ( 0.00%)      if (!window->IsFallbackWindow)
   12,904 ( 0.00%)          if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size))
        .                   {
        .                       if (window->AutoFitFramesX > 0) { window->AutoFitFramesX++; }
        .                       if (window->AutoFitFramesY > 0) { window->AutoFitFramesY++; }
        .                       return false;
        .                   }
        .           #endif
        .           
    6,048 ( 0.00%)      return !window->SkipItems;
   10,080 ( 0.00%)  }
        .           
        .           static void ImGui::SetLastItemDataForWindow(ImGuiWindow* window, const ImRect& rect)
   10,080 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
   10,080 ( 0.00%)      if (window->DockIsActive)
    4,030 ( 0.00%)          SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
   13,299 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetLastItemData(unsigned int, int, int, ImRect const&) (403x)
        .               else
   30,647 ( 0.00%)          SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, rect);
  123,727 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsMouseHoveringRect(ImVec2 const&, ImVec2 const&, bool) (1,613x)
   53,229 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetLastItemData(unsigned int, int, int, ImRect const&) (1,613x)
    6,451 ( 0.00%)  }
        .           
        .           void ImGui::End()
   10,080 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,048 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
        .               // Error checking: verify that user hasn't called End() too many times!
    9,676 ( 0.00%)      if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
        .                   return;
        .               }
    8,064 ( 0.00%)      IM_ASSERT(g.CurrentWindowStack.Size > 0);
        .           
        .               // Error checking: verify that user doesn't directly call End() on a child window.
   16,528 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
        .                   IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
        .           
        .               // Close anything that is open
    8,064 ( 0.00%)      if (window->DC.CurrentColumns)
        .                   EndColumns();
   18,145 ( 0.00%)      if (!(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)   // Pop inner window clip rectangle
    1,613 ( 0.00%)          PopClipRect();
  361,352 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PopClipRect() (1,613x)
    2,016 ( 0.00%)      PopFocusScope();
  115,723 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PopFocusScope() (2,016x)
        .           
    8,064 ( 0.00%)      if (window->SkipRefresh)
        .               {
        .                   IM_ASSERT(window->DrawList == NULL);
        .                   window->DrawList = &window->DrawListInst;
        .               }
        .           
        .               // Stop logging
   10,080 ( 0.00%)      if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
    1,210 ( 0.00%)          LogFinish();
   15,730 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LogFinish() (1,210x)
        .           
    8,064 ( 0.00%)      if (window->DC.IsSetPos)
        .                   ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
        .           
        .               // Docking: report contents sizes to parent to allow for auto-resize
   10,482 ( 0.00%)      if (window->DockNode && window->DockTabIsVisible)
    2,412 ( 0.00%)          if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
    7,236 ( 0.00%)              host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
   15,678 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (402x)
   15,678 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (402x)
        .           
        .               // Pop from window stack
   26,208 ( 0.00%)      g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
   46,368 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::back() (2,016x)
   10,080 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_ChildMenu)
        .                   g.BeginMenuDepth--;
   10,080 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_Popup)
        .                   g.BeginPopupStack.pop_back();
   18,144 ( 0.00%)      g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithContextState(&g);
  151,200 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStackSizes::CompareWithContextState(ImGuiContext*) (2,016x)
   46,368 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::back() (2,016x)
    8,064 ( 0.00%)      g.CurrentWindowStack.pop_back();
   32,256 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::pop_back() (2,016x)
   22,177 ( 0.00%)      SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
  135,889 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetCurrentWindow(ImGuiWindow*) (2,016x)
   37,099 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindowStackData>::back() (1,613x)
    8,064 ( 0.00%)      if (g.CurrentWindow)
   14,517 ( 0.00%)          SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
   32,277 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetCurrentViewport(ImGuiWindow*, ImGuiViewportP*) (1,613x)
   10,080 ( 0.00%)  }
        .           
        .           void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
       35 ( 0.00%)  {
       14 ( 0.00%)      ImGuiContext& g = *GImGui;
       28 ( 0.00%)      IM_ASSERT(window == window->RootWindow);
        .           
       28 ( 0.00%)      const int cur_order = window->FocusOrder;
       63 ( 0.00%)      IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
      133 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (7x)
       63 ( 0.00%)      if (g.WindowsFocusOrder.back() == window)
      126 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::back() (7x)
        6 ( 0.00%)          return;
        .           
        4 ( 0.00%)      const int new_order = g.WindowsFocusOrder.Size - 1;
       10 ( 0.00%)      for (int n = cur_order; n < new_order; n++)
        .               {
       15 ( 0.00%)          g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
       38 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (2x)
       10 ( 0.00%)          g.WindowsFocusOrder[n]->FocusOrder--;
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (1x)
       11 ( 0.00%)          IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (1x)
        .               }
        8 ( 0.00%)      g.WindowsFocusOrder[new_order] = window;
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (1x)
        5 ( 0.00%)      window->FocusOrder = (short)new_order;
       21 ( 0.00%)  }
        .           
        .           void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
       30 ( 0.00%)  {
       10 ( 0.00%)      ImGuiContext& g = *GImGui;
       30 ( 0.00%)      ImGuiWindow* current_front_window = g.Windows.back();
       90 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::back() (5x)
       15 ( 0.00%)      if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
        5 ( 0.00%)          return;
        .               for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
        .                   if (g.Windows[i] == window)
        .                   {
        .                       memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
        .                       g.Windows[g.Windows.Size - 1] = window;
        .                       break;
        .                   }
       25 ( 0.00%)  }
        .           
        .           void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.Windows[0] == window)
        .                   return;
        .               for (int i = 0; i < g.Windows.Size; i++)
        .                   if (g.Windows[i] == window)
-- line 7791 ----------------------------------------
-- line 7821 ----------------------------------------
        .           int ImGui::FindWindowDisplayIndex(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return g.Windows.index_from_ptr(g.Windows.find(window));
        .           }
        .           
        .           // Moving window to front of display and set focus (which happens to be back of our sorted list)
        .           void ImGui::FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags)
       35 ( 0.00%)  {
       14 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Modal check?
       48 ( 0.00%)      if ((flags & ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window)) // Early out in common case.
       30 ( 0.00%)          if (ImGuiWindow* blocking_modal = FindBlockingModal(window))
       70 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindBlockingModal(ImGuiWindow*) (5x)
        .                   {
        .                       IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window->Name : "<NULL>", blocking_modal->Name);
        .                       if (window && window == window->RootWindow && (window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
        .                           BringWindowToDisplayBehind(window, blocking_modal); // Still bring to right below modal.
        .                       return;
        .                   }
        .           
        .               // Find last focused child (if any) and focus it instead.
       28 ( 0.00%)      if ((flags & ImGuiFocusRequestFlags_RestoreFocusedChild) && window != NULL)
        .                   window = NavRestoreLastChildNavWindow(window);
        .           
        .               // Apply focus
       28 ( 0.00%)      if (g.NavWindow != window)
        .               {
       18 ( 0.00%)          SetNavWindow(window);
      342 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavWindow(ImGuiWindow*) (6x)
       36 ( 0.00%)          if (window && g.NavDisableMouseHover)
        .                       g.NavMousePosDirty = true;
       42 ( 0.00%)          g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
       12 ( 0.00%)          g.NavLayer = ImGuiNavLayer_Main;
       42 ( 0.00%)          SetNavFocusScope(window ? window->NavRootFocusScopeId : 0);
      895 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavFocusScope(unsigned int) (6x)
       12 ( 0.00%)          g.NavIdIsAlive = false;
       12 ( 0.00%)          g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        .           
        .                   // Close popups if any
       24 ( 0.00%)          ClosePopupsOverWindow(window, false);
       90 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ClosePopupsOverWindow(ImGuiWindow*, bool) (6x)
        .               }
        .           
        .               // Move the root window to the top of the pile
       42 ( 0.00%)      IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
       42 ( 0.00%)      ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
       42 ( 0.00%)      ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
       42 ( 0.00%)      ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
       42 ( 0.00%)      bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
        .           
        .               // Steal active widgets. Some of the cases it triggers includes:
        .               // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
        .               // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
        .               // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
       28 ( 0.00%)      if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
        .                   if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
        .                       ClearActiveID();
        .           
        .               // Passing NULL allow to disable keyboard focus
       14 ( 0.00%)      if (!window)
        .                   return;
       28 ( 0.00%)      window->LastFrameJustFocused = g.FrameCount;
        .           
        .               // Select in dock node
        .               // For #2304 we avoid applying focus immediately before the tabbar is visible.
        .               //if (dock_node && dock_node->TabBar)
        .               //    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
        .           
        .               // Bring to front
       21 ( 0.00%)      BringWindowToFocusFront(focus_front_window);
      675 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BringWindowToFocusFront(ImGuiWindow*) (7x)
       77 ( 0.00%)      if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
       12 ( 0.00%)          BringWindowToDisplayFront(display_front_window);
      123 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BringWindowToDisplayFront(ImGuiWindow*) (3x)
       14 ( 0.00%)  }
        .           
        .           void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window, ImGuiViewport* filter_viewport, ImGuiFocusRequestFlags flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               int start_idx = g.WindowsFocusOrder.Size - 1;
        .               if (under_this_window != NULL)
        .               {
        .                   // Aim at root window behind us, if we are in a child window that's our own root (see #4640)
-- line 7899 ----------------------------------------
-- line 7924 ----------------------------------------
        .                       return;
        .                   }
        .               }
        .               FocusWindow(NULL, flags);
        .           }
        .           
        .           // Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
        .           void ImGui::SetCurrentFont(ImFont* font)
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,821 ( 0.00%)      IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFont::IsLoaded() const (403x)
    2,015 ( 0.00%)      IM_ASSERT(font->Scale > 0.0f);
    1,209 ( 0.00%)      g.Font = font;
    6,851 ( 0.00%)      g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (403x)
    2,821 ( 0.00%)      g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
        .           
    1,612 ( 0.00%)      ImFontAtlas* atlas = g.Font->ContainerAtlas;
    1,612 ( 0.00%)      g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    1,612 ( 0.00%)      g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
    1,612 ( 0.00%)      g.DrawListSharedData.Font = g.Font;
    1,612 ( 0.00%)      g.DrawListSharedData.FontSize = g.FontSize;
    1,209 ( 0.00%)  }
        .           
        .           void ImGui::PushFont(ImFont* font)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (!font)
        .                   font = GetDefaultFont();
        .               SetCurrentFont(font);
        .               g.FontStack.push_back(font);
-- line 7953 ----------------------------------------
-- line 8047 ----------------------------------------
        .           void ImGui::PopTextWrapPos()
        .           {
        .               ImGuiWindow* window = GetCurrentWindow();
        .               window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
        .               window->DC.TextWrapPosStack.pop_back();
        .           }
        .           
        .           static ImGuiWindow* GetCombinedRootWindow(ImGuiWindow* window, bool popup_hierarchy, bool dock_hierarchy)
    1,344 ( 0.00%)  {
      168 ( 0.00%)      ImGuiWindow* last_window = NULL;
    1,680 ( 0.00%)      while (last_window != window)
        .               {
      672 ( 0.00%)          last_window = window;
    1,008 ( 0.00%)          window = window->RootWindow;
      672 ( 0.00%)          if (popup_hierarchy)
        .                       window = window->RootWindowPopupTree;
      672 ( 0.00%)  		if (dock_hierarchy)
    1,008 ( 0.00%)  			window = window->RootWindowDockTree;
        .           	}
      168 ( 0.00%)      return window;
      336 ( 0.00%)  }
        .           
        .           bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy, bool dock_hierarchy)
    1,344 ( 0.00%)  {
    1,176 ( 0.00%)      ImGuiWindow* window_root = GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy);
    7,728 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:GetCombinedRootWindow(ImGuiWindow*, bool, bool) (168x)
      504 ( 0.00%)      if (window_root == potential_parent)
        .                   return true;
      670 ( 0.00%)      while (window != NULL)
        .               {
    1,005 ( 0.00%)          if (window == potential_parent)
      336 ( 0.00%)              return true;
      501 ( 0.00%)          if (window == window_root) // end of chain
        .                       return false;
      501 ( 0.00%)          window = window->ParentWindow;
        .               }
        .               return false;
      336 ( 0.00%)  }
        .           
        .           bool ImGui::IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
        .           {
        .               if (window->RootWindow == potential_parent)
        .                   return true;
        .               while (window != NULL)
        .               {
        .                   if (window == potential_parent)
-- line 8091 ----------------------------------------
-- line 8216 ----------------------------------------
        .           
        .           float ImGui::GetWindowHeight()
        .           {
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->Size.y;
        .           }
        .           
        .           ImVec2 ImGui::GetWindowPos()
    2,418 ( 0.00%)  {
    2,418 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,627 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    2,418 ( 0.00%)      return window->Pos;
    3,627 ( 0.00%)  }
        .           
        .           void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
   11,284 ( 0.00%)  {
        .               // Test condition (NB: bit 0 is always true) and clear flags for next time
   12,896 ( 0.00%)      if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        .                   return;
        .           
   11,284 ( 0.00%)      IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
   22,568 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImIsPowerOfTwo(int) (1,612x)
    9,672 ( 0.00%)      window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
   14,508 ( 0.00%)      window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
   22,568 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1,612x)
        .           
        .               // Set
    4,836 ( 0.00%)      const ImVec2 old_pos = window->Pos;
    9,672 ( 0.00%)      window->Pos = ImTrunc(pos);
   58,032 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(ImVec2 const&) (1,612x)
   12,896 ( 0.00%)      ImVec2 offset = window->Pos - old_pos;
   62,868 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (1,612x)
   22,554 ( 0.00%)      if (offset.x == 0.0f && offset.y == 0.0f)
    1,610 ( 0.00%)          return;
        6 ( 0.00%)      MarkIniSettingsDirty(window);
       26 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MarkIniSettingsDirty(ImGuiWindow*) (2x)
        .               // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
       12 ( 0.00%)      window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (2x)
       12 ( 0.00%)      window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (2x)
       12 ( 0.00%)      window->DC.IdealMaxPos += offset;
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (2x)
       14 ( 0.00%)      window->DC.CursorStartPos += offset;
       42 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (2x)
    4,836 ( 0.00%)  }
        .           
        .           void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               SetWindowPos(window, pos, cond);
        .           }
        .           
        .           void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
-- line 8260 ----------------------------------------
-- line 8265 ----------------------------------------
        .           
        .           ImVec2 ImGui::GetWindowSize()
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               return window->Size;
        .           }
        .           
        .           void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
   12,090 ( 0.00%)  {
        .               // Test condition (NB: bit 0 is always true) and clear flags for next time
   16,120 ( 0.00%)      if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
      403 ( 0.00%)          return;
        .           
   11,284 ( 0.00%)      IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
   22,568 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImIsPowerOfTwo(int) (1,612x)
    9,672 ( 0.00%)      window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        .           
        .               // Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
   15,304 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
    6,464 ( 0.00%)          window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
   15,304 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
    6,464 ( 0.00%)          window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
        .           
        .               // Set
    4,836 ( 0.00%)      ImVec2 old_size = window->SizeFull;
    8,060 ( 0.00%)      if (size.x <= 0.0f)
        .                   window->AutoFitOnlyGrows = false;
        .               else
    9,672 ( 0.00%)          window->SizeFull.x = IM_TRUNC(size.x);
    8,060 ( 0.00%)      if (size.y <= 0.0f)
        .                   window->AutoFitOnlyGrows = false;
        .               else
    9,672 ( 0.00%)          window->SizeFull.y = IM_TRUNC(size.y);
   22,554 ( 0.00%)      if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
        8 ( 0.00%)          MarkIniSettingsDirty(window);
       26 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MarkIniSettingsDirty(ImGuiWindow*) (2x)
    4,030 ( 0.00%)  }
        .           
        .           void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
        .           {
        .               SetWindowSize(GImGui->CurrentWindow, size, cond);
        .           }
        .           
        .           void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
        .           {
-- line 8307 ----------------------------------------
-- line 8370 ----------------------------------------
        .               }
        .               else
        .               {
        .                   FocusWindow(NULL);
        .               }
        .           }
        .           
        .           void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
    9,672 ( 0.00%)  {
    3,224 ( 0.00%)      ImGuiContext& g = *GImGui;
    5,239 ( 0.00%)      IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImIsPowerOfTwo(int) (403x)
    9,672 ( 0.00%)      g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
    6,448 ( 0.00%)      g.NextWindowData.PosVal = pos;
    6,448 ( 0.00%)      g.NextWindowData.PosPivotVal = pivot;
    8,463 ( 0.00%)      g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
    3,224 ( 0.00%)      g.NextWindowData.PosUndock = true;
    4,836 ( 0.00%)  }
        .           
        .           void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
   10,075 ( 0.00%)  {
    4,030 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,060 ( 0.00%)      IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
   11,284 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImIsPowerOfTwo(int) (806x)
   12,090 ( 0.00%)      g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
    8,060 ( 0.00%)      g.NextWindowData.SizeVal = size;
   10,881 ( 0.00%)      g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
    6,045 ( 0.00%)  }
        .           
        .           // For each axis:
        .           // - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
        .           // - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
        .           // - See "Demo->Examples->Constrained-resizing window" for examples.
        .           void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
        .           {
        .               ImGuiContext& g = *GImGui;
-- line 8403 ----------------------------------------
-- line 8441 ----------------------------------------
        .           void ImGui::SetNextWindowBgAlpha(float alpha)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
        .               g.NextWindowData.BgAlphaVal = alpha;
        .           }
        .           
        .           void ImGui::SetNextWindowViewport(ImGuiID id)
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,418 ( 0.00%)      g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;
    1,209 ( 0.00%)      g.NextWindowData.ViewportId = id;
    1,209 ( 0.00%)  }
        .           
        .           void ImGui::SetNextWindowDockID(ImGuiID id, ImGuiCond cond)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasDock;
        .               g.NextWindowData.DockCond = cond ? cond : ImGuiCond_Always;
        .               g.NextWindowData.DockId = id;
        .           }
-- line 8461 ----------------------------------------
-- line 8515 ----------------------------------------
        .               IM_ASSERT(scale > 0.0f);
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = GetCurrentWindow();
        .               window->FontWindowScale = scale;
        .               g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
        .           }
        .           
        .           void ImGui::PushFocusScope(ImGuiID id)
    8,064 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiFocusScopeData data;
    4,032 ( 0.00%)      data.ID = id;
    8,064 ( 0.00%)      data.WindowID = g.CurrentWindow->ID;
   12,096 ( 0.00%)      g.FocusScopeStack.push_back(data);
   58,639 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiFocusScopeData>::push_back(ImGuiFocusScopeData const&) (2,016x)
    6,048 ( 0.00%)      g.CurrentFocusScopeId = id;
    6,048 ( 0.00%)  }
        .           
        .           void ImGui::PopFocusScope()
    6,048 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,064 ( 0.00%)      if (g.FocusScopeStack.Size == 0)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.FocusScopeStack.Size > 0, "Calling PopFocusScope() too many times!");
        .                   return;
        .               }
    8,064 ( 0.00%)      g.FocusScopeStack.pop_back();
   32,256 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiFocusScopeData>::pop_back() (2,016x)
   24,193 ( 0.00%)      g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back().ID : 0;
   29,034 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiFocusScopeData>::back() (1,613x)
    4,032 ( 0.00%)  }
        .           
        .           void ImGui::SetNavFocusScope(ImGuiID focus_scope_id)
       44 ( 0.00%)  {
       22 ( 0.00%)      ImGuiContext& g = *GImGui;
       33 ( 0.00%)      g.NavFocusScopeId = focus_scope_id;
       55 ( 0.00%)      g.NavFocusRoute.resize(0); // Invalidate
      165 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiFocusScopeData>::resize(int) (11x)
       22 ( 0.00%)      if (focus_scope_id == 0)
        .                   return;
       44 ( 0.00%)      IM_ASSERT(g.NavWindow != NULL);
        .           
        .               // Store current path (in reverse order)
       44 ( 0.00%)      if (focus_scope_id == g.CurrentFocusScopeId)
        .               {
        .                   // Top of focus stack contains local focus scopes inside current window
      324 ( 0.00%)          for (int n = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow->ID; n--)
      110 ( 0.00%)              g.NavFocusRoute.push_back(g.FocusScopeStack.Data[n]);
      465 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiFocusScopeData>::push_back(ImGuiFocusScopeData const&) (10x)
        .               }
        5 ( 0.00%)      else if (focus_scope_id == g.NavWindow->NavRootFocusScopeId)
       12 ( 0.00%)          g.NavFocusRoute.push_back({ focus_scope_id, g.NavWindow->ID });
       29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiFocusScopeData>::push_back(ImGuiFocusScopeData const&) (1x)
        .               else
        .                   return;
        .           
        .               // Then follow on manually set ParentWindowForFocusRoute field (#6798)
       77 ( 0.00%)      for (ImGuiWindow* window = g.NavWindow->ParentWindowForFocusRoute; window != NULL; window = window->ParentWindowForFocusRoute)
        .                   g.NavFocusRoute.push_back({ window->NavRootFocusScopeId, window->ID });
       44 ( 0.00%)      IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
       22 ( 0.00%)  }
        .           
        .           // Focus = move navigation cursor, set scrolling, set focus window.
        .           void ImGui::FocusItem()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               IMGUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window->Name);
        .               if (g.DragDropActive || g.MovingWindow != NULL) // FIXME: Opt-in flags for this?
-- line 8577 ----------------------------------------
-- line 8673 ----------------------------------------
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ID STACK
        .           //-----------------------------------------------------------------------------
        .           
        .           // This is one of the very rare legacy case where we use ImGuiWindow methods,
        .           // it should ideally be flattened at some point but it's been used a lots by widgets.
        .           ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
   55,698 ( 0.00%)  {
   55,698 ( 0.00%)      ImGuiID seed = IDStack.back();
  167,094 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::back() (9,283x)
   83,547 ( 0.00%)      ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
1,875,595 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (9,283x)
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
   27,849 ( 0.00%)      ImGuiContext& g = *Ctx;
   37,132 ( 0.00%)      if (g.DebugHookIdInfo == id)
        .                   ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
        .           #endif
    9,283 ( 0.00%)      return id;
   18,566 ( 0.00%)  }
        .           
        .           ImGuiID ImGuiWindow::GetID(const void* ptr)
        .           {
        .               ImGuiID seed = IDStack.back();
        .               ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        .               ImGuiContext& g = *Ctx;
        .               if (g.DebugHookIdInfo == id)
-- line 8698 ----------------------------------------
-- line 8718 ----------------------------------------
        .           {
        .               ImGuiID seed = IDStack.back();
        .               ImRect r_rel = ImGui::WindowRectAbsToRel(this, r_abs);
        .               ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
        .               return id;
        .           }
        .           
        .           void ImGui::PushID(const char* str_id)
   11,284 ( 0.00%)  {
    5,642 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,463 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
   19,747 ( 0.00%)      ImGuiID id = window->GetID(str_id);
  801,164 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (2,821x)
   16,926 ( 0.00%)      window->IDStack.push_back(id);
   81,809 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::push_back(unsigned int const&) (2,821x)
    8,463 ( 0.00%)  }
        .           
        .           void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               ImGuiID id = window->GetID(str_id_begin, str_id_end);
        .               window->IDStack.push_back(id);
        .           }
-- line 8739 ----------------------------------------
-- line 8787 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               if (g.DebugHookIdInfo == id)
        .                   DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
        .           #endif
        .               return id;
        .           }
        .           
        .           void ImGui::PopID()
    8,463 ( 0.00%)  {
    8,463 ( 0.00%)      ImGuiWindow* window = GImGui->CurrentWindow;
   11,284 ( 0.00%)      IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
   11,284 ( 0.00%)      window->IDStack.pop_back();
   45,136 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned int>::pop_back() (2,821x)
    8,463 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::GetID(const char* str_id)
    1,612 ( 0.00%)  {
    1,209 ( 0.00%)      ImGuiWindow* window = GImGui->CurrentWindow;
    2,418 ( 0.00%)      return window->GetID(str_id);
  116,467 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (403x)
      806 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
        .           {
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->GetID(str_id_begin, str_id_end);
        .           }
        .           
        .           ImGuiID ImGui::GetID(const void* ptr_id)
-- line 8813 ----------------------------------------
-- line 8876 ----------------------------------------
        .           // - GetKeyOwner() [Internal]
        .           // - TestKeyOwner() [Internal]
        .           // - SetKeyOwner() [Internal]
        .           // - SetItemKeyOwner() [Internal]
        .           // - Shortcut() [Internal]
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiKeyChord ImGui::FixupKeyChord(ImGuiContext* ctx, ImGuiKeyChord key_chord)
    8,060 ( 0.00%)  {
        .               // Convert ImGuiMod_Shortcut and add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
    4,836 ( 0.00%)      ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    8,060 ( 0.00%)      if (IsModKey(key))
   12,896 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsModKey(ImGuiKey) (1,612x)
        .               {
        .                   if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)
        .                       key_chord |= ImGuiMod_Ctrl;
        .                   if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)
        .                       key_chord |= ImGuiMod_Shift;
        .                   if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)
        .                       key_chord |= ImGuiMod_Alt;
        .                   if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)
        .                       key_chord |= ImGuiMod_Super;
        .               }
    6,448 ( 0.00%)      if (key_chord & ImGuiMod_Shortcut)
        .                   return (key_chord & ~ImGuiMod_Shortcut) | (ctx->IO.ConfigMacOSXBehaviors ? ImGuiMod_Super : ImGuiMod_Ctrl);
    1,612 ( 0.00%)      return key_chord;
    3,224 ( 0.00%)  }
        .           
        .           ImGuiKeyData* ImGui::GetKeyData(ImGuiContext* ctx, ImGuiKey key)
   50,370 ( 0.00%)  {
   20,148 ( 0.00%)      ImGuiContext& g = *ctx;
        .           
        .               // Special storage location for mods
   40,296 ( 0.00%)      if (key & ImGuiMod_Mask_)
   26,976 ( 0.00%)          key = ConvertSingleModFlagToKey(ctx, key);
   67,440 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::ConvertSingleModFlagToKey(ImGuiContext*, ImGuiKey) (4,496x)
        .           
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
   40,296 ( 0.00%)      IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
   80,856 ( 0.00%)      if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
  100,773 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsLegacyKey(ImGuiKey) (10,074x)
      198 ( 0.00%)          key = (ImGuiKey)g.IO.KeyMap[key];  // Remap native->imgui or imgui->native
        .           #else
        .               IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
        .           #endif
   80,592 ( 0.00%)      return &g.IO.KeysData[key - ImGuiKey_KeysData_OFFSET];
   20,148 ( 0.00%)  }
        .           
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        .           ImGuiKey ImGui::GetKeyIndex(ImGuiKey key)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(IsNamedKey(key));
        .               const ImGuiKeyData* key_data = GetKeyData(key);
        .               return (ImGuiKey)(key_data - g.IO.KeysData);
-- line 8927 ----------------------------------------
-- line 9042 ----------------------------------------
        .                   GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
        .           }
        .           
        .           // Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
        .           //   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
        .           //   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
        .           // See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
        .           static void ImGui::UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt)
    2,015 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      rt->EntriesNext.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiKeyRoutingData>::resize(int) (403x)
  187,798 ( 0.00%)      for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
        .               {
  186,186 ( 0.00%)          const int new_routing_start_idx = rt->EntriesNext.Size;
        .                   ImGuiKeyRoutingData* routing_entry;
  620,620 ( 0.00%)          for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
        .                   {
        .                       routing_entry = &rt->Entries[old_routing_idx];
        .                       routing_entry->RoutingCurrScore = routing_entry->RoutingNextScore;
        .                       routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
        .                       routing_entry->RoutingNext = ImGuiKeyOwner_None;
        .                       routing_entry->RoutingNextScore = 255;
        .                       if (routing_entry->RoutingCurr == ImGuiKeyOwner_None)
        .                           continue;
-- line 9065 ----------------------------------------
-- line 9074 ----------------------------------------
        .                           {
        .                               owner_data->OwnerCurr = routing_entry->RoutingCurr;
        .                               //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
        .                           }
        .                       }
        .                   }
        .           
        .                   // Rewrite linked-list
  620,620 ( 0.00%)          rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
  434,434 ( 0.00%)          for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
        .                       rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
        .               }
    2,821 ( 0.00%)      rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
   14,911 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiKeyRoutingData>::swap(ImVector<ImGuiKeyRoutingData>&) (403x)
    1,612 ( 0.00%)  }
        .           
        .           // owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
        .           static inline ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return (owner_id != ImGuiKeyOwner_None && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;
        .           }
        .           
-- line 9095 ----------------------------------------
-- line 9191 ----------------------------------------
        .           }
        .           
        .           // Request a desired route for an input chord (key + mods).
        .           // Return true if the route is available this frame.
        .           // - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
        .           //   (Conceptually this does a "Submit for next frame" + "Test for current frame".
        .           //   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
        .           bool ImGui::SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
    4,836 ( 0.00%)  {
    1,612 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,224 ( 0.00%)      if ((flags & ImGuiInputFlags_RouteMask_) == 0)
        .                   flags |= ImGuiInputFlags_RouteGlobalHigh; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
        .               else
    4,836 ( 0.00%)          IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)); // Check that only 1 routing flag is used
   11,284 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImIsPowerOfTwo(int) (806x)
    3,224 ( 0.00%)      IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_None);
        .           
        .               // Convert ImGuiMod_Shortcut and add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
    4,836 ( 0.00%)      key_chord = FixupKeyChord(&g, key_chord);
   22,568 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FixupKeyChord(ImGuiContext*, int) (806x)
        .           
        .               // [DEBUG] Debug break requested by user
    3,224 ( 0.00%)      if (g.DebugBreakInShortcutRouting == key_chord)
        .                   IM_DEBUG_BREAK();
        .           
    3,224 ( 0.00%)      if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
        .                   if (g.NavWindow == NULL)
        .                       return false;
        .           
        .               // Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
    3,224 ( 0.00%)      if (flags & ImGuiInputFlags_RouteAlways)
        .               {
    4,030 ( 0.00%)          IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, owner_id=0x%08X, flags=%04X) -> always\n", GetKeyChordName(key_chord), owner_id, flags);
    1,612 ( 0.00%)          return true;
        .               }
        .           
        .               // Specific culling when there's an active.
        .               if (g.ActiveId != 0 && g.ActiveId != owner_id)
        .               {
        .                   // Cull shortcuts with no modifiers when it could generate a character.
        .                   // e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
        .                   // but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
-- line 9230 ----------------------------------------
-- line 9262 ----------------------------------------
        .                   routing_data->RoutingNext = owner_id;
        .                   routing_data->RoutingNextScore = (ImU8)score;
        .               }
        .           
        .               // Return routing state for CURRENT frame
        .               if (routing_data->RoutingCurr == owner_id)
        .                   IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n");
        .               return routing_data->RoutingCurr == owner_id;
    1,612 ( 0.00%)  }
        .           
        .           // Currently unused by core (but used by tests)
        .           // Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.
        .           bool ImGui::TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
        .               key_chord = FixupKeyChord(&g, key_chord);
        .               ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
        .               return routing_data->RoutingCurr == routing_id;
        .           }
        .           
        .           // Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
        .           // Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)
        .           bool ImGui::IsKeyDown(ImGuiKey key)
   16,252 ( 0.00%)  {
   16,252 ( 0.00%)      return IsKeyDown(key, ImGuiKeyOwner_Any);
  370,181 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyDown(ImGuiKey, unsigned int) (4,063x)
    8,126 ( 0.00%)  }
        .           
        .           bool ImGui::IsKeyDown(ImGuiKey key, ImGuiID owner_id)
   20,315 ( 0.00%)  {
   16,252 ( 0.00%)      const ImGuiKeyData* key_data = GetKeyData(key);
  295,727 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetKeyData(ImGuiKey) (4,063x)
   20,315 ( 0.00%)      if (!key_data->Down)
    8,060 ( 0.00%)          return false;
      264 ( 0.00%)      if (!TestKeyOwner(key, owner_id))
    1,089 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::TestKeyOwner(ImGuiKey, unsigned int) (33x)
        .                   return false;
       33 ( 0.00%)      return true;
    8,126 ( 0.00%)  }
        .           
        .           bool ImGui::IsKeyPressed(ImGuiKey key, bool repeat)
    7,254 ( 0.00%)  {
    9,672 ( 0.00%)      return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
   90,675 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyPressed(ImGuiKey, unsigned int, int) (1,209x)
    2,418 ( 0.00%)  }
        .           
        .           // Important: unless legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
        .           bool ImGui::IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
    9,558 ( 0.00%)  {
    6,372 ( 0.00%)      const ImGuiKeyData* key_data = GetKeyData(key);
   89,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetKeyData(ImGuiKey) (1,593x)
    7,965 ( 0.00%)      if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
    3,186 ( 0.00%)          return false;
        .               const float t = key_data->DownDuration;
        .               if (t < 0.0f)
        .                   return false;
        .               IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
        .               if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) // Setting any _RepeatXXX option enables _Repeat
        .                   flags |= ImGuiInputFlags_Repeat;
        .           
        .               bool pressed = (t == 0.0f);
-- line 9318 ----------------------------------------
-- line 9335 ----------------------------------------
        .                           pressed = false;
        .                   }
        .               }
        .               if (!pressed)
        .                   return false;
        .               if (!TestKeyOwner(key, owner_id))
        .                   return false;
        .               return true;
    3,186 ( 0.00%)  }
        .           
        .           bool ImGui::IsKeyReleased(ImGuiKey key)
        .           {
        .               return IsKeyReleased(key, ImGuiKeyOwner_Any);
        .           }
        .           
        .           bool ImGui::IsKeyReleased(ImGuiKey key, ImGuiID owner_id)
        .           {
-- line 9351 ----------------------------------------
-- line 9432 ----------------------------------------
        .               IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
        .               return g.IO.MouseClickedCount[button];
        .           }
        .           
        .           // Test if mouse cursor is hovering given rectangle
        .           // NB- Rectangle is clipped by our current clip setting
        .           // NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
        .           bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
   33,873 ( 0.00%)  {
    9,678 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Clip
   29,034 ( 0.00%)      ImRect rect_clipped(r_min, r_max);
   77,424 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (4,839x)
    9,678 ( 0.00%)      if (clip)
   22,582 ( 0.00%)          rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
  381,478 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ClipWith(ImRect const&) (3,226x)
        .           
        .               // Hit testing, expanded for touch input
   53,229 ( 0.00%)      if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
  131,499 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ContainsWithPad(ImVec2 const&, ImVec2 const&) const (4,839x)
    9,342 ( 0.00%)          return false;
    2,688 ( 0.00%)      if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
   14,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (168x)
    5,376 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Overlaps(ImRect const&) const (168x)
        .                   return false;
      168 ( 0.00%)      return true;
    9,678 ( 0.00%)  }
        .           
        .           // Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
        .           // [Internal] This doesn't test if the button is pressed
        .           bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
        .               if (lock_threshold < 0.0f)
-- line 9462 ----------------------------------------
-- line 9496 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               if (g.BeginPopupStack.Size > 0)
        .                   return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
        .               return g.IO.MousePos;
        .           }
        .           
        .           // We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
        .           bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
    4,032 ( 0.00%)  {
        .               // The assert is only to silence a false-positive in XCode Static Analysis.
        .               // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    3,024 ( 0.00%)      IM_ASSERT(GImGui != NULL);
    2,016 ( 0.00%)      const float MOUSE_INVALID = -256000.0f;
    5,040 ( 0.00%)      ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
    6,420 ( 0.00%)      return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
    2,016 ( 0.00%)  }
        .           
        .           // [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
        .           bool ImGui::IsAnyMouseDown()
       12 ( 0.00%)  {
       12 ( 0.00%)      ImGuiContext& g = *GImGui;
       69 ( 0.00%)      for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
      108 ( 0.00%)          if (g.IO.MouseDown[n])
        6 ( 0.00%)              return true;
        3 ( 0.00%)      return false;
       12 ( 0.00%)  }
        .           
        .           // Return the delta from the initial clicking position while the mouse button is clicked or was just released.
        .           // This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
        .           // NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
        .           ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
-- line 9529 ----------------------------------------
-- line 9556 ----------------------------------------
        .           
        .           void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.MouseCursor = cursor_type;
        .           }
        .           
        .           static void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)
   19,747 ( 0.00%)  {
   14,105 ( 0.00%)      IM_ASSERT(ImGui::IsAliasKey(key));
   31,031 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsAliasKey(ImGuiKey) (2,821x)
   11,284 ( 0.00%)      ImGuiKeyData* key_data = ImGui::GetKeyData(key);
  157,976 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetKeyData(ImGuiKey) (2,821x)
    8,463 ( 0.00%)      key_data->Down = v;
    8,463 ( 0.00%)      key_data->AnalogValue = analog_value;
    8,463 ( 0.00%)  }
        .           
        .           // [Internal] Do not use directly
        .           static ImGuiKeyChord GetMergedModsFromKeys()
    2,418 ( 0.00%)  {
      806 ( 0.00%)      ImGuiKeyChord mods = 0;
    3,224 ( 0.00%)      if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
   82,212 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyDown(ImGuiKey) (806x)
    3,224 ( 0.00%)      if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
   83,824 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyDown(ImGuiKey) (806x)
    3,224 ( 0.00%)      if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
   85,436 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyDown(ImGuiKey) (806x)
    3,224 ( 0.00%)      if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
   87,048 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyDown(ImGuiKey) (806x)
      806 ( 0.00%)      return mods;
    1,612 ( 0.00%)  }
        .           
        .           static void ImGui::UpdateKeyboardInputs()
    2,015 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
        .           
        .               // Import legacy keys or verify they are not used
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    1,612 ( 0.00%)      if (io.BackendUsingLegacyKeyArrays == 0)
        .               {
        .                   // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
  580,957 ( 0.00%)          for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
1,351,333 ( 0.00%)              IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
    4,587 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyDown(ImGuiKey) (33x)
        .               }
        .               else
        .               {
      104 ( 0.00%)          if (g.FrameCount == 0)
        .                       for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
        .                           IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
        .           
        .                   // Build reverse KeyMap (Named -> Legacy)
   12,116 ( 0.00%)          for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
   28,028 ( 0.00%)              if (io.KeyMap[n] != -1)
        .                       {
        .                           IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
        .                           io.KeyMap[io.KeyMap[n]] = n;
        .                       }
        .           
        .                   // Import legacy keys into new ones
   40,040 ( 0.00%)          for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
  133,120 ( 0.00%)              if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
        .                       {
        .                           const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
        .                           IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
        .                           io.KeysData[key].Down = io.KeysDown[n];
        .                           if (key != n)
        .                               io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
        .                           io.BackendUsingLegacyKeyArrays = 1;
        .                       }
      104 ( 0.00%)          if (io.BackendUsingLegacyKeyArrays == 1)
        .                   {
        .                       GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
        .                       GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
        .                       GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
        .                       GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
        .                   }
        .               }
        .           #endif
        .           
        .               // Import legacy ImGuiNavInput_ io inputs and convert to gamepad keys
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    2,821 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    2,418 ( 0.00%)      if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
        .               {
        .                   #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
        .                   #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
-- line 9641 ----------------------------------------
-- line 9648 ----------------------------------------
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
        .                   #undef NAV_MAP_KEY
        .               }
        .           #endif
        .           
        .               // Update aliases
    7,657 ( 0.00%)      for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
   38,290 ( 0.00%)          UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
  185,380 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:UpdateAliasKey(ImGuiKey, bool, float) (2,015x)
   24,180 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::MouseButtonToKey(int) (2,015x)
    6,448 ( 0.00%)      UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
   37,076 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:UpdateAliasKey(ImGuiKey, bool, float) (403x)
    6,448 ( 0.00%)      UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
   37,076 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:UpdateAliasKey(ImGuiKey, bool, float) (403x)
        .           
        .               // Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
        .               // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
        .               // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
        .               // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
    1,209 ( 0.00%)      const ImGuiKeyChord prev_key_mods = io.KeyMods;
    1,209 ( 0.00%)      io.KeyMods = GetMergedModsFromKeys();
  178,529 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:GetMergedModsFromKeys() (403x)
    2,821 ( 0.00%)      io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
    2,821 ( 0.00%)      io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
    2,821 ( 0.00%)      io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
    2,821 ( 0.00%)      io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
    1,612 ( 0.00%)      if (prev_key_mods != io.KeyMods)
        .                   g.LastKeyModsChangeTime = g.Time;
    1,612 ( 0.00%)      if (prev_key_mods != io.KeyMods && prev_key_mods == 0)
        .                   g.LastKeyModsChangeFromNoneTime = g.Time;
        .           
        .               // Clear gamepad data if disabled
    2,015 ( 0.00%)      if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
   30,628 ( 0.00%)          for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
        .                   {
   67,704 ( 0.00%)              io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
   87,048 ( 0.00%)              io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
        .                   }
        .           
        .               // Update keys
  806,806 ( 0.00%)      for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
        .               {
2,147,184 ( 0.00%)          ImGuiKeyData* key_data = &io.KeysData[i];
1,073,592 ( 0.00%)          key_data->DownDurationPrev = key_data->DownDuration;
1,879,142 ( 0.00%)          key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
2,147,184 ( 0.00%)          if (key_data->DownDuration == 0.0f)
        .                   {
       12 ( 0.00%)              ImGuiKey key = (ImGuiKey)(ImGuiKey_KeysData_OFFSET + i);
       30 ( 0.00%)              if (IsKeyboardKey(key))
       64 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsKeyboardKey(ImGuiKey) (6x)
       20 ( 0.00%)                  g.LastKeyboardKeyPressTime = g.Time;
       16 ( 0.00%)              else if (key == ImGuiKey_ReservedForModCtrl || key == ImGuiKey_ReservedForModShift || key == ImGuiKey_ReservedForModAlt || key == ImGuiKey_ReservedForModSuper)
        .                           g.LastKeyboardKeyPressTime = g.Time;
        .                   }
        .               }
        .           
        .               // Update keys/input owner (named keys only): one entry per key
  187,798 ( 0.00%)      for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
        .               {
  496,496 ( 0.00%)          ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
  744,744 ( 0.00%)          ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
  248,248 ( 0.00%)          owner_data->OwnerCurr = owner_data->OwnerNext;
  310,310 ( 0.00%)          if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
  124,048 ( 0.00%)              owner_data->OwnerNext = ImGuiKeyOwner_None;
  682,682 ( 0.00%)          owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
        .               }
        .           
        .               // Update key routing (for e.g. shortcuts)
    1,612 ( 0.00%)      UpdateKeyRoutingTable(&g.KeysRoutingTable);
2,079,883 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateKeyRoutingTable(ImGuiKeyRoutingTable*) (403x)
    2,418 ( 0.00%)  }
        .           
        .           static void ImGui::UpdateMouseInputs()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
        .           
        .               // Mouse Wheel swapping flag
        .               // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
        .               // - We avoid doing it on OSX as it the OS input layer handles this already.
        .               // - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
        .               // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
    2,821 ( 0.00%)      io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;
        .           
        .               // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    2,418 ( 0.00%)      if (IsMousePosValid(&io.MousePos))
    8,856 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsMousePosValid(ImVec2 const*) (403x)
    2,388 ( 0.00%)          io.MousePos = g.MouseLastValidPos = ImFloor(io.MousePos);
   12,935 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImFloor(ImVec2 const&) (199x)
        .           
        .               // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    5,017 ( 0.00%)      if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
   13,620 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsMousePosValid(ImVec2 const*) (602x)
    2,156 ( 0.00%)          io.MouseDelta = io.MousePos - io.MousePosPrev;
    7,644 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (196x)
        .               else
    1,863 ( 0.00%)          io.MouseDelta = ImVec2(0.0f, 0.0f);
    2,898 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (207x)
        .           
        .               // Update stationary timer.
        .               // FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
    2,821 ( 0.00%)      const float mouse_stationary_threshold = (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0f : 3.0f; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
    4,030 ( 0.00%)      const bool mouse_stationary = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLengthSqr(ImVec2 const&) (403x)
    3,940 ( 0.00%)      g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
        .               //IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);
        .           
        .               // If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
    6,304 ( 0.00%)      if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
       44 ( 0.00%)          g.NavDisableMouseHover = false;
        .           
    7,657 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
        .               {
   22,207 ( 0.00%)          io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
   10,075 ( 0.00%)          io.MouseClickedCount[i] = 0; // Will be filled below
   40,262 ( 0.00%)          io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
   20,150 ( 0.00%)          io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
   24,246 ( 0.00%)          io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
   12,090 ( 0.00%)          if (io.MouseClicked[i])
        .                   {
        2 ( 0.00%)              bool is_repeated_click = false;
       26 ( 0.00%)              if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
        .                       {
        .                           ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
        .                           if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
        .                               is_repeated_click = true;
        .                       }
        4 ( 0.00%)              if (is_repeated_click)
        .                           io.MouseClickedLastCount[i]++;
        .                       else
       10 ( 0.00%)                  io.MouseClickedLastCount[i] = 1;
       14 ( 0.00%)              io.MouseClickedTime[i] = g.Time;
       14 ( 0.00%)              io.MouseClickedPos[i] = io.MousePos;
       20 ( 0.00%)              io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
       24 ( 0.00%)              io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2x)
       14 ( 0.00%)              io.MouseDragMaxDistanceSqr[i] = 0.0f;
        .                   }
   12,078 ( 0.00%)          else if (io.MouseDown[i])
        .                   {
        .                       // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
       63 ( 0.00%)              ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
       72 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsMousePosValid(ImVec2 const*) (3x)
      117 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (3x)
       54 ( 0.00%)              io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
       48 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImLengthSqr(ImVec2 const&) (3x)
       33 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (3x)
       57 ( 0.00%)              io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
       33 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (3x)
       57 ( 0.00%)              io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
       33 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (3x)
        .                   }
        .           
        .                   // We provide io.MouseDoubleClicked[] as a legacy service
   22,165 ( 0.00%)          io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
        .           
        .                   // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
   12,090 ( 0.00%)          if (io.MouseClicked[i])
        4 ( 0.00%)              g.NavDisableMouseHover = false;
        .               }
    2,015 ( 0.00%)  }
        .           
        .           static void LockWheelingWindow(ImGuiWindow* window, float wheel_amount)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (window)
        .                   g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
        .               else
        .                   g.WheelingWindowReleaseTimer = 0.0f;
-- line 9798 ----------------------------------------
-- line 9844 ----------------------------------------
        .                   g.WheelingWindowWheelRemainder = wheel;
        .                   return NULL;
        .               }
        .               return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
        .           }
        .           
        .           // Called by NewFrame()
        .           void ImGui::UpdateMouseWheel()
    1,612 ( 0.00%)  {
        .               // Reset the locked window if we move the mouse or after the timer elapses.
        .               // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,612 ( 0.00%)      if (g.WheelingWindow != NULL)
        .               {
        .                   g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
        .                   if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
        .                       g.WheelingWindowReleaseTimer = 0.0f;
        .                   if (g.WheelingWindowReleaseTimer <= 0.0f)
        .                       LockWheelingWindow(NULL, 0.0f);
        .               }
        .           
    1,612 ( 0.00%)      ImVec2 wheel;
    3,627 ( 0.00%)      wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_None) ? g.IO.MouseWheelH : 0.0f;
   32,673 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::TestKeyOwner(ImGuiKey, unsigned int) (403x)
    3,627 ( 0.00%)      wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_None) ? g.IO.MouseWheel : 0.0f;
   32,673 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::TestKeyOwner(ImGuiKey, unsigned int) (403x)
        .           
        .               //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
    2,821 ( 0.00%)      ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
    1,478 ( 0.00%)      if (!mouse_window || mouse_window->Collapsed)
      470 ( 0.00%)          return;
        .           
        .               // Zoom / Scale window
        .               // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    1,176 ( 0.00%)      if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
        .               {
        .                   LockWheelingWindow(mouse_window, wheel.y);
        .                   ImGuiWindow* window = mouse_window;
        .                   const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
        .                   const float scale = new_font_scale / window->FontWindowScale;
        .                   window->FontWindowScale = new_font_scale;
        .                   if (window == window->RootWindow)
        .                   {
        .                       const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
        .                       SetWindowPos(window, window->Pos + offset, 0);
        .                       window->Size = ImTrunc(window->Size * scale);
        .                       window->SizeFull = ImTrunc(window->SizeFull * scale);
        .                   }
        .                   return;
        .               }
      672 ( 0.00%)      if (g.IO.KeyCtrl)
        .                   return;
        .           
        .               // Mouse wheel scrolling
        .               // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
      672 ( 0.00%)      if (g.IO.MouseWheelRequestAxisSwap)
        .                   wheel = ImVec2(wheel.y, 0.0f);
        .           
        .               // Maintain a rough average of moving magnitude on both axises
        .               // FIXME: should by based on wall clock time rather than frame-counter
    2,184 ( 0.00%)      g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
    3,360 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImExponentialMovingAverage(float, float, int) (168x)
    1,344 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImAbs(float) (168x)
    2,184 ( 0.00%)      g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
    3,360 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImExponentialMovingAverage(float, float, int) (168x)
    1,344 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImAbs(float) (168x)
        .           
        .               // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
    1,008 ( 0.00%)      wheel += g.WheelingWindowWheelRemainder;
    3,528 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+=(ImVec2&, ImVec2 const&) (168x)
    1,512 ( 0.00%)      g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
    2,352 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (168x)
    2,352 ( 0.00%)      if (wheel.x == 0.0f && wheel.y == 0.0f)
      168 ( 0.00%)          return;
        .           
        .               // Mouse wheel scrolling: find target and apply
        .               // - don't renew lock if axis doesn't apply on the window.
        .               // - select a main axis when both axises are being moved.
        .               if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
        .                   if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
        .                   {
        .                       bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
-- line 9917 ----------------------------------------
-- line 9929 ----------------------------------------
        .                       {
        .                           LockWheelingWindow(window, wheel.y);
        .                           float max_step = window->InnerRect.GetHeight() * 0.67f;
        .                           float scroll_step = ImTrunc(ImMin(5 * window->CalcFontSize(), max_step));
        .                           SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
        .                           g.WheelingWindowScrolledFrame = g.FrameCount;
        .                       }
        .                   }
    1,209 ( 0.00%)  }
        .           
        .           void ImGui::SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
        .           }
        .           
        .           void ImGui::SetNextFrameWantCaptureMouse(bool want_capture_mouse)
-- line 9945 ----------------------------------------
-- line 9974 ----------------------------------------
        .           }
        .           #endif
        .           
        .           // Process input queue
        .           // We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
        .           // - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
        .           // - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
        .           void ImGui::UpdateInputEvents(bool trickle_fast_inputs)
    2,418 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
        .           
        .               // Only trickle chars<>key when working with InputText()
        .               // FIXME: InputText() could parse event trail?
        .               // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
    3,224 ( 0.00%)      const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
        .           
    1,612 ( 0.00%)      bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
      403 ( 0.00%)      int  mouse_button_changed = 0x00;
    1,209 ( 0.00%)      ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
   16,926 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitArray<666, 0>::ImBitArray() (403x)
        .           
      403 ( 0.00%)      int event_n = 0;
    6,115 ( 0.00%)      for (; event_n < g.InputEventsQueue.Size; event_n++)
        .               {
    5,327 ( 0.00%)          ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
   16,742 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::operator[](int) (761x)
    3,044 ( 0.00%)          if (e->Type == ImGuiInputEventType_MousePos)
        .                   {
    2,316 ( 0.00%)              if (g.IO.WantSetMousePos)
        .                           continue;
        .                       // Trickling Rule: Stop processing queued events if we already handled a mouse button change
    5,211 ( 0.00%)              ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
    8,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (579x)
    5,790 ( 0.00%)              if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
        .                           break;
    1,737 ( 0.00%)              io.MousePos = event_pos;
    2,316 ( 0.00%)              io.MouseSource = e->MousePos.MouseSource;
    1,158 ( 0.00%)              mouse_moved = true;
        .                   }
      728 ( 0.00%)          else if (e->Type == ImGuiInputEventType_MouseButton)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if we got multiple action on the same button
       15 ( 0.00%)              const ImGuiMouseButton button = e->MouseButton.Button;
       20 ( 0.00%)              IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
       48 ( 0.00%)              if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
        .                           break;
       24 ( 0.00%)              if (trickle_fast_inputs && e->MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) // #2702: TouchScreen have no initial hover.
        .                           break;
       24 ( 0.00%)              io.MouseDown[button] = e->MouseButton.Down;
       16 ( 0.00%)              io.MouseSource = e->MouseButton.MouseSource;
       20 ( 0.00%)              mouse_button_changed |= (1 << button);
        .                   }
      708 ( 0.00%)          else if (e->Type == ImGuiInputEventType_MouseWheel)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if we got multiple action on the event
        .                       if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
        .                           break;
        .                       io.MouseWheelH += e->MouseWheel.WheelX;
        .                       io.MouseWheel += e->MouseWheel.WheelY;
        .                       io.MouseSource = e->MouseWheel.MouseSource;
        .                       mouse_wheeled = true;
        .                   }
      708 ( 0.00%)          else if (e->Type == ImGuiInputEventType_MouseViewport)
        .                   {
       15 ( 0.00%)              io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
        .                   }
      696 ( 0.00%)          else if (e->Type == ImGuiInputEventType_Key)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if we got multiple action on the same button
       21 ( 0.00%)              ImGuiKey key = e->Key.Key;
       14 ( 0.00%)              IM_ASSERT(key != ImGuiKey_None);
       28 ( 0.00%)              ImGuiKeyData* key_data = GetKeyData(key);
      392 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetKeyData(ImGuiKey) (7x)
       49 ( 0.00%)              const int key_data_index = (int)(key_data - g.IO.KeysData);
      154 ( 0.00%)              if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
      161 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitArray<666, 0>::TestBit(int) const (7x)
        .                           break;
       28 ( 0.00%)              key_data->Down = e->Key.Down;
       28 ( 0.00%)              key_data->AnalogValue = e->Key.AnalogValue;
        7 ( 0.00%)              key_changed = true;
       35 ( 0.00%)              key_changed_mask.SetBit(key_data_index);
      308 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImBitArray<666, 0>::SetBit(int) (7x)
        .           
        .                       // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
       42 ( 0.00%)              io.KeysDown[key_data_index] = key_data->Down;
       49 ( 0.00%)              if (io.KeyMap[key_data_index] != -1)
       77 ( 0.00%)                  io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
        .           #endif
        .                   }
      668 ( 0.00%)          else if (e->Type == ImGuiInputEventType_Text)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
    1,624 ( 0.00%)              if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
        .                           break;
      444 ( 0.00%)              unsigned int c = e->Text.Char;
    1,628 ( 0.00%)              io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
    6,879 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::push_back(unsigned short const&) (148x)
      296 ( 0.00%)              if (trickle_interleaved_keys_and_text)
        .                           text_inputted = true;
        .                   }
        8 ( 0.00%)          else if (e->Type == ImGuiInputEventType_Focus)
        .                   {
        .                       // We intentionally overwrite this and process in NewFrame(), in order to give a chance
        .                       // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
        8 ( 0.00%)              const bool focus_lost = !e->AppFocused.Focused;
        8 ( 0.00%)              io.AppFocusLost = focus_lost;
        .                   }
        .                   else
        .                   {
        .                       IM_ASSERT(0 && "Unknown event!");
        .                   }
        .               }
        .           
        .               // Record trail (for domain-specific applications wanting to access a precise trail)
        .               //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
    4,987 ( 0.00%)      for (int n = 0; n < event_n; n++)
    8,173 ( 0.00%)          g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
   41,769 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::push_back(ImGuiInputEvent const&) (743x)
   16,346 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::operator[](int) (743x)
        .           
        .               // [DEBUG]
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    1,011 ( 0.00%)      if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
        .                   for (int n = 0; n < g.InputEventsQueue.Size; n++)
        .                       DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
        .           #endif
        .           
        .               // Remaining events will be processed on the next frame
    1,612 ( 0.00%)      if (event_n == g.InputEventsQueue.Size)
    2,310 ( 0.00%)          g.InputEventsQueue.resize(0);
    5,775 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::resize(int) (385x)
        .               else
      288 ( 0.00%)          g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
  227,547 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiInputEvent>::erase(ImGuiInputEvent const*, ImGuiInputEvent const*) (18x)
        .           
        .               // Clear buttons state when focus is lost
        .               // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
        .               // - we clear in EndFrame() and not now in order allow application/user code polling this flag
        .               //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
    1,612 ( 0.00%)      if (g.IO.AppFocusLost)
        8 ( 0.00%)          g.IO.ClearInputKeys();
   37,816 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiIO::ClearInputKeys() (2x)
    1,612 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::GetKeyOwner(ImGuiKey key)
        .           {
        .               if (!IsNamedKeyOrModKey(key))
        .                   return ImGuiKeyOwner_None;
        .           
        .               ImGuiContext& g = *GImGui;
        .               ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
-- line 10114 ----------------------------------------
-- line 10121 ----------------------------------------
        .               return owner_id;
        .           }
        .           
        .           // TestKeyOwner(..., ID)   : (owner == None || owner == ID)
        .           // TestKeyOwner(..., None) : (owner == None)
        .           // TestKeyOwner(..., Any)  : no owner test
        .           // All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
        .           bool ImGui::TestKeyOwner(ImGuiKey key, ImGuiID owner_id)
    4,195 ( 0.00%)  {
    5,034 ( 0.00%)      if (!IsNamedKeyOrModKey(key))
    9,460 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsNamedKeyOrModKey(ImGuiKey) (839x)
       66 ( 0.00%)          return true;
        .           
    1,612 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,260 ( 0.00%)      if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
       24 ( 0.00%)          if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
        .                       return false;
        .           
    4,836 ( 0.00%)      ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
   30,628 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetKeyOwnerData(ImGuiContext*, ImGuiKey) (806x)
    1,612 ( 0.00%)      if (owner_id == ImGuiKeyOwner_Any)
        .                   return (owner_data->LockThisFrame == false);
        .           
        .               // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
        .               // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
        .               // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
    3,224 ( 0.00%)      if (owner_data->OwnerCurr != owner_id)
        .               {
        .                   if (owner_data->LockThisFrame)
        .                       return false;
        .                   if (owner_data->OwnerCurr != ImGuiKeyOwner_None)
        .                       return false;
        .               }
        .           
      806 ( 0.00%)      return true;
    1,678 ( 0.00%)  }
        .           
        .           // _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
        .           // When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
        .           // - SetKeyOwner(..., None)              : clears owner
        .           // - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
        .           // - SetKeyOwner(..., Any or None, Lock) : set lock
        .           void ImGui::SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
        .           {
-- line 10162 ----------------------------------------
-- line 10209 ----------------------------------------
        .           // This is the only public API until we expose owner_id versions of the API as replacements.
        .           bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord)
        .           {
        .               return IsKeyChordPressed(key_chord, 0, ImGuiInputFlags_None);
        .           }
        .           
        .           // This is equivalent to comparing KeyMods + doing a IsKeyPressed()
        .           bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
    4,836 ( 0.00%)  {
    1,612 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,836 ( 0.00%)      key_chord = FixupKeyChord(&g, key_chord);
   22,568 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FixupKeyChord(ImGuiContext*, int) (806x)
    2,418 ( 0.00%)      ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
    3,224 ( 0.00%)      if (g.IO.KeyMods != mods)
    1,612 ( 0.00%)          return false;
        .           
        .               // Special storage location for mods
        .               ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
        .               if (key == ImGuiKey_None)
        .                   key = ConvertSingleModFlagToKey(&g, mods);
        .               if (!IsKeyPressed(key, owner_id, (flags & ImGuiInputFlags_RepeatMask_)))
        .                   return false;
        .               return true;
    1,612 ( 0.00%)  }
        .           
        .           void ImGui::SetNextItemShortcut(ImGuiKeyChord key_chord)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasShortcut;
        .               g.NextItemData.Shortcut = key_chord;
        .           }
        .           
        .           bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
    4,836 ( 0.00%)  {
        .               //ImGuiContext& g = *GImGui;
        .               //IMGUI_DEBUG_LOG("Shortcut(%s, owner_id=0x%08X, flags=%X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), owner_id, flags);
        .           
        .               // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
    3,224 ( 0.00%)      if ((flags & ImGuiInputFlags_RouteMask_) == 0)
      806 ( 0.00%)          flags |= ImGuiInputFlags_RouteFocused;
        .           
        .               // Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
        .               // Effectively makes Shortcut() always input-owner aware.
    3,224 ( 0.00%)      if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_None)
        .                   owner_id = GetRoutingIdFromOwnerId(owner_id);
        .           
        .               // Submit route
    7,254 ( 0.00%)      if (!SetShortcutRouting(key_chord, owner_id, flags))
   73,346 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetShortcutRouting(int, unsigned int, int) (806x)
        .                   return false;
        .           
        .               // Default repeat behavior for Shortcut()
        .               // So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
    6,448 ( 0.00%)      if ((flags & ImGuiInputFlags_Repeat) != 0 && (flags & ImGuiInputFlags_RepeatUntilMask_) == 0)
      806 ( 0.00%)          flags |= ImGuiInputFlags_RepeatUntilKeyModsChange;
        .           
    7,254 ( 0.00%)      if (!IsKeyChordPressed(key_chord, owner_id, flags))
   42,718 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyChordPressed(int, unsigned int, int) (806x)
    1,612 ( 0.00%)          return false;
        .               IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
        .               return true;
    1,612 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ERROR CHECKING
        .           //-----------------------------------------------------------------------------
        .           
        .           // Helper function to verify ABI compatibility between caller code and compiled version of Dear ImGui.
        .           // This is called by IMGUI_CHECKVERSION().
-- line 10275 ----------------------------------------
-- line 10322 ----------------------------------------
        .                   return;
        .               IM_ASSERT(0 && "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.");
        .           #else
        .               window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
        .           #endif
        .           }
        .           
        .           static void ImGui::ErrorCheckNewFrameSanityChecks()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Check user IM_ASSERT macro
        .               // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
        .               //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
        .               //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
        .               // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
        .               // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
        .               if (true) IM_ASSERT(1); else IM_ASSERT(0);
-- line 10339 ----------------------------------------
-- line 10342 ----------------------------------------
        .               // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
        .           #ifdef __EMSCRIPTEN__
        .               if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
        .                   g.IO.DeltaTime = 0.00001f;
        .           #endif
        .           
        .               // Check user data
        .               // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    1,612 ( 0.00%)      IM_ASSERT(g.Initialized);
    2,015 ( 0.00%)      IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
    4,024 ( 0.00%)      IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    4,030 ( 0.00%)      IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
    2,418 ( 0.00%)      IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImFontAtlas::IsBuilt() const (403x)
    2,015 ( 0.00%)      IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
    2,015 ( 0.00%)      IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
    4,030 ( 0.00%)      IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
    4,030 ( 0.00%)      IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
    3,224 ( 0.00%)      IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
    3,224 ( 0.00%)      IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
  187,798 ( 0.00%)      for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
  868,868 ( 0.00%)          IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
        .           
        .               // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
    2,015 ( 0.00%)      if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
        .                   IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
        .           #endif
        .           
        .               // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    3,627 ( 0.00%)      if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        .                   g.IO.ConfigWindowsResizeFromEdges = false;
        .           
        .               // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
    1,622 ( 0.00%)      if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
        .                   IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
    1,622 ( 0.00%)      if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
        .                   IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
        .           
        .               // Perform simple checks: multi-viewport and platform windows support
    2,015 ( 0.00%)      if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        .               {
    4,030 ( 0.00%)          if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
        .                   {
    4,024 ( 0.00%)              IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
    1,612 ( 0.00%)              IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
    3,627 ( 0.00%)              IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (403x)
    2,015 ( 0.00%)              if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .                           IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
        .                   }
        .                   else
        .                   {
        .                       // Disable feature, our backends do not support it
        .                       g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
        .                   }
        .           
        .                   // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
   10,881 ( 0.00%)          for (ImGuiPlatformMonitor& mon : g.PlatformIO.Monitors)
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::begin() (403x)
        .                   {
        .                       IM_UNUSED(mon);
    8,060 ( 0.00%)              IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
   29,822 ( 0.00%)              IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
   62,868 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (1,612x)
   25,792 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Contains(ImRect const&) const (806x)
   25,792 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (1,612x)
    6,448 ( 0.00%)              IM_ASSERT(mon.DpiScale != 0.0f);
        .                   }
        .               }
    1,209 ( 0.00%)  }
        .           
        .           static void ImGui::ErrorCheckEndFrameSanityChecks()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
        .               // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
        .               // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
        .               // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
        .               // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
        .               // while still correctly asserting on mid-frame key press events.
      806 ( 0.00%)      const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
  178,529 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:GetMergedModsFromKeys() (403x)
      806 ( 0.00%)      IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
        .               IM_UNUSED(key_mods);
        .           
        .               // [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
        .               //ErrorCheckEndFrameRecover();
        .           
        .               // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
        .               // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
    1,612 ( 0.00%)      if (g.CurrentWindowStack.Size != 1)
        .               {
        .                   if (g.CurrentWindowStack.Size > 1)
        .                   {
        .                       ImGuiWindow* window = g.CurrentWindowStack.back().Window; // <-- This window was not Ended!
        .                       IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
        .                       IM_UNUSED(window);
        .                       while (g.CurrentWindowStack.Size > 1)
        .                           End();
        .                   }
        .                   else
        .                   {
        .                       IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
        .                   }
        .               }
        .           
    1,612 ( 0.00%)      IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
    1,209 ( 0.00%)  }
        .           
        .           // Experimental recovery from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
        .           // Must be called during or before EndFrame().
        .           // This is generally flawed as we are not necessarily End/Popping things in the right order.
        .           // FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
        .           // FIXME: Can't recover from interleaved BeginTabBar/Begin
        .           void    ImGui::ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data)
        .           {
-- line 10458 ----------------------------------------
-- line 10542 ----------------------------------------
        .               {
        .                   if (log_callback) log_callback(user_data, "Recovered from missing PopFocusScope() in '%s'", window->Name);
        .                   PopFocusScope();
        .               }
        .           }
        .           
        .           // Save current stack sizes for later compare
        .           void ImGuiStackSizes::SetToContextState(ImGuiContext* ctx)
    8,064 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *ctx;
    6,048 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
   10,080 ( 0.00%)      SizeOfIDStack = (short)window->IDStack.Size;
   10,080 ( 0.00%)      SizeOfColorStack = (short)g.ColorStack.Size;
   10,080 ( 0.00%)      SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
   10,080 ( 0.00%)      SizeOfFontStack = (short)g.FontStack.Size;
   10,080 ( 0.00%)      SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
   10,080 ( 0.00%)      SizeOfGroupStack = (short)g.GroupStack.Size;
   10,080 ( 0.00%)      SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
   10,080 ( 0.00%)      SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
    8,064 ( 0.00%)      SizeOfDisabledStack = (short)g.DisabledStackSize;
    6,048 ( 0.00%)  }
        .           
        .           // Compare to detect usage errors
        .           void ImGuiStackSizes::CompareWithContextState(ImGuiContext* ctx)
   10,080 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *ctx;
    6,048 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .               IM_UNUSED(window);
        .           
        .               // Window stacks
        .               // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
   14,112 ( 0.00%)      IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");
        .           
        .               // Global stacks
        .               // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
   14,112 ( 0.00%)      IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
   14,112 ( 0.00%)      IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
   12,096 ( 0.00%)      IM_ASSERT(SizeOfDisabledStack   == g.DisabledStackSize      && "BeginDisabled/EndDisabled Mismatch!");
   14,112 ( 0.00%)      IM_ASSERT(SizeOfItemFlagsStack  >= g.ItemFlagsStack.Size    && "PushItemFlag/PopItemFlag Mismatch!");
   14,112 ( 0.00%)      IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
   14,112 ( 0.00%)      IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
   14,112 ( 0.00%)      IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
   14,112 ( 0.00%)      IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
    6,048 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ITEM SUBMISSION
        .           //-----------------------------------------------------------------------------
        .           // - KeepAliveID()
        .           // - ItemHandleShortcut() [Internal]
        .           // - ItemAdd()
        .           //-----------------------------------------------------------------------------
        .           
        .           // Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
        .           void ImGui::KeepAliveID(ImGuiID id)
    9,693 ( 0.00%)  {
    6,462 ( 0.00%)      ImGuiContext& g = *GImGui;
   12,924 ( 0.00%)      if (g.ActiveId == id)
       15 ( 0.00%)          g.ActiveIdIsAlive = id;
   12,924 ( 0.00%)      if (g.ActiveIdPreviousFrame == id)
       10 ( 0.00%)          g.ActiveIdPreviousFrameIsAlive = true;
    9,693 ( 0.00%)  }
        .           
        .           static void ItemHandleShortcut(ImGuiID id)
        .           {
        .               // FIXME: Generalize Activation queue?
        .               ImGuiContext& g = *GImGui;
        .               if (ImGui::Shortcut(g.NextItemData.Shortcut, id, ImGuiInputFlags_None) && g.NavActivateId == 0)
        .               {
        .                   g.NavActivateId = id; // Will effectively disable clipping.
-- line 10611 ----------------------------------------
-- line 10616 ----------------------------------------
        .               }
        .           }
        .           
        .           // Declare item bounding box for clipping and interaction.
        .           // Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
        .           // declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
        .           // THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)
        .           bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg, ImGuiItemFlags extra_flags)
   22,582 ( 0.00%)  {
    6,452 ( 0.00%)      ImGuiContext& g = *GImGui;
    9,678 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
        .               // Set item data
        .               // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
    9,678 ( 0.00%)      g.LastItemData.ID = id;
   19,356 ( 0.00%)      g.LastItemData.Rect = bb;
   25,808 ( 0.00%)      g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
   29,034 ( 0.00%)      g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
    6,452 ( 0.00%)      g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
        .               // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.
        .           
    6,452 ( 0.00%)      if (id != 0)
        .               {
    9,678 ( 0.00%)          KeepAliveID(id);
   51,616 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::KeepAliveID(unsigned int) (3,226x)
        .           
        .                   // Directional navigation processing
        .                   // Runs prior to clipping early-out
        .                   //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        .                   //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
        .                   //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
        .                   //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        .                   //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
        .                   //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
        .                   // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
        .                   // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
   16,130 ( 0.00%)          if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
        .                   {
        .                       // FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
   25,407 ( 0.00%)              window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
   22,584 ( 0.00%)              if (g.NavId == id || g.NavAnyRequest)
       63 ( 0.00%)                  if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
       36 ( 0.00%)                      if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
        9 ( 0.00%)                          NavProcessItem();
      423 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavProcessItem() (9x)
        .                   }
        .           
   16,130 ( 0.00%)          if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasShortcut)
        .                       ItemHandleShortcut(id);
        .               }
        .           
        .               // Lightweight clear of SetNextItemXXX data.
    6,452 ( 0.00%)      g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
    6,452 ( 0.00%)      g.NextItemData.ItemFlags = ImGuiItemFlags_None;
        .           
        .           #ifdef IMGUI_ENABLE_TEST_ENGINE
        .               if (id != 0)
        .                   IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
        .           #endif
        .           
        .               // Clipping test
        .               // (this is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
        .               //const bool is_clipped = IsClippedEx(bb, id);
        .               //if (is_clipped)
        .               //    return false;
        .               // g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
   22,582 ( 0.00%)      const bool is_rect_visible = bb.Overlaps(window->ClipRect);
  103,232 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Overlaps(ImRect const&) const (3,226x)
   12,904 ( 0.00%)      if (!is_rect_visible)
        .                   if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
        .                       if (!g.LogEnabled)
        .                           return false;
        .           
        .               // [DEBUG]
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    6,452 ( 0.00%)      if (id != 0)
        .               {
   12,904 ( 0.00%)          if (id == g.DebugLocateId)
        .                       DebugLocateItemResolveWithLastItem();
        .           
        .                   // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
        .                   // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
        .                   // READ THE FAQ: https://dearimgui.com/faq
   12,904 ( 0.00%)          IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
        .               }
        .               //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
        .               //if ((g.LastItemData.InFlags & ImGuiItemFlags_NoNav) == 0)
        .               //    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
        .           #endif
        .           
        .               // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    6,452 ( 0.00%)      if (is_rect_visible)
   19,356 ( 0.00%)          g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
   29,034 ( 0.00%)      if (IsMouseHoveringRect(bb.Min, bb.Max))
  666,448 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsMouseHoveringRect(ImVec2 const&, ImVec2 const&, bool) (3,226x)
    1,008 ( 0.00%)          g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    3,226 ( 0.00%)      return true;
    6,452 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] LAYOUT
        .           //-----------------------------------------------------------------------------
        .           // - ItemSize()
        .           // - SameLine()
        .           // - GetCursorScreenPos()
-- line 10717 ----------------------------------------
-- line 10740 ----------------------------------------
        .           // Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
        .           //-----------------------------------------------------------------------------
        .           
        .           // Advance cursor given item size for layout.
        .           // Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
        .           // See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
        .           // THIS IS IN THE PERFORMANCE CRITICAL PATH.
        .           void ImGui::ItemSize(const ImVec2& size, float text_baseline_y)
   14,105 ( 0.00%)  {
    5,642 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,463 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
   11,284 ( 0.00%)      if (window->SkipItems)
        .                   return;
        .           
        .               // We increase the height in this function to accommodate for baseline offset.
        .               // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
        .               // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
   36,270 ( 0.00%)      const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
   24,180 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,418x)
        .           
   21,762 ( 0.00%)      const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
   39,494 ( 0.00%)      const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
   30,628 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,821x)
        .           
        .               // Always align ourselves on pixel boundaries
        .               //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
   19,747 ( 0.00%)      window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
    8,463 ( 0.00%)      window->DC.CursorPosPrevLine.y = line_y1;
   33,852 ( 0.00%)      window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
   25,389 ( 0.00%)      window->DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
   28,210 ( 0.00%)      window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
   28,210 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,821x)
   36,673 ( 0.00%)      window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
   30,225 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,821x)
        .               //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
        .           
    8,463 ( 0.00%)      window->DC.PrevLineSize.y = line_height;
    8,463 ( 0.00%)      window->DC.CurrLineSize.y = 0.0f;
   25,389 ( 0.00%)      window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
   31,031 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (2,821x)
    8,463 ( 0.00%)      window->DC.CurrLineTextBaseOffset = 0.0f;
   16,926 ( 0.00%)      window->DC.IsSameLine = window->DC.IsSetPos = false;
        .           
        .               // Horizontal layout mode
   11,284 ( 0.00%)      if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
   12,090 ( 0.00%)          SameLine();
  113,646 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SameLine(float, float) (2,418x)
    5,642 ( 0.00%)  }
        .           
        .           // Gets back to previous line and continue with horizontal layout
        .           //      offset_from_start_x == 0 : follow right after previous item
        .           //      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
        .           //      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
        .           //      spacing_w >= 0           : enforce spacing amount
        .           void ImGui::SameLine(float offset_from_start_x, float spacing_w)
    9,672 ( 0.00%)  {
    4,836 ( 0.00%)      ImGuiContext& g = *GImGui;
    7,254 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    9,672 ( 0.00%)      if (window->SkipItems)
        .                   return;
        .           
   14,508 ( 0.00%)      if (offset_from_start_x != 0.0f)
        .               {
        .                   if (spacing_w < 0.0f)
        .                       spacing_w = 0.0f;
        .                   window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        .                   window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
        .               }
        .               else
        .               {
    7,254 ( 0.00%)          if (spacing_w < 0.0f)
    7,254 ( 0.00%)              spacing_w = g.Style.ItemSpacing.x;
   12,090 ( 0.00%)          window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
    9,672 ( 0.00%)          window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
        .               }
    9,672 ( 0.00%)      window->DC.CurrLineSize = window->DC.PrevLineSize;
    9,672 ( 0.00%)      window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
    7,254 ( 0.00%)      window->DC.IsSameLine = true;
    4,836 ( 0.00%)  }
        .           
        .           ImVec2 ImGui::GetCursorScreenPos()
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               return window->DC.CursorPos;
        .           }
        .           
        .           void ImGui::SetCursorScreenPos(const ImVec2& pos)
-- line 10820 ----------------------------------------
-- line 10857 ----------------------------------------
        .           {
        .               ImGuiWindow* window = GetCurrentWindow();
        .               window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
        .               //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
        .               window->DC.IsSetPos = true;
        .           }
        .           
        .           void ImGui::SetCursorPosY(float y)
    8,060 ( 0.00%)  {
    4,030 ( 0.00%)      ImGuiWindow* window = GetCurrentWindow();
   24,180 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetCurrentWindow() (2,015x)
   16,120 ( 0.00%)      window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
        .               //window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
    4,030 ( 0.00%)      window->DC.IsSetPos = true;
    6,045 ( 0.00%)  }
        .           
        .           ImVec2 ImGui::GetCursorStartPos()
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               return window->DC.CursorStartPos - window->Pos;
        .           }
        .           
        .           void ImGui::Indent(float indent_w)
-- line 10878 ----------------------------------------
-- line 11013 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
        .               return mx - window->Pos;
        .           }
        .           
        .           // [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.
        .           ImVec2 ImGui::GetContentRegionMaxAbs()
    2,418 ( 0.00%)  {
    2,418 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,627 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
   14,508 ( 0.00%)      ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
    1,209 ( 0.00%)      return mx;
    3,627 ( 0.00%)  }
        .           
        .           ImVec2 ImGui::GetContentRegionAvail()
    4,836 ( 0.00%)  {
    3,627 ( 0.00%)      ImGuiWindow* window = GImGui->CurrentWindow;
   12,090 ( 0.00%)      return GetContentRegionMaxAbs() - window->DC.CursorPos;
   47,151 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (1,209x)
   27,807 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetContentRegionMaxAbs() (1,209x)
    4,836 ( 0.00%)  }
        .           
        .           // In window space (not screen space!)
        .           ImVec2 ImGui::GetWindowContentRegionMin()
        .           {
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->ContentRegionRect.Min - window->Pos;
        .           }
        .           
-- line 11040 ----------------------------------------
-- line 11043 ----------------------------------------
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->ContentRegionRect.Max - window->Pos;
        .           }
        .           
        .           // Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
        .           // Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
        .           // FIXME-OPT: Could we safely early out on ->SkipItems?
        .           void ImGui::BeginGroup()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
    3,224 ( 0.00%)      g.GroupStack.resize(g.GroupStack.Size + 1);
    6,609 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiGroupData>::resize(int) (403x)
    2,015 ( 0.00%)      ImGuiGroupData& group_data = g.GroupStack.back();
    8,463 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiGroupData>::back() (403x)
    1,612 ( 0.00%)      group_data.WindowID = window->ID;
    1,612 ( 0.00%)      group_data.BackupCursorPos = window->DC.CursorPos;
    1,612 ( 0.00%)      group_data.BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
    1,612 ( 0.00%)      group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    1,612 ( 0.00%)      group_data.BackupIndent = window->DC.Indent;
    1,612 ( 0.00%)      group_data.BackupGroupOffset = window->DC.GroupOffset;
    1,612 ( 0.00%)      group_data.BackupCurrLineSize = window->DC.CurrLineSize;
    1,612 ( 0.00%)      group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
    1,612 ( 0.00%)      group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    2,418 ( 0.00%)      group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
    1,612 ( 0.00%)      group_data.BackupIsSameLine = window->DC.IsSameLine;
    1,612 ( 0.00%)      group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
      806 ( 0.00%)      group_data.EmitItem = true;
        .           
    4,030 ( 0.00%)      window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    1,612 ( 0.00%)      window->DC.Indent = window->DC.GroupOffset;
    1,612 ( 0.00%)      window->DC.CursorMaxPos = window->DC.CursorPos;
    3,627 ( 0.00%)      window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (403x)
    1,612 ( 0.00%)      if (g.LogEnabled)
        .                   g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
    1,209 ( 0.00%)  }
        .           
        .           void ImGui::EndGroup()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    1,612 ( 0.00%)      IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls
        .           
    2,015 ( 0.00%)      ImGuiGroupData& group_data = g.GroupStack.back();
    8,463 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiGroupData>::back() (403x)
    2,418 ( 0.00%)      IM_ASSERT(group_data.WindowID == window->ID); // EndGroup() in wrong window?
        .           
    1,612 ( 0.00%)      if (window->DC.IsSetPos)
        .                   ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
        .           
    6,448 ( 0.00%)      ImRect group_bb(group_data.BackupCursorPos, ImMax(window->DC.CursorMaxPos, group_data.BackupCursorPos));
   18,135 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImMax(ImVec2 const&, ImVec2 const&) (403x)
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (403x)
        .           
    1,612 ( 0.00%)      window->DC.CursorPos = group_data.BackupCursorPos;
    1,612 ( 0.00%)      window->DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine;
    4,030 ( 0.00%)      window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
   18,538 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImMax(ImVec2 const&, ImVec2 const&) (403x)
    1,612 ( 0.00%)      window->DC.Indent = group_data.BackupIndent;
    1,612 ( 0.00%)      window->DC.GroupOffset = group_data.BackupGroupOffset;
    1,612 ( 0.00%)      window->DC.CurrLineSize = group_data.BackupCurrLineSize;
    1,612 ( 0.00%)      window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
    1,612 ( 0.00%)      window->DC.IsSameLine = group_data.BackupIsSameLine;
    1,612 ( 0.00%)      if (g.LogEnabled)
        .                   g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
        .           
    2,015 ( 0.00%)      if (!group_data.EmitItem)
        .               {
    2,015 ( 0.00%)          g.GroupStack.pop_back();
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiGroupData>::pop_back() (403x)
        .                   return;
        .               }
        .           
        .               window->DC.CurrLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        .               ItemSize(group_bb.GetSize());
        .               ItemAdd(group_bb, 0, NULL, ImGuiItemFlags_NoTabStop);
        .           
        .               // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
-- line 11114 ----------------------------------------
-- line 11135 ----------------------------------------
        .               // Forward Deactivated flag
        .               g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
        .               if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
        .                   g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Deactivated;
        .           
        .               g.GroupStack.pop_back();
        .               if (g.DebugShowGroupRects)
        .                   window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
    1,209 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] SCROLLING
        .           //-----------------------------------------------------------------------------
        .           
        .           // Helper to snap on edges when aiming at an item very close to the edge,
        .           // So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
-- line 11151 ----------------------------------------
-- line 11156 ----------------------------------------
        .               if (target <= snap_min + snap_threshold)
        .                   return ImLerp(snap_min, target, center_ratio);
        .               if (target >= snap_max - snap_threshold)
        .                   return ImLerp(target, snap_max, center_ratio);
        .               return target;
        .           }
        .           
        .           static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)
   10,080 ( 0.00%)  {
    6,048 ( 0.00%)      ImVec2 scroll = window->Scroll;
   44,352 ( 0.00%)      ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
   28,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2,016x)
   20,160 ( 0.00%)      for (int axis = 0; axis < 2; axis++)
        .               {
   52,416 ( 0.00%)          if (window->ScrollTarget[axis] < FLT_MAX)
   56,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::operator[](unsigned long) (4,032x)
        .                   {
        .                       float center_ratio = window->ScrollTargetCenterRatio[axis];
        .                       float scroll_target = window->ScrollTarget[axis];
        .                       if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
        .                       {
        .                           float snap_min = 0.0f;
        .                           float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
        .                           scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
        .                       }
        .                       scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
        .                   }
   92,736 ( 0.00%)          scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0f));
  112,896 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::operator[](unsigned long) (8,064x)
   44,352 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (4,032x)
   40,320 ( 0.00%)          if (!window->Collapsed && !window->SkipItems)
  108,864 ( 0.00%)              scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
  169,344 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::operator[](unsigned long) (12,096x)
   40,320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (4,032x)
        .               }
    2,016 ( 0.00%)      return scroll;
    8,064 ( 0.00%)  }
        .           
        .           void ImGui::ScrollToItem(ImGuiScrollFlags flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               ScrollToRectEx(window, g.LastItemData.NavRect, flags);
        .           }
        .           
-- line 11194 ----------------------------------------
-- line 11480 ----------------------------------------
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] POPUPS
        .           //-----------------------------------------------------------------------------
        .           
        .           // Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
        .           bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags)
   12,090 ( 0.00%)  {
    4,836 ( 0.00%)      ImGuiContext& g = *GImGui;
    9,672 ( 0.00%)      if (popup_flags & ImGuiPopupFlags_AnyPopupId)
        .               {
        .                   // Return true if any popup is open at the current BeginPopup() level of the popup stack
        .                   // This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
        .                   IM_ASSERT(id == 0);
        .                   if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
        .                       return g.OpenPopupStack.Size > 0;
        .                   else
        .                       return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
        .               }
        .               else
        .               {
    9,672 ( 0.00%)          if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
        .                   {
        .                       // Return true if the popup is open anywhere in the popup stack
        .                       for (ImGuiPopupData& popup_data : g.OpenPopupStack)
        .                           if (popup_data.PopupId == id)
        .                               return true;
        .                       return false;
        .                   }
        .                   else
        .                   {
        .                       // Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
   19,344 ( 0.00%)              return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
        .                   }
        .               }
    4,836 ( 0.00%)  }
        .           
        .           bool ImGui::IsPopupOpen(const char* str_id, ImGuiPopupFlags popup_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiID id = (popup_flags & ImGuiPopupFlags_AnyPopupId) ? 0 : g.CurrentWindow->GetID(str_id);
        .               if ((popup_flags & ImGuiPopupFlags_AnyPopupLevel) && id != 0)
        .                   IM_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."); // But non-string version is legal and used internally
        .               return IsPopupOpen(id, popup_flags);
        .           }
        .           
        .           // Also see FindBlockingModal(NULL)
        .           ImGuiWindow* ImGui::GetTopMostPopupModal()
    2,418 ( 0.00%)  {
    2,418 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,463 ( 0.00%)      for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        .                   if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
        .                       if (popup->Flags & ImGuiWindowFlags_Modal)
        .                           return popup;
    1,209 ( 0.00%)      return NULL;
    2,418 ( 0.00%)  }
        .           
        .           // See Demo->Stacked Modal to confirm what this is for.
        .           ImGuiWindow* ImGui::GetTopMostAndVisiblePopupModal()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,821 ( 0.00%)      for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        .                   if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
        .                       if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
        .                           return popup;
      403 ( 0.00%)      return NULL;
      806 ( 0.00%)  }
        .           
        .           void ImGui::OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiID id = g.CurrentWindow->GetID(str_id);
        .               IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id);
        .               OpenPopupEx(id, popup_flags);
        .           }
-- line 11555 ----------------------------------------
-- line 11614 ----------------------------------------
        .                   //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        .                   //    FocusWindow(parent_window);
        .               }
        .           }
        .           
        .           // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
        .           // This function closes any popups that are over 'ref_window'.
        .           void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
       36 ( 0.00%)  {
       12 ( 0.00%)      ImGuiContext& g = *GImGui;
       24 ( 0.00%)      if (g.OpenPopupStack.Size == 0)
        6 ( 0.00%)          return;
        .           
        .               // Don't close our own child popup windows.
        .               //IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
        .               int popup_count_to_keep = 0;
        .               if (ref_window)
        .               {
        .                   // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        .                   for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
-- line 11633 ----------------------------------------
-- line 11658 ----------------------------------------
        .                           break;
        .                   }
        .               }
        .               if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
        .               {
        .                   IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
        .                   ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
        .               }
       12 ( 0.00%)  }
        .           
        .           void ImGui::ClosePopupsExceptModals()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               int popup_count_to_keep;
        .               for (popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; popup_count_to_keep--)
        .               {
-- line 11674 ----------------------------------------
-- line 12050 ----------------------------------------
        .           // [SECTION] KEYBOARD/GAMEPAD NAVIGATION
        .           //-----------------------------------------------------------------------------
        .           
        .           // FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
        .           // In our terminology those should be interchangeable, yet right now this is super confusing.
        .           // Those two functions are merely a legacy artifact, so at minimum naming should be clarified.
        .           
        .           void ImGui::SetNavWindow(ImGuiWindow* window)
       24 ( 0.00%)  {
       12 ( 0.00%)      ImGuiContext& g = *GImGui;
       24 ( 0.00%)      if (g.NavWindow != window)
        .               {
       30 ( 0.00%)          IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
       18 ( 0.00%)          g.NavWindow = window;
       12 ( 0.00%)          g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        .               }
       60 ( 0.00%)      g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        6 ( 0.00%)      NavUpdateAnyRequestFlag();
      138 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateAnyRequestFlag() (6x)
       18 ( 0.00%)  }
        .           
        .           void ImGui::NavHighlightActivated(ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NavHighlightActivatedId = id;
        .               g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER;
        .           }
        .           
        .           void ImGui::NavClearPreferredPosForAxis(ImGuiAxis axis)
       32 ( 0.00%)  {
       16 ( 0.00%)      ImGuiContext& g = *GImGui;
      128 ( 0.00%)      g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;
      112 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::operator[](unsigned long) (8x)
       24 ( 0.00%)  }
        .           
        .           void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel)
       28 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
       16 ( 0.00%)      IM_ASSERT(g.NavWindow != NULL);
        8 ( 0.00%)      IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
       12 ( 0.00%)      g.NavId = id;
       12 ( 0.00%)      g.NavLayer = nav_layer;
       12 ( 0.00%)      SetNavFocusScope(focus_scope_id);
      495 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavFocusScope(unsigned int) (4x)
       28 ( 0.00%)      g.NavWindow->NavLastIds[nav_layer] = id;
       48 ( 0.00%)      g.NavWindow->NavRectRel[nav_layer] = rect_rel;
        .           
        .               // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
        8 ( 0.00%)      NavClearPreferredPosForAxis(ImGuiAxis_X);
      152 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavClearPreferredPosForAxis(ImGuiAxis) (4x)
        8 ( 0.00%)      NavClearPreferredPosForAxis(ImGuiAxis_Y);
      160 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavClearPreferredPosForAxis(ImGuiAxis) (4x)
       12 ( 0.00%)  }
        .           
        .           void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(id != 0);
        .           
        .               if (g.NavWindow != window)
        .                  SetNavWindow(window);
-- line 12105 ----------------------------------------
-- line 12293 ----------------------------------------
        .                   IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
        .                   result->SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
        .               }
        .           }
        .           
        .           // True when current work location may be scrolled horizontally when moving left / right.
        .           // This is generally always true UNLESS within a column. We don't have a vertical equivalent.
        .           void ImGui::NavUpdateCurrentWindowIsScrollPushableX()
    7,258 ( 0.00%)  {
    7,258 ( 0.00%)      ImGuiContext& g = *GImGui;
   10,887 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
   43,548 ( 0.00%)      window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
   10,887 ( 0.00%)  }
        .           
        .           // We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
        .           // This is called after LastItemData is set, but NextItemData is also still valid.
        .           static void ImGui::NavProcessItem()
       36 ( 0.00%)  {
       18 ( 0.00%)      ImGuiContext& g = *GImGui;
       27 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
       27 ( 0.00%)      const ImGuiID id = g.LastItemData.ID;
       27 ( 0.00%)      const ImGuiItemFlags item_flags = g.LastItemData.InFlags;
        .           
        .               // When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
       45 ( 0.00%)      if (window->DC.NavIsScrollPushableX == false)
        .               {
        .                   g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
        .                   g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
        .               }
       45 ( 0.00%)      const ImRect nav_bb = g.LastItemData.NavRect;
        .           
        .               // Process Init Request
       90 ( 0.00%)      if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
        .               {
        .                   // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        .                   const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
        .                   if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0)
        .                   {
        .                       NavApplyItemToResult(&g.NavInitResult);
        .                   }
        .                   if (candidate_for_nav_default_focus)
-- line 12333 ----------------------------------------
-- line 12334 ----------------------------------------
        .                   {
        .                       g.NavInitRequest = false; // Found a match, clear request
        .                       NavUpdateAnyRequestFlag();
        .                   }
        .               }
        .           
        .               // Process Move Request (scoring for navigation)
        .               // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
       36 ( 0.00%)      if (g.NavMoveScoringItems && (item_flags & ImGuiItemFlags_Disabled) == 0)
        .               {
        .                   if ((g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi) || (window->Flags & ImGuiWindowFlags_NoNavInputs) == 0)
        .                   {
        .                       const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
        .                       if (is_tabbing)
        .                       {
        .                           NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
        .                       }
-- line 12350 ----------------------------------------
-- line 12360 ----------------------------------------
        .                               if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
        .                                   if (NavScoreItem(&g.NavMoveResultLocalVisible))
        .                                       NavApplyItemToResult(&g.NavMoveResultLocalVisible);
        .                       }
        .                   }
        .               }
        .           
        .               // Update information for currently focused/navigated item
       36 ( 0.00%)      if (g.NavId == id)
        .               {
        .                   if (g.NavWindow != window)
        .                       SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
        .                   g.NavLayer = window->DC.NavLayerCurrent;
        .                   SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
        .                   g.NavFocusScopeId = g.CurrentFocusScopeId;
        .                   g.NavIdIsAlive = true;
        .                   if (g.LastItemData.InFlags & ImGuiItemFlags_HasSelectionUserData)
        .                   {
        .                       IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
        .                       g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
        .                   }
        .                   window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
        .               }
       36 ( 0.00%)  }
        .           
        .           // Handle "scoring" of an item for a tabbing/focusing request initiated by NavUpdateCreateTabbingRequest().
        .           // Note that SetKeyboardFocusHere() API calls are considered tabbing requests!
        .           // - Case 1: no nav/active id:    set result to first eligible item, stop storing.
        .           // - Case 2: tab forward:         on ref id set counter, on counter elapse store result
        .           // - Case 3: tab forward wrap:    set result to first eligible item (preemptively), on ref id set counter, on next frame if counter hasn't elapsed store result. // FIXME-TABBING: Could be done as a next-frame forwarded request
        .           // - Case 4: tab backward:        store all results, on ref id pick prev, stop storing
        .           // - Case 5: tab backward wrap:   store all results, on ref id if no result keep storing until last // FIXME-TABBING: Could be done as next-frame forwarded requested
-- line 12391 ----------------------------------------
-- line 12444 ----------------------------------------
        .                   if (can_stop && g.NavId == id)
        .                       NavMoveRequestResolveWithLastItem(result);
        .                   if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
        .                       NavApplyItemToResult(&g.NavTabbingResultFirst);
        .               }
        .           }
        .           
        .           bool ImGui::NavMoveRequestButNoResultYet()
    1,612 ( 0.00%)  {
    1,612 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,030 ( 0.00%)      return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
    1,612 ( 0.00%)  }
        .           
        .           // FIXME: ScoringRect is not set
        .           void ImGui::NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.NavWindow != NULL);
        .           
        .               if (move_flags & ImGuiNavMoveFlags_IsTabbing)
-- line 12463 ----------------------------------------
-- line 12496 ----------------------------------------
        .               g.LastItemData.InFlags = tree_node_data->InFlags & ~ImGuiItemFlags_HasSelectionUserData; // Losing SelectionUserData, recovered next-frame (cheaper).
        .               g.LastItemData.NavRect = tree_node_data->NavRect;
        .               NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
        .               NavClearPreferredPosForAxis(ImGuiAxis_Y);
        .               NavUpdateAnyRequestFlag();
        .           }
        .           
        .           void ImGui::NavMoveRequestCancel()
        6 ( 0.00%)  {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
       12 ( 0.00%)      g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        2 ( 0.00%)      NavUpdateAnyRequestFlag();
       46 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateAnyRequestFlag() (2x)
        6 ( 0.00%)  }
        .           
        .           // Forward will reuse the move request again on the next frame (generally with modifications done to it)
        .           void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.NavMoveForwardToNextFrame == false);
        .               NavMoveRequestCancel();
        .               g.NavMoveForwardToNextFrame = true;
-- line 12516 ----------------------------------------
-- line 12531 ----------------------------------------
        .               // as NavEndFrame() will do the same test. It will end up calling NavUpdateCreateWrappingRequest().
        .               if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main)
        .                   g.NavMoveFlags = (g.NavMoveFlags & ~ImGuiNavMoveFlags_WrapMask_) | wrap_flags;
        .           }
        .           
        .           // FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
        .           // This way we could find the last focused window among our children. It would be much less confusing this way?
        .           static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)
    1,206 ( 0.00%)  {
      804 ( 0.00%)      ImGuiWindow* parent = nav_window;
    2,814 ( 0.00%)      while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        .                   parent = parent->ParentWindow;
    2,010 ( 0.00%)      if (parent && parent != nav_window)
        .                   parent->NavLastChildNavWindow = nav_window;
    1,206 ( 0.00%)  }
        .           
        .           // Restore the last focused child.
        .           // Call when we are expected to land on the Main Layer (0) after FocusWindow()
        .           static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
        .           {
        .               if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
        .                   return window->NavLastChildNavWindow;
        .               if (window->DockNodeAsHost && window->DockNodeAsHost->TabBar)
-- line 12553 ----------------------------------------
-- line 12582 ----------------------------------------
        .           void ImGui::NavRestoreHighlightAfterMove()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NavDisableHighlight = false;
        .               g.NavDisableMouseHover = g.NavMousePosDirty = true;
        .           }
        .           
        .           static inline void ImGui::NavUpdateAnyRequestFlag()
    1,245 ( 0.00%)  {
      830 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,569 ( 0.00%)      g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    1,660 ( 0.00%)      if (g.NavAnyRequest)
       16 ( 0.00%)          IM_ASSERT(g.NavWindow != NULL);
    1,245 ( 0.00%)  }
        .           
        .           // This needs to be called before we submit any widget (aka in or before Begin)
        .           void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
       30 ( 0.00%)  {
        .               // FIXME: ChildWindow test here is wrong for docking
       10 ( 0.00%)      ImGuiContext& g = *GImGui;
       20 ( 0.00%)      IM_ASSERT(window == g.NavWindow);
        .           
       25 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_NoNavInputs)
        .               {
        2 ( 0.00%)          g.NavId = 0;
        4 ( 0.00%)          SetNavFocusScope(window->NavRootFocusScopeId);
      127 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavFocusScope(unsigned int) (1x)
        1 ( 0.00%)          return;
        .               }
        .           
        4 ( 0.00%)      bool init_for_nav = false;
       16 ( 0.00%)      if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
        4 ( 0.00%)          init_for_nav = true;
       20 ( 0.00%)      IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
        8 ( 0.00%)      if (init_for_nav)
        .               {
       44 ( 0.00%)          SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
    1,007 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavID(unsigned int, ImGuiNavLayer, unsigned int, ImRect const&) (4x)
      192 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect() (4x)
        8 ( 0.00%)          g.NavInitRequest = true;
        8 ( 0.00%)          g.NavInitRequestFromMove = false;
        8 ( 0.00%)          g.NavInitResult.ID = 0;
        8 ( 0.00%)          NavUpdateAnyRequestFlag();
      112 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateAnyRequestFlag() (4x)
        .               }
        .               else
        .               {
        .                   g.NavId = window->NavLastIds[0];
        .                   SetNavFocusScope(window->NavRootFocusScopeId);
        .               }
       10 ( 0.00%)  }
        .           
        .           static ImVec2 ImGui::NavCalcPreferredRefPos()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.NavWindow;
        .               if (g.NavDisableHighlight || !g.NavDisableMouseHover || !window)
        .               {
        .                   // Mouse (we need a fallback in case the mouse becomes invalid after being used)
-- line 12636 ----------------------------------------
-- line 12674 ----------------------------------------
        .               }
        .               float amount = (float)GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - (float)GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
        .               if (amount != 0.0f && IsKeyDown(key_less) && IsKeyDown(key_more)) // Cancel when opposite directions are held, regardless of repeat phase
        .                   amount = 0.0f;
        .               return amount;
        .           }
        .           
        .           static void ImGui::NavUpdate()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
        .           
      806 ( 0.00%)      io.WantSetMousePos = false;
        .               //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
        .           
        .               // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
        .               // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
    2,821 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    3,224 ( 0.00%)      const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
      806 ( 0.00%)      if (nav_gamepad_active)
        .                   for (ImGuiKey key : nav_gamepad_keys_to_change_source)
        .                       if (IsKeyDown(key))
        .                           g.NavInputSource = ImGuiInputSource_Gamepad;
    2,418 ( 0.00%)      const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    2,821 ( 0.00%)      const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
      806 ( 0.00%)      if (nav_keyboard_active)
        .                   for (ImGuiKey key : nav_keyboard_keys_to_change_source)
        .                       if (IsKeyDown(key))
        .                           g.NavInputSource = ImGuiInputSource_Keyboard;
        .           
        .               // Process navigation init request (select first/default focus)
      806 ( 0.00%)      g.NavJustMovedToId = 0;
    1,612 ( 0.00%)      if (g.NavInitResult.ID != 0)
        .                   NavInitRequestApplyResult();
      806 ( 0.00%)      g.NavInitRequest = false;
      806 ( 0.00%)      g.NavInitRequestFromMove = false;
      806 ( 0.00%)      g.NavInitResult.ID = 0;
        .           
        .               // Process navigation move request
    1,612 ( 0.00%)      if (g.NavMoveSubmitted)
        .                   NavMoveRequestApplyResult();
      806 ( 0.00%)      g.NavTabbingCounter = 0;
    2,418 ( 0.00%)      g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        .           
        .               // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
      403 ( 0.00%)      bool set_mouse_pos = false;
    1,612 ( 0.00%)      if (g.NavMousePosDirty && g.NavIdIsAlive)
        .                   if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
        .                       set_mouse_pos = true;
      806 ( 0.00%)      g.NavMousePosDirty = false;
    1,612 ( 0.00%)      IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
        .           
        .               // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
    1,612 ( 0.00%)      if (g.NavWindow)
    1,608 ( 0.00%)          NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    8,040 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow*) (402x)
    3,622 ( 0.00%)      if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
        .                   g.NavWindow->NavLastChildNavWindow = NULL;
        .           
        .               // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
      403 ( 0.00%)      NavUpdateWindowing();
  448,942 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateWindowing() (403x)
        .           
        .               // Set output flags for user application
    2,821 ( 0.00%)      io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    4,433 ( 0.00%)      io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);
        .           
        .               // Process NavCancel input (to close a popup, get back to parent, clear focus)
      403 ( 0.00%)      NavUpdateCancelRequest();
   13,299 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateCancelRequest() (403x)
        .           
        .               // Process manual activation request
    4,030 ( 0.00%)      g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
      806 ( 0.00%)      g.NavActivateFlags = ImGuiActivateFlags_None;
    1,612 ( 0.00%)      if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        .               {
        .                   const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_None)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_None));
        .                   const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, ImGuiKeyOwner_None)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_None)));
        .                   const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_None) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_None))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_None));
        .                   const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, ImGuiKeyOwner_None) || IsKeyPressed(ImGuiKey_KeypadEnter, ImGuiKeyOwner_None))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_None)));
        .                   if (g.ActiveId == 0 && activate_pressed)
        .                   {
        .                       g.NavActivateId = g.NavId;
-- line 12753 ----------------------------------------
-- line 12761 ----------------------------------------
        .                   if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down))
        .                       g.NavActivateDownId = g.NavId;
        .                   if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed))
        .                   {
        .                       g.NavActivatePressedId = g.NavId;
        .                       NavHighlightActivated(g.NavId);
        .                   }
        .               }
    4,024 ( 0.00%)      if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
       36 ( 0.00%)          g.NavDisableHighlight = true;
    1,612 ( 0.00%)      if (g.NavActivateId != 0)
        .                   IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
        .           
        .               // Highlight
    2,015 ( 0.00%)      if (g.NavHighlightActivatedTimer > 0.0f)
        .                   g.NavHighlightActivatedTimer = ImMax(0.0f, g.NavHighlightActivatedTimer - io.DeltaTime);
    3,224 ( 0.00%)      if (g.NavHighlightActivatedTimer == 0.0f)
      806 ( 0.00%)          g.NavHighlightActivatedId = 0;
        .           
        .               // Process programmatic activation request
        .               // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
    1,612 ( 0.00%)      if (g.NavNextActivateId != 0)
        .               {
        .                   g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
        .                   g.NavActivateFlags = g.NavNextActivateFlags;
        .               }
      806 ( 0.00%)      g.NavNextActivateId = 0;
        .           
        .               // Process move requests
      403 ( 0.00%)      NavUpdateCreateMoveRequest();
  208,006 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateCreateMoveRequest() (403x)
    1,612 ( 0.00%)      if (g.NavMoveDir == ImGuiDir_None)
      403 ( 0.00%)          NavUpdateCreateTabbingRequest();
   43,896 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateCreateTabbingRequest() (403x)
      403 ( 0.00%)      NavUpdateAnyRequestFlag();
    9,269 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdateAnyRequestFlag() (403x)
      806 ( 0.00%)      g.NavIdIsAlive = false;
        .           
        .               // Scrolling
    5,560 ( 0.00%)      if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
        .               {
        .                   // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
    1,152 ( 0.00%)          ImGuiWindow* window = g.NavWindow;
    4,992 ( 0.00%)          const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
   10,752 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::CalcFontSize() const (384x)
    1,152 ( 0.00%)          const ImGuiDir move_dir = g.NavMoveDir;
    3,072 ( 0.00%)          if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY && move_dir != ImGuiDir_None)
        .                   {
        .                       if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
        .                           SetScrollX(window, ImTrunc(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
        .                       if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
        .                           SetScrollY(window, ImTrunc(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        .                   }
        .           
        .                   // *Normal* Manual scroll with LStick
        .                   // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
      768 ( 0.00%)          if (nav_gamepad_active)
        .                   {
        .                       const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
        .                       const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
        .                       if (scroll_dir.x != 0.0f && window->ScrollbarX)
        .                           SetScrollX(window, ImTrunc(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
        .                       if (scroll_dir.y != 0.0f)
        .                           SetScrollY(window, ImTrunc(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
        .                   }
        .               }
        .           
        .               // Always prioritize mouse highlight if navigation is disabled
    3,224 ( 0.00%)      if (!nav_keyboard_active && !nav_gamepad_active)
        .               {
      806 ( 0.00%)          g.NavDisableHighlight = true;
    1,612 ( 0.00%)          g.NavDisableMouseHover = set_mouse_pos = false;
        .               }
        .           
        .               // Update mouse position if requested
        .               // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
      806 ( 0.00%)      if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
        .                   TeleportMousePos(NavCalcPreferredRefPos());
        .           
        .               // [DEBUG]
      806 ( 0.00%)      g.NavScoringDebugCount = 0;
        .           #if IMGUI_DEBUG_NAV_RECTS
        .               if (ImGuiWindow* debug_window = g.NavWindow)
        .               {
        .                   ImDrawList* draw_list = GetForegroundDrawList(debug_window);
        .                   int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/ { ImRect r = WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255)); }
        .                   //if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
        .               }
        .           #endif
    1,209 ( 0.00%)  }
        .           
        .           void ImGui::NavInitRequestApplyResult()
        .           {
        .               // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
        .               ImGuiContext& g = *GImGui;
        .               if (!g.NavWindow)
        .                   return;
        .           
-- line 12854 ----------------------------------------
-- line 12892 ----------------------------------------
        .               // Apply general bias on the other axis
        .               if ((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX)
        .                   r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
        .               else if ((move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX)
        .                   r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
        .           }
        .           
        .           void ImGui::NavUpdateCreateMoveRequest()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
    1,209 ( 0.00%)      ImGuiWindow* window = g.NavWindow;
    2,821 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    2,418 ( 0.00%)      const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        .           
    1,612 ( 0.00%)      if (g.NavMoveForwardToNextFrame && window != NULL)
        .               {
        .                   // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        .                   // (preserve most state, which were already set by the NavMoveRequestForward() function)
        .                   IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        .                   IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
        .                   IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
        .               }
        .               else
        .               {
        .                   // Initiate directional inputs request
      806 ( 0.00%)          g.NavMoveDir = ImGuiDir_None;
      806 ( 0.00%)          g.NavMoveFlags = ImGuiNavMoveFlags_None;
      806 ( 0.00%)          g.NavMoveScrollFlags = ImGuiScrollFlags_None;
    4,424 ( 0.00%)          if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
        .                   {
      384 ( 0.00%)              const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateNavMove;
    4,588 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
    5,760 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsActiveIdUsingNavDir(int) (384x)
    4,588 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
    5,760 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsActiveIdUsingNavDir(int) (384x)
    4,588 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
    5,760 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsActiveIdUsingNavDir(int) (384x)
    4,588 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
    5,760 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::IsActiveIdUsingNavDir(int) (384x)
        .                   }
    1,612 ( 0.00%)          g.NavMoveClipDir = g.NavMoveDir;
    5,239 ( 0.00%)          g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
   21,762 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(float, float, float, float) (403x)
        .               }
        .           
        .               // Update PageUp/PageDown/Home/End scroll
        .               // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
      806 ( 0.00%)      float scoring_rect_offset_y = 0.0f;
    3,218 ( 0.00%)      if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
        .                   scoring_rect_offset_y = NavUpdatePageUpPageDown();
    2,418 ( 0.00%)      if (scoring_rect_offset_y != 0.0f)
        .               {
        .                   g.NavScoringNoClipRect = window->InnerRect;
        .                   g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
        .               }
        .           
        .               // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
        .           #if IMGUI_DEBUG_NAV_SCORING
        .               //if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
-- line 12946 ----------------------------------------
-- line 12950 ----------------------------------------
        .                   if (g.NavMoveDir == ImGuiDir_None)
        .                       g.NavMoveDir = g.NavMoveDirForDebug;
        .                   g.NavMoveClipDir = g.NavMoveDir;
        .                   g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
        .               }
        .           #endif
        .           
        .               // Submit
      806 ( 0.00%)      g.NavMoveForwardToNextFrame = false;
    1,612 ( 0.00%)      if (g.NavMoveDir != ImGuiDir_None)
        .                   NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
        .           
        .               // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
    1,612 ( 0.00%)      if (g.NavMoveSubmitted && g.NavId == 0)
        .               {
        .                   IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
        .                   g.NavInitRequest = g.NavInitRequestFromMove = true;
        .                   g.NavInitResult.ID = 0;
        .                   g.NavDisableHighlight = false;
        .               }
        .           
        .               // When using gamepad, we project the reference nav bounding box into window visible area.
        .               // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
        .               // since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
    1,612 ( 0.00%)      if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL)// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
        .               {
        .                   bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
        .                   bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
        .                   ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
        .           
        .                   // Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
        .                   // Otherwise 'inner_rect_rel' would be off on the move result frame.
        .                   inner_rect_rel.Translate(CalcNextScrollFromScrollTargetAndClamp(window) - window->Scroll);
-- line 12982 ----------------------------------------
-- line 12991 ----------------------------------------
        .                       inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
        .                       inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
        .                       window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
        .                       g.NavId = 0;
        .                   }
        .               }
        .           
        .               // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    3,224 ( 0.00%)      ImRect scoring_rect;
      806 ( 0.00%)      if (window != NULL)
        .               {
   10,452 ( 0.00%)          ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
    7,236 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::IsInverted() const (402x)
    3,618 ( 0.00%)          scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
   36,582 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::WindowRectRelToAbs(ImGuiWindow*, ImRect const&) (402x)
    2,010 ( 0.00%)          scoring_rect.TranslateY(scoring_rect_offset_y);
    6,834 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::TranslateY(float) (402x)
    1,608 ( 0.00%)          if (g.NavMoveSubmitted)
        .                       NavBiasScoringRect(scoring_rect, window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
    2,412 ( 0.00%)          IM_ASSERT(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
    7,236 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::IsInverted() const (402x)
        .                   //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
        .                   //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
        .               }
    2,015 ( 0.00%)      g.NavScoringRect = scoring_rect;
    2,418 ( 0.00%)      g.NavScoringNoClipRect.Add(scoring_rect);
   18,941 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Add(ImRect const&) (403x)
    1,612 ( 0.00%)  }
        .           
        .           void ImGui::NavUpdateCreateTabbingRequest()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiWindow* window = g.NavWindow;
    1,612 ( 0.00%)      IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
    4,424 ( 0.00%)      if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
       38 ( 0.00%)          return;
        .           
    3,072 ( 0.00%)      const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
   28,800 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyPressed(ImGuiKey, unsigned int, int) (384x)
    1,536 ( 0.00%)      if (!tab_pressed)
      384 ( 0.00%)          return;
        .           
        .               // Initiate tabbing request
        .               // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
        .               // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
        .               const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        .               if (nav_keyboard_active)
        .                   g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavDisableHighlight == true && g.ActiveId == 0) ? 0 : +1;
        .               else
        .                   g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
        .               ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate;
        .               ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
        .               ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
        .               NavMoveRequestSubmit(ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
        .               g.NavTabbingCounter = -1;
      806 ( 0.00%)  }
        .           
        .           // Apply result from previous frame navigation directional move request. Always called from NavUpdate()
        .           void ImGui::NavMoveRequestApplyResult()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           #if IMGUI_DEBUG_NAV_SCORING
        .               if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
        .                   return;
-- line 13048 ----------------------------------------
-- line 13149 ----------------------------------------
        .                   NavRestoreHighlightAfterMove();
        .           }
        .           
        .           // Process NavCancel input (to close a popup, get back to parent, clear focus)
        .           // FIXME: In order to support e.g. Escape to clear a selection we'll need:
        .           // - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
        .           // - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
        .           static void ImGui::NavUpdateCancelRequest()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,821 ( 0.00%)      const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    2,418 ( 0.00%)      const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    4,836 ( 0.00%)      if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
      403 ( 0.00%)          return;
        .           
        .               IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
        .               if (g.ActiveId != 0)
        .               {
        .                   ClearActiveID();
        .               }
        .               else if (g.NavLayer != ImGuiNavLayer_Main)
        .               {
-- line 13170 ----------------------------------------
-- line 13189 ----------------------------------------
        .               }
        .               else
        .               {
        .                   // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
        .                   if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
        .                       g.NavWindow->NavLastIds[0] = 0;
        .                   g.NavId = 0;
        .               }
      806 ( 0.00%)  }
        .           
        .           // Handle PageUp/PageDown/Home/End keys
        .           // Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
        .           // FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
        .           // FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
        .           static float ImGui::NavUpdatePageUpPageDown()
        .           {
        .               ImGuiContext& g = *GImGui;
-- line 13205 ----------------------------------------
-- line 13270 ----------------------------------------
        .                       // FIXME-NAV: MoveClipDir left to _None, intentional?
        .                   }
        .                   return nav_scoring_rect_offset_y;
        .               }
        .               return 0.0f;
        .           }
        .           
        .           static void ImGui::NavEndFrame()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Show CTRL+TAB list window
    1,612 ( 0.00%)      if (g.NavWindowingTarget != NULL)
        .                   NavUpdateWindowingOverlay();
        .           
        .               // Perform wrap-around in menus
        .               // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
        .               // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
    4,030 ( 0.00%)      if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
    4,433 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavMoveRequestButNoResultYet() (403x)
        .                   NavUpdateCreateWrappingRequest();
    1,209 ( 0.00%)  }
        .           
        .           static void ImGui::NavUpdateCreateWrappingRequest()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.NavWindow;
        .           
        .               bool do_forward = false;
        .               ImRect bb_rel = window->NavRectRel[g.NavLayer];
-- line 13298 ----------------------------------------
-- line 13385 ----------------------------------------
        .               }
        .               g.NavWindowingToggleLayer = false;
        .           }
        .           
        .           // Windowing management mode
        .           // Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
        .           // Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
        .           static void ImGui::NavUpdateWindowing()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIO& io = g.IO;
        .           
      403 ( 0.00%)      ImGuiWindow* apply_focus_window = NULL;
      403 ( 0.00%)      bool apply_toggle_layer = false;
        .           
      806 ( 0.00%)      ImGuiWindow* modal_window = GetTopMostPopupModal();
    5,642 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetTopMostPopupModal() (403x)
    1,209 ( 0.00%)      bool allow_windowing = (modal_window == NULL); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
    1,612 ( 0.00%)      if (!allow_windowing)
        .                   g.NavWindowingTarget = NULL;
        .           
        .               // Fade out
    1,612 ( 0.00%)      if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
        .               {
        .                   g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
        .                   if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
        .                       g.NavWindowingTargetAnim = NULL;
        .               }
        .           
        .               // Start CTRL+Tab or Square+L/R window selection
        .               // (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
    2,015 ( 0.00%)      const ImGuiID owner_id = ImHashStr("###NavUpdateWindowing");
  222,456 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (403x)
    2,821 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    2,418 ( 0.00%)      const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    6,851 ( 0.00%)      const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, owner_id, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
   76,570 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Shortcut(int, unsigned int, int) (403x)
    6,851 ( 0.00%)      const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, owner_id, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
   76,570 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Shortcut(int, unsigned int, int) (403x)
    2,418 ( 0.00%)      const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, 0, ImGuiInputFlags_None);
    4,836 ( 0.00%)      const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
    1,612 ( 0.00%)      if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        .                   if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        .                   {
        .                       g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
        .                       g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
        .                       g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
        .                       g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
        .                       g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
        .           
        .                       // Register ownership of our mods. Using ImGuiInputFlags_RouteGlobalHigh in the Shortcut() calls instead would probably be correct but may have more side-effects.
        .                       if (keyboard_next_window || keyboard_prev_window)
        .                           SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiMod_Mask_, owner_id);
        .                   }
        .           
        .               // Gamepad update
    2,821 ( 0.00%)      g.NavWindowingTimer += io.DeltaTime;
    1,612 ( 0.00%)      if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
        .               {
        .                   // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        .                   g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
        .           
        .                   // Select window to focus
        .                   const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
        .                   if (focus_change_dir != 0)
        .                   {
-- line 13446 ----------------------------------------
-- line 13456 ----------------------------------------
        .                           apply_toggle_layer = true;
        .                       else if (!g.NavWindowingToggleLayer)
        .                           apply_focus_window = g.NavWindowingTarget;
        .                       g.NavWindowingTarget = NULL;
        .                   }
        .               }
        .           
        .               // Keyboard: Focus
    1,612 ( 0.00%)      if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
        .               {
        .                   // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        .                   ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
        .                   IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
        .                   g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        .                   if (keyboard_next_window || keyboard_prev_window)
        .                       NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
        .                   else if ((io.KeyMods & shared_mods) != shared_mods)
        .                       apply_focus_window = g.NavWindowingTarget;
        .               }
        .           
        .               // Keyboard: Press and Release ALT to toggle menu layer
      806 ( 0.00%)      const ImGuiKey windowing_toggle_keys[] = { ImGuiKey_LeftAlt, ImGuiKey_RightAlt };
   10,075 ( 0.00%)      for (ImGuiKey windowing_toggle_key : windowing_toggle_keys)
    4,030 ( 0.00%)          if (nav_keyboard_active && IsKeyPressed(windowing_toggle_key, ImGuiKeyOwner_None))
        .                   {
        .                       g.NavWindowingToggleLayer = true;
        .                       g.NavWindowingToggleKey = windowing_toggle_key;
        .                       g.NavInputSource = ImGuiInputSource_Keyboard;
        .                       break;
        .                   }
    1,612 ( 0.00%)      if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
        .               {
        .                   // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
        .                   // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
        .                   // - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
        .                   // We cancel toggling nav layer if an owner has claimed the key.
        .                   if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper)
        .                       g.NavWindowingToggleLayer = false;
        .                   if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_None) == false || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_None) == false)
-- line 13494 ----------------------------------------
-- line 13500 ----------------------------------------
        .                       if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
        .                           if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
        .                               apply_toggle_layer = true;
        .                   if (!IsKeyDown(g.NavWindowingToggleKey))
        .                       g.NavWindowingToggleLayer = false;
        .               }
        .           
        .               // Move window
    1,612 ( 0.00%)      if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
        .               {
        .                   ImVec2 nav_move_dir;
        .                   if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
        .                       nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
        .                   if (g.NavInputSource == ImGuiInputSource_Gamepad)
        .                       nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
        .                   if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
        .                   {
-- line 13516 ----------------------------------------
-- line 13524 ----------------------------------------
        .                           ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
        .                           SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
        .                           g.NavWindowingAccumDeltaPos -= accum_floored;
        .                       }
        .                   }
        .               }
        .           
        .               // Apply final focus
      806 ( 0.00%)      if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
        .               {
        .                   // FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
        .                   // Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
        .                   ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
        .                   ClearActiveID();
        .                   NavRestoreHighlightAfterMove();
        .                   ClosePopupsOverWindow(apply_focus_window, false);
        .                   FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
-- line 13540 ----------------------------------------
-- line 13551 ----------------------------------------
        .                   // won't be valid.
        .                   if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
        .                       g.NavLayer = ImGuiNavLayer_Menu;
        .           
        .                   // Request OS level focus
        .                   if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
        .                       g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
        .               }
      806 ( 0.00%)      if (apply_focus_window)
        .                   g.NavWindowingTarget = NULL;
        .           
        .               // Apply menu/layer toggle
      806 ( 0.00%)      if (apply_toggle_layer && g.NavWindow)
        .               {
        .                   ClearActiveID();
        .           
        .                   // Move to parent menu if necessary
        .                   ImGuiWindow* new_nav_window = g.NavWindow;
        .                   while (new_nav_window->ParentWindow
        .                       && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
        .                       && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
-- line 13571 ----------------------------------------
-- line 13585 ----------------------------------------
        .                       // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
        .                       const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
        .                       if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
        .                           g.NavWindow->NavLastIds[new_nav_layer] = 0;
        .                       NavRestoreLayer(new_nav_layer);
        .                       NavRestoreHighlightAfterMove();
        .                   }
        .               }
    1,612 ( 0.00%)  }
        .           
        .           // Window has already passed the IsWindowNavFocusable()
        .           static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
        .           {
        .               if (window->Flags & ImGuiWindowFlags_Popup)
        .                   return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingPopup);
        .               if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        .                   return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingMainMenuBar);
-- line 13601 ----------------------------------------
-- line 13962 ----------------------------------------
        .               if (push_clip_rect)
        .                   window->DrawList->PushClipRectFullScreen();
        .               window->DrawList->AddRect(bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
        .               if (push_clip_rect)
        .                   window->DrawList->PopClipRect();
        .           }
        .           
        .           const ImGuiPayload* ImGui::GetDragDropPayload()
      806 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : NULL;
      806 ( 0.00%)  }
        .           
        .           void ImGui::EndDragDropTarget()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.DragDropActive);
        .               IM_ASSERT(g.DragDropWithinTarget);
        .               g.DragDropWithinTarget = false;
        .           
-- line 13981 ----------------------------------------
-- line 14163 ----------------------------------------
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.LogEnabled)
        .                   return;
        .               LogBegin(ImGuiLogType_Buffer, auto_open_depth);
        .           }
        .           
        .           void ImGui::LogFinish()
    3,630 ( 0.00%)  {
    2,420 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,050 ( 0.00%)      if (!g.LogEnabled)
    1,210 ( 0.00%)          return;
        .           
        .               LogText(IM_NEWLINE);
        .               switch (g.LogType)
        .               {
        .               case ImGuiLogType_TTY:
        .           #ifndef IMGUI_DISABLE_TTY_FUNCTIONS
        .                   fflush(g.LogFile);
        .           #endif
-- line 14182 ----------------------------------------
-- line 14194 ----------------------------------------
        .                   IM_ASSERT(0);
        .                   break;
        .               }
        .           
        .               g.LogEnabled = false;
        .               g.LogType = ImGuiLogType_None;
        .               g.LogFile = NULL;
        .               g.LogBuffer.clear();
    2,420 ( 0.00%)  }
        .           
        .           // Helper to display logging buttons
        .           // FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
        .           void ImGui::LogButtons()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               PushID("LogButtons");
-- line 14210 ----------------------------------------
-- line 14247 ----------------------------------------
        .           // - FindWindowSettingsByID() [Internal]
        .           // - FindWindowSettingsByWindow() [Internal]
        .           // - ClearWindowSettings() [Internal]
        .           // - WindowSettingsHandler_***() [Internal]
        .           //-----------------------------------------------------------------------------
        .           
        .           // Called by NewFrame()
        .           void ImGui::UpdateSettings()
    1,209 ( 0.00%)  {
        .               // Load settings on first frame (if not explicitly loaded manually before)
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      if (!g.SettingsLoaded)
        .               {
        6 ( 0.00%)          IM_ASSERT(g.SettingsWindows.empty());
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::empty() const (1x)
        4 ( 0.00%)          if (g.IO.IniFilename)
        4 ( 0.00%)              LoadIniSettingsFromDisk(g.IO.IniFilename);
  101,353 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LoadIniSettingsFromDisk(char const*) (1x)
        2 ( 0.00%)          g.SettingsLoaded = true;
        .               }
        .           
        .               // Save settings (with a delay after the last modification, so we don't spam disk too much)
    2,015 ( 0.00%)      if (g.SettingsDirtyTimer > 0.0f)
        .               {
        .                   g.SettingsDirtyTimer -= g.IO.DeltaTime;
        .                   if (g.SettingsDirtyTimer <= 0.0f)
        .                   {
        .                       if (g.IO.IniFilename != NULL)
        .                           SaveIniSettingsToDisk(g.IO.IniFilename);
        .                       else
        .                           g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
        .                       g.SettingsDirtyTimer = 0.0f;
        .                   }
        .               }
    1,612 ( 0.00%)  }
        .           
        .           void ImGui::MarkIniSettingsDirty()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.SettingsDirtyTimer <= 0.0f)
        .                   g.SettingsDirtyTimer = g.IO.IniSavingRate;
        .           }
        .           
        .           void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
       12 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
       20 ( 0.00%)      if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        .                   if (g.SettingsDirtyTimer <= 0.0f)
        .                       g.SettingsDirtyTimer = g.IO.IniSavingRate;
       12 ( 0.00%)  }
        .           
        .           void ImGui::AddSettingsHandler(const ImGuiSettingsHandler* handler)
        8 ( 0.00%)  {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
       12 ( 0.00%)      IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
      426 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindSettingsHandler(char const*) (2x)
       12 ( 0.00%)      g.SettingsHandlers.push_back(*handler);
      292 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::push_back(ImGuiSettingsHandler const&) (2x)
        6 ( 0.00%)  }
        .           
        .           void ImGui::RemoveSettingsHandler(const char* type_name)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (ImGuiSettingsHandler* handler = FindSettingsHandler(type_name))
        .                   g.SettingsHandlers.erase(handler);
        .           }
        .           
        .           ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
       28 ( 0.00%)  {
       14 ( 0.00%)      ImGuiContext& g = *GImGui;
       42 ( 0.00%)      const ImGuiID type_hash = ImHashStr(type_name);
    1,176 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (7x)
      133 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
      105 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::end() (7x)
       49 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::begin() (7x)
       32 ( 0.00%)          if (handler.TypeHash == type_hash)
       10 ( 0.00%)              return &handler;
        2 ( 0.00%)      return NULL;
       14 ( 0.00%)  }
        .           
        .           // Clear all settings (windows, tables, docking etc.)
        .           void ImGui::ClearIniSettings()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.SettingsIniData.clear();
        .               for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        .                   if (handler.ClearAllFn != NULL)
        .                       handler.ClearAllFn(&g, &handler);
        .           }
        .           
        .           void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
        4 ( 0.00%)  {
        1 ( 0.00%)      size_t file_data_size = 0;
        7 ( 0.00%)      char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
   36,810 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFileLoadToMemory(char const*, char const*, unsigned long*, int) (1x)
        2 ( 0.00%)      if (!file_data)
        .                   return;
        3 ( 0.00%)      if (file_data_size > 0)
        5 ( 0.00%)          LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
   64,356 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LoadIniSettingsFromMemory(char const*, unsigned long) (1x)
        4 ( 0.00%)      IM_FREE(file_data);
      159 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
        2 ( 0.00%)  }
        .           
        .           // Zero-tolerance, no error reporting, cheap .ini parsing
        .           // Set ini_size==0 to let us use strlen(ini_data). Do not call this function with a 0 if your buffer is actually empty!
        .           void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        4 ( 0.00%)      IM_ASSERT(g.Initialized);
        .               //IM_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
        .               //IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);
        .           
        .               // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
        .               // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
        2 ( 0.00%)      if (ini_size == 0)
        .                   ini_size = strlen(ini_data);
        7 ( 0.00%)      g.SettingsIniData.Buf.resize((int)ini_size + 1);
      186 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<char>::resize(int) (1x)
        3 ( 0.00%)      char* const buf = g.SettingsIniData.Buf.Data;
        4 ( 0.00%)      char* const buf_end = buf + ini_size;
        7 ( 0.00%)      memcpy(buf, ini_data, ini_size);
       65 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        2 ( 0.00%)      buf_end[0] = 0;
        .           
        .               // Call pre-read handlers
        .               // Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
       33 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
       15 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::end() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::begin() (1x)
       12 ( 0.00%)          if (handler.ReadInitFn != NULL)
        7 ( 0.00%)              handler.ReadInitFn(&g, &handler);
      230 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
        .           
        1 ( 0.00%)      void* entry_data = NULL;
        1 ( 0.00%)      ImGuiSettingsHandler* entry_handler = NULL;
        .           
        1 ( 0.00%)      char* line_end = NULL;
      126 ( 0.00%)      for (char* line = buf; line < buf_end; line = line_end + 1)
        .               {
        .                   // Skip new lines markers, then find end of the line
      180 ( 0.00%)          while (*line == '\n' || *line == '\r')
        5 ( 0.00%)              line++;
       40 ( 0.00%)          line_end = line;
    4,171 ( 0.00%)          while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
      365 ( 0.00%)              line_end++;
       40 ( 0.00%)          line_end[0] = 0;
       80 ( 0.00%)          if (line[0] == ';')
        .                       continue;
      120 ( 0.00%)          if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        .                   {
        .                       // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
       15 ( 0.00%)              line_end[-1] = 0;
       15 ( 0.00%)              const char* name_end = line_end - 1;
       15 ( 0.00%)              const char* type_start = line + 1;
       35 ( 0.00%)              char* type_end = (char*)(void*)ImStrchrRange(type_start, name_end, ']');
      195 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImStrchrRange(char const*, char const*, char) (5x)
       55 ( 0.00%)              const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
      195 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImStrchrRange(char const*, char const*, char) (5x)
       20 ( 0.00%)              if (!type_end || !name_start)
        .                           continue;
       10 ( 0.00%)              *type_end = 0; // Overwrite first ']'
        5 ( 0.00%)              name_start++;  // Skip second '['
       20 ( 0.00%)              entry_handler = FindSettingsHandler(type_start);
    1,179 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindSettingsHandler(char const*) (5x)
       60 ( 0.00%)              entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
    7,543 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, char const*) (4x)
       36 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, char const*) (1x)
        5 ( 0.00%)          }
       60 ( 0.00%)          else if (entry_handler != NULL && entry_data != NULL)
        .                   {
        .                       // Let type handler parse the line
      135 ( 0.00%)              entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
   29,728 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*, char const*) (13x)
   13,635 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*, char const*) (2x)
        .                   }
        .               }
        2 ( 0.00%)      g.SettingsLoaded = true;
        .           
        .               // [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
        7 ( 0.00%)      memcpy(buf, ini_data, ini_size);
       65 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        .           
        .               // Call post-read handlers
       33 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
       15 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::end() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::begin() (1x)
       12 ( 0.00%)          if (handler.ApplyAllFn != NULL)
       21 ( 0.00%)              handler.ApplyAllFn(&g, &handler);
    4,690 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
      790 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:WindowSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_tables.cpp:TableSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
        4 ( 0.00%)  }
        .           
        .           void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.SettingsDirtyTimer = 0.0f;
        .               if (!ini_filename)
        .                   return;
        .           
-- line 14419 ----------------------------------------
-- line 14436 ----------------------------------------
        .               for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        .                   handler.WriteAllFn(&g, &handler, &g.SettingsIniData);
        .               if (out_size)
        .                   *out_size = (size_t)g.SettingsIniData.size();
        .               return g.SettingsIniData.c_str();
        .           }
        .           
        .           ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
       20 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
       20 ( 0.00%)      if (g.IO.ConfigDebugIniSettings == false)
        .               {
        .                   // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
        .                   // Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
       36 ( 0.00%)          if (const char* p = strstr(name, "###"))
    1,185 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      200 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strstr-sse2-unaligned.S:__strstr_sse2_unaligned (4x)
        .                       name = p;
        .               }
       20 ( 0.00%)      const size_t name_len = strlen(name);
       56 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (4x)
        .           
        .               // Allocate chunk
       12 ( 0.00%)      const size_t chunk_size = sizeof(ImGuiWindowSettings) + name_len + 1;
       28 ( 0.00%)      ImGuiWindowSettings* settings = g.SettingsWindows.alloc_chunk(chunk_size);
    1,515 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::alloc_chunk(unsigned long) (4x)
       24 ( 0.00%)      IM_PLACEMENT_NEW(settings) ImGuiWindowSettings();
      276 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindowSettings::ImGuiWindowSettings() (4x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (4x)
       32 ( 0.00%)      settings->ID = ImHashStr(name, name_len);
    1,661 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (4x)
       48 ( 0.00%)      memcpy(settings->GetName(), name, name_len + 1);   // Store with zero terminator
       50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4x)
       28 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindowSettings::GetName() (4x)
        .           
        4 ( 0.00%)      return settings;
       12 ( 0.00%)  }
        .           
        .           // We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
        .           // This is called once per window .ini entry + once per newly instantiated window.
        .           ImGuiWindowSettings* ImGui::FindWindowSettingsByID(ImGuiID id)
       36 ( 0.00%)  {
       18 ( 0.00%)      ImGuiContext& g = *GImGui;
      189 ( 0.00%)      for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    1,203 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::next_chunk(ImGuiWindowSettings*) (13x)
      124 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::begin() (9x)
       97 ( 0.00%)          if (settings->ID == id && !settings->WantDelete)
       10 ( 0.00%)              return settings;
        4 ( 0.00%)      return NULL;
       18 ( 0.00%)  }
        .           
        .           // This is faster if you are holding on a Window already as we don't need to perform a search.
        .           ImGuiWindowSettings* ImGui::FindWindowSettingsByWindow(ImGuiWindow* window)
       16 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
       16 ( 0.00%)      if (window->SettingsOffset != -1)
        .                   return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
       20 ( 0.00%)      return FindWindowSettingsByID(window->ID);
      818 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByID(unsigned int) (4x)
        8 ( 0.00%)  }
        .           
        .           // This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
        .           void ImGui::ClearWindowSettings(const char* name)
        .           {
        .               //IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = FindWindowByName(name);
        .               if (window != NULL)
-- line 14492 ----------------------------------------
-- line 14504 ----------------------------------------
        .           {
        .               ImGuiContext& g = *ctx;
        .               for (ImGuiWindow* window : g.Windows)
        .                   window->SettingsOffset = -1;
        .               g.SettingsWindows.clear();
        .           }
        .           
        .           static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
       24 ( 0.00%)  {
       24 ( 0.00%)      ImGuiID id = ImHashStr(name);
    1,429 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (4x)
       16 ( 0.00%)      ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByID(id);
      731 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByID(unsigned int) (4x)
        8 ( 0.00%)      if (settings)
        .                   *settings = ImGuiWindowSettings(); // Clear existing if recycling previous entry
        .               else
       16 ( 0.00%)          settings = ImGui::CreateNewWindowSettings(name);
    5,263 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CreateNewWindowSettings(char const*) (4x)
       12 ( 0.00%)      settings->ID = id;
        8 ( 0.00%)      settings->WantApply = true;
        4 ( 0.00%)      return (void*)settings;
        8 ( 0.00%)  }
        .           
        .           static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
       91 ( 0.00%)  {
       26 ( 0.00%)      ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
        .               int x, y;
        .               int i;
        .               ImU32 u1;
      200 ( 0.00%)      if (sscanf(line, "Pos=%i,%i", &x, &y) == 2)             { settings->Pos = ImVec2ih((short)x, (short)y); }
    9,123 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (13x)
       68 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImVec2ih::ImVec2ih(short, short) (4x)
      152 ( 0.00%)      else if (sscanf(line, "Size=%i,%i", &x, &y) == 2)       { settings->Size = ImVec2ih((short)x, (short)y); }
    8,050 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (9x)
       68 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImVec2ih::ImVec2ih(short, short) (4x)
       55 ( 0.00%)      else if (sscanf(line, "ViewportId=0x%08X", &u1) == 1)   { settings->ViewportId = u1; }
    1,860 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (5x)
       60 ( 0.00%)      else if (sscanf(line, "ViewportPos=%i,%i", &x, &y) == 2){ settings->ViewportPos = ImVec2ih((short)x, (short)y); }
    1,860 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (5x)
       75 ( 0.00%)      else if (sscanf(line, "Collapsed=%d", &i) == 1)         { settings->Collapsed = (i != 0); }
    4,700 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (5x)
       11 ( 0.00%)      else if (sscanf(line, "IsChild=%d", &i) == 1)           { settings->IsChild = (i != 0); }
      372 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       12 ( 0.00%)      else if (sscanf(line, "DockId=0x%X,%d", &u1, &i) == 2)  { settings->DockId = u1; settings->DockOrder = (short)i; }
    1,448 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       16 ( 0.00%)      else if (sscanf(line, "DockId=0x%X", &u1) == 1)         { settings->DockId = u1; settings->DockOrder = -1; }
    1,429 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        .               else if (sscanf(line, "ClassId=0x%X", &u1) == 1)        { settings->ClassId = u1; }
       52 ( 0.00%)  }
        .           
        .           // Apply to existing windows (if any)
        .           static void WindowSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *ctx;
       44 ( 0.00%)      for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
      369 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::next_chunk(ImGuiWindowSettings*) (4x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::begin() (1x)
       16 ( 0.00%)          if (settings->WantApply)
        .                   {
       28 ( 0.00%)              if (ImGuiWindow* window = ImGui::FindWindowByID(settings->ID))
      300 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowByID(unsigned int) (4x)
        .                           ApplyWindowSettings(window, settings);
        8 ( 0.00%)              settings->WantApply = false;
        .                   }
        4 ( 0.00%)  }
        .           
        .           static void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
        .           {
        .               // Gather data from windows that were active during this session
        .               // (if a window wasn't opened in this session we preserve its settings)
        .               ImGuiContext& g = *ctx;
        .               for (ImGuiWindow* window : g.Windows)
        .               {
-- line 14560 ----------------------------------------
-- line 14622 ----------------------------------------
        .           }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] LOCALIZATION
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImGui::LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count)
        4 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
       49 ( 0.00%)      for (int n = 0; n < count; n++)
      198 ( 0.00%)          g.LocalizationTable[entries[n].Key] = entries[n].Text;
        4 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] VIEWPORTS, PLATFORM WINDOWS
        .           //-----------------------------------------------------------------------------
        .           // - GetMainViewport()
        .           // - FindViewportByID()
        .           // - FindViewportByPlatformHandle()
-- line 14642 ----------------------------------------
-- line 14658 ----------------------------------------
        .           // - FindPlatformMonitorForPos() [Internal]
        .           // - FindPlatformMonitorForRect() [Internal]
        .           // - UpdateViewportPlatformMonitor() [Internal]
        .           // - DestroyPlatformWindow() [Internal]
        .           // - DestroyPlatformWindows()
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiViewport* ImGui::GetMainViewport()
   12,129 ( 0.00%)  {
    8,086 ( 0.00%)      ImGuiContext& g = *GImGui;
   24,258 ( 0.00%)      return g.Viewports[0];
   76,817 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (4,043x)
    8,086 ( 0.00%)  }
        .           
        .           // FIXME: This leaks access to viewports not listed in PlatformIO.Viewports[]. Problematic? (#4236)
        .           ImGuiViewport* ImGui::FindViewportByID(ImGuiID id)
    3,900 ( 0.00%)  {
    1,950 ( 0.00%)      ImGuiContext& g = *GImGui;
   17,565 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
   11,700 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (975x)
    6,825 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (975x)
    3,904 ( 0.00%)          if (viewport->ID == id)
    1,946 ( 0.00%)              return viewport;
        2 ( 0.00%)      return NULL;
    1,950 ( 0.00%)  }
        .           
        .           ImGuiViewport* ImGui::FindViewportByPlatformHandle(void* platform_handle)
      668 ( 0.00%)  {
      334 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,006 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
    2,004 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (167x)
    1,169 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (167x)
      668 ( 0.00%)          if (viewport->PlatformHandle == platform_handle)
      334 ( 0.00%)              return viewport;
        .               return NULL;
      334 ( 0.00%)  }
        .           
        .           void ImGui::SetCurrentViewport(ImGuiWindow* current_window, ImGuiViewportP* viewport)
   20,160 ( 0.00%)  {
    8,064 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               (void)current_window;
        .           
    8,064 ( 0.00%)      if (viewport)
   14,516 ( 0.00%)          viewport->LastFrameActive = g.FrameCount;
   16,128 ( 0.00%)      if (g.CurrentViewport == viewport)
    3,224 ( 0.00%)          return;
    4,850 ( 0.00%)      g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
    2,424 ( 0.00%)      g.CurrentViewport = viewport;
        .               //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
        .           
        .               // Notify platform layer of viewport changes
        .               // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
    4,852 ( 0.00%)      if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
        .                   g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
    8,064 ( 0.00%)  }
        .           
        .           void ImGui::SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
       10 ( 0.00%)  {
        .               // Abandon viewport
        8 ( 0.00%)      if (window->ViewportOwned && window->Viewport->Window == window)
        .                   window->Viewport->Size = ImVec2(0.0f, 0.0f);
        .           
        6 ( 0.00%)      window->Viewport = viewport;
        8 ( 0.00%)      window->ViewportId = viewport->ID;
       12 ( 0.00%)      window->ViewportOwned = (viewport->Window == window);
        6 ( 0.00%)  }
        .           
        .           static bool ImGui::GetWindowAlwaysWantOwnViewport(ImGuiWindow* window)
    2,427 ( 0.00%)  {
        .               // Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
    1,618 ( 0.00%)      ImGuiContext& g = *GImGui;
    7,281 ( 0.00%)      if (g.IO.ConfigViewportsNoAutoMerge || (window->WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_NoAutoMerge))
        .                   if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
        .                       if (!window->DockIsActive)
        .                           if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip)) == 0)
        .                               if ((window->Flags & ImGuiWindowFlags_Popup) == 0 || (window->Flags & ImGuiWindowFlags_Modal) != 0)
        .                                   return true;
      809 ( 0.00%)      return false;
    1,618 ( 0.00%)  }
        .           
        .           static bool ImGui::UpdateTryMergeWindowIntoHostViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
       15 ( 0.00%)  {
        6 ( 0.00%)      ImGuiContext& g = *GImGui;
       12 ( 0.00%)      if (window->Viewport == viewport)
        .                   return false;
       15 ( 0.00%)      if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) == 0)
        .                   return false;
       15 ( 0.00%)      if ((viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0)
        .                   return false;
       66 ( 0.00%)      if (!viewport->GetMainRect().Contains(window->Rect()))
      258 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::Rect() const (3x)
      258 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (3x)
       89 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Contains(ImRect const&) const (3x)
        2 ( 0.00%)          return false;
       10 ( 0.00%)      if (GetWindowAlwaysWantOwnViewport(window))
       34 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetWindowAlwaysWantOwnViewport(ImGuiWindow*) (2x)
        .                   return false;
        .           
        .               // FIXME: Can't use g.WindowsFocusOrder[] for root windows only as we care about Z order. If we maintained a DisplayOrder along with FocusOrder we could..
       71 ( 0.00%)      for (ImGuiWindow* window_behind : g.Windows)
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (2x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (2x)
        .               {
       21 ( 0.00%)          if (window_behind == window)
        2 ( 0.00%)              break;
       20 ( 0.00%)          if (window_behind->WasActive && window_behind->ViewportOwned && !(window_behind->Flags & ImGuiWindowFlags_ChildWindow))
        .                       if (window_behind->Viewport->GetMainRect().Overlaps(window->Rect()))
        .                           return false;
        .               }
        .           
        .               // Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
        6 ( 0.00%)      ImGuiViewportP* old_viewport = window->Viewport;
        8 ( 0.00%)      if (window->ViewportOwned)
        .                   for (int n = 0; n < g.Windows.Size; n++)
        .                       if (g.Windows[n]->Viewport == old_viewport)
        .                           SetWindowViewport(g.Windows[n], viewport);
       10 ( 0.00%)      SetWindowViewport(window, viewport);
       50 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetWindowViewport(ImGuiWindow*, ImGuiViewportP*) (2x)
        6 ( 0.00%)      BringWindowToDisplayFront(window);
       82 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BringWindowToDisplayFront(ImGuiWindow*) (2x)
        .           
        2 ( 0.00%)      return true;
        6 ( 0.00%)  }
        .           
        .           // FIXME: handle 0 to N host viewports
        .           static bool ImGui::UpdateTryMergeWindowIntoHostViewports(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports[0]);
        .           }
        .           
        .           // Translate Dear ImGui windows when a Host Viewport has been moved
        .           // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
        .           void ImGui::TranslateWindowsInViewport(ImGuiViewportP* viewport, const ImVec2& old_pos, const ImVec2& new_pos)
       12 ( 0.00%)  {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
       18 ( 0.00%)      IM_ASSERT(viewport->Window == NULL && (viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows));
        .           
        .               // 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
        .               // translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
        .               // 2) If it's not going to fit into the new size, keep it at same absolute position.
        .               // One problem with this is that most Win32 applications doesn't update their render while dragging,
        .               // and so the window will appear to teleport when releasing the mouse.
       18 ( 0.00%)      const bool translate_all_windows = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable);
       28 ( 0.00%)      ImRect test_still_fit_rect(old_pos, old_pos + viewport->Size);
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (2x)
       32 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (2x)
       14 ( 0.00%)      ImVec2 delta_pos = new_pos - old_pos;
       78 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (2x)
       72 ( 0.00%)      for (ImGuiWindow* window : g.Windows) // FIXME-OPT
       24 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (2x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (2x)
      129 ( 0.00%)          if (translate_all_windows || (window->Viewport == viewport && test_still_fit_rect.Contains(window->Rect())))
      430 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiWindow::Rect() const (5x)
      160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Contains(ImRect const&) const (5x)
       25 ( 0.00%)              TranslateWindow(window, delta_pos);
    1,330 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:TranslateWindow(ImGuiWindow*, ImVec2 const&) (5x)
        8 ( 0.00%)  }
        .           
        .           // Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
        .           void ImGui::ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (viewport->Window)
        .               {
        .                   ScaleWindow(viewport->Window, scale);
-- line 14802 ----------------------------------------
-- line 14821 ----------------------------------------
        .                       if (best_candidate == NULL || best_candidate->LastFocusedStampCount < viewport->LastFocusedStampCount)
        .                           best_candidate = viewport;
        .               return best_candidate;
        .           }
        .           
        .           // Update viewports and monitor infos
        .           // Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
        .           static void ImGui::UpdateViewportsNewFrame()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,418 ( 0.00%)      IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
        .           
        .               // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
        .               // Update Focused status
    2,418 ( 0.00%)      const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
      806 ( 0.00%)      if (viewports_enabled)
        .               {
      403 ( 0.00%)          ImGuiViewportP* focused_viewport = NULL;
    8,887 ( 0.00%)          for (ImGuiViewportP* viewport : g.Viewports)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::begin() (403x)
        .                   {
    1,218 ( 0.00%)              const bool platform_funcs_available = viewport->PlatformWindowCreated;
    2,436 ( 0.00%)              if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
        .                       {
    2,418 ( 0.00%)                  bool is_minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
   13,299 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowMinimized(ImGuiViewport*) (403x)
      806 ( 0.00%)                  if (is_minimized)
        .                               viewport->Flags |= ImGuiViewportFlags_IsMinimized;
        .                           else
    2,418 ( 0.00%)                      viewport->Flags &= ~ImGuiViewportFlags_IsMinimized;
        .                       }
        .           
        .                       // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
        .                       // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
    2,436 ( 0.00%)              if (g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available)
        .                       {
    2,418 ( 0.00%)                  bool is_focused = g.PlatformIO.Platform_GetWindowFocus(viewport);
   13,299 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowFocus(ImGuiViewport*) (403x)
      806 ( 0.00%)                  if (is_focused)
    1,393 ( 0.00%)                      viewport->Flags |= ImGuiViewportFlags_IsFocused;
        .                           else
    1,224 ( 0.00%)                      viewport->Flags &= ~ImGuiViewportFlags_IsFocused;
      806 ( 0.00%)                  if (is_focused)
      398 ( 0.00%)                      focused_viewport = viewport;
        .                       }
        .                   }
        .           
        .                   // Focused viewport has changed?
    2,000 ( 0.00%)          if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport->ID)
        .                   {
        5 ( 0.00%)              IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport->ID);
        5 ( 0.00%)              const ImGuiViewport* prev_focused_viewport = FindViewportByID(g.PlatformLastFocusedViewportId);
       65 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindViewportByID(unsigned int) (1x)
        5 ( 0.00%)              const bool prev_focused_has_been_destroyed = (prev_focused_viewport == NULL) || (prev_focused_viewport->PlatformWindowCreated == false);
        .           
        .                       // Store a tag so we can infer z-order easily from all our windows
        .                       // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
        .                       // will keep the front most stamp instead of losing it back to their parent viewport.
        6 ( 0.00%)              if (focused_viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
        9 ( 0.00%)                  focused_viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
        4 ( 0.00%)              g.PlatformLastFocusedViewportId = focused_viewport->ID;
        .           
        .                       // Focus associated dear imgui window
        .                       // - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
        .                       // - if focus didn't happen because we destroyed another window (#6462)
        .                       // FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
       10 ( 0.00%)              const bool apply_imgui_focus_on_focused_viewport = !IsAnyMouseDown() && !prev_focused_has_been_destroyed;
       56 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsAnyMouseDown() (1x)
        2 ( 0.00%)              if (apply_imgui_focus_on_focused_viewport)
        .                       {
        .                           focused_viewport->LastFocusedHadNavWindow |= (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
        .                           ImGuiFocusRequestFlags focus_request_flags = ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild;
        .                           if (focused_viewport->Window != NULL)
        .                               FocusWindow(focused_viewport->Window, focus_request_flags);
        .                           else if (focused_viewport->LastFocusedHadNavWindow)
        .                               FocusTopMostWindowUnderOne(NULL, NULL, focused_viewport, focus_request_flags); // Focus top most in viewport
        .                           else
        .                               FocusWindow(NULL, focus_request_flags); // No window had focus last time viewport was focused
        .                       }
        .                   }
      806 ( 0.00%)          if (focused_viewport)
    2,587 ( 0.00%)              focused_viewport->LastFocusedHadNavWindow = (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport);
        .               }
        .           
        .               // Create/update main viewport with current platform position.
        .               // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
    2,821 ( 0.00%)      ImGuiViewportP* main_viewport = g.Viewports[0];
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (403x)
    1,612 ( 0.00%)      IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
    1,612 ( 0.00%)      IM_ASSERT(main_viewport->Window == NULL);
    4,030 ( 0.00%)      ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
   34,326 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowPos(ImGuiViewport*) (403x)
    1,209 ( 0.00%)      ImVec2 main_viewport_size = g.IO.DisplaySize;
    2,821 ( 0.00%)      if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_IsMinimized))
        .               {
        .                   main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
        .                   main_viewport_size = main_viewport->Size;
        .               }
    3,224 ( 0.00%)      AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
  109,217 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::AddUpdateViewport(ImGuiWindow*, unsigned int, ImVec2 const&, ImVec2 const&, int) (403x)
        .           
    1,209 ( 0.00%)      g.CurrentDpiScale = 0.0f;
      806 ( 0.00%)      g.CurrentViewport = NULL;
      806 ( 0.00%)      g.MouseViewport = NULL;
    4,448 ( 0.00%)      for (int n = 0; n < g.Viewports.Size; n++)
        .               {
    3,248 ( 0.00%)          ImGuiViewportP* viewport = g.Viewports[n];
    7,714 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (406x)
    1,218 ( 0.00%)          viewport->Idx = n;
        .           
        .                   // Erase unused viewports
      833 ( 0.00%)          if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
        .                   {
        3 ( 0.00%)              DestroyViewport(viewport);
      737 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DestroyViewport(ImGuiViewportP*) (1x)
        2 ( 0.00%)              n--;
        .                       continue;
        .                   }
        .           
    1,215 ( 0.00%)          const bool platform_funcs_available = viewport->PlatformWindowCreated;
      810 ( 0.00%)          if (viewports_enabled)
        .                   {
        .                       // Update Position and Size (from Platform Window to ImGui) if requested.
        .                       // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
    2,835 ( 0.00%)              if (!(viewport->Flags & ImGuiViewportFlags_IsMinimized) && platform_funcs_available)
        .                       {
        .                           // Viewport->WorkPos and WorkSize will be updated below
    1,612 ( 0.00%)                  if (viewport->PlatformRequestMove)
       13 ( 0.00%)                      viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
       83 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowPos(ImGuiViewport*) (1x)
    1,612 ( 0.00%)                  if (viewport->PlatformRequestResize)
        .                               viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
        .                       }
        .                   }
        .           
        .                   // Update/copy monitor info
    1,215 ( 0.00%)          UpdateViewportPlatformMonitor(viewport);
  128,565 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP*) (405x)
        .           
        .                   // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
    1,620 ( 0.00%)          viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
    1,620 ( 0.00%)          viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
    5,670 ( 0.00%)          viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
    5,670 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (405x)
    1,215 ( 0.00%)          viewport->UpdateWorkRect();
   58,725 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::UpdateWorkRect() (405x)
        .           
        .                   // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
    1,215 ( 0.00%)          viewport->Alpha = 1.0f;
        .           
        .                   // Translate Dear ImGui windows when a Host Viewport has been moved
        .                   // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
    3,645 ( 0.00%)          const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
   15,795 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator-(ImVec2 const&, ImVec2 const&) (405x)
    7,660 ( 0.00%)          if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
       16 ( 0.00%)              TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);
    2,474 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::TranslateWindowsInViewport(ImGuiViewportP*, ImVec2 const&, ImVec2 const&) (2x)
        .           
        .                   // Update DPI scale
        .                   float new_dpi_scale;
    1,620 ( 0.00%)          if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
        .                       new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
    1,620 ( 0.00%)          else if (viewport->PlatformMonitor != -1)
    4,455 ( 0.00%)              new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
    8,910 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::operator[](int) (405x)
        .                   else
        .                       new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
    5,664 ( 0.00%)          if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
        .                   {
        .                       float scale_factor = new_dpi_scale / viewport->DpiScale;
        .                       if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
        .                           ScaleWindowsInViewport(viewport, scale_factor);
        .                       //if (viewport == GetMainViewport())
        .                       //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
        .           
        .                       // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
        .                       // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
        .                       // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
        .                       //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
        .                       //    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
        .                   }
    1,215 ( 0.00%)          viewport->DpiScale = new_dpi_scale;
        .               }
        .           
        .               // Update fallback monitor
    5,239 ( 0.00%)      g.PlatformMonitorsFullWorkRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
   21,762 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(float, float, float, float) (403x)
    1,612 ( 0.00%)      if (g.PlatformIO.Monitors.Size == 0)
        .               {
        .                   ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
        .                   monitor->MainPos = main_viewport->Pos;
        .                   monitor->MainSize = main_viewport->Size;
        .                   monitor->WorkPos = main_viewport->WorkPos;
        .                   monitor->WorkSize = main_viewport->WorkSize;
        .                   monitor->DpiScale = main_viewport->DpiScale;
        .                   g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos);
        .                   g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos + monitor->WorkSize);
        .               }
   10,881 ( 0.00%)      for (ImGuiPlatformMonitor& monitor : g.PlatformIO.Monitors)
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::begin() (403x)
        .               {
    5,642 ( 0.00%)          g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos);
   33,449 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Add(ImVec2 const&) (806x)
   12,090 ( 0.00%)          g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos + monitor.WorkSize);
   30,225 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Add(ImVec2 const&) (806x)
   31,434 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (806x)
        .               }
        .           
    1,612 ( 0.00%)      if (!viewports_enabled)
        .               {
        .                   g.MouseViewport = main_viewport;
        .                   return;
        .               }
        .           
        .               // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
        .               // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
      403 ( 0.00%)      ImGuiViewportP* viewport_hovered = NULL;
    2,015 ( 0.00%)      if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
        .               {
    3,086 ( 0.00%)          viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
    8,517 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindViewportByID(unsigned int) (167x)
    1,641 ( 0.00%)          if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
        .                       viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
        .               }
        .               else
        .               {
        .                   // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
        .                   // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
        .                   // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
        .                   // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
        .                   viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
        .               }
      806 ( 0.00%)      if (viewport_hovered != NULL)
      668 ( 0.00%)          g.MouseLastHoveredViewport = viewport_hovered;
      944 ( 0.00%)      else if (g.MouseLastHoveredViewport == NULL)
        8 ( 0.00%)          g.MouseLastHoveredViewport = g.Viewports[0];
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (1x)
        .           
        .               // Update mouse reference viewport
        .               // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
        .               // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
    1,612 ( 0.00%)      if (g.MovingWindow && g.MovingWindow->Viewport)
        .                   g.MouseViewport = g.MovingWindow->Viewport;
        .               else
    1,612 ( 0.00%)          g.MouseViewport = g.MouseLastHoveredViewport;
        .           
        .               // When dragging something, always refer to the last hovered viewport.
        .               // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
        .               // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
        .               // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
        .               // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
    1,209 ( 0.00%)      const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
      806 ( 0.00%)      if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
        .                   viewport_hovered = g.MouseLastHoveredViewport;
    4,047 ( 0.00%)      if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
      166 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsAnyMouseDown() (5x)
    1,456 ( 0.00%)          if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
        .                       g.MouseViewport = viewport_hovered;
        .           
    1,612 ( 0.00%)      IM_ASSERT(g.MouseViewport != NULL);
    1,209 ( 0.00%)  }
        .           
        .           // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
        .           static void ImGui::UpdateViewportsEndFrame()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      g.PlatformIO.Viewports.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewport*>::resize(int) (403x)
    4,448 ( 0.00%)      for (int i = 0; i < g.Viewports.Size; i++)
        .               {
    3,248 ( 0.00%)          ImGuiViewportP* viewport = g.Viewports[i];
    7,714 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (406x)
    1,624 ( 0.00%)          viewport->LastPos = viewport->Pos;
    6,476 ( 0.00%)          if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
        4 ( 0.00%)              if (i > 0) // Always include main viewport in the list
        4 ( 0.00%)                  continue;
    2,836 ( 0.00%)          if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
       15 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:IsWindowActiveAndVisible(ImGuiWindow*) (1x)
        1 ( 0.00%)              continue;
      806 ( 0.00%)          if (i > 0)
        .                       IM_ASSERT(viewport->Window != NULL);
    3,627 ( 0.00%)          g.PlatformIO.Viewports.push_back(viewport);
   11,687 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewport*>::push_back(ImGuiViewport* const&) (403x)
        .               }
    3,224 ( 0.00%)      g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (403x)
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::ClearRequestFlags() (403x)
    1,209 ( 0.00%)  }
        .           
        .           // FIXME: We should ideally refactor the system to call this every frame (we currently don't)
        .           ImGuiViewportP* ImGui::AddUpdateViewport(ImGuiWindow* window, ImGuiID id, const ImVec2& pos, const ImVec2& size, ImGuiViewportFlags flags)
    4,848 ( 0.00%)  {
      808 ( 0.00%)      ImGuiContext& g = *GImGui;
      808 ( 0.00%)      IM_ASSERT(id != 0);
        .           
      404 ( 0.00%)      flags |= ImGuiViewportFlags_IsPlatformWindow;
      808 ( 0.00%)      if (window != NULL)
        .               {
        4 ( 0.00%)          if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
        .                       flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
        5 ( 0.00%)          if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
        .                       flags |= ImGuiViewportFlags_NoInputs;
        5 ( 0.00%)          if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
        .                       flags |= ImGuiViewportFlags_NoFocusOnAppearing;
        .               }
        .           
    1,616 ( 0.00%)      ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
   20,607 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindViewportByID(unsigned int) (404x)
    1,212 ( 0.00%)      if (viewport)
        .               {
        .                   // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
    2,019 ( 0.00%)          if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
    1,612 ( 0.00%)              viewport->Pos = pos;
    2,015 ( 0.00%)          if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
    1,612 ( 0.00%)              viewport->Size = size;
    3,224 ( 0.00%)          viewport->Flags = flags | (viewport->Flags & (ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_IsFocused)); // Preserve existing flags
        .               }
        .               else
        .               {
        .                   // New viewport
       11 ( 0.00%)          viewport = IM_NEW(ImGuiViewportP)();
      509 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::ImGuiViewportP() (1x)
      118 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        3 ( 0.00%)          viewport->ID = id;
        4 ( 0.00%)          viewport->Idx = g.Viewports.Size;
        9 ( 0.00%)          viewport->Pos = viewport->LastPos = pos;
        4 ( 0.00%)          viewport->Size = size;
        3 ( 0.00%)          viewport->Flags = flags;
        3 ( 0.00%)          UpdateViewportPlatformMonitor(viewport);
      317 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP*) (1x)
        6 ( 0.00%)          g.Viewports.push_back(viewport);
       29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::push_back(ImGuiViewportP* const&) (1x)
        5 ( 0.00%)          g.ViewportCreatedCount++;
        5 ( 0.00%)          IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
        .           
        .                   // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
        .                   // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
       10 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (1x)
       10 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMin<float>(float, float) (1x)
       13 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (1x)
       13 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (1x)
        .           
        .                   // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
        .                   // This is so we can select an appropriate font size on the first frame of our window lifetime
        4 ( 0.00%)          if (viewport->PlatformMonitor != -1)
       11 ( 0.00%)              viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::operator[](int) (1x)
        .               }
        .           
    1,212 ( 0.00%)      viewport->Window = window;
    1,616 ( 0.00%)      viewport->LastFrameActive = g.FrameCount;
    1,212 ( 0.00%)      viewport->UpdateWorkRect();
   58,580 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::UpdateWorkRect() (404x)
      814 ( 0.00%)      IM_ASSERT(window == NULL || viewport->ID == window->ID);
        .           
      808 ( 0.00%)      if (window != NULL)
        2 ( 0.00%)          window->ViewportOwned = true;
        .           
      808 ( 0.00%)      return viewport;
    2,828 ( 0.00%)  }
        .           
        .           static void ImGui::DestroyViewport(ImGuiViewportP* viewport)
        4 ( 0.00%)  {
        .               // Clear references to this viewport in windows (window->ViewportId becomes the master data)
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
       57 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (1x)
        .               {
       24 ( 0.00%)          if (window->Viewport != viewport)
        5 ( 0.00%)              continue;
        2 ( 0.00%)          window->Viewport = NULL;
        3 ( 0.00%)          window->ViewportOwned = false;
        .               }
        4 ( 0.00%)      if (viewport == g.MouseLastHoveredViewport)
        .                   g.MouseLastHoveredViewport = NULL;
        .           
        .               // Destroy
        5 ( 0.00%)      IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Delete Viewport %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
        3 ( 0.00%)      DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
       54 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DestroyPlatformWindow(ImGuiViewportP*) (1x)
       11 ( 0.00%)      IM_ASSERT(g.PlatformIO.Viewports.contains(viewport) == false);
       35 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewport*>::contains(ImGuiViewport* const&) const (1x)
       10 ( 0.00%)      IM_ASSERT(g.Viewports[viewport->Idx] == viewport);
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (1x)
       12 ( 0.00%)      g.Viewports.erase(g.Viewports.Data + viewport->Idx);
       72 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::erase(ImGuiViewportP* const*) (1x)
        3 ( 0.00%)      IM_DELETE(viewport);
      390 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:void IM_DELETE<ImGuiViewportP>(ImGuiViewportP*) (1x)
        3 ( 0.00%)  }
        .           
        .           // FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
        .           static void ImGui::WindowSelectViewport(ImGuiWindow* window)
    8,064 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,048 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
    4,032 ( 0.00%)      window->ViewportAllowPlatformMonitorExtend = -1;
        .           
        .               // Restore main viewport if multi-viewport is not supported by the backend
    4,032 ( 0.00%)      ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
   64,512 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetMainViewport() (2,016x)
   10,080 ( 0.00%)      if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
        .               {
        .                   SetWindowViewport(window, main_viewport);
        .                   return;
        .               }
    4,032 ( 0.00%)      window->ViewportOwned = false;
        .           
        .               // Appearing popups reset their viewport so they can inherit again
    8,064 ( 0.00%)      if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
        .               {
        .                   window->Viewport = NULL;
        .                   window->ViewportId = 0;
        .               }
        .           
   10,080 ( 0.00%)      if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
        .               {
        .                   // By default inherit from parent window
    6,484 ( 0.00%)          if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
       10 ( 0.00%)              window->Viewport = window->ParentWindow->Viewport;
        .           
        .                   // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
    6,464 ( 0.00%)          if (window->Viewport == NULL && window->ViewportId != 0)
        .                   {
        .                       window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
        .                       if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
        .                           window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
        .                   }
        .               }
        .           
    2,016 ( 0.00%)      bool lock_viewport = false;
   10,080 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
        .               {
        .                   // Code explicitly request a viewport
    2,418 ( 0.00%)          window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
   20,553 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindViewportByID(unsigned int) (403x)
    1,612 ( 0.00%)          window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
    3,627 ( 0.00%)          if (window->Viewport && (window->Flags & ImGuiWindowFlags_DockNodeHost) != 0 && window->Viewport->Window != NULL)
        .                   {
        .                       window->Viewport->Window = window;
        .                       window->Viewport->ID = window->ViewportId = window->ID; // Overwrite ID (always owned by node)
        .                   }
      806 ( 0.00%)          lock_viewport = true;
        .               }
    9,680 ( 0.00%)      else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
        .               {
        .                   // Always inherit viewport from parent window
    5,239 ( 0.00%)          if (window->DockNode && window->DockNode->HostWindow)
    3,627 ( 0.00%)              IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
    4,836 ( 0.00%)          window->Viewport = window->ParentWindow->Viewport;
        .               }
    3,228 ( 0.00%)      else if (window->DockNode && window->DockNode->HostWindow)
        .               {
        .                   // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
        .                   window->Viewport = window->DockNode->HostWindow->Viewport;
        .               }
    3,228 ( 0.00%)      else if (flags & ImGuiWindowFlags_Tooltip)
        .               {
        .                   window->Viewport = g.MouseViewport;
        .               }
    4,035 ( 0.00%)      else if (GetWindowAlwaysWantOwnViewport(window))
   13,719 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetWindowAlwaysWantOwnViewport(ImGuiWindow*) (807x)
        .               {
        .                   window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
        .               }
    5,649 ( 0.00%)      else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
        .               {
        .                   if (window->Viewport != NULL && window->Viewport->Window == window)
        .                       window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
        .               }
        .               else
        .               {
        .                   // Merge into host viewport?
        .                   // We cannot test window->ViewportOwned as it set lower in the function.
        .                   // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
    8,862 ( 0.00%)          bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
    1,614 ( 0.00%)          if (try_to_merge_into_host_viewport)
        .                       UpdateTryMergeWindowIntoHostViewports(window);
        .               }
        .           
        .               // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
    8,064 ( 0.00%)      if (window->Viewport == NULL)
       24 ( 0.00%)          if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
    1,102 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateTryMergeWindowIntoHostViewport(ImGuiWindow*, ImGuiViewportP*) (3x)
       12 ( 0.00%)              window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
    1,428 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::AddUpdateViewport(ImGuiWindow*, unsigned int, ImVec2 const&, ImVec2 const&, int) (1x)
        .           
        .               // Mark window as allowed to protrude outside of its viewport and into the current monitor
    8,064 ( 0.00%)      if (!lock_viewport)
        .               {
    6,452 ( 0.00%)          if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        .                   {
        .                       // We need to take account of the possibility that mouse may become invalid.
        .                       // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
        .                       ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
        .                       bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
        .                       bool mouse_valid = IsMousePosValid(&mouse_ref);
        .                       if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
        .                           window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
        .                       else
        .                           window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
        .                   }
   22,577 ( 0.00%)          else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
        .                   {
        .                       // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
        .                       const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
        .                       if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
        .                       {
        .                           // Steal/transfer ownership
        .                           IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
        .                           window->Viewport->Window = window;
-- line 15281 ----------------------------------------
-- line 15283 ----------------------------------------
        .                           window->Viewport->LastNameHash = 0;
        .                       }
        .                       else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
        .                       {
        .                           // New viewport
        .                           window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
        .                       }
        .                   }
   12,904 ( 0.00%)          else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
        .                   {
        .                       // Regular (non-child, non-popup) windows by default are also allowed to protrude
        .                       // Child windows are kept contained within their parent.
    5,649 ( 0.00%)              window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
        .                   }
        .               }
        .           
        .               // Update flags
   14,112 ( 0.00%)      window->ViewportOwned = (window == window->Viewport->Window);
   10,080 ( 0.00%)      window->ViewportId = window->Viewport->ID;
        .           
        .               // If the OS window has a title bar, hide our imgui title bar
        .               //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
        .               //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
    4,032 ( 0.00%)  }
        .           
        .           void ImGui::WindowSyncOwnedViewport(ImGuiWindow* window, ImGuiWindow* parent_window_in_stack)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        1 ( 0.00%)      bool viewport_rect_changed = false;
        .           
        .               // Synchronize window --> viewport in most situations
        .               // Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
        5 ( 0.00%)      if (window->Viewport->PlatformRequestMove)
        .               {
        .                   window->Pos = window->Viewport->Pos;
        .                   MarkIniSettingsDirty(window);
        .               }
       12 ( 0.00%)      else if (memcmp(&window->Viewport->Pos, &window->Pos, sizeof(window->Pos)) != 0)
       19 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1x)
        .               {
        .                   viewport_rect_changed = true;
        .                   window->Viewport->Pos = window->Pos;
        .               }
        .           
        5 ( 0.00%)      if (window->Viewport->PlatformRequestResize)
        .               {
        .                   window->Size = window->SizeFull = window->Viewport->Size;
        .                   MarkIniSettingsDirty(window);
        .               }
       12 ( 0.00%)      else if (memcmp(&window->Viewport->Size, &window->Size, sizeof(window->Size)) != 0)
       19 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1x)
        .               {
        .                   viewport_rect_changed = true;
        .                   window->Viewport->Size = window->Size;
        .               }
        4 ( 0.00%)      window->Viewport->UpdateWorkRect();
      145 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::UpdateWorkRect() (1x)
        .           
        .               // The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
        .               // Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
        2 ( 0.00%)      if (viewport_rect_changed)
        .                   UpdateViewportPlatformMonitor(window->Viewport);
        .           
        .               // Update common viewport flags
        1 ( 0.00%)      const ImGuiViewportFlags viewport_flags_to_clear = ImGuiViewportFlags_TopMost | ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_NoRendererClear;
        5 ( 0.00%)      ImGuiViewportFlags viewport_flags = window->Viewport->Flags & ~viewport_flags_to_clear;
        3 ( 0.00%)      ImGuiWindowFlags window_flags = window->Flags;
        5 ( 0.00%)      const bool is_modal = (window_flags & ImGuiWindowFlags_Modal) != 0;
        5 ( 0.00%)      const bool is_short_lived_floating_window = (window_flags & (ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup)) != 0;
        4 ( 0.00%)      if (window_flags & ImGuiWindowFlags_Tooltip)
        .                   viewport_flags |= ImGuiViewportFlags_TopMost;
        6 ( 0.00%)      if ((g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal)
        .                   viewport_flags |= ImGuiViewportFlags_NoTaskBarIcon;
        4 ( 0.00%)      if (g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window)
        1 ( 0.00%)          viewport_flags |= ImGuiViewportFlags_NoDecoration;
        .           
        .               // Not correct to set modal as topmost because:
        .               // - Because other popups can be stacked above a modal (e.g. combo box in a modal)
        .               // - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
        .               //if (flags & ImGuiWindowFlags_Modal)
        .               //    viewport_flags |= ImGuiViewportFlags_TopMost;
        .           
        .               // For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
        .               // won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
        .               // Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
        .               // but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
        2 ( 0.00%)      if (is_short_lived_floating_window && !is_modal)
        .                   viewport_flags |= ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_NoFocusOnClick;
        .           
        .               // We can overwrite viewport flags using ImGuiWindowClass (advanced users)
        4 ( 0.00%)      if (window->WindowClass.ViewportFlagsOverrideSet)
        .                   viewport_flags |= window->WindowClass.ViewportFlagsOverrideSet;
        4 ( 0.00%)      if (window->WindowClass.ViewportFlagsOverrideClear)
        .                   viewport_flags &= ~window->WindowClass.ViewportFlagsOverrideClear;
        .           
        .               // We can also tell the backend that clearing the platform window won't be necessary,
        .               // as our window background is filling the viewport and we have disabled BgAlpha.
        .               // FIXME: Work on support for per-viewport transparency (#2766)
        4 ( 0.00%)      if (!(window_flags & ImGuiWindowFlags_NoBackground))
        1 ( 0.00%)          viewport_flags |= ImGuiViewportFlags_NoRendererClear;
        .           
        4 ( 0.00%)      window->Viewport->Flags = viewport_flags;
        .           
        .               // Update parent viewport ID
        .               // (the !IsFallbackWindow test mimic the one done in WindowSelectViewport())
        4 ( 0.00%)      if (window->WindowClass.ParentViewportId != (ImGuiID)-1)
        .                   window->Viewport->ParentViewportId = window->WindowClass.ParentViewportId;
        4 ( 0.00%)      else if ((window_flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && parent_window_in_stack && (!parent_window_in_stack->IsFallbackWindow || parent_window_in_stack->WasActive))
        .                   window->Viewport->ParentViewportId = parent_window_in_stack->Viewport->ID;
        .               else
        8 ( 0.00%)          window->Viewport->ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID;
        3 ( 0.00%)  }
        .           
        .           // Called by user at the end of the main loop, after EndFrame()
        .           // This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
        .           void ImGui::UpdatePlatformWindows()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,418 ( 0.00%)      IM_ASSERT(g.FrameCountEnded == g.FrameCount && "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?");
    2,418 ( 0.00%)      IM_ASSERT(g.FrameCountPlatformEnded < g.FrameCount);
    1,612 ( 0.00%)      g.FrameCountPlatformEnded = g.FrameCount;
    2,015 ( 0.00%)      if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
        .                   return;
        .           
        .               // Create/resize/destroy platform windows to match each active viewport.
        .               // Skip the main viewport (index 0), which is always fully handled by the application!
    2,836 ( 0.00%)      for (int i = 1; i < g.Viewports.Size; i++)
        .               {
       24 ( 0.00%)          ImGuiViewportP* viewport = g.Viewports[i];
       57 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewportP*>::operator[](int) (3x)
        .           
        .                   // Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
        .                   // (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
        3 ( 0.00%)          bool destroy_platform_window = false;
       39 ( 0.00%)          destroy_platform_window |= (viewport->LastFrameActive < g.FrameCount - 1);
       54 ( 0.00%)          destroy_platform_window |= (viewport->Window && !IsWindowActiveAndVisible(viewport->Window));
       35 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:IsWindowActiveAndVisible(ImGuiWindow*) (3x)
        6 ( 0.00%)          if (destroy_platform_window)
        .                   {
        9 ( 0.00%)              DestroyPlatformWindow(viewport);
      162 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DestroyPlatformWindow(ImGuiViewportP*) (3x)
        3 ( 0.00%)              continue;
        .                   }
        .           
        .                   // New windows that appears directly in a new viewport won't always have a size on their first frame
        .                   if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0 || viewport->Size.y <= 0)
        .                       continue;
        .           
        .                   // Create window
        .                   const bool is_new_platform_window = (viewport->PlatformWindowCreated == false);
-- line 15427 ----------------------------------------
-- line 15486 ----------------------------------------
        .                       // This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
        .                       if (viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
        .                           viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
        .                   }
        .           
        .                   // Clear request flags
        .                   viewport->ClearRequestFlags();
        .               }
      806 ( 0.00%)  }
        .           
        .           // This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
        .           // Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
        .           // The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
        .           //
        .           //    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
        .           //    for (int i = 1; i < platform_io.Viewports.Size; i++)
        .           //        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
        .           //            MyRenderFunction(platform_io.Viewports[i], my_args);
        .           //    for (int i = 1; i < platform_io.Viewports.Size; i++)
        .           //        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
        .           //            MySwapBufferFunction(platform_io.Viewports[i], my_args);
        .           //
        .           void ImGui::RenderPlatformWindowsDefault(void* platform_render_arg, void* renderer_render_arg)
    2,015 ( 0.00%)  {
        .               // Skip the main viewport (index 0), which is always fully handled by the application!
      806 ( 0.00%)      ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
    3,627 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetPlatformIO() (403x)
    2,418 ( 0.00%)      for (int i = 1; i < platform_io.Viewports.Size; i++)
        .               {
        .                   ImGuiViewport* viewport = platform_io.Viewports[i];
        .                   if (viewport->Flags & ImGuiViewportFlags_IsMinimized)
        .                       continue;
        .                   if (platform_io.Platform_RenderWindow) platform_io.Platform_RenderWindow(viewport, platform_render_arg);
        .                   if (platform_io.Renderer_RenderWindow) platform_io.Renderer_RenderWindow(viewport, renderer_render_arg);
        .               }
    2,418 ( 0.00%)      for (int i = 1; i < platform_io.Viewports.Size; i++)
        .               {
        .                   ImGuiViewport* viewport = platform_io.Viewports[i];
        .                   if (viewport->Flags & ImGuiViewportFlags_IsMinimized)
        .                       continue;
        .                   if (platform_io.Platform_SwapBuffers) platform_io.Platform_SwapBuffers(viewport, platform_render_arg);
        .                   if (platform_io.Renderer_SwapBuffers) platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg);
        .               }
    1,612 ( 0.00%)  }
        .           
        .           static int ImGui::FindPlatformMonitorForPos(const ImVec2& pos)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
        .               {
        .                   const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
        .                   if (ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize).Contains(pos))
-- line 15536 ----------------------------------------
-- line 15538 ----------------------------------------
        .               }
        .               return -1;
        .           }
        .           
        .           // Search for the monitor with the largest intersection area with the given rectangle
        .           // We generally try to avoid searching loops but the monitor count should be very small here
        .           // FIXME-OPT: We could test the last monitor used for that viewport first, and early
        .           static int ImGui::FindPlatformMonitorForRect(const ImRect& rect)
    1,624 ( 0.00%)  {
      812 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
    1,218 ( 0.00%)      const int monitor_count = g.PlatformIO.Monitors.Size;
      812 ( 0.00%)      if (monitor_count <= 1)
        .                   return monitor_count - 1;
        .           
        .               // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
        .               // This is necessary for tooltips which always resize down to zero at first.
    6,496 ( 0.00%)      const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
    4,466 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (406x)
    4,060 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetWidth() const (406x)
    4,060 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetHeight() const (406x)
      406 ( 0.00%)      int best_monitor_n = -1;
      812 ( 0.00%)      float best_monitor_surface = 0.001f;
        .           
    3,662 ( 0.00%)      for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
        .               {
    2,842 ( 0.00%)          const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
    8,932 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::operator[](int) (406x)
    5,684 ( 0.00%)          const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
   15,834 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (406x)
    6,496 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (406x)
    2,842 ( 0.00%)          if (monitor_rect.Contains(rect))
   12,979 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Contains(ImRect const&) const (406x)
      810 ( 0.00%)              return monitor_n;
        5 ( 0.00%)          ImRect overlapping_rect = rect;
        5 ( 0.00%)          overlapping_rect.ClipWithFull(monitor_rect);
      139 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ClipWithFull(ImRect const&) (1x)
        9 ( 0.00%)          float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetHeight() const (1x)
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::GetWidth() const (1x)
        3 ( 0.00%)          if (overlapping_surface < best_monitor_surface)
        .                       continue;
        2 ( 0.00%)          best_monitor_surface = overlapping_surface;
        3 ( 0.00%)          best_monitor_n = monitor_n;
        .               }
        1 ( 0.00%)      return best_monitor_n;
      812 ( 0.00%)  }
        .           
        .           // Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
        .           static void ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP* viewport)
    1,624 ( 0.00%)  {
    5,278 ( 0.00%)      viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
   85,846 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindPlatformMonitorForRect(ImRect const&) (406x)
   34,916 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::GetMainRect() const (406x)
    1,218 ( 0.00%)  }
        .           
        .           // Return value is always != NULL, but don't hold on it across frames.
        .           const ImGuiPlatformMonitor* ImGui::GetViewportPlatformMonitor(ImGuiViewport* viewport_p)
        4 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        2 ( 0.00%)      ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)viewport_p;
        4 ( 0.00%)      int monitor_idx = viewport->PlatformMonitor;
        6 ( 0.00%)      if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
        7 ( 0.00%)          return &g.PlatformIO.Monitors[monitor_idx];
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::operator[](int) (1x)
        .               return &g.FallbackMonitor;
        2 ( 0.00%)  }
        .           
        .           void ImGui::DestroyPlatformWindow(ImGuiViewportP* viewport)
       16 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
       16 ( 0.00%)      if (viewport->PlatformWindowCreated)
        .               {
        .                   IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Destroy Platform Window %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
        .                   if (g.PlatformIO.Renderer_DestroyWindow)
        .                       g.PlatformIO.Renderer_DestroyWindow(viewport);
        .                   if (g.PlatformIO.Platform_DestroyWindow)
        .                       g.PlatformIO.Platform_DestroyWindow(viewport);
        .                   IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL);
        .           
        .                   // Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
        .                   // The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
        .                   if (viewport->ID != IMGUI_VIEWPORT_DEFAULT_ID)
        .                       viewport->PlatformWindowCreated = false;
        .               }
        .               else
        .               {
       48 ( 0.00%)          IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL && viewport->PlatformHandle == NULL);
        .               }
       40 ( 0.00%)      viewport->RendererUserData = viewport->PlatformUserData = viewport->PlatformHandle = NULL;
       12 ( 0.00%)      viewport->ClearRequestFlags();
       64 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::ClearRequestFlags() (4x)
       12 ( 0.00%)  }
        .           
        .           void ImGui::DestroyPlatformWindows()
        .           {
        .               // We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
        .               // to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
        .               // It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
        .               // code to operator a consistent manner.
        .               // It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
-- line 15624 ----------------------------------------
-- line 15755 ----------------------------------------
        .               ImGuiID             ParentWindowId;
        .               ImGuiID             SelectedTabId;
        .               signed char         SplitAxis;
        .               char                Depth;
        .               ImGuiDockNodeFlags  Flags;                  // NB: We save individual flags one by one in ascii format (ImGuiDockNodeFlags_SavedFlagsMask_)
        .               ImVec2ih            Pos;
        .               ImVec2ih            Size;
        .               ImVec2ih            SizeRef;
       54 ( 0.00%)      ImGuiDockNodeSettings() { memset(this, 0, sizeof(*this)); SplitAxis = ImGuiAxis_None; }
       60 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImVec2ih::ImVec2ih() (6x)
       24 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2x)
        .           };
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: Forward Declarations
        .           //-----------------------------------------------------------------------------
        .           
        .           namespace ImGui
        .           {
-- line 15771 ----------------------------------------
-- line 15798 ----------------------------------------
        .               static void             DockNodeUpdateVisibleFlag(ImGuiDockNode* node);
        .               static void             DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window);
        .               static bool             DockNodeIsDropAllowed(ImGuiWindow* host_window, ImGuiWindow* payload_window);
        .               static void             DockNodePreviewDockSetup(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, ImGuiDockNode* payload_node, ImGuiDockPreviewData* preview_data, bool is_explicit_target, bool is_outer_docking);
        .               static void             DockNodePreviewDockRender(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, const ImGuiDockPreviewData* preview_data);
        .               static void             DockNodeCalcTabBarLayout(const ImGuiDockNode* node, ImRect* out_title_rect, ImRect* out_tab_bar_rect, ImVec2* out_window_menu_button_pos, ImVec2* out_close_button_pos);
        .               static void             DockNodeCalcSplitRects(ImVec2& pos_old, ImVec2& size_old, ImVec2& pos_new, ImVec2& size_new, ImGuiDir dir, ImVec2 size_new_desired);
        .               static bool             DockNodeCalcDropRectsAndTestMousePos(const ImRect& parent, ImGuiDir dir, ImRect& out_draw, bool outer_docking, ImVec2* test_mouse_pos);
       19 ( 0.00%)      static const char*      DockNodeGetHostWindowTitle(ImGuiDockNode* node, char* buf, int buf_size) { ImFormatString(buf, buf_size, "##DockNode_%02X", node->ID); return buf; }
      598 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFormatString(char*, unsigned long, char const*, ...) (1x)
        .               static int              DockNodeGetTabOrder(ImGuiWindow* window);
        .           
        .               // ImGuiDockNode tree manipulations
        .               static void             DockNodeTreeSplit(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiAxis split_axis, int split_first_child, float split_ratio, ImGuiDockNode* new_node);
        .               static void             DockNodeTreeMerge(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiDockNode* merge_lead_child);
        .               static void             DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, ImGuiDockNode* only_write_to_single_node = NULL);
        .               static void             DockNodeTreeUpdateSplitter(ImGuiDockNode* node);
        .               static ImGuiDockNode*   DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos);
-- line 15814 ----------------------------------------
-- line 15849 ----------------------------------------
        .           // - DockContextRemoveNode()
        .           // - ImGuiDockContextPruneNodeData
        .           // - DockContextPruneUnusedSettingsNodes()
        .           // - DockContextBuildNodesFromSettings()
        .           // - DockContextBuildAddWindowsToNodes()
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImGui::DockContextInitialize(ImGuiContext* ctx)
        4 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *ctx;
        .           
        .               // Add .ini handle for persistent docking data
        3 ( 0.00%)      ImGuiSettingsHandler ini_handler;
       32 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiSettingsHandler::ImGuiSettingsHandler() (1x)
        1 ( 0.00%)      ini_handler.TypeName = "Docking";
        5 ( 0.00%)      ini_handler.TypeHash = ImHashStr("Docking");
      192 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (1x)
        1 ( 0.00%)      ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
        1 ( 0.00%)      ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
        1 ( 0.00%)      ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
        1 ( 0.00%)      ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
        1 ( 0.00%)      ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
        1 ( 0.00%)      ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
        6 ( 0.00%)      g.SettingsHandlers.push_back(ini_handler);
       57 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::push_back(ImGuiSettingsHandler const&) (1x)
        .           
        2 ( 0.00%)      g.DockNodeWindowMenuHandler = &DockNodeWindowMenuHandler_Default;
        3 ( 0.00%)  }
        .           
        .           void ImGui::DockContextShutdown(ImGuiContext* ctx)
        .           {
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .               for (int n = 0; n < dc->Nodes.Data.Size; n++)
        .                   if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                       IM_DELETE(node);
        .           }
        .           
        .           void ImGui::DockContextClearNodes(ImGuiContext* ctx, ImGuiID root_id, bool clear_settings_refs)
        7 ( 0.00%)  {
        .               IM_UNUSED(ctx);
        3 ( 0.00%)      IM_ASSERT(ctx == GImGui);
        5 ( 0.00%)      DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs);
       40 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockBuilderRemoveNodeDockedWindows(unsigned int, bool) (1x)
        3 ( 0.00%)      DockBuilderRemoveNodeChildNodes(root_id);
      138 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockBuilderRemoveNodeChildNodes(unsigned int) (1x)
        3 ( 0.00%)  }
        .           
        .           // [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
        .           // (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
        .           void ImGui::DockContextRebuildNodes(ImGuiContext* ctx)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .               IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRebuildNodes\n");
-- line 15897 ----------------------------------------
-- line 15899 ----------------------------------------
        .               ImGuiID root_id = 0; // Rebuild all
        .               DockContextClearNodes(ctx, root_id, false);
        .               DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
        .               DockContextBuildAddWindowsToNodes(ctx, root_id);
        .           }
        .           
        .           // Docking context update function, called by NewFrame()
        .           void ImGui::DockContextNewFrameUpdateUndocking(ImGuiContext* ctx)
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *ctx;
    1,209 ( 0.00%)      ImGuiDockContext* dc = &ctx->DockContext;
    2,015 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .               {
        .                   if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
        .                       DockContextClearNodes(ctx, 0, true);
        .                   return;
        .               }
        .           
        .               // Setting NoSplit at runtime merges all nodes
    1,612 ( 0.00%)      if (g.IO.ConfigDockingNoSplit)
        .                   for (int n = 0; n < dc->Nodes.Data.Size; n++)
        .                       if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                           if (node->IsRootNode() && node->IsSplitNode())
        .                           {
        .                               DockBuilderRemoveNodeChildNodes(node->ID);
        .                               //dc->WantFullRebuild = true;
        .                           }
        .           
        .               // Process full rebuild
        .           #if 0
        .               if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
        .                   dc->WantFullRebuild = true;
        .           #endif
    1,612 ( 0.00%)      if (dc->WantFullRebuild)
        .               {
        .                   DockContextRebuildNodes(ctx);
        .                   dc->WantFullRebuild = false;
        .               }
        .           
        .               // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
    6,448 ( 0.00%)      for (ImGuiDockRequest& req : dc->Requests)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockRequest>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockRequest>::begin() (403x)
        .               {
        .                   if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetWindow)
        .                       DockContextProcessUndockWindow(ctx, req.UndockTargetWindow);
        .                   else if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetNode)
        .                       DockContextProcessUndockNode(ctx, req.UndockTargetNode);
        .               }
      806 ( 0.00%)  }
        .           
        .           // Docking context update function, called by NewFrame()
        .           void ImGui::DockContextNewFrameUpdateDocking(ImGuiContext* ctx)
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *ctx;
    1,209 ( 0.00%)      ImGuiDockContext* dc = &ctx->DockContext;
    2,015 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .                   return;
        .           
        .               // [DEBUG] Store hovered dock node.
        .               // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
        .               // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
      806 ( 0.00%)      g.DebugHoveredDockNode = NULL;
    2,015 ( 0.00%)      if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
        .               {
      672 ( 0.00%)          if (hovered_window->DockNodeAsHost)
       10 ( 0.00%)              g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
      162 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode*, ImVec2) (1x)
      835 ( 0.00%)          else if (hovered_window->RootWindow->DockNode)
      835 ( 0.00%)              g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
        .               }
        .           
        .               // Process Docking requests
    6,045 ( 0.00%)      for (ImGuiDockRequest& req : dc->Requests)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockRequest>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockRequest>::begin() (403x)
        .                   if (req.Type == ImGuiDockRequestType_Dock)
        .                       DockContextProcessDock(ctx, &req);
    2,015 ( 0.00%)      dc->Requests.resize(0);
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockRequest>::resize(int) (403x)
        .           
        .               // Create windows for each automatic docking nodes
        .               // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
    4,836 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
    3,627 ( 0.00%)          if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::operator[](int) (403x)
    2,015 ( 0.00%)              if (node->IsFloatingNode())
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsFloatingNode() const (403x)
        .                           DockNodeUpdate(node);
      806 ( 0.00%)  }
        .           
        .           void ImGui::DockContextEndFrame(ImGuiContext* ctx)
    2,015 ( 0.00%)  {
        .               // Draw backgrounds of node missing their window
      806 ( 0.00%)      ImGuiContext& g = *ctx;
    1,209 ( 0.00%)      ImGuiDockContext* dc = &g.DockContext;
    4,433 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
    3,627 ( 0.00%)          if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
    7,657 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::operator[](int) (403x)
   12,493 ( 0.00%)              if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsLeafNode() const (403x)
        .                       {
        .                           ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
        .                           ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), g.Style.DockingSeparatorSize);
        .                           node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        .                           node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
        .                       }
    2,015 ( 0.00%)  }
        .           
        .           ImGuiDockNode* ImGui::DockContextFindNodeByID(ImGuiContext* ctx, ImGuiID id)
    4,040 ( 0.00%)  {
    4,848 ( 0.00%)      return (ImGuiDockNode*)ctx->DockContext.Nodes.GetVoidPtr(id);
   65,428 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::GetVoidPtr(unsigned int) const (808x)
    1,616 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::DockContextGenNodeID(ImGuiContext* ctx)
        .           {
        .               // Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
        .               // FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry.0
        .               // We should poke in ctx->Nodes to find a suitable ID faster. Even more so trivial that ctx->Nodes lookup is already sorted.
        .               ImGuiID id = 0x0001;
        .               while (DockContextFindNodeByID(ctx, id) != NULL)
        .                   id++;
        .               return id;
        .           }
        .           
        .           static ImGuiDockNode* ImGui::DockContextAddNode(ImGuiContext* ctx, ImGuiID id)
        9 ( 0.00%)  {
        .               // Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
        2 ( 0.00%)      ImGuiContext& g = *ctx;
        2 ( 0.00%)      if (id == 0)
        .                   id = DockContextGenNodeID(ctx);
        .               else
        7 ( 0.00%)          IM_ASSERT(DockContextFindNodeByID(ctx, id) == NULL);
       74 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextFindNodeByID(ImGuiContext*, unsigned int) (1x)
        .           
        .               // We don't set node->LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
        5 ( 0.00%)      IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextAddNode 0x%08X\n", id);
       13 ( 0.00%)      ImGuiDockNode* node = IM_NEW(ImGuiDockNode)(id);
      289 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiDockNode::ImGuiDockNode(unsigned int) (1x)
      118 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        8 ( 0.00%)      ctx->DockContext.Nodes.SetVoidPtr(node->ID, node);
      324 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::SetVoidPtr(unsigned int, void*) (1x)
        2 ( 0.00%)      return node;
        7 ( 0.00%)  }
        .           
        .           static void ImGui::DockContextRemoveNode(ImGuiContext* ctx, ImGuiDockNode* node, bool merge_sibling_into_parent_node)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .           
        .               IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRemoveNode 0x%08X\n", node->ID);
        .               IM_ASSERT(DockContextFindNodeByID(ctx, node->ID) == node);
-- line 16036 ----------------------------------------
-- line 16065 ----------------------------------------
        .               return ImGui::DockNodeGetDepth(b) - ImGui::DockNodeGetDepth(a);
        .           }
        .           
        .           // Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
        .           struct ImGuiDockContextPruneNodeData
        .           {
        .               int         CountWindows, CountChildWindows, CountChildNodes;
        .               ImGuiID     RootId;
       18 ( 0.00%)      ImGuiDockContextPruneNodeData() { CountWindows = CountChildWindows = CountChildNodes = 0; RootId = 0; }
        .           };
        .           
        .           // Garbage collect unused nodes (run once at init time)
        .           static void ImGui::DockContextPruneUnusedSettingsNodes(ImGuiContext* ctx)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *ctx;
        3 ( 0.00%)      ImGuiDockContext* dc = &ctx->DockContext;
        4 ( 0.00%)      IM_ASSERT(g.Windows.Size == 0);
        .           
        3 ( 0.00%)      ImPool<ImGuiDockContextPruneNodeData> pool;
       58 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImPool<ImGuiDockContextPruneNodeData>::ImPool() (1x)
        6 ( 0.00%)      pool.Reserve(dc->NodesSettings.Size);
      311 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImPool<ImGuiDockContextPruneNodeData>::Reserve(int) (1x)
        .           
        .               // Count child nodes and compute RootID
       11 ( 0.00%)      for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        .               {
        7 ( 0.00%)          ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNodeSettings>::operator[](int) (1x)
        6 ( 0.00%)          ImGuiDockContextPruneNodeData* parent_data = settings->ParentNodeId ? pool.GetByKey(settings->ParentNodeId) : 0;
       11 ( 0.00%)          pool.GetOrAddByKey(settings->ID)->RootId = parent_data ? parent_data->RootId : settings->ID;
      301 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImPool<ImGuiDockContextPruneNodeData>::GetOrAddByKey(unsigned int) (1x)
        4 ( 0.00%)          if (settings->ParentNodeId)
        .                       pool.GetOrAddByKey(settings->ParentNodeId)->CountChildNodes++;
        .               }
        .           
        .               // Count reference to dock ids from dockspaces
        .               // We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
       11 ( 0.00%)      for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        .               {
        7 ( 0.00%)          ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNodeSettings>::operator[](int) (1x)
        4 ( 0.00%)          if (settings->ParentWindowId != 0)
        7 ( 0.00%)              if (ImGuiWindowSettings* window_settings = FindWindowSettingsByID(settings->ParentWindowId))
      150 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByID(unsigned int) (1x)
        4 ( 0.00%)                  if (window_settings->DockId)
        .                               if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(window_settings->DockId))
        .                                   data->CountChildNodes++;
        .               }
        .           
        .               // Count reference to dock ids from window settings
        .               // We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
       44 ( 0.00%)      for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
      369 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::next_chunk(ImGuiWindowSettings*) (4x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::begin() (1x)
       20 ( 0.00%)          if (ImGuiID dock_id = settings->DockId)
        8 ( 0.00%)              if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(dock_id))
      124 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImPool<ImGuiDockContextPruneNodeData>::GetByKey(unsigned int) (1x)
        .                       {
        5 ( 0.00%)                  data->CountWindows++;
        8 ( 0.00%)                  if (ImGuiDockContextPruneNodeData* data_root = (data->RootId == dock_id) ? data : pool.GetByKey(data->RootId))
        5 ( 0.00%)                      data_root->CountChildWindows++;
        .                       }
        .           
        .               // Prune
       11 ( 0.00%)      for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        .               {
        7 ( 0.00%)          ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
       22 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNodeSettings>::operator[](int) (1x)
        7 ( 0.00%)          ImGuiDockContextPruneNodeData* data = pool.GetByKey(settings->ID);
      124 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImPool<ImGuiDockContextPruneNodeData>::GetByKey(unsigned int) (1x)
        4 ( 0.00%)          if (data->CountWindows > 1)
        .                       continue;
        8 ( 0.00%)          ImGuiDockContextPruneNodeData* data_root = (data->RootId == settings->ID) ? data : pool.GetByKey(data->RootId);
        .           
        1 ( 0.00%)          bool remove = false;
       23 ( 0.00%)          remove |= (data->CountWindows == 1 && settings->ParentNodeId == 0 && data->CountChildNodes == 0 && !(settings->Flags & ImGuiDockNodeFlags_CentralNode));  // Floating root node with only 1 window
       10 ( 0.00%)          remove |= (data->CountWindows == 0 && settings->ParentNodeId == 0 && data->CountChildNodes == 0); // Leaf nodes with 0 window
       10 ( 0.00%)          remove |= (data_root->CountChildWindows == 0);
        2 ( 0.00%)          if (remove)
        .                   {
        .                       IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings->ID);
        .                       DockSettingsRemoveNodeReferences(&settings->ID, 1);
        .                       settings->ID = 0;
        .                   }
        .               }
        7 ( 0.00%)  }
      507 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImPool<ImGuiDockContextPruneNodeData>::~ImPool() (1x)
        .           
        .           static void ImGui::DockContextBuildNodesFromSettings(ImGuiContext* ctx, ImGuiDockNodeSettings* node_settings_array, int node_settings_count)
        6 ( 0.00%)  {
        .               // Build nodes
        9 ( 0.00%)      for (int node_n = 0; node_n < node_settings_count; node_n++)
        .               {
       10 ( 0.00%)          ImGuiDockNodeSettings* settings = &node_settings_array[node_n];
        4 ( 0.00%)          if (settings->ID == 0)
        .                       continue;
        7 ( 0.00%)          ImGuiDockNode* node = DockContextAddNode(ctx, settings->ID);
      867 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextAddNode(ImGuiContext*, unsigned int) (1x)
        7 ( 0.00%)          node->ParentNode = settings->ParentNodeId ? DockContextFindNodeByID(ctx, settings->ParentNodeId) : NULL;
       17 ( 0.00%)          node->Pos = ImVec2(settings->Pos.x, settings->Pos.y);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
       17 ( 0.00%)          node->Size = ImVec2(settings->Size.x, settings->Size.y);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
       17 ( 0.00%)          node->SizeRef = ImVec2(settings->SizeRef.x, settings->SizeRef.y);
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
       28 ( 0.00%)          node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_DockNode;
        4 ( 0.00%)          if (node->ParentNode && node->ParentNode->ChildNodes[0] == NULL)
        .                       node->ParentNode->ChildNodes[0] = node;
        4 ( 0.00%)          else if (node->ParentNode && node->ParentNode->ChildNodes[1] == NULL)
        .                       node->ParentNode->ChildNodes[1] = node;
        4 ( 0.00%)          node->SelectedTabId = settings->SelectedTabId;
        5 ( 0.00%)          node->SplitAxis = (ImGuiAxis)settings->SplitAxis;
        8 ( 0.00%)          node->SetLocalFlags(settings->Flags & ImGuiDockNodeFlags_SavedFlagsMask_);
       30 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::SetLocalFlags(int) (1x)
        .           
        .                   // Bind host window immediately if it already exist (in case of a rebuild)
        .                   // This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node->HostWindow to be set.
        .                   char host_window_title[20];
        4 ( 0.00%)          ImGuiDockNode* root_node = DockNodeGetRootNode(node);
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::DockNodeGetRootNode(ImGuiDockNode*) (1x)
       11 ( 0.00%)          node->HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title, IM_ARRAYSIZE(host_window_title)));
      617 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeGetHostWindowTitle(ImGuiDockNode*, char*, int) (1x)
      583 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowByName(char const*) (1x)
        .               }
        4 ( 0.00%)  }
        .           
        .           void ImGui::DockContextBuildAddWindowsToNodes(ImGuiContext* ctx, ImGuiID root_id)
        5 ( 0.00%)  {
        .               // Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
        2 ( 0.00%)      ImGuiContext& g = *ctx;
       15 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (1x)
        .               {
        .                   if (window->DockId == 0 || window->LastFrameActive < g.FrameCount - 1)
        .                       continue;
        .                   if (window->DockNode != NULL)
        .                       continue;
        .           
        .                   ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
        .                   IM_ASSERT(node != NULL);   // This should have been called after DockContextBuildNodesFromSettings()
        .                   if (root_id == 0 || DockNodeGetRootNode(node)->ID == root_id)
        .                       DockNodeAddWindow(node, window, true);
        .               }
        4 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: ImGuiDockContext Docking/Undocking functions
        .           //-----------------------------------------------------------------------------
        .           // - DockContextQueueDock()
        .           // - DockContextQueueUndockWindow()
        .           // - DockContextQueueUndockNode()
        .           // - DockContextQueueNotifyRemovedNode()
-- line 16195 ----------------------------------------
-- line 16501 ----------------------------------------
        .           // - DockNodeIsDropAllowed()
        .           // - DockNodeCalcTabBarLayout()
        .           // - DockNodeCalcSplitRects()
        .           // - DockNodeCalcDropRectsAndTestMousePos()
        .           // - DockNodePreviewDockSetup()
        .           // - DockNodePreviewDockRender()
        .           //-----------------------------------------------------------------------------
        .           
       25 ( 0.00%)  ImGuiDockNode::ImGuiDockNode(ImGuiID id)
       36 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (3x)
       29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiWindowClass::ImGuiWindowClass() (1x)
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::ImVector() (1x)
        .           {
        3 ( 0.00%)      ID = id;
       14 ( 0.00%)      SharedFlags = LocalFlags = LocalFlagsInWindows = MergedFlags = ImGuiDockNodeFlags_None;
       10 ( 0.00%)      ParentNode = ChildNodes[0] = ChildNodes[1] = NULL;
        2 ( 0.00%)      TabBar = NULL;
        2 ( 0.00%)      SplitAxis = ImGuiAxis_None;
        .           
        2 ( 0.00%)      State = ImGuiDockNodeState_Unknown;
        2 ( 0.00%)      LastBgColor = IM_COL32_WHITE;
        6 ( 0.00%)      HostWindow = VisibleWindow = NULL;
        6 ( 0.00%)      CentralNode = OnlyNodeWithWindows = NULL;
        2 ( 0.00%)      CountNodeWithWindows = 0;
       10 ( 0.00%)      LastFrameAlive = LastFrameActive = LastFrameFocused = -1;
        2 ( 0.00%)      LastFocusedNodeId = 0;
        2 ( 0.00%)      SelectedTabId = 0;
        2 ( 0.00%)      WantCloseTabId = 0;
        2 ( 0.00%)      RefViewportId = 0;
       16 ( 0.00%)      AuthorityForPos = AuthorityForSize = ImGuiDataAuthority_DockNode;
        4 ( 0.00%)      AuthorityForViewport = ImGuiDataAuthority_Auto;
        4 ( 0.00%)      IsVisible = true;
       39 ( 0.00%)      IsFocused = HasCloseButton = HasWindowMenuButton = HasCentralNodeChild = false;
        4 ( 0.00%)      IsBgDrawnThisFrame = false;
       48 ( 0.00%)      WantCloseAll = WantLockSizeOnce = WantMouseMove = WantHiddenTabBarUpdate = WantHiddenTabBarToggle = false;
        3 ( 0.00%)  }
        .           
        .           ImGuiDockNode::~ImGuiDockNode()
        .           {
        .               IM_DELETE(TabBar);
        .               TabBar = NULL;
        .               ChildNodes[0] = ChildNodes[1] = NULL;
        .           }
        .           
-- line 16541 ----------------------------------------
-- line 16550 ----------------------------------------
        .           
        .           static void DockNodeHideWindowDuringHostWindowCreation(ImGuiWindow* window)
        .           {
        .               window->Hidden = true;
        .               window->HiddenFramesCanSkipItems = window->Active ? 1 : 2;
        .           }
        .           
        .           static void ImGui::DockNodeAddWindow(ImGuiDockNode* node, ImGuiWindow* window, bool add_to_tab_bar)
        7 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui; (void)g;
        4 ( 0.00%)      if (window->DockNode)
        .               {
        .                   // Can overwrite an existing window->DockNode (e.g. pointing to a disabled DockSpace node)
        .                   IM_ASSERT(window->DockNode->ID != node->ID);
        .                   DockNodeRemoveWindow(window->DockNode, window, 0);
        .               }
        4 ( 0.00%)      IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL);
        5 ( 0.00%)      IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeAddWindow node 0x%08X window '%s'\n", node->ID, window->Name);
        .           
        .               // If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
        .               // we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
        .               // We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
        7 ( 0.00%)      if (node->HostWindow == NULL && node->Windows.Size == 1 && node->Windows[0]->WasActive == false)
        .                   DockNodeHideWindowDuringHostWindowCreation(node->Windows[0]);
        .           
        6 ( 0.00%)      node->Windows.push_back(window);
      204 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::push_back(ImGuiWindow* const&) (1x)
        4 ( 0.00%)      node->WantHiddenTabBarUpdate = true;
        3 ( 0.00%)      window->DockNode = node;
        4 ( 0.00%)      window->DockId = node->ID;
       11 ( 0.00%)      window->DockIsActive = (node->Windows.Size > 1);
        4 ( 0.00%)      window->DockTabWantClose = false;
        .           
        .               // When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
        .               // In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
        7 ( 0.00%)      if (node->HostWindow == NULL && node->IsFloatingNode())
        .               {
        .                   if (node->AuthorityForPos == ImGuiDataAuthority_Auto)
        .                       node->AuthorityForPos = ImGuiDataAuthority_Window;
        .                   if (node->AuthorityForSize == ImGuiDataAuthority_Auto)
        .                       node->AuthorityForSize = ImGuiDataAuthority_Window;
        .                   if (node->AuthorityForViewport == ImGuiDataAuthority_Auto)
        .                       node->AuthorityForViewport = ImGuiDataAuthority_Window;
        .               }
        .           
        .               // Add to tab bar if requested
        2 ( 0.00%)      if (add_to_tab_bar)
        .               {
        4 ( 0.00%)          if (node->TabBar == NULL)
        .                   {
        3 ( 0.00%)              DockNodeAddTabBar(node);
      333 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeAddTabBar(ImGuiDockNode*) (1x)
        9 ( 0.00%)              node->TabBar->SelectedTabId = node->TabBar->NextSelectedTabId = node->SelectedTabId;
        .           
        .                       // Add existing windows
        7 ( 0.00%)              for (int n = 0; n < node->Windows.Size - 1; n++)
        .                           TabBarAddTab(node->TabBar, ImGuiTabItemFlags_None, node->Windows[n]);
        .                   }
        6 ( 0.00%)          TabBarAddTab(node->TabBar, ImGuiTabItemFlags_Unsorted, window);
      589 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGui::TabBarAddTab(ImGuiTabBar*, int, ImGuiWindow*) (1x)
        .               }
        .           
        3 ( 0.00%)      DockNodeUpdateVisibleFlag(node);
       67 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdateVisibleFlag(ImGuiDockNode*) (1x)
        .           
        .               // Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
        4 ( 0.00%)      if (node->HostWindow)
       10 ( 0.00%)          UpdateWindowParentAndRootLinks(window, window->Flags | ImGuiWindowFlags_ChildWindow, node->HostWindow);
       84 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow*, int, ImGuiWindow*) (1x)
        3 ( 0.00%)  }
        .           
        .           static void ImGui::DockNodeRemoveWindow(ImGuiDockNode* node, ImGuiWindow* window, ImGuiID save_dock_id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(window->DockNode == node);
        .               //IM_ASSERT(window->RootWindowDockTree == node->HostWindow);
        .               //IM_ASSERT(window->LastFrameActive < g.FrameCount);    // We may call this from Begin()
        .               IM_ASSERT(save_dock_id == 0 || save_dock_id == node->ID);
-- line 16622 ----------------------------------------
-- line 16760 ----------------------------------------
        .           // Search function called once by root node in DockNodeUpdate()
        .           struct ImGuiDockNodeTreeInfo
        .           {
        .               ImGuiDockNode*      CentralNode;
        .               ImGuiDockNode*      FirstNodeWithWindows;
        .               int                 CountNodesWithWindows;
        .               //ImGuiWindowClass  WindowClassForMerges;
        .           
    5,239 ( 0.00%)      ImGuiDockNodeTreeInfo() { memset(this, 0, sizeof(*this)); }
    4,433 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (403x)
        .           };
        .           
        .           static void DockNodeFindInfo(ImGuiDockNode* node, ImGuiDockNodeTreeInfo* info)
    2,015 ( 0.00%)  {
    1,612 ( 0.00%)      if (node->Windows.Size > 0)
        .               {
    1,608 ( 0.00%)          if (info->FirstNodeWithWindows == NULL)
    1,206 ( 0.00%)              info->FirstNodeWithWindows = node;
    2,010 ( 0.00%)          info->CountNodesWithWindows++;
        .               }
    2,015 ( 0.00%)      if (node->IsCentralNode())
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsCentralNode() const (403x)
        .               {
    1,612 ( 0.00%)          IM_ASSERT(info->CentralNode == NULL); // Should be only one
    2,015 ( 0.00%)          IM_ASSERT(node->IsLeafNode() && "If you get this assert: please submit .ini file + repro of actions leading to this.");
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsLeafNode() const (403x)
    1,209 ( 0.00%)          info->CentralNode = node;
        .               }
    1,612 ( 0.00%)      if (info->CountNodesWithWindows > 1 && info->CentralNode != NULL)
        .                   return;
    1,612 ( 0.00%)      if (node->ChildNodes[0])
        .                   DockNodeFindInfo(node->ChildNodes[0], info);
    1,612 ( 0.00%)      if (node->ChildNodes[1])
        .                   DockNodeFindInfo(node->ChildNodes[1], info);
      806 ( 0.00%)  }
        .           
        .           static ImGuiWindow* ImGui::DockNodeFindWindowByID(ImGuiDockNode* node, ImGuiID id)
        .           {
        .               IM_ASSERT(id != 0);
        .               for (ImGuiWindow* window : node->Windows)
        .                   if (window->ID == id)
        .                       return window;
        .               return NULL;
        .           }
        .           
        .           // - Remove inactive windows/nodes.
        .           // - Update visibility flag.
        .           static void ImGui::DockNodeUpdateFlagsAndCollapse(ImGuiDockNode* node)
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,612 ( 0.00%)      IM_ASSERT(node->ParentNode == NULL || node->ParentNode->ChildNodes[0] == node || node->ParentNode->ChildNodes[1] == node);
        .           
        .               // Inherit most flags
    1,612 ( 0.00%)      if (node->ParentNode)
        .                   node->SharedFlags = node->ParentNode->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
        .           
        .               // Recurse into children
        .               // There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
        .               // If 'node->ChildNode[0]' delete itself, then 'node->ChildNode[1]->Windows' will be moved into 'node'
        .               // If 'node->ChildNode[1]' delete itself, then 'node->ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
    1,612 ( 0.00%)      node->HasCentralNodeChild = false;
    1,612 ( 0.00%)      if (node->ChildNodes[0])
        .                   DockNodeUpdateFlagsAndCollapse(node->ChildNodes[0]);
    1,612 ( 0.00%)      if (node->ChildNodes[1])
        .                   DockNodeUpdateFlagsAndCollapse(node->ChildNodes[1]);
        .           
        .               // Remove inactive windows, collapse nodes
        .               // Merge node flags overrides stored in windows
      806 ( 0.00%)      node->LocalFlagsInWindows = ImGuiDockNodeFlags_None;
    4,428 ( 0.00%)      for (int window_n = 0; window_n < node->Windows.Size; window_n++)
        .               {
    3,216 ( 0.00%)          ImGuiWindow* window = node->Windows[window_n];
    7,638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (402x)
    1,608 ( 0.00%)          IM_ASSERT(window->DockNode == node);
        .           
    3,216 ( 0.00%)          bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
      402 ( 0.00%)          bool remove = false;
    6,030 ( 0.00%)          remove |= node_was_active && (window->LastFrameActive + 1 < g.FrameCount);
    7,638 ( 0.00%)          remove |= node_was_active && (node->WantCloseAll || node->WantCloseTabId == window->TabId) && window->HasCloseButton && !(window->Flags & ImGuiWindowFlags_UnsavedDocument);  // Submit all _expected_ closure from last frame
    3,618 ( 0.00%)          remove |= (window->DockTabWantClose);
      804 ( 0.00%)          if (remove)
        .                   {
        .                       window->DockTabWantClose = false;
        .                       if (node->Windows.Size == 1 && !node->IsCentralNode())
        .                       {
        .                           DockNodeHideHostWindow(node);
        .                           node->State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
        .                           DockNodeRemoveWindow(node, window, node->ID); // Will delete the node so it'll be invalid on return
        .                           return;
-- line 16844 ----------------------------------------
-- line 16845 ----------------------------------------
        .                       }
        .                       DockNodeRemoveWindow(node, window, node->ID);
        .                       window_n--;
        .                       continue;
        .                   }
        .           
        .                   // FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
        .                   //node->LocalFlagsInWindow &= ~window->WindowClass.DockNodeFlagsOverrideClear;
    2,814 ( 0.00%)          node->LocalFlagsInWindows |= window->WindowClass.DockNodeFlagsOverrideSet;
        .               }
    1,209 ( 0.00%)      node->UpdateMergedFlags();
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::UpdateMergedFlags() (403x)
        .           
        .               // Auto-hide tab bar option
    1,209 ( 0.00%)      ImGuiDockNodeFlags node_flags = node->MergedFlags;
    3,635 ( 0.00%)      if (node->WantHiddenTabBarUpdate && node->Windows.Size == 1 && (node_flags & ImGuiDockNodeFlags_AutoHideTabBar) && !node->IsHiddenTabBar())
        .                   node->WantHiddenTabBarToggle = true;
    1,612 ( 0.00%)      node->WantHiddenTabBarUpdate = false;
        .           
        .               // Cancel toggling if we know our tab bar is enforced to be hidden at all times
    2,418 ( 0.00%)      if (node->WantHiddenTabBarToggle && node->VisibleWindow && (node->VisibleWindow->WindowClass.DockNodeFlagsOverrideSet & ImGuiDockNodeFlags_HiddenTabBar))
        .                   node->WantHiddenTabBarToggle = false;
        .           
        .               // Apply toggles at a single point of the frame (here!)
    1,612 ( 0.00%)      if (node->Windows.Size > 1)
        .                   node->SetLocalFlags(node->LocalFlags & ~ImGuiDockNodeFlags_HiddenTabBar);
    2,418 ( 0.00%)      else if (node->WantHiddenTabBarToggle)
        .                   node->SetLocalFlags(node->LocalFlags ^ ImGuiDockNodeFlags_HiddenTabBar);
    1,612 ( 0.00%)      node->WantHiddenTabBarToggle = false;
        .           
    1,209 ( 0.00%)      DockNodeUpdateVisibleFlag(node);
   27,001 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdateVisibleFlag(ImGuiDockNode*) (403x)
      806 ( 0.00%)  }
        .           
        .           // This is rarely called as DockNodeUpdateForRootNode() generally does it most frames.
        .           static void ImGui::DockNodeUpdateHasCentralNodeChild(ImGuiDockNode* node)
        .           {
        .               node->HasCentralNodeChild = false;
        .               if (node->ChildNodes[0])
        .                   DockNodeUpdateHasCentralNodeChild(node->ChildNodes[0]);
        .               if (node->ChildNodes[1])
-- line 16883 ----------------------------------------
-- line 16889 ----------------------------------------
        .                   {
        .                       mark_node->HasCentralNodeChild = true;
        .                       mark_node = mark_node->ParentNode;
        .                   }
        .               }
        .           }
        .           
        .           static void ImGui::DockNodeUpdateVisibleFlag(ImGuiDockNode* node)
    1,616 ( 0.00%)  {
        .               // Update visibility flag
    4,848 ( 0.00%)      bool is_visible = (node->ParentNode == NULL) ? node->IsDockSpace() : node->IsCentralNode();
    4,040 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsDockSpace() const (404x)
    4,040 ( 0.00%)      is_visible |= (node->Windows.Size > 0);
    4,040 ( 0.00%)      is_visible |= (node->ChildNodes[0] && node->ChildNodes[0]->IsVisible);
    4,040 ( 0.00%)      is_visible |= (node->ChildNodes[1] && node->ChildNodes[1]->IsVisible);
    3,232 ( 0.00%)      node->IsVisible = is_visible;
    1,212 ( 0.00%)  }
        .           
        .           static void ImGui::DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(node->WantMouseMove == true);
        .               StartMouseMovingWindow(window);
        .               g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node->Pos;
        .               g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
        .               node->WantMouseMove = false;
        .           }
        .           
        .           // Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
        .           static void ImGui::DockNodeUpdateForRootNode(ImGuiDockNode* node)
    1,612 ( 0.00%)  {
    1,209 ( 0.00%)      DockNodeUpdateFlagsAndCollapse(node);
  103,885 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdateFlagsAndCollapse(ImGuiDockNode*) (403x)
        .           
        .               // - Setup central node pointers
        .               // - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
        .               // Cannot merge this with DockNodeUpdateFlagsAndCollapse() because FirstNodeWithWindows is found after window removal and child collapsing
    1,209 ( 0.00%)      ImGuiDockNodeTreeInfo info;
    9,672 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiDockNodeTreeInfo::ImGuiDockNodeTreeInfo() (403x)
    2,015 ( 0.00%)      DockNodeFindInfo(node, &info);
   28,601 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:DockNodeFindInfo(ImGuiDockNode*, ImGuiDockNodeTreeInfo*) (403x)
    1,209 ( 0.00%)      node->CentralNode = info.CentralNode;
    2,820 ( 0.00%)      node->OnlyNodeWithWindows = (info.CountNodesWithWindows == 1) ? info.FirstNodeWithWindows : NULL;
    1,209 ( 0.00%)      node->CountNodeWithWindows = info.CountNodesWithWindows;
    1,618 ( 0.00%)      if (node->LastFocusedNodeId == 0 && info.FirstNodeWithWindows != NULL)
        4 ( 0.00%)          node->LastFocusedNodeId = info.FirstNodeWithWindows->ID;
        .           
        .               // Copy the window class from of our first window so it can be used for proper dock filtering.
        .               // When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
        .               // FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
    1,612 ( 0.00%)      if (ImGuiDockNode* first_node_with_windows = info.FirstNodeWithWindows)
        .               {
    6,030 ( 0.00%)          node->WindowClass = first_node_with_windows->Windows[0]->WindowClass;
    7,638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (402x)
    2,412 ( 0.00%)          for (int n = 1; n < first_node_with_windows->Windows.Size; n++)
        .                       if (first_node_with_windows->Windows[n]->WindowClass.DockingAllowUnclassed == false)
        .                       {
        .                           node->WindowClass = first_node_with_windows->Windows[n]->WindowClass;
        .                           break;
        .                       }
        .               }
        .           
    1,209 ( 0.00%)      ImGuiDockNode* mark_node = node->CentralNode;
    2,015 ( 0.00%)      while (mark_node)
        .               {
    1,612 ( 0.00%)          mark_node->HasCentralNodeChild = true;
    1,209 ( 0.00%)          mark_node = mark_node->ParentNode;
        .               }
    1,612 ( 0.00%)  }
        .           
        .           static void DockNodeSetupHostWindow(ImGuiDockNode* node, ImGuiWindow* host_window)
    1,612 ( 0.00%)  {
        .               // Remove ourselves from any previous different host window
        .               // This can happen if a user mistakenly does (see #4295 for details):
        .               //  - N+0: DockBuilderAddNode(id, 0)    // missing ImGuiDockNodeFlags_DockSpace
        .               //  - N+1: NewFrame()                   // will create floating host window for that node
        .               //  - N+1: DockSpace(id)                // requalify node as dockspace, moving host window
    3,220 ( 0.00%)      if (node->HostWindow && node->HostWindow != host_window && node->HostWindow->DockNodeAsHost == node)
        .                   node->HostWindow->DockNodeAsHost = NULL;
        .           
    1,209 ( 0.00%)      host_window->DockNodeAsHost = node;
    1,209 ( 0.00%)      node->HostWindow = host_window;
    1,209 ( 0.00%)  }
        .           
        .           static void ImGui::DockNodeUpdate(ImGuiDockNode* node)
    2,418 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,418 ( 0.00%)      IM_ASSERT(node->LastFrameActive != g.FrameCount);
    1,612 ( 0.00%)      node->LastFrameAlive = g.FrameCount;
    1,612 ( 0.00%)      node->IsBgDrawnThisFrame = false;
        .           
    2,418 ( 0.00%)      node->CentralNode = node->OnlyNodeWithWindows = NULL;
    2,015 ( 0.00%)      if (node->IsRootNode())
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
    1,209 ( 0.00%)          DockNodeUpdateForRootNode(node);
  180,412 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdateForRootNode(ImGuiDockNode*) (403x)
        .           
        .               // Remove tab bar if not needed
    2,827 ( 0.00%)      if (node->TabBar && node->IsNoTabBar())
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsNoTabBar() const (1x)
        3 ( 0.00%)          DockNodeRemoveTabBar(node);
      400 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeRemoveTabBar(ImGuiDockNode*) (1x)
        .           
        .               // Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
      403 ( 0.00%)      bool want_to_hide_host_window = false;
    2,015 ( 0.00%)      if (node->IsFloatingNode())
    6,045 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsFloatingNode() const (403x)
        .               {
        .                   if (node->Windows.Size <= 1 && node->IsLeafNode())
        .                       if (!g.IO.ConfigDockingAlwaysTabBar && (node->Windows.Size == 0 || !node->Windows[0]->WindowClass.DockingAlwaysTabBar))
        .                           want_to_hide_host_window = true;
        .                   if (node->CountNodeWithWindows == 0)
        .                       want_to_hide_host_window = true;
        .               }
      806 ( 0.00%)      if (want_to_hide_host_window)
        .               {
        .                   if (node->Windows.Size == 1)
        .                   {
        .                       // Floating window pos/size is authoritative
        .                       ImGuiWindow* single_window = node->Windows[0];
        .                       node->Pos = single_window->Pos;
        .                       node->Size = single_window->SizeFull;
        .                       node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;
-- line 17001 ----------------------------------------
-- line 17035 ----------------------------------------
        .               // This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
        .               // otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
        .               //   N+0: Begin(): window created (with no known size), node is created
        .               //   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
        .               //   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
        .               // We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
        .               // It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
        .               // In reality it isn't very important as user quickly ends up with size data in .ini file.
    5,239 ( 0.00%)      if (node->IsVisible && node->HostWindow == NULL && node->IsFloatingNode() && node->IsLeafNode())
        .               {
        .                   IM_ASSERT(node->Windows.Size > 0);
        .                   ImGuiWindow* ref_window = NULL;
        .                   if (node->SelectedTabId != 0) // Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!
        .                       ref_window = DockNodeFindWindowByID(node, node->SelectedTabId);
        .                   if (ref_window == NULL)
        .                       ref_window = node->Windows[0];
        .                   if (ref_window->AutoFitFramesX > 0 || ref_window->AutoFitFramesY > 0)
        .                   {
        .                       node->State = ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing;
        .                       return;
        .                   }
        .               }
        .           
    1,209 ( 0.00%)      const ImGuiDockNodeFlags node_flags = node->MergedFlags;
        .           
        .               // Decide if the node will have a close button and a window menu button
    7,249 ( 0.00%)      node->HasWindowMenuButton = (node->Windows.Size > 0) && (node_flags & ImGuiDockNodeFlags_NoWindowMenuButton) == 0;
    1,612 ( 0.00%)      node->HasCloseButton = false;
    8,859 ( 0.00%)      for (ImGuiWindow* window : node->Windows)
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::end() (403x)
    2,821 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::begin() (403x)
        .               {
        .                   // FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
    7,236 ( 0.00%)          node->HasCloseButton |= window->HasCloseButton;
    4,422 ( 0.00%)          window->DockIsActive = (node->Windows.Size > 1);
        .               }
    1,612 ( 0.00%)      if (node_flags & ImGuiDockNodeFlags_NoCloseButton)
        .                   node->HasCloseButton = false;
        .           
        .               // Bind or create host window
      403 ( 0.00%)      ImGuiWindow* host_window = NULL;
      403 ( 0.00%)      bool beginned_into_host_window = false;
    2,015 ( 0.00%)      if (node->IsDockSpace())
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsDockSpace() const (403x)
        .               {
        .                   // [Explicit root dockspace node]
    1,612 ( 0.00%)          IM_ASSERT(node->HostWindow);
    1,612 ( 0.00%)          host_window = node->HostWindow;
        .               }
        .               else
        .               {
        .                   // [Automatic root or child nodes]
        .                   if (node->IsRootNode() && node->IsVisible)
        .                   {
        .                       ImGuiWindow* ref_window = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
        .           
-- line 17087 ----------------------------------------
-- line 17143 ----------------------------------------
        .                   else if (node->ParentNode)
        .                   {
        .                       node->HostWindow = host_window = node->ParentNode->HostWindow;
        .                       node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Auto;
        .                   }
        .                   if (node->WantMouseMove && node->HostWindow)
        .                       DockNodeStartMouseMovingWindow(node, node->HostWindow);
        .               }
      806 ( 0.00%)      node->RefViewportId = 0; // Clear when we have a host window
        .           
        .               // Update focused node (the one whose title bar is highlight) within a node tree
    2,015 ( 0.00%)      if (node->IsSplitNode())
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsSplitNode() const (403x)
        .                   IM_ASSERT(node->TabBar == NULL);
    2,015 ( 0.00%)      if (node->IsRootNode())
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
    4,433 ( 0.00%)          if (ImGuiWindow* p_window = g.NavWindow ? g.NavWindow->RootWindow : NULL)
    2,821 ( 0.00%)              while (p_window != NULL && p_window->DockNode != NULL)
        .                       {
    1,920 ( 0.00%)                  ImGuiDockNode* p_node = DockNodeGetRootNode(p_window->DockNode);
    4,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::DockNodeGetRootNode(ImGuiDockNode*) (384x)
    1,152 ( 0.00%)                  if (p_node == node)
        .                           {
    1,920 ( 0.00%)                      node->LastFocusedNodeId = p_window->DockNode->ID; // Note: not using root node ID!
      384 ( 0.00%)                      break;
        .                           }
        .                           p_window = p_node->HostWindow ? p_node->HostWindow->RootWindow : NULL;
        .                       }
        .           
        .               // Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
    1,209 ( 0.00%)      ImGuiDockNode* central_node = node->CentralNode;
    5,239 ( 0.00%)      const bool central_node_hole = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0 && central_node != NULL && central_node->IsEmpty();
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
      806 ( 0.00%)      bool central_node_hole_register_hit_test_hole = central_node_hole;
      806 ( 0.00%)      if (central_node_hole)
        .                   if (const ImGuiPayload* payload = ImGui::GetDragDropPayload())
        .                       if (payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, *(ImGuiWindow**)payload->Data))
        .                           central_node_hole_register_hit_test_hole = false;
      806 ( 0.00%)      if (central_node_hole_register_hit_test_hole)
        .               {
        .                   // We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
        .                   // (But we only add it if there's something else on the other side of the hole, otherwise for e.g. fullscreen
        .                   // covering passthru node we'd have a gap on the edge not covered by the hole)
        .                   IM_ASSERT(node->IsDockSpace()); // We cannot pass this flag without the DockSpace() api. Testing this because we also setup the hole in host_window->ParentNode
        .                   ImGuiDockNode* root_node = DockNodeGetRootNode(central_node);
        .                   ImRect root_rect(root_node->Pos, root_node->Pos + root_node->Size);
        .                   ImRect hole_rect(central_node->Pos, central_node->Pos + central_node->Size);
-- line 17185 ----------------------------------------
-- line 17192 ----------------------------------------
        .                   {
        .                       SetWindowHitTestHole(host_window, hole_rect.Min, hole_rect.Max - hole_rect.Min);
        .                       if (host_window->ParentWindow)
        .                           SetWindowHitTestHole(host_window->ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min);
        .                   }
        .               }
        .           
        .               // Update position/size, process and draw resizing splitters
    4,433 ( 0.00%)      if (node->IsRootNode() && host_window)
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
        .               {
    4,030 ( 0.00%)          DockNodeTreeUpdatePosSize(node, host_window->Pos, host_window->Size);
   16,523 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeTreeUpdatePosSize(ImGuiDockNode*, ImVec2, ImVec2, ImGuiDockNode*) (403x)
    2,015 ( 0.00%)          PushStyleColor(ImGuiCol_Separator, g.Style.Colors[ImGuiCol_Border]);
   48,941 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleColor(int, ImVec4 const&) (403x)
    2,015 ( 0.00%)          PushStyleColor(ImGuiCol_SeparatorActive, g.Style.Colors[ImGuiCol_ResizeGripActive]);
   48,763 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleColor(int, ImVec4 const&) (403x)
    2,015 ( 0.00%)          PushStyleColor(ImGuiCol_SeparatorHovered, g.Style.Colors[ImGuiCol_ResizeGripHovered]);
   48,763 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleColor(int, ImVec4 const&) (403x)
    1,209 ( 0.00%)          DockNodeTreeUpdateSplitter(node);
   10,881 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeTreeUpdateSplitter(ImGuiDockNode*) (403x)
      806 ( 0.00%)          PopStyleColor(3);
   80,197 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PopStyleColor(int) (403x)
        .               }
        .           
        .               // Draw empty node background (currently can only be the Central Node)
    4,037 ( 0.00%)      if (host_window && node->IsEmpty() && node->IsVisible)
    5,643 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsEmpty() const (403x)
        .               {
        5 ( 0.00%)          host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
      139 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::ChannelsSetCurrent(int) (1x)
       11 ( 0.00%)          node->LastBgColor = (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) ? 0 : GetColorU32(ImGuiCol_DockingEmptyBg);
      131 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (1x)
        4 ( 0.00%)          if (node->LastBgColor != 0)
       23 ( 0.00%)              host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, node->LastBgColor);
      651 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (1x)
       39 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (1x)
        4 ( 0.00%)          node->IsBgDrawnThisFrame = true;
        .               }
        .           
        .               // Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
        .               // We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
        .               // _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
    5,239 ( 0.00%)      const bool render_dockspace_bg = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0;
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
      806 ( 0.00%)      if (render_dockspace_bg && node->IsVisible)
        .               {
        .                   host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        .                   if (central_node_hole)
        .                       RenderRectFilledWithHole(host_window->DrawList, node->Rect(), central_node->Rect(), GetColorU32(ImGuiCol_WindowBg), 0.0f);
        .                   else
        .                       host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, GetColorU32(ImGuiCol_WindowBg), 0.0f);
        .               }
        .           
        .               // Draw and populate Tab Bar
      806 ( 0.00%)      if (host_window)
    2,015 ( 0.00%)          host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
   13,807 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImDrawList::ChannelsSetCurrent(int) (403x)
    2,418 ( 0.00%)      if (host_window && node->Windows.Size > 0)
        .               {
    2,412 ( 0.00%)          DockNodeUpdateTabBar(node, host_window);
   92,796 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdateTabBar(ImGuiDockNode*, ImGuiWindow*) (402x)
        .               }
        .               else
        .               {
        4 ( 0.00%)          node->WantCloseAll = false;
        2 ( 0.00%)          node->WantCloseTabId = 0;
        4 ( 0.00%)          node->IsFocused = false;
        .               }
    1,612 ( 0.00%)      if (node->TabBar && node->TabBar->SelectedTabId)
        .                   node->SelectedTabId = node->TabBar->SelectedTabId;
    1,612 ( 0.00%)      else if (node->Windows.Size > 0)
    3,618 ( 0.00%)          node->SelectedTabId = node->Windows[0]->TabId;
    7,638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (402x)
        .           
        .               // Draw payload drop target
    3,224 ( 0.00%)      if (host_window && node->IsVisible)
    5,239 ( 0.00%)          if (node->IsRootNode() && (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != host_window))
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
    1,209 ( 0.00%)              BeginDockableDragDropTarget(host_window);
    8,866 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BeginDockableDragDropTarget(ImGuiWindow*) (403x)
        .           
        .               // We update this after DockNodeUpdateTabBar()
    1,612 ( 0.00%)      node->LastFrameActive = g.FrameCount;
        .           
        .               // Recurse into children
        .               // FIXME-DOCK FIXME-OPT: Should not need to recurse into children
      806 ( 0.00%)      if (host_window)
        .               {
    1,612 ( 0.00%)          if (node->ChildNodes[0])
        .                       DockNodeUpdate(node->ChildNodes[0]);
    1,612 ( 0.00%)          if (node->ChildNodes[1])
        .                       DockNodeUpdate(node->ChildNodes[1]);
        .           
        .                   // Render outer borders last (after the tab bar)
    2,015 ( 0.00%)          if (node->IsRootNode())
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
    1,209 ( 0.00%)              RenderWindowOuterBorders(host_window);
   70,525 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowOuterBorders(ImGuiWindow*) (403x)
        .               }
        .           
        .               // End host window
      806 ( 0.00%)      if (beginned_into_host_window) //-V1020
        .                   End();
    2,015 ( 0.00%)  }
        .           
        .           // Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
        .           static int IMGUI_CDECL TabItemComparerByDockOrder(const void* lhs, const void* rhs)
        .           {
        .               ImGuiWindow* a = ((const ImGuiTabItem*)lhs)->Window;
        .               ImGuiWindow* b = ((const ImGuiTabItem*)rhs)->Window;
        .               if (int d = ((a->DockOrder == -1) ? INT_MAX : a->DockOrder) - ((b->DockOrder == -1) ? INT_MAX : b->DockOrder))
        .                   return d;
-- line 17284 ----------------------------------------
-- line 17351 ----------------------------------------
        .           void ImGui::DockNodeEndAmendTabBar()
        .           {
        .               EndTabBar();
        .               PopID();
        .               End();
        .           }
        .           
        .           static bool IsDockNodeTitleBarHighlighted(ImGuiDockNode* node, ImGuiDockNode* root_node)
    2,010 ( 0.00%)  {
        .               // CTRL+Tab highlight (only highlighting leaf node, not whole hierarchy)
      804 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,608 ( 0.00%)      if (g.NavWindowingTarget)
        .                   return (g.NavWindowingTarget->DockNode == node);
        .           
        .               // FIXME-DOCKING: May want alternative to treat central node void differently? e.g. if (g.NavWindow == host_window)
    4,020 ( 0.00%)      if (g.NavWindow && root_node->LastFocusedNodeId == node->ID)
        .               {
        .                   // FIXME: This could all be backed in RootWindowForTitleBarHighlight? Probably need to reorganize for both dock nodes + other RootWindowForTitleBarHighlight users (not-node)
    1,608 ( 0.00%)          ImGuiWindow* parent_window = g.NavWindow->RootWindow;
    2,412 ( 0.00%)          while (parent_window->Flags & ImGuiWindowFlags_ChildMenu)
        .                       parent_window = parent_window->ParentWindow->RootWindow;
    2,814 ( 0.00%)          ImGuiDockNode* start_parent_node = parent_window->DockNodeAsHost ? parent_window->DockNodeAsHost : parent_window->DockNode;
    2,010 ( 0.00%)          for (ImGuiDockNode* parent_node = start_parent_node; parent_node != NULL; parent_node = parent_node->HostWindow ? parent_node->HostWindow->RootWindow->DockNode : NULL)
    3,456 ( 0.00%)              if ((parent_node = ImGui::DockNodeGetRootNode(parent_node)) == root_node)
    4,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::DockNodeGetRootNode(ImGuiDockNode*) (384x)
      768 ( 0.00%)                  return true;
        .               }
       18 ( 0.00%)      return false;
      804 ( 0.00%)  }
        .           
        .           // Submit the tab bar corresponding to a dock node and various housekeeping details.
        .           static void ImGui::DockNodeUpdateTabBar(ImGuiDockNode* node, ImGuiWindow* host_window)
    3,216 ( 0.00%)  {
      804 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,206 ( 0.00%)      ImGuiStyle& style = g.Style;
        .           
    3,216 ( 0.00%)      const bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
    2,814 ( 0.00%)      const bool closed_all = node->WantCloseAll && node_was_active;
    2,814 ( 0.00%)      const ImGuiID closed_one = node->WantCloseTabId && node_was_active;
    1,608 ( 0.00%)      node->WantCloseAll = false;
      804 ( 0.00%)      node->WantCloseTabId = 0;
        .           
        .               // Decide if we should use a focused title bar color
      402 ( 0.00%)      bool is_focused = false;
    1,608 ( 0.00%)      ImGuiDockNode* root_node = DockNodeGetRootNode(node);
    4,422 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::DockNodeGetRootNode(ImGuiDockNode*) (402x)
    2,814 ( 0.00%)      if (IsDockNodeTitleBarHighlighted(node, root_node))
   26,556 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:IsDockNodeTitleBarHighlighted(ImGuiDockNode*, ImGuiDockNode*) (402x)
      384 ( 0.00%)          is_focused = true;
        .           
        .               // Hidden tab bar will show a triangle on the upper-left (in Begin)
    5,628 ( 0.00%)      if (node->IsHiddenTabBar() || node->IsNoTabBar())
    4,020 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsNoTabBar() const (402x)
    4,020 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsHiddenTabBar() const (402x)
        .               {
    5,226 ( 0.00%)          node->VisibleWindow = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
    7,638 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::operator[](int) (402x)
    3,216 ( 0.00%)          node->IsFocused = is_focused;
      804 ( 0.00%)          if (is_focused)
    1,536 ( 0.00%)              node->LastFrameFocused = g.FrameCount;
    1,608 ( 0.00%)          if (node->VisibleWindow)
        .                   {
        .                       // Notify root of visible window (used to display title in OS task bar)
      876 ( 0.00%)              if (is_focused || root_node->VisibleWindow == NULL)
    1,536 ( 0.00%)                  root_node->VisibleWindow = node->VisibleWindow;
    1,608 ( 0.00%)              if (node->TabBar)
        .                           node->TabBar->VisibleTabId = node->VisibleWindow->TabId;
        .                   }
      402 ( 0.00%)          return;
        .               }
        .           
        .               // Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
        .               bool backup_skip_item = host_window->SkipItems;
        .               if (!node->IsDockSpace())
        .               {
        .                   host_window->SkipItems = false;
        .                   host_window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
-- line 17421 ----------------------------------------
-- line 17651 ----------------------------------------
        .               PopID();
        .           
        .               // Restore SkipItems flag
        .               if (!node->IsDockSpace())
        .               {
        .                   host_window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
        .                   host_window->SkipItems = backup_skip_item;
        .               }
    2,010 ( 0.00%)  }
        .           
        .           static void ImGui::DockNodeAddTabBar(ImGuiDockNode* node)
        8 ( 0.00%)  {
        4 ( 0.00%)      IM_ASSERT(node->TabBar == NULL);
       12 ( 0.00%)      node->TabBar = IM_NEW(ImGuiTabBar);
      176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGuiTabBar::ImGuiTabBar() (1x)
      118 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        7 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator new(unsigned long, ImNewWrapper, void*) (1x)
        8 ( 0.00%)  }
        .           
        .           static void ImGui::DockNodeRemoveTabBar(ImGuiDockNode* node)
        4 ( 0.00%)  {
        4 ( 0.00%)      if (node->TabBar == NULL)
        .                   return;
        4 ( 0.00%)      IM_DELETE(node->TabBar);
      383 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:void IM_DELETE<ImGuiTabBar>(ImGuiTabBar*) (1x)
        3 ( 0.00%)      node->TabBar = NULL;
        2 ( 0.00%)  }
        .           
        .           static bool DockNodeIsDropAllowedOne(ImGuiWindow* payload, ImGuiWindow* host_window)
        .           {
        .               if (host_window->DockNodeAsHost && host_window->DockNodeAsHost->IsDockSpace() && payload->BeginOrderWithinContext < host_window->BeginOrderWithinContext)
        .                   return false;
        .           
        .               ImGuiWindowClass* host_class = host_window->DockNodeAsHost ? &host_window->DockNodeAsHost->WindowClass : &host_window->WindowClass;
        .               ImGuiWindowClass* payload_class = &payload->WindowClass;
-- line 17681 ----------------------------------------
-- line 18149 ----------------------------------------
        .                   ctx->DockContext.Nodes.SetVoidPtr(child_1->ID, NULL);
        .                   IM_DELETE(child_1);
        .               }
        .           }
        .           
        .           // Update Pos/Size for a node hierarchy (don't affect child Windows yet)
        .           // (Depth-first, Pre-Order)
        .           void ImGui::DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, ImGuiDockNode* only_write_to_single_node)
    3,224 ( 0.00%)  {
        .               // During the regular dock node update we write to all nodes.
        .               // 'only_write_to_single_node' is only set when turning a node visible mid-frame and we need its size right-away.
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      const bool write_to_node = only_write_to_single_node == NULL || only_write_to_single_node == node;
      806 ( 0.00%)      if (write_to_node)
        .               {
    1,209 ( 0.00%)          node->Pos = pos;
    1,209 ( 0.00%)          node->Size = size;
        .               }
        .           
    2,015 ( 0.00%)      if (node->IsLeafNode())
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsLeafNode() const (403x)
      403 ( 0.00%)          return;
        .           
        .               ImGuiDockNode* child_0 = node->ChildNodes[0];
        .               ImGuiDockNode* child_1 = node->ChildNodes[1];
        .               ImVec2 child_0_pos = pos, child_1_pos = pos;
        .               ImVec2 child_0_size = size, child_1_size = size;
        .           
        .               const bool child_0_is_toward_single_node = (only_write_to_single_node != NULL && DockNodeIsInHierarchyOf(only_write_to_single_node, child_0));
        .               const bool child_1_is_toward_single_node = (only_write_to_single_node != NULL && DockNodeIsInHierarchyOf(only_write_to_single_node, child_1));
-- line 18177 ----------------------------------------
-- line 18241 ----------------------------------------
        .                   child_0->WantLockSizeOnce = child_1->WantLockSizeOnce = false;
        .           
        .               const bool child_0_recurse = only_write_to_single_node ? child_0_is_toward_single_node : child_0->IsVisible;
        .               const bool child_1_recurse = only_write_to_single_node ? child_1_is_toward_single_node : child_1->IsVisible;
        .               if (child_0_recurse)
        .                   DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size);
        .               if (child_1_recurse)
        .                   DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size);
    1,209 ( 0.00%)  }
        .           
        .           static void DockNodeTreeUpdateSplitterFindTouchingNode(ImGuiDockNode* node, ImGuiAxis axis, int side, ImVector<ImGuiDockNode*>* touching_nodes)
        .           {
        .               if (node->IsLeafNode())
        .               {
        .                   touching_nodes->push_back(node);
        .                   return;
        .               }
-- line 18257 ----------------------------------------
-- line 18260 ----------------------------------------
        .                       DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[0], axis, side, touching_nodes);
        .               if (node->ChildNodes[1]->IsVisible)
        .                   if (node->SplitAxis != axis || side == 1 || !node->ChildNodes[0]->IsVisible)
        .                       DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[1], axis, side, touching_nodes);
        .           }
        .           
        .           // (Depth-First, Pre-Order)
        .           void ImGui::DockNodeTreeUpdateSplitter(ImGuiDockNode* node)
    2,418 ( 0.00%)  {
    2,015 ( 0.00%)      if (node->IsLeafNode())
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsLeafNode() const (403x)
      806 ( 0.00%)          return;
        .           
        .               ImGuiContext& g = *GImGui;
        .           
        .               ImGuiDockNode* child_0 = node->ChildNodes[0];
        .               ImGuiDockNode* child_1 = node->ChildNodes[1];
        .               if (child_0->IsVisible && child_1->IsVisible)
        .               {
        .                   // Bounding box of the splitter cover the space between both nodes (w = Spacing, h = Size[xy^1] for when splitting horizontally)
-- line 18278 ----------------------------------------
-- line 18374 ----------------------------------------
        .                       PopID();
        .                   }
        .               }
        .           
        .               if (child_0->IsVisible)
        .                   DockNodeTreeUpdateSplitter(child_0);
        .               if (child_1->IsVisible)
        .                   DockNodeTreeUpdateSplitter(child_1);
    2,015 ( 0.00%)  }
        .           
        .           ImGuiDockNode* ImGui::DockNodeTreeFindFallbackLeafNode(ImGuiDockNode* node)
        .           {
        .               if (node->IsLeafNode())
        .                   return node;
        .               if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[0]))
        .                   return leaf_node;
        .               if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[1]))
        .                   return leaf_node;
        .               return NULL;
        .           }
        .           
        .           ImGuiDockNode* ImGui::DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos)
        5 ( 0.00%)  {
        7 ( 0.00%)      if (!node->IsVisible)
        .                   return NULL;
        .           
        2 ( 0.00%)      const float dock_spacing = 0.0f;// g.Style.ItemInnerSpacing.x; // FIXME: Relation to DOCKING_SPLITTER_SIZE?
       16 ( 0.00%)      ImRect r(node->Pos, node->Pos + node->Size);
       39 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (1x)
       16 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (1x)
        5 ( 0.00%)      r.Expand(dock_spacing * 0.5f);
       27 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Expand(float) (1x)
        6 ( 0.00%)      bool inside = r.Contains(pos);
       31 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::Contains(ImVec2 const&) const (1x)
        4 ( 0.00%)      if (!inside)
        2 ( 0.00%)          return NULL;
        .           
        .               if (node->IsLeafNode())
        .                   return node;
        .               if (ImGuiDockNode* hovered_node = DockNodeTreeFindVisibleNodeByPos(node->ChildNodes[0], pos))
        .                   return hovered_node;
        .               if (ImGuiDockNode* hovered_node = DockNodeTreeFindVisibleNodeByPos(node->ChildNodes[1], pos))
        .                   return hovered_node;
        .           
        .               // This means we are hovering over the splitter/spacing of a parent node
        .               return node;
        2 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
        .           //-----------------------------------------------------------------------------
        .           // - SetWindowDock() [Internal]
        .           // - DockSpace()
        .           // - DockSpaceOverViewport()
        .           //-----------------------------------------------------------------------------
-- line 18424 ----------------------------------------
-- line 18460 ----------------------------------------
        .               window->DockId = dock_id;
        .           }
        .           
        .           // Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
        .           // The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
        .           // DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
        .           // When ImGuiDockNodeFlags_KeepAliveOnly is set, nothing is submitted in the current window (function may be called from any location).
        .           ImGuiID ImGui::DockSpace(ImGuiID id, const ImVec2& size_arg, ImGuiDockNodeFlags flags, const ImGuiWindowClass* window_class)
    3,627 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
      806 ( 0.00%)      ImGuiWindow* window = GetCurrentWindowRead();
    3,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetCurrentWindowRead() (403x)
    2,015 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .                   return 0;
        .           
        .               // Early out if parent window is hidden/collapsed
        .               // This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
        .               // If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
    1,612 ( 0.00%)      if (window->SkipItems)
        .                   flags |= ImGuiDockNodeFlags_KeepAliveOnly;
    1,612 ( 0.00%)      if ((flags & ImGuiDockNodeFlags_KeepAliveOnly) == 0)
      806 ( 0.00%)          window = GetCurrentWindow(); // call to set window->WriteAccessed = true;
    4,836 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::GetCurrentWindow() (403x)
        .           
    1,612 ( 0.00%)      IM_ASSERT((flags & ImGuiDockNodeFlags_DockSpace) == 0);
      806 ( 0.00%)      IM_ASSERT(id != 0);
    2,418 ( 0.00%)      ImGuiDockNode* node = DockContextFindNodeByID(&g, id);
   37,882 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextFindNodeByID(ImGuiContext*, unsigned int) (403x)
      806 ( 0.00%)      if (!node)
        .               {
        .                   IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X created\n", id);
        .                   node = DockContextAddNode(&g, id);
        .                   node->SetLocalFlags(ImGuiDockNodeFlags_CentralNode);
        .               }
      806 ( 0.00%)      if (window_class && window_class->ClassId != node->WindowClass.ClassId)
        .                   IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", id, node->WindowClass.ClassId, window_class->ClassId);
    1,209 ( 0.00%)      node->SharedFlags = flags;
    5,642 ( 0.00%)      node->WindowClass = window_class ? *window_class : ImGuiWindowClass();
   11,687 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiWindowClass::ImGuiWindowClass() (403x)
        .           
        .               // When a DockSpace transitioned form implicit to explicit this may be called a second time
        .               // It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
    2,418 ( 0.00%)      if (node->LastFrameActive == g.FrameCount && !(flags & ImGuiDockNodeFlags_KeepAliveOnly))
        .               {
        .                   IM_ASSERT(node->IsDockSpace() == false && "Cannot call DockSpace() twice a frame with the same ID");
        .                   node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_DockSpace);
        .                   return id;
        .               }
    3,224 ( 0.00%)      node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_DockSpace);
   12,090 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::SetLocalFlags(int) (403x)
        .           
        .               // Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
    1,612 ( 0.00%)      if (flags & ImGuiDockNodeFlags_KeepAliveOnly)
        .               {
        .                   node->LastFrameAlive = g.FrameCount;
        .                   return id;
        .               }
        .           
    1,209 ( 0.00%)      const ImVec2 content_avail = GetContentRegionAvail();
   33,449 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetContentRegionAvail() (403x)
    2,015 ( 0.00%)      ImVec2 size = ImTrunc(size_arg);
   14,508 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImTrunc(ImVec2 const&) (403x)
    1,612 ( 0.00%)      if (size.x <= 0.0f)
    3,627 ( 0.00%)          size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    4,433 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (403x)
    1,612 ( 0.00%)      if (size.y <= 0.0f)
    3,627 ( 0.00%)          size.y = ImMax(content_avail.y + size.y, 4.0f);
    4,433 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:float ImMax<float>(float, float) (403x)
    3,224 ( 0.00%)      IM_ASSERT(size.x > 0.0f && size.y > 0.0f);
        .           
    1,612 ( 0.00%)      node->Pos = window->DC.CursorPos;
    3,224 ( 0.00%)      node->Size = node->SizeRef = size;
    5,239 ( 0.00%)      SetNextWindowPos(node->Pos);
   13,702 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNextWindowPos(ImVec2 const&, int, ImVec2 const&) (403x)
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (403x)
    2,015 ( 0.00%)      SetNextWindowSize(node->Size);
   10,881 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNextWindowSize(ImVec2 const&, int) (403x)
      806 ( 0.00%)      g.NextWindowData.PosUndock = false;
        .           
        .               // FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
        .               // FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
      403 ( 0.00%)      ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_DockNodeHost;
      403 ( 0.00%)      window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
      403 ( 0.00%)      window_flags |= ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;
      403 ( 0.00%)      window_flags |= ImGuiWindowFlags_NoBackground;
        .           
        .               char title[256];
    4,433 ( 0.00%)      ImFormatString(title, IM_ARRAYSIZE(title), "%s/DockSpace_%08X", window->Name, id);
  315,549 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFormatString(char*, unsigned long, char const*, ...) (403x)
        .           
    1,612 ( 0.00%)      PushStyleVar(ImGuiStyleVar_ChildBorderSize, 0.0f);
   55,614 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleVar(int, float) (403x)
    2,015 ( 0.00%)      Begin(title, NULL, window_flags);
3,498,084 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Begin(char const*, bool*, int) (403x)
      806 ( 0.00%)      PopStyleVar();
   47,554 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PopStyleVar(int) (403x)
        .           
    1,209 ( 0.00%)      ImGuiWindow* host_window = g.CurrentWindow;
    2,015 ( 0.00%)      DockNodeSetupHostWindow(node, host_window);
    8,459 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:DockNodeSetupHostWindow(ImGuiDockNode*, ImGuiWindow*) (403x)
    3,224 ( 0.00%)      host_window->ChildId = window->GetID(title);
  319,579 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (403x)
      806 ( 0.00%)      node->OnlyNodeWithWindows = NULL;
        .           
    2,015 ( 0.00%)      IM_ASSERT(node->IsRootNode());
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsRootNode() const (403x)
        .           
        .               // We need to handle the rare case were a central node is missing.
        .               // This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
        .               // Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
        .               // It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
        .               // The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
        .               // as it doesn't make sense for an empty dockspace to not have this property.
    5,642 ( 0.00%)      if (node->IsLeafNode() && !node->IsCentralNode())
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsCentralNode() const (403x)
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsLeafNode() const (403x)
        .                   node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
        .           
        .               // Update the node
    1,209 ( 0.00%)      DockNodeUpdate(node);
  838,988 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdate(ImGuiDockNode*) (403x)
        .           
      403 ( 0.00%)      End();
  177,723 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::End() (403x)
        .           
    6,045 ( 0.00%)      ImRect bb(node->Pos, node->Pos + size);
   15,717 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:operator+(ImVec2 const&, ImVec2 const&) (403x)
    6,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImRect::ImRect(ImVec2 const&, ImVec2 const&) (403x)
    2,015 ( 0.00%)      ItemSize(size);
   66,898 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ItemSize(ImVec2 const&, float) (403x)
    2,418 ( 0.00%)      ItemAdd(bb, id, NULL, ImGuiItemFlags_NoNav); // Not a nav point (could be, would need to draw the nav rect and replicate/refactor activation from BeginChild(), but seems like CTRL+Tab works better here?)
  164,828 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ItemAdd(ImRect const&, unsigned int, ImRect const*, int) (403x)
    4,904 ( 0.00%)      if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && IsWindowChildOf(g.HoveredWindow, host_window, false, true)) // To fullfill IsItemHovered(), similar to EndChild()
   14,101 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsWindowChildOf(ImGuiWindow*, ImGuiWindow*, bool, bool) (168x)
    1,008 ( 0.00%)          g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
        .           
      403 ( 0.00%)      return id;
    1,209 ( 0.00%)  }
        .           
        .           // Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
        .           // The limitation with this call is that your window won't have a menu bar.
        .           // Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
        .           // But you can also use BeginMainMenuBar(). If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
        .           ImGuiID ImGui::DockSpaceOverViewport(const ImGuiViewport* viewport, ImGuiDockNodeFlags dockspace_flags, const ImGuiWindowClass* window_class)
        .           {
        .               if (viewport == NULL)
-- line 18577 ----------------------------------------
-- line 18648 ----------------------------------------
        .                       settings = CreateNewWindowSettings(window_name);
        .                   if (settings->DockId != node_id)
        .                       settings->DockOrder = -1;
        .                   settings->DockId = node_id;
        .               }
        .           }
        .           
        .           ImGuiDockNode* ImGui::DockBuilderGetNode(ImGuiID node_id)
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      return DockContextFindNodeByID(&g, node_id);
   37,882 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextFindNodeByID(ImGuiContext*, unsigned int) (403x)
      806 ( 0.00%)  }
        .           
        .           void ImGui::DockBuilderSetNodePos(ImGuiID node_id, ImVec2 pos)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiDockNode* node = DockContextFindNodeByID(&g, node_id);
        .               if (node == NULL)
        .                   return;
        .               node->Pos = pos;
-- line 18667 ----------------------------------------
-- line 18725 ----------------------------------------
        .                   return;
        .               if (node->IsCentralNode() && node->ParentNode)
        .                   node->ParentNode->SetLocalFlags(node->ParentNode->LocalFlags | ImGuiDockNodeFlags_CentralNode);
        .               DockContextRemoveNode(&g, node, true);
        .           }
        .           
        .           // root_id = 0 to remove all, root_id != 0 to remove child of given node.
        .           void ImGui::DockBuilderRemoveNodeChildNodes(ImGuiID root_id)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        3 ( 0.00%)      ImGuiDockContext* dc = &g.DockContext;
        .           
        4 ( 0.00%)      ImGuiDockNode* root_node = root_id ? DockContextFindNodeByID(&g, root_id) : NULL;
        2 ( 0.00%)      if (root_id && root_node == NULL)
        .                   return;
        1 ( 0.00%)      bool has_central_node = false;
        .           
        4 ( 0.00%)      ImGuiDataAuthority backup_root_node_authority_for_pos = root_node ? root_node->AuthorityForPos : ImGuiDataAuthority_Auto;
        4 ( 0.00%)      ImGuiDataAuthority backup_root_node_authority_for_size = root_node ? root_node->AuthorityForSize : ImGuiDataAuthority_Auto;
        .           
        .               // Process active windows
        3 ( 0.00%)      ImVector<ImGuiDockNode*> nodes_to_remove;
       14 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNode*>::ImVector() (1x)
        6 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
        .                   if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                   {
        .                       bool want_removal = (root_id == 0) || (node->ID != root_id && DockNodeGetRootNode(node)->ID == root_id);
        .                       if (want_removal)
        .                       {
        .                           if (node->IsCentralNode())
        .                               has_central_node = true;
        .                           if (root_id != 0)
-- line 18755 ----------------------------------------
-- line 18760 ----------------------------------------
        .                               DockSettingsRenameNodeReferences(node->ID, root_node->ID);
        .                           }
        .                           nodes_to_remove.push_back(node);
        .                       }
        .                   }
        .           
        .               // DockNodeMoveWindows->DockNodeAddWindow will normally set those when reaching two windows (which is only adequate during interactive merge)
        .               // Make sure we don't lose our current pos/size. (FIXME-DOCK: Consider tidying up that code in DockNodeAddWindow instead)
        2 ( 0.00%)      if (root_node)
        .               {
        .                   root_node->AuthorityForPos = backup_root_node_authority_for_pos;
        .                   root_node->AuthorityForSize = backup_root_node_authority_for_size;
        .               }
        .           
        .               // Apply to settings
        8 ( 0.00%)      for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::begin() (1x)
        .                   if (ImGuiID window_settings_dock_id = settings->DockId)
        .                       for (int n = 0; n < nodes_to_remove.Size; n++)
        .                           if (nodes_to_remove[n]->ID == window_settings_dock_id)
        .                           {
        .                               settings->DockId = root_id;
        .                               break;
        .                           }
        .           
        .               // Not really efficient, but easier to destroy a whole hierarchy considering DockContextRemoveNode is attempting to merge nodes
        3 ( 0.00%)      if (nodes_to_remove.Size > 1)
        .                   ImQsort(nodes_to_remove.Data, nodes_to_remove.Size, sizeof(ImGuiDockNode*), DockNodeComparerDepthMostFirst);
        5 ( 0.00%)      for (int n = 0; n < nodes_to_remove.Size; n++)
        .                   DockContextRemoveNode(&g, nodes_to_remove[n], false);
        .           
        2 ( 0.00%)      if (root_id == 0)
        .               {
        3 ( 0.00%)          dc->Nodes.Clear();
       21 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImGuiStorage::Clear() (1x)
        5 ( 0.00%)          dc->Requests.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockRequest>::clear() (1x)
        .               }
        .               else if (has_central_node)
        .               {
        .                   root_node->CentralNode = root_node;
        .                   root_node->SetLocalFlags(root_node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
        .               }
        7 ( 0.00%)  }
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNode*>::~ImVector() (1x)
        .           
        .           void ImGui::DockBuilderRemoveNodeDockedWindows(ImGuiID root_id, bool clear_settings_refs)
        6 ( 0.00%)  {
        .               // Clear references in settings
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        2 ( 0.00%)      if (clear_settings_refs)
        .               {
        8 ( 0.00%)          for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
       12 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImChunkStream<ImGuiWindowSettings>::begin() (1x)
        .                   {
        .                       bool want_removal = (root_id == 0) || (settings->DockId == root_id);
        .                       if (!want_removal && settings->DockId != 0)
        .                           if (ImGuiDockNode* node = DockContextFindNodeByID(&g, settings->DockId))
        .                               if (DockNodeGetRootNode(node)->ID == root_id)
        .                                   want_removal = true;
        .                       if (want_removal)
        .                           settings->DockId = 0;
        .                   }
        .               }
        .           
        .               // Clear references in windows
        6 ( 0.00%)      for (int n = 0; n < g.Windows.Size; n++)
        .               {
        .                   ImGuiWindow* window = g.Windows[n];
        .                   bool want_removal = (root_id == 0) || (window->DockNode && DockNodeGetRootNode(window->DockNode)->ID == root_id) || (window->DockNodeAsHost && window->DockNodeAsHost->ID == root_id);
        .                   if (want_removal)
        .                   {
        .                       const ImGuiID backup_dock_id = window->DockId;
        .                       IM_UNUSED(backup_dock_id);
        .                       DockContextProcessUndockWindow(&g, window, clear_settings_refs);
        .                       if (!clear_settings_refs)
        .                           IM_ASSERT(window->DockId == backup_dock_id);
        .                   }
        .               }
        4 ( 0.00%)  }
        .           
        .           // If 'out_id_at_dir' or 'out_id_at_opposite_dir' are non NULL, the function will write out the ID of the two new nodes created.
        .           // Return value is ID of the node at the specified direction, so same as (*out_id_at_dir) if that pointer is set.
        .           // FIXME-DOCK: We are not exposing nor using split_outer.
        .           ImGuiID ImGui::DockBuilderSplitNode(ImGuiID id, ImGuiDir split_dir, float size_ratio_for_node_at_dir, ImGuiID* out_id_at_dir, ImGuiID* out_id_at_opposite_dir)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(split_dir != ImGuiDir_None);
-- line 18842 ----------------------------------------
-- line 19042 ----------------------------------------
        .           // - GetWindowAlwaysWantOwnTabBar()
        .           // - DockContextBindNodeToWindow()
        .           // - BeginDocked()
        .           // - BeginDockableDragDropSource()
        .           // - BeginDockableDragDropTarget()
        .           //-----------------------------------------------------------------------------
        .           
        .           bool ImGui::GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window)
    6,048 ( 0.00%)  {
    4,032 ( 0.00%)      ImGuiContext& g = *GImGui;
   16,128 ( 0.00%)      if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
        .                   if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
        .                       if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
        .                           return true;
    2,016 ( 0.00%)      return false;
    4,032 ( 0.00%)  }
        .           
        .           static ImGuiDockNode* ImGui::DockContextBindNodeToWindow(ImGuiContext* ctx, ImGuiWindow* window)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *ctx;
        7 ( 0.00%)      ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
       94 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextFindNodeByID(ImGuiContext*, unsigned int) (1x)
        4 ( 0.00%)      IM_ASSERT(window->DockNode == NULL);
        .           
        .               // We should not be docking into a split node (SetWindowDock should avoid this)
       10 ( 0.00%)      if (node && node->IsSplitNode())
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsSplitNode() const (1x)
        .               {
        .                   DockContextProcessUndockWindow(ctx, window);
        .                   return NULL;
        .               }
        .           
        .               // Create node
        2 ( 0.00%)      if (node == NULL)
        .               {
        .                   node = DockContextAddNode(ctx, window->DockId);
        .                   node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;
        .                   node->LastFrameAlive = g.FrameCount;
        .               }
        .           
        .               // If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
        .               // so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
        .               // If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
        .               // This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
        7 ( 0.00%)      if (!node->IsVisible)
        .               {
        .                   ImGuiDockNode* ancestor_node = node;
        .                   while (!ancestor_node->IsVisible && ancestor_node->ParentNode)
        .                       ancestor_node = ancestor_node->ParentNode;
        .                   IM_ASSERT(ancestor_node->Size.x > 0.0f && ancestor_node->Size.y > 0.0f);
        .                   DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(ancestor_node));
        .                   DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node->Pos, ancestor_node->Size, node);
        .               }
        .           
        .               // Add window to node
        5 ( 0.00%)      bool node_was_visible = node->IsVisible;
        6 ( 0.00%)      DockNodeAddWindow(node, window, true);
    1,396 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeAddWindow(ImGuiDockNode*, ImGuiWindow*, bool) (1x)
        8 ( 0.00%)      node->IsVisible = node_was_visible; // Don't mark visible right away (so DockContextEndFrame() doesn't render it, maybe other side effects? will see)
        4 ( 0.00%)      IM_ASSERT(node == window->DockNode);
        1 ( 0.00%)      return node;
        2 ( 0.00%)  }
        .           
        .           static void StoreDockStyleForWindow(ImGuiWindow* window)
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,866 ( 0.00%)      for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
   41,106 ( 0.00%)          window->DockStyle.Colors[color_n] = ImGui::ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
  246,636 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ColorConvertFloat4ToU32(ImVec4 const&) (2,418x)
    1,612 ( 0.00%)  }
        .           
        .           void ImGui::BeginDocked(ImGuiWindow* window, bool* p_open)
    2,015 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Clear fields ahead so most early-out paths don't have to do it
   10,478 ( 0.00%)      window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
        .           
    1,612 ( 0.00%)      const bool auto_dock_node = GetWindowAlwaysWantOwnTabBar(window);
    6,448 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetWindowAlwaysWantOwnTabBar(ImGuiWindow*) (403x)
      806 ( 0.00%)      if (auto_dock_node)
        .               {
        .                   if (window->DockId == 0)
        .                   {
        .                       IM_ASSERT(window->DockNode == NULL);
        .                       window->DockId = DockContextGenNodeID(&g);
        .                   }
        .               }
        .               else
        .               {
        .                   // Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
      403 ( 0.00%)          bool want_undock = false;
    4,433 ( 0.00%)          want_undock |= (window->Flags & ImGuiWindowFlags_NoDocking) != 0;
    4,433 ( 0.00%)          want_undock |= (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) && (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) && g.NextWindowData.PosUndock;
      806 ( 0.00%)          if (want_undock)
        .                   {
        .                       DockContextProcessUndockWindow(&g, window);
        .                       return;
        .                   }
        .               }
        .           
        .               // Bind to our dock node
    1,209 ( 0.00%)      ImGuiDockNode* node = window->DockNode;
      806 ( 0.00%)      if (node != NULL)
    2,412 ( 0.00%)          IM_ASSERT(window->DockId == node->ID);
    2,418 ( 0.00%)      if (window->DockId != 0 && node == NULL)
        .               {
        6 ( 0.00%)          node = DockContextBindNodeToWindow(&g, window);
    1,562 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextBindNodeToWindow(ImGuiContext*, ImGuiWindow*) (1x)
        2 ( 0.00%)          if (node == NULL)
        .                       return;
        .               }
        .           
        .           #if 0
        .               // Undock if the ImGuiDockNodeFlags_NoDockingInCentralNode got set
        .               if (node->IsCentralNode && (node->Flags & ImGuiDockNodeFlags_NoDockingInCentralNode))
        .               {
        .                   DockContextProcessUndockWindow(ctx, window);
        .                   return;
        .               }
        .           #endif
        .           
        .               // Undock if our dockspace node disappeared
        .               // Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
    2,418 ( 0.00%)      if (node->LastFrameAlive < g.FrameCount)
        .               {
        .                   // If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
        .                   ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        .                   if (root_node->LastFrameAlive < g.FrameCount)
        .                       DockContextProcessUndockWindow(&g, window);
        .                   else
        .                       window->DockIsActive = true;
        .                   return;
        .               }
        .           
        .               // Store style overrides
    1,209 ( 0.00%)      StoreDockStyleForWindow(window);
  300,638 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:StoreDockStyleForWindow(ImGuiWindow*) (403x)
        .           
        .               // Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
        .               // and never create neither a host window neither a tab bar.
        .               // FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
    1,612 ( 0.00%)      if (node->HostWindow == NULL)
        .               {
        .                   if (node->State == ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing)
        .                       window->DockIsActive = true;
        .                   if (node->Windows.Size > 1 && window->Appearing) // Only hide appearing window
        .                       DockNodeHideWindowDuringHostWindowCreation(window);
        .                   return;
        .               }
        .           
        .               // We can have zero-sized nodes (e.g. children of a small-size dockspace)
    1,612 ( 0.00%)      IM_ASSERT(node->HostWindow);
    2,015 ( 0.00%)      IM_ASSERT(node->IsLeafNode());
    3,627 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsLeafNode() const (403x)
    4,030 ( 0.00%)      IM_ASSERT(node->Size.x >= 0.0f && node->Size.y >= 0.0f);
      806 ( 0.00%)      node->State = ImGuiDockNodeState_HostWindowVisible;
        .           
        .               // Undock if we are submitted earlier than the host window
    4,836 ( 0.00%)      if (!(node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly) && window->BeginOrderWithinContext < node->HostWindow->BeginOrderWithinContext)
        .               {
        .                   DockContextProcessUndockWindow(&g, window);
        .                   return;
        .               }
        .           
        .               // Position/Size window
    5,239 ( 0.00%)      SetNextWindowPos(node->Pos);
   13,702 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNextWindowPos(ImVec2 const&, int, ImVec2 const&) (403x)
    5,642 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (403x)
    2,015 ( 0.00%)      SetNextWindowSize(node->Size);
   10,881 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNextWindowSize(ImVec2 const&, int) (403x)
      806 ( 0.00%)      g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
    1,612 ( 0.00%)      window->DockIsActive = true;
    1,612 ( 0.00%)      window->DockNodeIsVisible = true;
    1,612 ( 0.00%)      window->DockTabIsVisible = false;
    2,015 ( 0.00%)      if (node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly)
        .                   return;
        .           
        .               // When the window is selected we mark it as visible.
    1,612 ( 0.00%)      if (node->VisibleWindow == window)
    1,608 ( 0.00%)          window->DockTabIsVisible = true;
        .           
        .               // Update window flag
    2,015 ( 0.00%)      IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) == 0);
    2,418 ( 0.00%)      window->Flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize;
    2,418 ( 0.00%)      window->ChildFlags |= ImGuiChildFlags_AlwaysUseWindowPadding;
    5,642 ( 0.00%)      if (node->IsHiddenTabBar() || node->IsNoTabBar())
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsHiddenTabBar() const (403x)
    4,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiDockNode::IsNoTabBar() const (403x)
    2,821 ( 0.00%)          window->Flags |= ImGuiWindowFlags_NoTitleBar;
        .               else
        .                   window->Flags &= ~ImGuiWindowFlags_NoTitleBar;      // Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!
        .           
        .               // Save new dock order only if the window has been visible once already
        .               // This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
    1,616 ( 0.00%)      if (node->TabBar && window->WasActive)
        .                   window->DockOrder = (short)DockNodeGetTabOrder(window);
        .           
    4,433 ( 0.00%)      if ((node->WantCloseAll || node->WantCloseTabId == window->TabId) && p_open != NULL)
        .                   *p_open = false;
        .           
        .               // Update ChildId to allow returning from Child to Parent with Escape
    1,612 ( 0.00%)      ImGuiWindow* parent_window = window->DockNode->HostWindow;
    4,030 ( 0.00%)      window->ChildId = parent_window->GetID(window->Name);
  116,467 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) (403x)
      806 ( 0.00%)  }
        .           
        .           void ImGui::BeginDockableDragDropSource(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.ActiveId == window->MoveId);
        .               IM_ASSERT(g.MovingWindow == window);
        .               IM_ASSERT(g.CurrentWindow == window);
        .           
-- line 19241 ----------------------------------------
-- line 19259 ----------------------------------------
        .               {
        .                   SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
        .                   EndDragDropSource();
        .                   StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
        .               }
        .           }
        .           
        .           void ImGui::BeginDockableDragDropTarget(ImGuiWindow* window)
    2,015 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
    2,015 ( 0.00%)      IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
    2,015 ( 0.00%)      if (!g.DragDropActive)
      806 ( 0.00%)          return;
        .               //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
        .               if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
        .                   return;
        .           
        .               // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
        .               // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
        .               const ImGuiPayload* payload = &g.DragDropPayload;
        .               if (!payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, *(ImGuiWindow**)payload->Data))
-- line 19281 ----------------------------------------
-- line 19339 ----------------------------------------
        .                       DockNodePreviewDockRender(window, node, payload_window, &split_outer);
        .           
        .                       // Queue docking request
        .                       if (split_data->IsDropAllowed && payload->IsDelivery())
        .                           DockContextQueueDock(&g, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
        .                   }
        .               }
        .               EndDragDropTarget();
    1,209 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: Settings
        .           //-----------------------------------------------------------------------------
        .           // - DockSettingsRenameNodeReferences()
        .           // - DockSettingsRemoveNodeReferences()
        .           // - DockSettingsFindNodeSettings()
        .           // - DockSettingsHandler_ApplyAll()
-- line 19355 ----------------------------------------
-- line 19400 ----------------------------------------
        .               for (int n = 0; n < dc->NodesSettings.Size; n++)
        .                   if (dc->NodesSettings[n].ID == id)
        .                       return &dc->NodesSettings[n];
        .               return NULL;
        .           }
        .           
        .           // Clear settings data
        .           static void ImGui::DockSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        5 ( 0.00%)  {
        3 ( 0.00%)      ImGuiDockContext* dc = &ctx->DockContext;
        4 ( 0.00%)      dc->NodesSettings.clear();
       11 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNodeSettings>::clear() (1x)
        5 ( 0.00%)      DockContextClearNodes(ctx, 0, true);
      199 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextClearNodes(ImGuiContext*, unsigned int, bool) (1x)
        3 ( 0.00%)  }
        .           
        .           // Recreate nodes based on settings data
        .           static void ImGui::DockSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        5 ( 0.00%)  {
        .               // Prune settings at boot time only
        3 ( 0.00%)      ImGuiDockContext* dc = &ctx->DockContext;
        4 ( 0.00%)      if (ctx->Windows.Size == 0)
        3 ( 0.00%)          DockContextPruneUnusedSettingsNodes(ctx);
    2,299 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextPruneUnusedSettingsNodes(ImGuiContext*) (1x)
        8 ( 0.00%)      DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
    2,316 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextBuildNodesFromSettings(ImGuiContext*, ImGuiDockNodeSettings*, int) (1x)
        4 ( 0.00%)      DockContextBuildAddWindowsToNodes(ctx, 0);
       45 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextBuildAddWindowsToNodes(ImGuiContext*, unsigned int) (1x)
        3 ( 0.00%)  }
        .           
        .           static void* ImGui::DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
        6 ( 0.00%)  {
        7 ( 0.00%)      if (strcmp(name, "Data") != 0)
       20 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 (1x)
        .                   return NULL;
        1 ( 0.00%)      return (void*)1;
        2 ( 0.00%)  }
        .           
        .           static void ImGui::DockSettingsHandler_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void*, const char* line)
       14 ( 0.00%)  {
        2 ( 0.00%)      char c = 0;
        4 ( 0.00%)      int x = 0, y = 0;
        2 ( 0.00%)      int r = 0;
        .           
        .               // Parsing, e.g.
        .               // " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
        .               // "   DockNode ID=0x00000002 Parent=0x00000001 "
        .               // Important: this code expect currently fields in a fixed order.
        6 ( 0.00%)      ImGuiDockNodeSettings node;
      138 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiDockNodeSettings::ImGuiDockNodeSettings() (2x)
        8 ( 0.00%)      line = ImStrSkipBlank(line);
       30 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImStrSkipBlank(char const*) (2x)
       16 ( 0.00%)      if      (strncmp(line, "DockNode", 8) == 0)  { line = ImStrSkipBlank(line + strlen("DockNode")); }
       50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (2x)
       24 ( 0.00%)      else if (strncmp(line, "DockSpace", 9) == 0) { line = ImStrSkipBlank(line + strlen("DockSpace")); node.Flags |= ImGuiDockNodeFlags_DockSpace; }
       47 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (2x)
       20 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImStrSkipBlank(char const*) (1x)
        2 ( 0.00%)      else return;
       15 ( 0.00%)      if (sscanf(line, "ID=0x%08X%n",      &node.ID, &r) == 1)            { line += r; } else return;
    1,381 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       15 ( 0.00%)      if (sscanf(line, " Parent=0x%08X%n", &node.ParentNodeId, &r) == 1)  { line += r; if (node.ParentNodeId == 0) return; }
      427 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       21 ( 0.00%)      if (sscanf(line, " Window=0x%08X%n", &node.ParentWindowId, &r) ==1) { line += r; if (node.ParentWindowId == 0) return; }
    1,517 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        3 ( 0.00%)      if (node.ParentNodeId == 0)
        .               {
       27 ( 0.00%)          if (sscanf(line, " Pos=%i,%i%n",  &x, &y, &r) == 2)         { line += r; node.Pos = ImVec2ih((short)x, (short)y); } else return;
    1,690 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImVec2ih::ImVec2ih(short, short) (1x)
       28 ( 0.00%)          if (sscanf(line, " Size=%i,%i%n", &x, &y, &r) == 2)         { line += r; node.Size = ImVec2ih((short)x, (short)y); } else return;
    1,672 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImVec2ih::ImVec2ih(short, short) (1x)
        .               }
        .               else
        .               {
        .                   if (sscanf(line, " SizeRef=%i,%i%n", &x, &y, &r) == 2)      { line += r; node.SizeRef = ImVec2ih((short)x, (short)y); }
        .               }
       12 ( 0.00%)      if (sscanf(line, " Split=%c%n", &c, &r) == 1)                   { line += r; if (c == 'X') node.SplitAxis = ImGuiAxis_X; else if (c == 'Y') node.SplitAxis = ImGuiAxis_Y; }
      419 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       12 ( 0.00%)      if (sscanf(line, " NoResize=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoResize; }
      419 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       21 ( 0.00%)      if (sscanf(line, " CentralNode=%d%n", &x, &r) == 1)             { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_CentralNode; }
    1,251 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       21 ( 0.00%)      if (sscanf(line, " NoTabBar=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoTabBar; }
    1,150 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       12 ( 0.00%)      if (sscanf(line, " HiddenTabBar=%d%n", &x, &r) == 1)            { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_HiddenTabBar; }
      411 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       12 ( 0.00%)      if (sscanf(line, " NoWindowMenuButton=%d%n", &x, &r) == 1)      { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoWindowMenuButton; }
      411 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       12 ( 0.00%)      if (sscanf(line, " NoCloseButton=%d%n", &x, &r) == 1)           { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoCloseButton; }
      411 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       18 ( 0.00%)      if (sscanf(line, " Selected=0x%08X%n", &node.SelectedTabId,&r) == 1) { line += r; }
    1,611 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        3 ( 0.00%)      if (node.ParentNodeId != 0)
        .                   if (ImGuiDockNodeSettings* parent_settings = DockSettingsFindNodeSettings(ctx, node.ParentNodeId))
        .                       node.Depth = parent_settings->Depth + 1;
        7 ( 0.00%)      ctx->DockContext.NodesSettings.push_back(node);
      225 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.h:ImVector<ImGuiDockNodeSettings>::push_back(ImGuiDockNodeSettings const&) (1x)
        4 ( 0.00%)  }
        .           
        .           static void DockSettingsHandler_DockNodeToSettings(ImGuiDockContext* dc, ImGuiDockNode* node, int depth)
        .           {
        .               ImGuiDockNodeSettings node_settings;
        .               IM_ASSERT(depth < (1 << (sizeof(node_settings.Depth) << 3)));
        .               node_settings.ID = node->ID;
        .               node_settings.ParentNodeId = node->ParentNode ? node->ParentNode->ID : 0;
        .               node_settings.ParentWindowId = (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow) ? node->HostWindow->ParentWindow->ID : 0;
-- line 19479 ----------------------------------------
-- line 19932 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               DebugFlashStyleColorStop();
        .               g.DebugFlashStyleColorTime = 0.5f;
        .               g.DebugFlashStyleColorIdx = idx;
        .               g.DebugFlashStyleColorBackup = g.Style.Colors[idx];
        .           }
        .           
        .           void ImGui::UpdateDebugToolFlashStyleColor()
    2,418 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,015 ( 0.00%)      if (g.DebugFlashStyleColorTime <= 0.0f)
      403 ( 0.00%)          return;
        .               ColorConvertHSVtoRGB(cosf(g.DebugFlashStyleColorTime * 6.0f) * 0.5f + 0.5f, 0.5f, 0.5f, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z);
        .               g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0f;
        .               if ((g.DebugFlashStyleColorTime -= g.IO.DeltaTime) <= 0.0f)
        .                   DebugFlashStyleColorStop();
    2,418 ( 0.00%)  }
        .           
        .           // Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
        .           static void MetricsHelpMarker(const char* desc)
        .           {
        .               ImGui::TextDisabled("(?)");
        .               if (ImGui::BeginItemTooltip())
        .               {
        .                   ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
-- line 19956 ----------------------------------------
-- line 21446 ----------------------------------------
        .           void ImGui::DebugStartItemPicker()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.DebugItemPickerActive = true;
        .           }
        .           
        .           // [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
        .           void ImGui::UpdateDebugToolItemPicker()
    1,612 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
      806 ( 0.00%)      g.DebugItemPickerBreakId = 0;
    2,015 ( 0.00%)      if (!g.DebugItemPickerActive)
      806 ( 0.00%)          return;
        .           
        .               const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
        .               SetMouseCursor(ImGuiMouseCursor_Hand);
        .               if (IsKeyPressed(ImGuiKey_Escape))
        .                   g.DebugItemPickerActive = false;
        .               const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
        .               if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
        .               {
-- line 21466 ----------------------------------------
-- line 21476 ----------------------------------------
        .               Text("HoveredId: 0x%08X", hovered_id);
        .               Text("Press ESC to abort picking.");
        .               const char* mouse_button_names[] = { "Left", "Right", "Middle" };
        .               if (change_mapping)
        .                   Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
        .               else
        .                   TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
        .               EndTooltip();
    1,209 ( 0.00%)  }
        .           
        .           // [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
        .           void ImGui::UpdateDebugToolStackQueries()
    1,209 ( 0.00%)  {
      806 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,209 ( 0.00%)      ImGuiIDStackTool* tool = &g.DebugIDStackTool;
        .           
        .               // Clear hook when id stack tool is not visible
      806 ( 0.00%)      g.DebugHookIdInfo = 0;
    2,821 ( 0.00%)      if (g.FrameCount != tool->LastActiveFrame + 1)
      804 ( 0.00%)          return;
        .           
        .               // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
        .               // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
        7 ( 0.00%)      const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
        4 ( 0.00%)      if (tool->QueryId != query_id)
        .               {
        .                   tool->QueryId = query_id;
        .                   tool->StackLevel = -1;
        .                   tool->Results.resize(0);
        .               }
        2 ( 0.00%)      if (query_id == 0)
        1 ( 0.00%)          return;
        .           
        .               // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
        .               int stack_level = tool->StackLevel;
        .               if (stack_level >= 0 && stack_level < tool->Results.Size)
        .                   if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
        .                       tool->StackLevel++;
        .           
        .               // Update hook
-- line 21515 ----------------------------------------
-- line 21516 ----------------------------------------
        .               stack_level = tool->StackLevel;
        .               if (stack_level == -1)
        .                   g.DebugHookIdInfo = query_id;
        .               if (stack_level >= 0 && stack_level < tool->Results.Size)
        .               {
        .                   g.DebugHookIdInfo = tool->Results[stack_level].ID;
        .                   tool->Results[stack_level].QueryFrameCount++;
        .               }
      806 ( 0.00%)  }
        .           
        .           // [DEBUG] ID Stack tool: hooks called by GetID() family functions
        .           void ImGui::DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void* data_id, const void* data_id_end)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               ImGuiIDStackTool* tool = &g.DebugIDStackTool;
        .           
-- line 21532 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/variant
--------------------------------------------------------------------------------
Ir                 

-- line 138 ----------------------------------------
        .           
        .             template<typename _Result_type, typename _Visitor, typename... _Variants>
        .               constexpr decltype(auto)
        .               __do_visit(_Visitor&& __visitor, _Variants&&... __variants);
        .           
        .             template <typename... _Types, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               decltype(auto)
1,168,836 ( 0.00%)      __variant_cast(_Tp&& __rhs)
        .               {
        .                 if constexpr (is_lvalue_reference_v<_Tp>)
        .           	{
        .           	  if constexpr (is_const_v<remove_reference_t<_Tp>>)
  192,907 ( 0.00%)  	    return static_cast<const variant<_Types...>&>(__rhs);
        .           	  else
  196,705 ( 0.00%)  	    return static_cast<variant<_Types...>&>(__rhs);
        .           	}
        .                 else
        .                   return static_cast<variant<_Types...>&&>(__rhs);
  779,224 ( 0.00%)      }
        .           
        .           namespace __detail
        .           {
        .           namespace __variant
        .           {
        .             // used for raw visitation
        .             struct __variant_cookie {};
        .             // used for raw visitation with indices passed in
-- line 165 ----------------------------------------
-- line 174 ----------------------------------------
        .               {
        .                 std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
        .           				        std::forward<_Variants>(__variants)...);
        .               }
        .           
        .             // Visit variants that might be valueless, passing indices to the visitor.
        .             template<typename _Visitor, typename... _Variants>
        .               constexpr void
1,157,442 ( 0.00%)      __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)
        .               {
1,929,070 ( 0.00%)        std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),
92,720,459 ( 0.08%)  => /usr/include/c++/14/variant:decltype(auto) std::__do_visit<std::__detail::__variant::__variant_idx_cookie, std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
1,157,442 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>::type&) (192,907x)
1,157,442 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&& std::forward<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}>(std::remove_reference<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}>::type&) (192,907x)
        .           	  std::forward<_Variants>(__variants)...);
  771,628 ( 0.00%)      }
        .           
        .             // The __as function templates implement the exposition-only "as-variant"
        .           
        .             template<typename... _Types>
        .               constexpr std::variant<_Types...>&
        .               __as(std::variant<_Types...>& __v) noexcept
        .               { return __v; }
        .           
-- line 194 ----------------------------------------
-- line 216 ----------------------------------------
        .             template<typename _Type, bool = std::is_trivially_destructible_v<_Type>>
        .               struct _Uninitialized;
        .           
        .             template<typename _Type>
        .               struct _Uninitialized<_Type, true>
        .               {
        .                 template<typename... _Args>
        .           	constexpr
   14,401 ( 0.00%)  	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
   16,238 ( 0.00%)  	: _M_storage(std::forward<_Args>(__args)...)
    3,912 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager::ResourceLoadError const& std::forward<Ship::ResourceManager::ResourceLoadError const&>(std::remove_reference<Ship::ResourceManager::ResourceLoadError const&>::type&) (652x)
    9,423 ( 0.00%)  	{ }
        .           
    1,956 ( 0.00%)        constexpr const _Type& _M_get() const & noexcept
    1,956 ( 0.00%)        { return _M_storage; }
        .           
    9,423 ( 0.00%)        constexpr _Type& _M_get() & noexcept
    9,423 ( 0.00%)        { return _M_storage; }
        .           
        .                 constexpr const _Type&& _M_get() const && noexcept
        .                 { return std::move(_M_storage); }
        .           
        .                 constexpr _Type&& _M_get() && noexcept
        .                 { return std::move(_M_storage); }
        .           
        .                 _Type _M_storage;
-- line 240 ----------------------------------------
-- line 241 ----------------------------------------
        .               };
        .           
        .             template<typename _Type>
        .               struct _Uninitialized<_Type, false>
        .               {
        .           #if __cpp_lib_variant >= 202106L
        .                 template<typename... _Args>
        .           	constexpr
1,163,982 ( 0.00%)  	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
1,356,884 ( 0.00%)  	: _M_storage(std::forward<_Args>(__args)...)
14,803,635 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource> const&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource> const& std::forward<std::shared_ptr<Ship::IResource> const&>(std::remove_reference<std::shared_ptr<Ship::IResource> const&>::type&) (192,255x)
  776,207 ( 0.00%)  	{ }
        .           
        .                 constexpr ~_Uninitialized() { }
        .           
        .                 _Uninitialized(const _Uninitialized&) = default;
        .                 _Uninitialized(_Uninitialized&&) = default;
        .                 _Uninitialized& operator=(const _Uninitialized&) = default;
        .                 _Uninitialized& operator=(_Uninitialized&&) = default;
        .           
  576,765 ( 0.00%)        constexpr const _Type& _M_get() const & noexcept
  576,765 ( 0.00%)        { return _M_storage; }
        .           
1,021,389 ( 0.00%)        constexpr _Type& _M_get() & noexcept
1,021,389 ( 0.00%)        { return _M_storage; }
        .           
        .                 constexpr const _Type&& _M_get() const && noexcept
        .                 { return std::move(_M_storage); }
        .           
        .                 constexpr _Type&& _M_get() && noexcept
        .                 { return std::move(_M_storage); }
        .           
        .                 struct _Empty_byte { };
-- line 272 ----------------------------------------
-- line 297 ----------------------------------------
        .                 { return std::move(*_M_storage._M_ptr()); }
        .           
        .                 __gnu_cxx::__aligned_membuf<_Type> _M_storage;
        .           #endif
        .               };
        .           
        .             template<size_t _Np, typename _Union>
        .               constexpr decltype(auto)
2,146,044 ( 0.00%)      __get_n(_Union&& __u) noexcept
        .               {
        .                 if constexpr (_Np == 0)
   22,250 ( 0.00%)  	return std::forward<_Union>(__u)._M_first._M_get();
   18,846 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) (3,141x)
   18,846 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Uninitialized<Ship::ResourceManager::ResourceLoadError, true>::_M_get() & (3,141x)
        .                 else if constexpr (_Np == 1)
2,660,305 ( 0.00%)  	return std::forward<_Union>(__u)._M_rest._M_first._M_get();
2,027,100 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) (337,850x)
2,027,100 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Uninitialized<std::shared_ptr<Ship::IResource>, false>::_M_get() & (337,850x)
        .                 else if constexpr (_Np == 2)
        .           	return std::forward<_Union>(__u)._M_rest._M_rest._M_first._M_get();
        .                 else
        .           	return __variant::__get_n<_Np - 3>(
        .           		 std::forward<_Union>(__u)._M_rest._M_rest._M_rest);
1,073,022 ( 0.00%)      }
        .           
        .             // Returns the typed storage for __v.
        .             template<size_t _Np, typename _Variant>
        .               constexpr decltype(auto)
2,146,044 ( 0.00%)      __get(_Variant&& __v) noexcept
3,755,577 ( 0.00%)      { return __variant::__get_n<_Np>(std::forward<_Variant>(__v)._M_u); }
7,770,550 ( 0.01%)  => /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__get_n<1ul, std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (337,850x)
2,027,100 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) (337,850x)
        .           
        .             // Gets the _Uninitialized to construct into for __u.
        .             template<size_t _Np, typename _Union>
        .               constexpr decltype(auto)
    5,216 ( 0.00%)      __construct_n(_Union& __u) noexcept
        .               {
        .                 if constexpr (_Np == 0)
        .           	return &__u._M_first;
        .                 else if constexpr (_Np == 1)
        .           	{
    3,912 ( 0.00%)  	  std::_Construct(&__u._M_rest);
   18,256 ( 0.00%)  => /usr/include/c++/14/bits/stl_construct.h:void std::_Construct<std::__detail::__variant::_Variadic_union<false, std::shared_ptr<Ship::BinaryReader> >>(std::__detail::__variant::_Variadic_union<false, std::shared_ptr<Ship::BinaryReader> >*) (652x)
    1,304 ( 0.00%)  	  return &__u._M_rest._M_first;
        .           	}
        .                 else if constexpr (_Np == 2)
        .           	{
        .           	  std::_Construct(&__u._M_rest);
        .           	  std::_Construct(&__u._M_rest._M_rest);
        .           	  return &__u._M_rest._M_rest._M_first;
        .           	}
        .                 else
        .           	{
        .           	  std::_Construct(&__u._M_rest);
        .           	  std::_Construct(&__u._M_rest._M_rest);
        .           	  std::_Construct(&__u._M_rest._M_rest._M_rest);
        .           	  return __variant::__construct_n<_Np - 3>(__u._M_rest._M_rest._M_rest);
        .           	}
    2,608 ( 0.00%)      }
        .           
        .             template<typename... _Types>
        .               struct _Traits
        .               {
        .                 static constexpr bool _S_default_ctor =
        .           	  is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
        .                 static constexpr bool _S_copy_ctor =
        .           	  (is_copy_constructible_v<_Types> && ...);
-- line 357 ----------------------------------------
-- line 399 ----------------------------------------
        .           
        .                 template<size_t _Np, typename... _Args>
        .           	_Variadic_union(in_place_index_t<_Np>, _Args&&...) = delete;
        .               };
        .           
        .             template<bool __trivially_destructible, typename _First, typename... _Rest>
        .               union _Variadic_union<__trivially_destructible, _First, _Rest...>
        .               {
3,094,336 ( 0.00%)        constexpr _Variadic_union() : _M_rest() { }
1,157,442 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, std::shared_ptr<Ship::IResource> >::_Variadic_union() (192,907x)
        .           
        .                 template<typename... _Args>
        .           	constexpr
1,173,700 ( 0.00%)  	_Variadic_union(in_place_index_t<0>, _Args&&... __args)
1,367,135 ( 0.00%)  	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
   36,740 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Uninitialized<Ship::ResourceManager::ResourceLoadError, true>::_Uninitialized<Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
   11,022 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager::ResourceLoadError&& std::forward<Ship::ResourceManager::ResourceLoadError>(std::remove_reference<Ship::ResourceManager::ResourceLoadError>::type&) (1,837x)
  782,903 ( 0.00%)  	{ }
        .           
        .                 template<size_t _Np, typename... _Args>
        .           	constexpr
1,153,530 ( 0.00%)  	_Variadic_union(in_place_index_t<_Np>, _Args&&... __args)
1,345,785 ( 0.00%)  	: _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)
23,647,365 ( 0.02%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, std::shared_ptr<Ship::IResource> >::_Variadic_union<std::shared_ptr<Ship::IResource> const&>(std::in_place_index_t<0ul>, std::shared_ptr<Ship::IResource> const&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource> const& std::forward<std::shared_ptr<Ship::IResource> const&>(std::remove_reference<std::shared_ptr<Ship::IResource> const&>::type&) (192,255x)
  769,020 ( 0.00%)  	{ }
        .           
        .           #if __cpp_lib_variant >= 202106L
        .                 _Variadic_union(const _Variadic_union&) = default;
        .                 _Variadic_union(_Variadic_union&&) = default;
        .                 _Variadic_union& operator=(const _Variadic_union&) = default;
        .                 _Variadic_union& operator=(_Variadic_union&&) = default;
        .           
        .                 ~_Variadic_union() = default;
        .           
  586,203 ( 0.00%)        constexpr ~_Variadic_union()
        .           	requires (!__trivially_destructible)
  586,203 ( 0.00%)        { }
        .           #endif
        .           
        .                 _Uninitialized<_First> _M_first;
        .                 _Variadic_union<__trivially_destructible, _Rest...> _M_rest;
        .               };
        .           
        .             // _Never_valueless_alt is true for variant alternatives that can
        .             // always be placed in a variant without it becoming valueless.
-- line 439 ----------------------------------------
-- line 471 ----------------------------------------
        .                 typename __select_int::_Select_int_base<sizeof...(_Types),
        .           					      unsigned char,
        .           					      unsigned short>::type::value_type;
        .           
        .             template<typename... _Types>
        .               struct _Variant_storage<false, _Types...>
        .               {
        .                 constexpr
  771,628 ( 0.00%)        _Variant_storage()
  964,535 ( 0.00%)        : _M_index(static_cast<__index_type>(variant_npos))
3,086,512 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variadic_union() (192,907x)
  578,721 ( 0.00%)        { }
        .           
        .                 template<size_t _Np, typename... _Args>
        .           	constexpr
   16,258 ( 0.00%)  	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
   16,786 ( 0.00%)  	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
   78,991 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variadic_union<Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
   11,022 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager::ResourceLoadError&& std::forward<Ship::ResourceManager::ResourceLoadError>(std::remove_reference<Ship::ResourceManager::ResourceLoadError>::type&) (1,837x)
    6,292 ( 0.00%)  	_M_index{_Np}
   11,275 ( 0.00%)  	{ }
        .           
        .                 constexpr void
  786,820 ( 0.00%)        _M_reset()
        .                 {
1,180,230 ( 0.00%)  	if (!_M_valid()) [[__unlikely__]]
1,172,376 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_valid() const (195,396x)
        .           	  return;
        .           
3,147,280 ( 0.00%)  	std::__do_visit<void>([](auto&& __this_mem) mutable
63,813,480 ( 0.05%)  => /usr/include/c++/14/variant:decltype(auto) std::__do_visit<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (195,396x)
1,172,376 ( 0.00%)  => /usr/include/c++/14/variant:decltype(auto) std::__variant_cast<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource>, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (195,396x)
        .           	  {
  983,525 ( 0.00%)  	    std::_Destroy(std::__addressof(__this_mem));
19,610,010 ( 0.02%)  => /usr/include/c++/14/bits/stl_construct.h:void std::_Destroy<std::shared_ptr<Ship::IResource> >(std::shared_ptr<Ship::IResource>*) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource>* std::__addressof<std::shared_ptr<Ship::IResource> >(std::shared_ptr<Ship::IResource>&) (192,255x)
        .           	  }, __variant_cast<_Types...>(*this));
        .           
  590,115 ( 0.00%)  	_M_index = static_cast<__index_type>(variant_npos);
  393,410 ( 0.00%)        }
        .           
        .                 _GLIBCXX20_CONSTEXPR
  781,604 ( 0.00%)        ~_Variant_storage()
1,758,609 ( 0.00%)        { _M_reset(); }
70,473,040 ( 0.06%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset() (194,744x)
1,168,464 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Variadic_union() (194,744x)
        .           
        .                 constexpr bool
  590,115 ( 0.00%)        _M_valid() const noexcept
        .                 {
        .           	if constexpr (__variant::__never_valueless<_Types...>())
  196,705 ( 0.00%)  	  return true;
        .           	return this->_M_index != __index_type(variant_npos);
  393,410 ( 0.00%)        }
        .           
        .                 _Variadic_union<false, _Types...> _M_u;
        .                 using __index_type = __select_index<_Types...>;
        .                 __index_type _M_index;
        .               };
        .           
        .             template<typename... _Types>
        .               struct _Variant_storage<true, _Types...>
-- line 522 ----------------------------------------
-- line 555 ----------------------------------------
        .                 using __index_type = __select_index<_Types...>;
        .                 __index_type _M_index;
        .               };
        .           
        .             // Implementation of v.emplace<N>(args...).
        .             template<size_t _Np, bool _Triv, typename... _Types, typename... _Args>
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
    6,520 ( 0.00%)      __emplace(_Variant_storage<_Triv, _Types...>& __v, _Args&&... __args)
        .               {
    3,912 ( 0.00%)        __v._M_reset();
  179,300 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset() (652x)
    5,216 ( 0.00%)        auto* __addr = __variant::__construct_n<_Np>(__v._M_u);
   24,776 ( 0.00%)  => /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__construct_n<1ul, std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >(std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (652x)
   10,432 ( 0.00%)        std::_Construct(__addr, in_place_index<0>,
   97,800 ( 0.00%)  => /usr/include/c++/14/bits/stl_construct.h:void std::_Construct<std::__detail::__variant::_Uninitialized<std::shared_ptr<Ship::IResource>, false>, std::in_place_index_t<0ul> const&, std::shared_ptr<Ship::IResource>&>(std::__detail::__variant::_Uninitialized<std::shared_ptr<Ship::IResource>, false>*, std::in_place_index_t<0ul> const&, std::shared_ptr<Ship::IResource>&) (652x)
    3,912 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource>& std::forward<std::shared_ptr<Ship::IResource>&>(std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&) (652x)
        .           		      std::forward<_Args>(__args)...);
        .                 // Construction didn't throw, so can set the new index now:
    2,608 ( 0.00%)        __v._M_index = _Np;
    3,912 ( 0.00%)      }
        .           
        .             template<typename... _Types>
        .               using _Variant_storage_alias =
        .           	_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;
        .           
        .             // The following are (Copy|Move) (ctor|assign) layers for forwarding
        .             // triviality and handling non-trivial SMF behaviors.
        .           
        .             template<bool, typename... _Types>
1,954,010 ( 0.00%)      struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
74,173,176 ( 0.06%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Variant_storage() (194,744x)
        .               {
        .                 using _Base = _Variant_storage_alias<_Types...>;
   36,971 ( 0.00%)        using _Base::_Base;
  124,916 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage<0ul, Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
        .           
        .                 _GLIBCXX20_CONSTEXPR
1,157,442 ( 0.00%)        _Copy_ctor_base(const _Copy_ctor_base& __rhs)
        .           	  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
  578,721 ( 0.00%)        {
5,401,396 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage() (192,907x)
1,543,256 ( 0.00%)  	__variant::__raw_idx_visit(
98,893,483 ( 0.08%)  => /usr/include/c++/14/variant:void std::__detail::__variant::__raw_idx_visit<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
1,157,442 ( 0.00%)  => /usr/include/c++/14/variant:decltype(auto) std::__variant_cast<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource>, std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
1,929,070 ( 0.00%)  	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
        .           	  {
  192,907 ( 0.00%)  	    constexpr size_t __j = __rhs_index;
        .           	    if constexpr (__j != variant_npos)
1,929,070 ( 0.00%)  	      std::_Construct(std::__addressof(this->_M_u),
   64,548 ( 0.00%)  => /usr/include/c++/14/bits/stl_construct.h:void std::_Construct<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >, std::in_place_index_t<0ul> const&, Ship::ResourceManager::ResourceLoadError const&>(std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >*, std::in_place_index_t<0ul> const&, Ship::ResourceManager::ResourceLoadError const&) (652x)
    3,912 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >* std::__addressof<std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >(std::__detail::__variant::_Variadic_union<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (652x)
        .           			      in_place_index<__j>, __rhs_mem);
        .           	  }, __variant_cast<_Types...>(__rhs));
  771,628 ( 0.00%)  	this->_M_index = __rhs._M_index;
  771,628 ( 0.00%)        }
        .           
        .                 _Copy_ctor_base(_Copy_ctor_base&&) = default;
        .                 _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
        .                 _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
        .               };
        .           
        .             template<typename... _Types>
        .               struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
-- line 607 ----------------------------------------
-- line 610 ----------------------------------------
        .                 using _Base::_Base;
        .               };
        .           
        .             template<typename... _Types>
        .               using _Copy_ctor_alias =
        .           	_Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;
        .           
        .             template<bool, typename... _Types>
1,954,010 ( 0.00%)      struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
76,120,616 ( 0.06%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Copy_ctor_base() (194,744x)
        .               {
        .                 using _Base = _Copy_ctor_alias<_Types...>;
   36,971 ( 0.00%)        using _Base::_Base;
  148,797 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage<0ul, Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Move_ctor_base(_Move_ctor_base&& __rhs)
        .           	  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
        .                 {
        .           	__variant::__raw_idx_visit(
        .           	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
        .           	  {
-- line 629 ----------------------------------------
-- line 631 ----------------------------------------
        .           	    if constexpr (__j != variant_npos)
        .           	      std::_Construct(std::__addressof(this->_M_u),
        .           			      in_place_index<__j>,
        .           			      std::forward<decltype(__rhs_mem)>(__rhs_mem));
        .           	  }, __variant_cast<_Types...>(std::move(__rhs)));
        .           	this->_M_index = __rhs._M_index;
        .                 }
        .           
2,507,791 ( 0.00%)        _Move_ctor_base(const _Move_ctor_base&) = default;
110,660,810 ( 0.09%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
        .                 _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
        .                 _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
        .               };
        .           
        .             template<typename... _Types>
        .               struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
        .               {
        .                 using _Base = _Copy_ctor_alias<_Types...>;
-- line 647 ----------------------------------------
-- line 648 ----------------------------------------
        .                 using _Base::_Base;
        .               };
        .           
        .             template<typename... _Types>
        .               using _Move_ctor_alias =
        .           	_Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;
        .           
        .             template<bool, typename... _Types>
1,954,010 ( 0.00%)      struct _Copy_assign_base : _Move_ctor_alias<_Types...>
78,068,056 ( 0.06%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Move_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Move_ctor_base() (194,744x)
        .               {
        .                 using _Base = _Move_ctor_alias<_Types...>;
   36,971 ( 0.00%)        using _Base::_Base;
  172,678 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Move_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage<0ul, Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Copy_assign_base&
        .                 operator=(const _Copy_assign_base& __rhs)
        .           	  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
        .                 {
        .           	__variant::__raw_idx_visit(
        .           	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
-- line 667 ----------------------------------------
-- line 683 ----------------------------------------
        .           		    _Variant& __self = __variant_cast<_Types...>(*this);
        .           		    __self = _Variant(in_place_index<__j>, __rhs_mem);
        .           		  }
        .           	      }
        .           	  }, __variant_cast<_Types...>(__rhs));
        .           	return *this;
        .                 }
        .           
2,507,791 ( 0.00%)        _Copy_assign_base(const _Copy_assign_base&) = default;
113,168,601 ( 0.09%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Move_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Move_ctor_base(std::__detail::__variant::_Move_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
        .                 _Copy_assign_base(_Copy_assign_base&&) = default;
        .                 _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
        .               };
        .           
        .             template<typename... _Types>
        .               struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
        .               {
        .                 using _Base = _Move_ctor_alias<_Types...>;
-- line 699 ----------------------------------------
-- line 700 ----------------------------------------
        .                 using _Base::_Base;
        .               };
        .           
        .             template<typename... _Types>
        .               using _Copy_assign_alias =
        .                 _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;
        .           
        .             template<bool, typename... _Types>
1,954,010 ( 0.00%)      struct _Move_assign_base : _Copy_assign_alias<_Types...>
  817,068 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Copy_assign_base<false, std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> >::~_Copy_assign_base() (657x)
        .               {
        .                 using _Base = _Copy_assign_alias<_Types...>;
   36,971 ( 0.00%)        using _Base::_Base;
  196,559 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Copy_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage<0ul, Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 _Move_assign_base&
        .                 operator=(_Move_assign_base&& __rhs)
        .           	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
        .                 {
        .           	__variant::__raw_idx_visit(
        .           	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
-- line 719 ----------------------------------------
-- line 737 ----------------------------------------
        .           		  }
        .           	      }
        .           	    else
        .           	      this->_M_reset();
        .           	  }, __variant_cast<_Types...>(__rhs));
        .           	return *this;
        .                 }
        .           
2,507,791 ( 0.00%)        _Move_assign_base(const _Move_assign_base&) = default;
115,676,392 ( 0.10%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Copy_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_assign_base(std::__detail::__variant::_Copy_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
        .                 _Move_assign_base(_Move_assign_base&&) = default;
        .                 _Move_assign_base& operator=(const _Move_assign_base&) = default;
        .               };
        .           
        .             template<typename... _Types>
        .               struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
        .               {
        .                 using _Base = _Copy_assign_alias<_Types...>;
-- line 753 ----------------------------------------
-- line 754 ----------------------------------------
        .                 using _Base::_Base;
        .               };
        .           
        .             template<typename... _Types>
        .               using _Move_assign_alias =
        .                 _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;
        .           
        .             template<typename... _Types>
1,954,010 ( 0.00%)      struct _Variant_base : _Move_assign_alias<_Types...>
81,962,936 ( 0.07%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Move_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Move_assign_base() (194,744x)
        .               {
        .                 using _Base = _Move_assign_alias<_Types...>;
        .           
        .                 constexpr
    5,236 ( 0.00%)        _Variant_base() noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
    7,854 ( 0.00%)        : _Variant_base(in_place_index<0>) { }
   52,160 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_base<0ul>(std::in_place_index_t<0ul>) (652x)
        .           
        .                 template<size_t _Np, typename... _Args>
        .           	constexpr explicit
   16,258 ( 0.00%)  	_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
   16,786 ( 0.00%)  	: _Base(__i, std::forward<_Args>(__args)...)
   45,640 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Move_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_storage<0ul>(std::in_place_index_t<0ul>) (652x)
   11,275 ( 0.00%)  	{ }
        .           
2,507,791 ( 0.00%)        _Variant_base(const _Variant_base&) = default;
118,184,183 ( 0.10%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Move_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Move_assign_base(std::__detail::__variant::_Move_assign_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
        .                 _Variant_base(_Variant_base&&) = default;
        .                 _Variant_base& operator=(const _Variant_base&) = default;
        .                 _Variant_base& operator=(_Variant_base&&) = default;
        .               };
        .           
        .             template<typename _Tp, typename... _Types>
        .               inline constexpr bool __exactly_once
        .                 = std::__find_uniq_type_in_pack<_Tp, _Types...>() < sizeof...(_Types);
-- line 784 ----------------------------------------
-- line 1027 ----------------------------------------
        .                 _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
        .           		   std::index_sequence<__indices...>>
        .               {
        .                 using _Array_type =
        .           	  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;
        .           
        .                 template<size_t __index, typename _Variant>
        .           	static constexpr decltype(auto)
  771,628 ( 0.00%)  	__element_by_index_or_cookie(_Variant&& __var) noexcept
        .                   {
        .           	  if constexpr (__index != variant_npos)
  964,535 ( 0.00%)  	    return __variant::__get<__index>(std::forward<_Variant>(__var));
7,690,200 ( 0.01%)  => /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__get<1ul, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>::type&) (192,255x)
        .           	  else
        .           	    return __variant_cookie{};
  385,814 ( 0.00%)  	}
        .           
        .                 static constexpr decltype(auto)
2,337,672 ( 0.00%)        __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
        .                 {
        .           	if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)
        .           	  // For raw visitation using indices, pass the indices to the visitor
        .           	  // and discard the return value:
2,893,605 ( 0.00%)  	  std::__invoke(std::forward<_Visitor>(__visitor),
60,752,580 ( 0.05%)  => /usr/include/c++/14/bits/invoke.h:std::__invoke_result<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul> >::type std::__invoke<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul> >(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::shared_ptr<Ship::IResource> const&, std::integral_constant<unsigned long, 1ul>&&) (192,255x)
10,958,535 ( 0.01%)  => /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__gen_vtable_impl<std::__detail::__variant::_Multi_array<std::__detail::__variant::__variant_idx_cookie (*)(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)>, std::integer_sequence<unsigned long, 1ul> >::__element_by_index_or_cookie<1ul, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&>::type&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&& std::forward<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&>(std::remove_reference<std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Copy_ctor_base(std::__detail::__variant::_Copy_ctor_base<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&)::{lambda(auto:1&&, auto:2)#1}&&>::type&) (192,255x)
        .           	      __element_by_index_or_cookie<__indices>(
        .           		std::forward<_Variants>(__vars))...,
        .           	      integral_constant<size_t, __indices>()...);
        .           	else if constexpr (is_same_v<_Result_type, __variant_cookie>)
        .           	  // For raw visitation without indices, and discard the return value:
        .           	  std::__invoke(std::forward<_Visitor>(__visitor),
        .           	      __element_by_index_or_cookie<__indices>(
        .           		std::forward<_Variants>(__vars))...);
        .           	else if constexpr (_Array_type::__result_is_deduced::value)
        .           	  // For the usual std::visit case deduce the return value:
        .           	  return std::__invoke(std::forward<_Visitor>(__visitor),
        .           	      __element_by_index_or_cookie<__indices>(
        .           		std::forward<_Variants>(__vars))...);
        .           	else // for std::visit<R> use INVOKE<R>
2,360,460 ( 0.00%)  	  return std::__invoke_r<_Result_type>(
35,567,175 ( 0.03%)  => /usr/include/c++/14/bits/invoke.h:std::enable_if<is_invocable_r_v<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::shared_ptr<Ship::IResource>&>, void>::type std::__invoke_r<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::shared_ptr<Ship::IResource>&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::shared_ptr<Ship::IResource>&) (192,255x)
7,690,200 ( 0.01%)  => /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__get<1ul, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&& std::forward<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&>(std::remove_reference<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&>::type&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) (192,255x)
        .           	      std::forward<_Visitor>(__visitor),
  196,705 ( 0.00%)  	      __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
1,361,743 ( 0.00%)        }
        .           
        .                 static constexpr auto
        .                 _S_apply()
        .                 {
        .           	if constexpr (_Array_type::__result_is_deduced::value)
        .           	  {
        .           	    constexpr bool __visit_ret_type_mismatch =
        .           	      !is_same_v<typename _Result_type::type,
-- line 1075 ----------------------------------------
-- line 1133 ----------------------------------------
        .           	>;
        .               }
        .           
        .           } // namespace __variant
        .           } // namespace __detail
        .           
        .             template<typename _Tp, typename... _Types>
        .               constexpr bool
  737,160 ( 0.00%)      holds_alternative(const variant<_Types...>& __v) noexcept
        .               {
        .                 static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
        .           		    "T must occur exactly once in alternatives");
1,032,024 ( 0.00%)        return __v.index() == std::__find_uniq_type_in_pack<_Tp, _Types...>();
5,137,300 ( 0.00%)  => /usr/include/c++/14/bits/utility.h:unsigned long std::__find_uniq_type_in_pack<std::shared_ptr<Ship::IResource>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >() (146,780x)
1,174,240 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::index() const (146,780x)
  442,296 ( 0.00%)      }
        .           
        .             template<typename _Tp, typename... _Types>
        .               constexpr _Tp&
  582,380 ( 0.00%)      get(variant<_Types...>& __v)
        .               {
        .                 static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
        .           		    "T must occur exactly once in alternatives");
  145,595 ( 0.00%)        constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
  436,785 ( 0.00%)        return std::get<__n>(__v);
   41,728 ( 0.00%)  => /usr/include/c++/14/variant:std::variant_alternative<1ul, std::variant<std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> > >::type& std::get<1ul, std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> >(std::variant<std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> >&) (652x)
  291,190 ( 0.00%)      }
        .           
        .             template<typename _Tp, typename... _Types>
        .               constexpr _Tp&&
        .               get(variant<_Types...>&& __v)
        .               {
        .                 static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
        .           		    "T must occur exactly once in alternatives");
        .                 constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
-- line 1164 ----------------------------------------
-- line 1417 ----------------------------------------
        .           
        .                 template<typename _Tp>
        .           	static constexpr bool __not_in_place_tag
        .           	  = !__is_in_place_type_v<__remove_cvref_t<_Tp>>
        .           	      && !__is_in_place_index_v<__remove_cvref_t<_Tp>>;
        .           
        .               public:
        .           #if __cpp_concepts
   13,090 ( 0.00%)        variant() requires is_default_constructible_v<__to_type<0>> = default;
   58,680 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_base() (652x)
        .           #else
        .                 template<typename _Tp0 = __to_type<0>,
        .           	       typename = enable_if_t<is_default_constructible_v<_Tp0>>>
        .           	constexpr
        .           	variant() noexcept(is_nothrow_default_constructible_v<__to_type<0>>)
        .           	{ }
        .           #endif
        .           
2,507,791 ( 0.00%)        variant(const variant& __rhs) = default;
120,691,974 ( 0.10%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_base(std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (192,907x)
        .                 variant(variant&&) = default;
        .                 variant& operator=(const variant&) = default;
        .                 variant& operator=(variant&&) = default;
1,954,010 ( 0.00%)        _GLIBCXX20_CONSTEXPR ~variant() = default;
83,910,376 ( 0.07%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~_Variant_base() (194,744x)
        .           
        .                 template<typename _Tp,
        .           	       typename = enable_if_t<sizeof...(_Types) != 0>,
        .           	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
        .           	       typename _Tj = __accepted_type<_Tp&&>,
        .           	       typename = enable_if_t<__exactly_once<_Tj>
        .           				      && is_constructible_v<_Tj, _Tp>>>
        .           	constexpr
    9,185 ( 0.00%)  	variant(_Tp&& __t)
        .           	noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
        .           	: variant(in_place_index<__accepted_index<_Tp>>,
   14,696 ( 0.00%)  		  std::forward<_Tp>(__t))
  304,942 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::variant<0ul, Ship::ResourceManager::ResourceLoadError, Ship::ResourceManager::ResourceLoadError, void>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
   11,022 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager::ResourceLoadError&& std::forward<Ship::ResourceManager::ResourceLoadError>(std::remove_reference<Ship::ResourceManager::ResourceLoadError>::type&) (1,837x)
    5,511 ( 0.00%)  	{ }
        .           
        .                 template<typename _Tp, typename... _Args,
        .           	       typename = enable_if_t<__exactly_once<_Tp>
        .           				      && is_constructible_v<_Tp, _Args...>>>
        .           	constexpr explicit
        .           	variant(in_place_type_t<_Tp>, _Args&&... __args)
        .           	: variant(in_place_index<__index_of<_Tp>>,
        .           		  std::forward<_Args>(__args)...)
-- line 1459 ----------------------------------------
-- line 1469 ----------------------------------------
        .           	: variant(in_place_index<__index_of<_Tp>>, __il,
        .           		  std::forward<_Args>(__args)...)
        .           	{ }
        .           
        .                 template<size_t _Np, typename... _Args,
        .           	       typename _Tp = __to_type<_Np>,
        .           	       typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
        .           	constexpr explicit
   11,022 ( 0.00%)  	variant(in_place_index_t<_Np>, _Args&&... __args)
   12,859 ( 0.00%)  	: _Base(in_place_index<_Np>, std::forward<_Args>(__args)...)
  262,691 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::_Variant_base<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_Variant_base<0ul, Ship::ResourceManager::ResourceLoadError>(std::in_place_index_t<0ul>, Ship::ResourceManager::ResourceLoadError&&) (1,837x)
   11,022 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager::ResourceLoadError&& std::forward<Ship::ResourceManager::ResourceLoadError>(std::remove_reference<Ship::ResourceManager::ResourceLoadError>::type&) (1,837x)
    7,348 ( 0.00%)  	{ }
        .           
        .                 template<size_t _Np, typename _Up, typename... _Args,
        .           	       typename _Tp = __to_type<_Np>,
        .           	       typename = enable_if_t<is_constructible_v<_Tp,
        .           							 initializer_list<_Up>&,
        .           							 _Args...>>>
        .           	constexpr explicit
        .           	variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
-- line 1487 ----------------------------------------
-- line 1490 ----------------------------------------
        .           	{ }
        .           
        .                 template<typename _Tp>
        .           	_GLIBCXX20_CONSTEXPR
        .           	enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
        .           		    && is_constructible_v<__accepted_type<_Tp&&>, _Tp>
        .           		    && is_assignable_v<__accepted_type<_Tp&&>&, _Tp>,
        .           		    variant&>
    7,824 ( 0.00%)  	operator=(_Tp&& __rhs)
        .           	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
        .           		 && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
        .           	{
    1,304 ( 0.00%)  	  constexpr auto __index = __accepted_index<_Tp>;
    9,128 ( 0.00%)  	  if (index() == __index)
    5,216 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::index() const (652x)
        .           	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
        .           	  else
        .           	    {
        .           	      using _Tj = __accepted_type<_Tp&&>;
        .           	      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
        .           			    || !is_nothrow_move_constructible_v<_Tj>)
   10,432 ( 0.00%)  		this->emplace<__index>(std::forward<_Tp>(__rhs));
  379,464 ( 0.00%)  => /usr/include/c++/14/variant:std::enable_if<is_constructible_v<std::_Nth_type<1ul, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::type, std::shared_ptr<Ship::IResource>&>, std::_Nth_type<1ul, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::type&>::type std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::emplace<1ul, std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) (652x)
    3,912 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource>& std::forward<std::shared_ptr<Ship::IResource>&>(std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&) (652x)
        .           	      else
        .           		// _GLIBCXX_RESOLVE_LIB_DEFECTS
        .           		// 3585. converting assignment with immovable alternative
        .           		this->emplace<__index>(_Tj(std::forward<_Tp>(__rhs)));
        .           	    }
    1,304 ( 0.00%)  	  return *this;
    3,912 ( 0.00%)  	}
        .           
        .                 template<typename _Tp, typename... _Args>
        .           	_GLIBCXX20_CONSTEXPR
        .           	enable_if_t<is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>,
        .           		    _Tp&>
        .           	emplace(_Args&&... __args)
        .           	{
        .           	  constexpr size_t __index = __index_of<_Tp>;
-- line 1525 ----------------------------------------
-- line 1536 ----------------------------------------
        .           	  constexpr size_t __index = __index_of<_Tp>;
        .           	  return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
        .           	}
        .           
        .                 template<size_t _Np, typename... _Args>
        .           	_GLIBCXX20_CONSTEXPR
        .           	enable_if_t<is_constructible_v<__to_type<_Np>, _Args...>,
        .           		    __to_type<_Np>&>
    6,520 ( 0.00%)  	emplace(_Args&&... __args)
        .           	{
        .           	  namespace __variant = std::__detail::__variant;
        .           	  using type = typename _Nth_type<_Np, _Types...>::type;
        .           	  // Provide the strong exception-safety guarantee when possible,
        .           	  // to avoid becoming valueless.
        .           	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
        .           	    {
   10,432 ( 0.00%)  	      __variant::__emplace<_Np>(*this, std::forward<_Args>(__args)...);
  342,952 ( 0.00%)  => /usr/include/c++/14/variant:void std::__detail::__variant::__emplace<1ul, false, std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader>, std::shared_ptr<Ship::BinaryReader> >(std::__detail::__variant::_Variant_storage<false, std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> >&, std::shared_ptr<Ship::BinaryReader>&&) (652x)
    3,912 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::BinaryReader>&& std::forward<std::shared_ptr<Ship::BinaryReader> >(std::remove_reference<std::shared_ptr<Ship::BinaryReader> >::type&) (652x)
        .           	    }
        .           	  else if constexpr (is_scalar_v<type>)
        .           	    {
        .           	      // This might invoke a potentially-throwing conversion operator:
        .           	      const type __tmp(std::forward<_Args>(__args)...);
        .           	      // But this won't throw:
        .           	      __variant::__emplace<_Np>(*this, __tmp);
        .           	    }
-- line 1560 ----------------------------------------
-- line 1568 ----------------------------------------
        .           	      *this = std::move(__tmp);
        .           	    }
        .           	  else
        .           	    {
        .           	      // This case only provides the basic exception-safety guarantee,
        .           	      // i.e. the variant can become valueless.
        .           	      __variant::__emplace<_Np>(*this, std::forward<_Args>(__args)...);
        .           	    }
    3,912 ( 0.00%)  	  return std::get<_Np>(*this);
   41,728 ( 0.00%)  => /usr/include/c++/14/variant:std::variant_alternative<1ul, std::variant<std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> > >::type& std::get<1ul, std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> >(std::variant<std::shared_ptr<tinyxml2::XMLDocument>, std::shared_ptr<Ship::BinaryReader> >&) (652x)
    2,608 ( 0.00%)  	}
        .           
        .                 template<size_t _Np, typename _Up, typename... _Args>
        .           	_GLIBCXX20_CONSTEXPR
        .           	enable_if_t<is_constructible_v<__to_type<_Np>,
        .           				       initializer_list<_Up>&, _Args...>,
        .           		    __to_type<_Np>&>
        .           	emplace(initializer_list<_Up> __il, _Args&&... __args)
        .           	{
-- line 1585 ----------------------------------------
-- line 1617 ----------------------------------------
        .           	enable_if_t<!(_Np < sizeof...(_Types))> emplace(_Args&&...) = delete;
        .           
        .                 template<typename _Tp, typename... _Args>
        .           	enable_if_t<!__exactly_once<_Tp>> emplace(_Args&&...) = delete;
        .           
        .                 constexpr bool valueless_by_exception() const noexcept
        .                 { return !this->_M_valid(); }
        .           
2,055,741 ( 0.00%)        constexpr size_t index() const noexcept
        .                 {
        .           	using __index_type = typename _Base::__index_type;
        .           	if constexpr (__detail::__variant::__never_valueless<_Types...>())
2,055,741 ( 0.00%)  	  return this->_M_index;
        .           	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
        .           	  return make_signed_t<__index_type>(this->_M_index);
        .           	else
        .           	  return size_t(__index_type(this->_M_index + 1)) - 1;
1,370,494 ( 0.00%)        }
        .           
        .                 _GLIBCXX20_CONSTEXPR
        .                 void
        .                 swap(variant& __rhs)
        .                 noexcept((__is_nothrow_swappable<_Types>::value && ...)
        .           	       && is_nothrow_move_constructible_v<variant>)
        .                 {
        .           	static_assert((is_move_constructible_v<_Types> && ...));
-- line 1642 ----------------------------------------
-- line 1707 ----------------------------------------
        .                 _VARIANT_RELATION_FUNCTION_TEMPLATE(>=)
        .                 _VARIANT_RELATION_FUNCTION_TEMPLATE(>)
        .           
        .           #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
        .               };
        .           
        .             template<size_t _Np, typename... _Types>
        .               constexpr variant_alternative_t<_Np, variant<_Types...>>&
  587,596 ( 0.00%)      get(variant<_Types...>& __v)
        .               {
        .                 static_assert(_Np < sizeof...(_Types),
        .           		    "The index must be in [0, number of alternatives)");
1,028,293 ( 0.00%)        if (__v.index() != _Np)
1,164,760 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::index() const (145,595x)
        .           	__throw_bad_variant_access(__v.valueless_by_exception());
  440,697 ( 0.00%)        return __detail::__variant::__get<_Np>(__v);
5,823,800 ( 0.00%)  => /usr/include/c++/14/variant:decltype(auto) std::__detail::__variant::__get<1ul, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (145,595x)
  293,798 ( 0.00%)      }
        .           
        .             template<size_t _Np, typename... _Types>
        .               constexpr variant_alternative_t<_Np, variant<_Types...>>&&
        .               get(variant<_Types...>&& __v)
        .               {
        .                 static_assert(_Np < sizeof...(_Types),
        .           		    "The index must be in [0, number of alternatives)");
        .                 if (__v.index() != _Np)
-- line 1730 ----------------------------------------
-- line 1752 ----------------------------------------
        .                 if (__v.index() != _Np)
        .           	__throw_bad_variant_access(__v.valueless_by_exception());
        .                 return __detail::__variant::__get<_Np>(std::move(__v));
        .               }
        .           
        .             /// @cond undocumented
        .             template<typename _Result_type, typename _Visitor, typename... _Variants>
        .               constexpr decltype(auto)
2,337,672 ( 0.00%)      __do_visit(_Visitor&& __visitor, _Variants&&... __variants)
        .               {
        .                 // Get the silly case of visiting no variants out of the way first.
        .                 if constexpr (sizeof...(_Variants) == 0)
        .           	{
        .           	  if constexpr (is_void_v<_Result_type>)
        .           	    return (void) std::forward<_Visitor>(__visitor)();
        .           	  else
        .           	    return std::forward<_Visitor>(__visitor)();
        .           	}
        .                 else
        .           	{
  389,612 ( 0.00%)  	  constexpr size_t __max = 11; // "These go to eleven."
        .           
        .           	  // The type of the first variant in the pack.
        .           	  using _V0 = typename _Nth_type<0, _Variants...>::type;
        .           	  // The number of alternatives in that first variant.
  389,612 ( 0.00%)  	  constexpr auto __n = variant_size_v<remove_reference_t<_V0>>;
        .           
        .           	  if constexpr (sizeof...(_Variants) > 1 || __n > __max)
        .           	    {
        .           	      // Use a jump table for the general case.
        .           	      constexpr auto& __vtable = __detail::__variant::__gen_vtable<
        .           		_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;
        .           
        .           	      auto __func_ptr = __vtable._M_access(__variants.index()...);
        .           	      return (*__func_ptr)(std::forward<_Visitor>(__visitor),
        .           				   std::forward<_Variants>(__variants)...);
        .           	    }
        .           	  else // We have a single variant with a small number of alternatives.
        .           	    {
        .           	      // A name for the first variant in the pack.
        .           	      _V0& __v0
8,181,852 ( 0.01%)  		= [](_V0& __v, ...) -> _V0& { return __v; }(__variants...);
2,735,544 ( 0.00%)  => /usr/include/c++/14/variant:std::__do_visit<void, std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&)::{lambda(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&, ...)#1}::operator()(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&, ...) const (195,396x)
        .           
        .           	      using __detail::__variant::_Multi_array;
        .           	      using __detail::__variant::__gen_vtable_impl;
        .           	      using _Ma = _Multi_array<_Result_type (*)(_Visitor&&, _V0&&)>;
        .           
        .           #ifdef _GLIBCXX_DEBUG
        .           # define _GLIBCXX_VISIT_UNREACHABLE __builtin_trap
        .           #else
-- line 1801 ----------------------------------------
-- line 1809 ----------------------------------------
        .                 {									\
        .           	return __gen_vtable_impl<_Ma, index_sequence<N>>::		\
        .           	  __visit_invoke(std::forward<_Visitor>(__visitor),		\
        .           			 std::forward<_V0>(__v0));		\
        .                 }									\
        .               else _GLIBCXX_VISIT_UNREACHABLE();					\
        .             }
        .           
2,719,036 ( 0.00%)  	      switch (__v0.index())
1,563,168 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::index() const (195,396x)
        .           		{
   45,152 ( 0.00%)  		  _GLIBCXX_VISIT_CASE(0)
   18,846 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&& std::forward<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}>(std::remove_reference<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}>::type&) (3,141x)
   18,846 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) (3,141x)
  543,393 ( 0.00%)  => /usr/include/c++/14/variant:std::__detail::__variant::__gen_vtable_impl<std::__detail::__variant::_Multi_array<void (*)(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&)>, std::integer_sequence<unsigned long, 0ul> >::__visit_invoke(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (3,141x)
4,236,782 ( 0.00%)  		  _GLIBCXX_VISIT_CASE(1)
49,794,045 ( 0.04%)  => /usr/include/c++/14/variant:std::__detail::__variant::__gen_vtable_impl<std::__detail::__variant::_Multi_array<void (*)(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&)>, std::integer_sequence<unsigned long, 1ul> >::__visit_invoke(std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&&, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}&& std::forward<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}>(std::remove_reference<std::__detail::__variant::_Variant_storage<false, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::_M_reset()::{lambda(auto:1&&)#1}>::type&) (192,255x)
1,153,530 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >& std::forward<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>(std::remove_reference<std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type&) (192,255x)
        .           		  _GLIBCXX_VISIT_CASE(2)
        .           		  _GLIBCXX_VISIT_CASE(3)
        .           		  _GLIBCXX_VISIT_CASE(4)
        .           		  _GLIBCXX_VISIT_CASE(5)
        .           		  _GLIBCXX_VISIT_CASE(6)
        .           		  _GLIBCXX_VISIT_CASE(7)
        .           		  _GLIBCXX_VISIT_CASE(8)
        .           		  _GLIBCXX_VISIT_CASE(9)
-- line 1828 ----------------------------------------
-- line 1842 ----------------------------------------
        .           		    _GLIBCXX_VISIT_UNREACHABLE();
        .           		default:
        .           		  _GLIBCXX_VISIT_UNREACHABLE();
        .           		}
        .           #undef _GLIBCXX_VISIT_CASE
        .           #undef _GLIBCXX_VISIT_UNREACHABLE
        .           	    }
        .           	}
1,168,836 ( 0.00%)      }
        .             /// @endcond
        .           
        .             template<typename _Visitor, typename... _Variants>
        .               constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
        .               visit(_Visitor&& __visitor, _Variants&&... __variants)
        .               {
        .                 namespace __variant = std::__detail::__variant;
        .           
-- line 1858 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/allocator.h
--------------------------------------------------------------------------------
Ir                 

-- line 153 ----------------------------------------
        .           	_GLIBCXX20_DEPRECATED_SUGGEST("std::allocator_traits::is_always_equal")
        .           	= true_type;
        .           #endif
        .           
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 3035. std::allocator's constructors should be constexpr
        .                 __attribute__((__always_inline__))
        .                 _GLIBCXX20_CONSTEXPR
  524,421 ( 0.00%)        allocator() _GLIBCXX_NOTHROW { }
        .           
        .                 __attribute__((__always_inline__))
        .                 _GLIBCXX20_CONSTEXPR
        .                 allocator(const allocator& __a) _GLIBCXX_NOTHROW
  787,577 ( 0.00%)        : __allocator_base<_Tp>(__a) { }
        .           
        .           #if __cplusplus >= 201103L
        .                 // Avoid implicit deprecation.
        .                 allocator& operator=(const allocator&) = default;
        .           #endif
        .           
        .                 template<typename _Tp1>
        .           	__attribute__((__always_inline__))
        .           	_GLIBCXX20_CONSTEXPR
  535,930 ( 0.00%)  	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
        .           
        .                 __attribute__((__always_inline__))
        .           #if __cpp_constexpr_dynamic_alloc
        .                 constexpr
        .           #endif
1,782,634 ( 0.00%)        ~allocator() _GLIBCXX_NOTHROW { }
        .           
        .           #if __cplusplus > 201703L
        .                 [[nodiscard,__gnu__::__always_inline__]]
        .                 constexpr _Tp*
        .                 allocate(size_t __n)
        .                 {
1,513,842 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  {
        .           	    if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
        .           	      std::__throw_bad_array_new_length();
        .           	    return static_cast<_Tp*>(::operator new(__n));
        .           	  }
        .           
5,505,232 ( 0.00%)  	return __allocator_base<_Tp>::allocate(__n, 0);
      231 ( 0.00%)  => /usr/include/c++/14/bits/new_allocator.h:std::__new_allocator<F3DGfx**>::allocate(unsigned long, void const*) (1x)
        .                 }
        .           
        .                 [[__gnu__::__always_inline__]]
        .                 constexpr void
        .                 deallocate(_Tp* __p, size_t __n)
        .                 {
1,338,632 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  {
        .           	    ::operator delete(__p);
        .           	    return;
        .           	  }
4,015,896 ( 0.00%)  	__allocator_base<_Tp>::deallocate(__p, __n);
      108 ( 0.00%)  => /usr/include/c++/14/bits/new_allocator.h:std::__new_allocator<F3DGfx**>::deallocate(F3DGfx***, unsigned long) (1x)
        .                 }
        .           #endif // C++20
        .           
        .                 friend __attribute__((__always_inline__)) _GLIBCXX20_CONSTEXPR
        .                 bool
        .                 operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW
        .                 { return true; }
        .           
-- line 216 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_function.h
--------------------------------------------------------------------------------
Ir                  

-- line 366 ----------------------------------------
         .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct equal_to : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
59,714,241 ( 0.05%)        operator()(const _Tp& __x, const _Tp& __y) const
95,053,489 ( 0.08%)        { return __x == __y; }
19,419,670 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:bool std::operator==<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (146,875x)
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct not_equal_to : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
-- line 383 ----------------------------------------
-- line 396 ----------------------------------------
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct less : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
   709,359 ( 0.00%)        operator()(const _Tp& __x, const _Tp& __y) const
 1,064,226 ( 0.00%)        { return __x < __y; }
   717,777 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:decltype ((__char_traits_cmp_cat<std::char_traits<char> >)(0)) std::operator<=><char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (4,239x)
    29,673 ( 0.00%)  => /usr/include/c++/14/compare:std::operator<(std::strong_ordering, std::__cmp_cat::__unspec) (4,239x)
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct greater_equal : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
-- line 413 ----------------------------------------
-- line 440 ----------------------------------------
         .                 }
         .               };
         .           
         .             // Partial specialization of std::less for pointers.
         .             template<typename _Tp>
         .               struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR bool
     3,195 ( 0.00%)        operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
         .                 {
         .           #if __cplusplus >= 201402L
     1,278 ( 0.00%)  	if (std::__is_constant_evaluated())
         .           	  return __x < __y;
         .           #endif
     2,556 ( 0.00%)  	return (__UINTPTR_TYPE__)__x < (__UINTPTR_TYPE__)__y;
     1,278 ( 0.00%)        }
         .               };
         .           
         .             // Partial specialization of std::greater_equal for pointers.
         .             template<typename _Tp>
         .               struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR bool
         .                 operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
-- line 463 ----------------------------------------
-- line 578 ----------------------------------------
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<>
         .               struct less<void>
         .               {
         .                 template <typename _Tp, typename _Up>
         .           	constexpr auto
   244,034 ( 0.00%)  	operator()(_Tp&& __t, _Up&& __u) const
         .           	noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
         .           	-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
         .           	{
   348,620 ( 0.00%)  	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
    26,414 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype(auto) std::less<void>::_S_cmp<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const (&) [5]>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const (&) [5], std::integral_constant<bool, false>) (132x)
       792 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type&) (132x)
       792 ( 0.00%)  => /usr/include/c++/14/bits/move.h:char const (&std::forward<char const (&) [5]>(std::remove_reference<char const (&) [5]>::type&)) [5] (132x)
         .           			__ptr_cmp<_Tp, _Up>{});
   104,586 ( 0.00%)  	}
         .           
         .                 template<typename _Tp, typename _Up>
         .           	constexpr bool
         .           	operator()(_Tp* __t, _Up* __u) const noexcept
         .           	{ return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
         .           
         .                 typedef __is_transparent is_transparent;
         .           
         .               private:
         .                 template <typename _Tp, typename _Up>
         .           	static constexpr decltype(auto)
   209,172 ( 0.00%)  	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
   522,930 ( 0.00%)  	{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }
    21,134 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:decltype ((__char_traits_cmp_cat<std::char_traits<char> >)(0)) std::operator<=><char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*) (132x)
       924 ( 0.00%)  => /usr/include/c++/14/compare:std::operator<(std::strong_ordering, std::__cmp_cat::__unspec) (132x)
       792 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type&) (132x)
       792 ( 0.00%)  => /usr/include/c++/14/bits/move.h:char const (&std::forward<char const (&) [5]>(std::remove_reference<char const (&) [5]>::type&)) [5] (132x)
         .           
         .                 template <typename _Tp, typename _Up>
         .           	static constexpr bool
         .           	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
         .           	{
         .           	  return less<const volatile void*>{}(
         .           	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
         .           	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
-- line 613 ----------------------------------------
-- line 1155 ----------------------------------------
         .               struct _Identity
         .               : public unary_function<_Tp, _Tp>
         .               {
         .                 _Tp&
         .                 operator()(_Tp& __x) const
         .                 { return __x; }
         .           
         .                 const _Tp&
       328 ( 0.00%)        operator()(const _Tp& __x) const
       246 ( 0.00%)        { return __x; }
         .               };
         .           
         .             // Partial specialization, avoids confusing errors in e.g. std::set<const T>.
         .             template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };
         .           
         .             template<typename _Pair>
         .               struct _Select1st
         .               : public unary_function<_Pair, typename _Pair::first_type>
         .               {
         .                 typename _Pair::first_type&
         .                 operator()(_Pair& __x) const
         .                 { return __x.first; }
         .           
         .                 const typename _Pair::first_type&
   601,672 ( 0.00%)        operator()(const _Pair& __x) const
   451,254 ( 0.00%)        { return __x.first; }
         .           
         .           #if __cplusplus >= 201103L
         .                 template<typename _Pair2>
         .                   typename _Pair2::first_type&
         .                   operator()(_Pair2& __x) const
         .                   { return __x.first; }
         .           
         .                 template<typename _Pair2>
-- line 1188 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_construct.h
--------------------------------------------------------------------------------
Ir                 

-- line 72 ----------------------------------------
        .           
        .           namespace std _GLIBCXX_VISIBILITY(default)
        .           {
        .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
        .           
        .           #if __glibcxx_raw_memory_algorithms // >= C++17
        .             template <typename _Tp>
        .               _GLIBCXX20_CONSTEXPR inline void
3,085,530 ( 0.00%)      destroy_at(_Tp* __location)
        .               {
        .                 if constexpr (__cplusplus > 201703L && is_array_v<_Tp>)
        .           	{
        .           	  for (auto& __x : *__location)
        .           	    std::destroy_at(std::__addressof(__x));
        .           	}
        .                 else
1,684,878 ( 0.00%)  	__location->~_Tp();
  142,130 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/binarytools/MemoryStream.cpp:Ship::MemoryStream::~MemoryStream() (1,306x)
2,623,389 ( 0.00%)      }
        .           
        .           #if __cpp_constexpr_dynamic_alloc // >= C++20
        .             template<typename _Tp, typename... _Args>
        .               constexpr auto
3,772,144 ( 0.00%)      construct_at(_Tp* __location, _Args&&... __args)
        .               noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
        .               -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
9,348,587 ( 0.01%)      { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
      231 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Archive>::shared_ptr(std::shared_ptr<Ship::Archive> const&) (3x)
       21 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (3x)
       18 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::Archive> const& std::forward<std::shared_ptr<Ship::Archive> const&>(std::remove_reference<std::shared_ptr<Ship::Archive> const&>::type&) (3x)
        .           #endif // C++20
        .           #endif// C++17
        .           
        .             /**
        .              * Constructs an object in existing memory by invoking an allocated
        .              * object's constructor with an initializer.
        .              */
        .           #if __cplusplus >= 201103L
        .             template<typename _Tp, typename... _Args>
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
3,186,348 ( 0.00%)      _Construct(_Tp* __p, _Args&&... __args)
        .               {
        .           #if __cpp_constexpr_dynamic_alloc // >= C++20
  801,300 ( 0.00%)        if (std::__is_constant_evaluated())
        .           	{
        .           	  // Allow std::_Construct to be used in constant expressions.
        .           	  std::construct_at(__p, std::forward<_Args>(__args)...);
        .           	  return;
        .           	}
        .           #endif
5,070,559 ( 0.00%)        ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
   14,703 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/config/ConsoleVariable.h:Ship::CVar::CVar() (87x)
      609 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (87x)
2,581,993 ( 0.00%)      }
        .           #else
        .             template<typename _T1, typename _T2>
        .               inline void
        .               _Construct(_T1* __p, const _T2& __value)
        .               {
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 402. wrong new expression in [some_]allocator::construct
        .                 ::new(static_cast<void*>(__p)) _T1(__value);
-- line 128 ----------------------------------------
-- line 138 ----------------------------------------
        .               _GLIBCXX20_CONSTEXPR void
        .               _Destroy(_ForwardIterator __first, _ForwardIterator __last);
        .           
        .             /**
        .              * Destroy the object pointed to by a pointer type.
        .              */
        .             template<typename _Tp>
        .               _GLIBCXX14_CONSTEXPR inline void
1,651,896 ( 0.00%)      _Destroy(_Tp* __pointer)
        .               {
        .           #if __cpp_constexpr_dynamic_alloc // >= C++20
1,238,922 ( 0.00%)        std::destroy_at(__pointer);
1,850,484 ( 0.00%)  => /usr/include/c++/14/bits/stl_construct.h:void std::destroy_at<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) (13,274x)
        .           #else
        8 ( 0.00%)        __pointer->~_Tp();
      455 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/sinks/ansicolor_sink.h:spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>::~ansicolor_stdout_sink() (1x)
        .           #endif
1,238,922 ( 0.00%)      }
        .           
        .             template<bool>
        .               struct _Destroy_aux
        .               {
        .                 template<typename _ForwardIterator>
        .           	static _GLIBCXX20_CONSTEXPR void
   22,055 ( 0.00%)  	__destroy(_ForwardIterator __first, _ForwardIterator __last)
        .           	{
   95,833 ( 0.00%)  	  for (; __first != __last; ++__first)
       62 ( 0.00%)  => /usr/include/c++/14/bits/stl_iterator.h:bool __gnu_cxx::operator==<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > >(__gnu_cxx::__normal_iterator<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > > const&, __gnu_cxx::__normal_iterator<Ship::CommandArgument*, std::vector<Ship::CommandArgument, std::allocator<Ship::CommandArgument> > > const&) (2x)
   66,950 ( 0.00%)  	    std::_Destroy(std::__addressof(*__first));
    2,258 ( 0.00%)  => /usr/include/c++/14/bits/stl_construct.h:void std::_Destroy<std::unique_ptr<GameObject, std::default_delete<GameObject> > >(std::unique_ptr<GameObject, std::default_delete<GameObject> >*) (7x)
       42 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::unique_ptr<GameObject, std::default_delete<GameObject> >* std::__addressof<std::unique_ptr<GameObject, std::default_delete<GameObject> > >(std::unique_ptr<GameObject, std::default_delete<GameObject> >&) (7x)
   17,644 ( 0.00%)  	}
        .               };
        .           
        .             template<>
        .               struct _Destroy_aux<true>
        .               {
        .                 template<typename _ForwardIterator>
        .                   static void
   26,005 ( 0.00%)          __destroy(_ForwardIterator, _ForwardIterator) { }
        .               };
        .           
        .             /**
        .              * Destroy a range of objects.  If the value_type of the object has
        .              * a trivial destructor, the compiler should optimize all of this
        .              * away, otherwise the objects' destructors must be invoked.
        .              */
        .             template<typename _ForwardIterator>
        .               _GLIBCXX20_CONSTEXPR inline void
   40,630 ( 0.00%)      _Destroy(_ForwardIterator __first, _ForwardIterator __last)
        .               {
        .                 typedef typename iterator_traits<_ForwardIterator>::value_type
        .                                  _Value_type;
        .           #if __cplusplus >= 201103L
        .                 // A deleted destructor is trivial, this ensures we reject such types:
        .                 static_assert(is_destructible<_Value_type>::value,
        .           		    "value type is destructible");
        .           #endif
        .           #if __cpp_constexpr_dynamic_alloc // >= C++20
   16,252 ( 0.00%)        if (std::__is_constant_evaluated())
        .           	return std::_Destroy_aux<false>::__destroy(__first, __last);
        .           #endif
        .                 std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
   40,630 ( 0.00%)  	__destroy(__first, __last);
   25,781 ( 0.00%)  => /usr/include/c++/14/bits/stl_construct.h:void std::_Destroy_aux<true>::__destroy<char*>(char*, char*) (3,683x)
   16,252 ( 0.00%)      }
        .           
        .             template<bool>
        .               struct _Destroy_n_aux
        .               {
        .                 template<typename _ForwardIterator, typename _Size>
        .           	static _GLIBCXX20_CONSTEXPR _ForwardIterator
        .           	__destroy_n(_ForwardIterator __first, _Size __count)
        .           	{
-- line 205 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_pc.h
--------------------------------------------------------------------------------
Ir                 

-- line 35 ----------------------------------------
        .           
        .           struct GfxDimensions {
        .               float internal_mul;
        .               uint32_t width, height;
        .               float aspect_ratio;
        .           };
        .           
        .           struct TextureCacheKey {
  160,048 ( 0.00%)      const uint8_t* texture_addr;
  396,480 ( 0.00%)      const uint8_t* palette_addrs[2];
  264,232 ( 0.00%)      uint8_t fmt, siz;
  132,116 ( 0.00%)      uint8_t palette_index;
  132,116 ( 0.00%)      uint32_t size_bytes;
        .           
1,292,079 ( 0.00%)      bool operator==(const TextureCacheKey&) const noexcept = default;
        .           
        .               struct Hasher {
  165,984 ( 0.00%)          size_t operator()(const TextureCacheKey& key) const noexcept {
  124,488 ( 0.00%)              uintptr_t addr = (uintptr_t)key.texture_addr;
  124,488 ( 0.00%)              return (size_t)(addr ^ (addr >> 5));
   82,992 ( 0.00%)          }
        .               };
        .           };
        .           
        .           typedef std::unordered_map<TextureCacheKey, struct TextureCacheValue, TextureCacheKey::Hasher> TextureCacheMap;
        .           typedef std::pair<const TextureCacheKey, struct TextureCacheValue> TextureCacheNode;
        .           
    4,400 ( 0.00%)  struct TextureCacheValue {
    3,200 ( 0.00%)  => /usr/include/c++/14/bits/stl_list.h:std::_List_iterator<TextureCacheMapIter>::_List_iterator() (400x)
        .               uint32_t texture_id;
        .               uint8_t cms, cmt;
        .               bool linear_filter;
        .           
        .               std::list<struct TextureCacheMapIter>::iterator lru_location;
        .           };
        .           
        .           struct TextureCacheMapIter {
        .               TextureCacheMap::iterator it;
        .           };
        .           union Gfx;
        .           
       18 ( 0.00%)  struct GfxExecStack {
      515 ( 0.00%)  => /usr/include/c++/14/bits/stl_stack.h:std::stack<F3DGfx*, std::deque<F3DGfx*, std::allocator<F3DGfx*> > >::~stack() (1x)
      258 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<F3DGfx const*, std::allocator<F3DGfx const*> >::~vector() (1x)
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<GfxExecStack::CodeDisp, std::allocator<GfxExecStack::CodeDisp> >::~vector() (1x)
        .               // This is a dlist stack used to handle dlist calls.
        .               std::stack<F3DGfx*> cmd_stack = {};
        .               // This is also a dlist stack but a std::vector is used to make it possible
        .               // to iterate on the elements.
        .               // The purpose of this is to identify an instruction at a poin in time
        .               // which would not be possible with just a F3DGfx* because a dlist can be called multiple times
        .               // what we do instead is store the call path that leads to the instruction (including branches)
        .               std::vector<const F3DGfx*> gfx_path = {};
-- line 83 ----------------------------------------
-- line 105 ----------------------------------------
        .           
        .           struct LoadedVertex {
        .               float x, y, z, w;
        .               float u, v;
        .               struct RGBA color;
        .               uint8_t clip_rej;
        .           };
        .           
8,896,308 ( 0.01%)  struct RawTexMetadata {
4,820,555 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<LUS::Texture>::shared_ptr(std::shared_ptr<LUS::Texture> const&) (71,772x)
        .               uint16_t width, height;
        .               float h_byte_scale = 1, v_pixel_scale = 1;
        .               std::shared_ptr<LUS::Texture> resource;
        .               LUS::TextureType type;
        .           };
        .           
        .           #define MAX_BUFFERED 256
        .           // #define MAX_LIGHTS 2
-- line 121 ----------------------------------------
-- line 144 ----------------------------------------
        .               struct {
        .                   // U0.16
        .                   uint16_t s, t;
        .               } texture_scaling_factor;
        .           
        .               struct LoadedVertex loaded_vertices[MAX_VERTICES + 4];
        .           };
        .           
       76 ( 0.00%)  struct RDP {
      118 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.h:RDP::{unnamed type#2}::RDP() (2x)
       59 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.h:RDP::{unnamed type#1}::RDP() (1x)
        .               const uint8_t* palettes[2];
       22 ( 0.00%)      struct {
       48 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::RawTexMetadata() (1x)
        .                   const uint8_t* addr;
        .                   uint8_t siz;
        .                   uint32_t width;
        .                   uint32_t tex_flags;
        .                   struct RawTexMetadata raw_tex_metadata;
        .               } texture_to_load;
       44 ( 0.00%)      struct {
       96 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.h:RawTexMetadata::RawTexMetadata() (2x)
        .                   const uint8_t* addr;
        .                   uint32_t orig_size_bytes;
        .                   uint32_t size_bytes;
        .                   uint32_t full_image_line_size_bytes;
        .                   uint32_t line_size_bytes;
        .                   uint32_t tex_flags;
        .                   struct RawTexMetadata raw_tex_metadata;
        .                   bool masked;
-- line 169 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_stack.h
--------------------------------------------------------------------------------
Ir                   

-- line 91 ----------------------------------------
          .              *  type.
          .              *
          .              *  Members not found in @a normal containers are @c container_type,
          .              *  which is a typedef for the second Sequence parameter, and @c
          .              *  push, @c pop, and @c top, which are standard %stack/FILO
          .              *  operations.
          .             */
          .             template<typename _Tp, typename _Sequence = deque<_Tp> >
      9,289 ( 0.00%)      class stack
    261,822 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::~deque() (404x)
          .               {
          .           #ifdef _GLIBCXX_CONCEPT_CHECKS
          .                 // concept requirements
          .                 typedef typename _Sequence::value_type _Sequence_value_type;
          .           # if __cplusplus < 201103L
          .                 __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
          .                 __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)
          .           # endif
-- line 107 ----------------------------------------
-- line 154 ----------------------------------------
          .                  */
          .           #if __cplusplus < 201103L
          .                 explicit
          .                 stack(const _Sequence& __c = _Sequence())
          .                 : c(__c) { }
          .           #else
          .                 template<typename _Seq = _Sequence, typename _Requires = typename
          .           	       enable_if<is_default_constructible<_Seq>::value>::type>
      1,620 ( 0.00%)  	stack()
      4,455 ( 0.00%)  	: c() { }
    236,470 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::deque() (404x)
          .           
          .                 explicit
          .                 stack(const _Sequence& __c)
          .                 : c(__c) { }
          .           
          .                 explicit
          .                 stack(_Sequence&& __c)
          .                 : c(std::move(__c)) { }
-- line 171 ----------------------------------------
-- line 207 ----------------------------------------
          .           	: c(__first, __last, __a) { }
          .           #endif
          .           #endif
          .           
          .                 /**
          .                  *  Returns true if the %stack is empty.
          .                  */
          .                 _GLIBCXX_NODISCARD bool
230,999,284 ( 0.19%)        empty() const
288,749,105 ( 0.24%)        { return c.empty(); }
1,443,745,525 ( 1.20%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::empty() const (57,749,821x)
          .           
          .                 /**  Returns the number of elements in the %stack.  */
          .                 _GLIBCXX_NODISCARD
          .                 size_type
    748,268 ( 0.00%)        size() const
    935,335 ( 0.00%)        { return c.size(); }
 13,094,690 ( 0.01%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::size() const (187,067x)
          .           
          .                 /**
          .                  *  Returns a read/write reference to the data at the first
          .                  *  element of the %stack.
          .                  */
          .                 _GLIBCXX_NODISCARD
          .                 reference
463,487,044 ( 0.38%)        top()
          .                 {
          .           	__glibcxx_requires_nonempty();
347,615,283 ( 0.29%)  	return c.back();
9,153,869,119 ( 7.58%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::back() (115,871,761x)
231,743,522 ( 0.19%)        }
          .           
          .                 /**
          .                  *  Returns a read-only (constant) reference to the data at the first
          .                  *  element of the %stack.
          .                  */
          .                 _GLIBCXX_NODISCARD
          .                 const_reference
          .                 top() const
-- line 242 ----------------------------------------
-- line 250 ----------------------------------------
          .                  *  @param  __x  Data to be added.
          .                  *
          .                  *  This is a typical %stack operation.  The function creates an
          .                  *  element at the top of the %stack and assigns the given data
          .                  *  to it.  The time complexity of the operation depends on the
          .                  *  underlying sequence.
          .                  */
          .                 void
    935,335 ( 0.00%)        push(const value_type& __x)
  1,496,536 ( 0.00%)        { c.push_back(__x); }
 14,217,092 ( 0.01%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::push_back(F3DGfx* const&) (187,067x)
          .           
          .           #if __cplusplus >= 201103L
          .                 void
          .                 push(value_type&& __x)
          .                 { c.push_back(std::move(__x)); }
          .           
          .           #if __cplusplus > 201402L
          .                 template<typename... _Args>
-- line 267 ----------------------------------------
-- line 283 ----------------------------------------
          .                  *  by one.  The time complexity of the operation depends on the
          .                  *  underlying sequence.
          .                  *
          .                  *  Note that no data is returned, and if the first element's
          .                  *  data is needed, it should be retrieved before pop() is
          .                  *  called.
          .                  */
          .                 void
    748,268 ( 0.00%)        pop()
          .                 {
          .           	__glibcxx_requires_nonempty();
    561,201 ( 0.00%)  	c.pop_back();
  8,043,881 ( 0.01%)  => /usr/include/c++/14/bits/stl_deque.h:std::deque<F3DGfx*, std::allocator<F3DGfx*> >::pop_back() (187,067x)
    561,201 ( 0.00%)        }
          .           
          .           #if __cplusplus >= 201103L
          .                 void
          .                 swap(stack& __s)
          .           #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
          .                 noexcept(__is_nothrow_swappable<_Sequence>::value)
          .           #else
          .                 noexcept(__is_nothrow_swappable<_Tp>::value)
-- line 303 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/racing/collision.c
--------------------------------------------------------------------------------
Ir                 

-- line 19 ----------------------------------------
        .           void nullify_displaylist(uintptr_t addr) {
        .               Gfx* macro;
        .           
        .               macro = (Gfx*) addr;
        .               macro->words.w0 = (G_ENDDL << 24);
        .               macro->words.w1 = 0;
        .           }
        .           
      160 ( 0.00%)  void func_802AAAAC(Collision* collision) {
       80 ( 0.00%)      collision->meshIndexYX = 5000;
       80 ( 0.00%)      collision->meshIndexZY = 5000;
       80 ( 0.00%)      collision->meshIndexZX = 5000;
       80 ( 0.00%)      collision->unk30 = 0;
       80 ( 0.00%)      collision->unk32 = 0;
       80 ( 0.00%)      collision->unk34 = 0;
      120 ( 0.00%)      collision->surfaceDistance[0] = 0;
      120 ( 0.00%)      collision->surfaceDistance[1] = 0;
      120 ( 0.00%)      collision->surfaceDistance[2] = 0;
      320 ( 0.00%)      vec3f_set(collision->unk48, 0.0f, 0.0f, 1.0f);
      800 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (40x)
      320 ( 0.00%)      vec3f_set(collision->unk54, 1.0f, 0.0f, 0.0f);
      800 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (40x)
      320 ( 0.00%)      vec3f_set(collision->orientationVector, 0.0f, 1.0f, 0.0f);
      800 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (40x)
      120 ( 0.00%)  }
        .           
    5,800 ( 0.00%)  f32 func_802AAB4C(Player* player) {
        .               f32 playerX;
        .               f32 playerZ;
        .               s32 temp_v1;
        .           
    3,480 ( 0.00%)      playerX = player->pos[0];
    3,480 ( 0.00%)      playerZ = player->pos[2];
    5,800 ( 0.00%)      if (GetCourse() == GetBowsersCastle()) {
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,160x)
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBowsersCastle (1,160x)
        .                   if (playerX > 1859.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerX < 1549.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ > -1102.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ < -1402.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   return 20.0f;
    5,800 ( 0.00%)      } else if (GetCourse() == GetKoopaTroopaBeach()) {
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,160x)
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetKoopaTroopaBeach (1,160x)
        .                   if (playerX > 239.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerX < 67.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ > 2405.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ < 2233.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   return 0.8f;
    5,800 ( 0.00%)      } else if (GetCourse() == GetSherbetLand()) {
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,160x)
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetSherbetLand (1,160x)
        .                   if ((get_surface_type(player->collision.meshIndexZX) & 0xFF) == SNOW) {
        .                       return (f32) (gCourseMinY - 0xA);
        .                   }
        .                   return D_8015F8E4;
    5,800 ( 0.00%)      } else if (GetCourse() == GetDkJungle()) {
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,160x)
    6,960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetDkJungle (1,160x)
        .                   temp_v1 = get_track_section_id(player->collision.meshIndexZX) & 0xFF;
        .                   if (temp_v1 == 0xFF) {
        .                       if ((get_surface_type(player->collision.meshIndexZX) & 0xFF) == CAVE) {
        .                           return -475.0f;
        .                       }
        .                       if (playerX > -478.0f) {
        .                           return -33.9f;
        .                       }
-- line 90 ----------------------------------------
-- line 102 ----------------------------------------
        .                       }
        .                       return -33.9f;
        .                   }
        .                   if (temp_v1 >= 0x14) {
        .                       return -475.0f;
        .                   }
        .                   return -33.9f;
        .               } else {
    2,320 ( 0.00%)          return D_8015F8E4;
        .               }
    3,480 ( 0.00%)  }
        .           
   47,511 ( 0.00%)  s32 check_collision_zx(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ, u16 index) {
   47,511 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED f32 pad;
        .               f32 x3;
        .               UNUSED f32 pad2;
        .               f32 z3;
        .               UNUSED f32 pad3[4];
        .               f32 x2;
        .               f32 z2;
        .               f32 x1;
        .               f32 z1;
        .               f32 distanceToSurface;
        .               f32 crossProductZX_1;
        .               f32 crossProductZX_2;
        .               f32 crossProductZX_3;
    5,279 ( 0.00%)      s32 b = true;
        .           
   26,395 ( 0.00%)      if (triangle->normalY < -0.9f) {
        .                   return 0;
        .               }
   31,674 ( 0.00%)      if (triangle->minX > posX) {
      306 ( 0.00%)          return 0;
        .               }
   30,756 ( 0.00%)      if (triangle->minZ > posZ) {
    1,812 ( 0.00%)          return 0;
        .               }
   29,540 ( 0.00%)      if (triangle->maxX < posX) {
    1,914 ( 0.00%)          return 0;
        .               }
   22,841 ( 0.00%)      if (triangle->maxZ < posZ) {
        6 ( 0.00%)          return 0;
        .               }
   32,600 ( 0.00%)      if ((triangle->minY - boundingBoxSize * 3.0f) > posY) {
        .                   return 0;
        .               }
        .           
   19,560 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
   19,560 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
        .           
   19,560 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
   19,560 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
        .           
   19,560 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
   19,560 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
        .           
   39,120 ( 0.00%)      crossProductZX_1 = (z1 - posZ) * (x2 - posX) - (x1 - posX) * (z2 - posZ);
        .           
   19,560 ( 0.00%)      if (!crossProductZX_1) {
        .           
        .                   crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
        .           
        .                   crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .           
        .                   if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
        .                       b = false;
        .                   }
        .               } else {
        .           
   39,120 ( 0.00%)          crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
        .           
   19,560 ( 0.00%)          if (!crossProductZX_2) {
        .                       crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .           
        .                       if ((crossProductZX_1 * crossProductZX_3) < 0.0f) {
        .                           b = false;
        .                       }
        .                   } else {
   16,300 ( 0.00%)              if ((crossProductZX_1 * crossProductZX_2) < 0.0f) {
    1,914 ( 0.00%)                  b = false;
        .                       } else {
   27,636 ( 0.00%)                  crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
   13,818 ( 0.00%)                  if (crossProductZX_3 != 0) {
   11,515 ( 0.00%)                      if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
      880 ( 0.00%)                          b = false;
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
    6,520 ( 0.00%)      if (!b) {
    3,674 ( 0.00%)          return 0;
        .               }
    2,846 ( 0.00%)      distanceToSurface =
   19,922 ( 0.00%)          ((triangle->normalX * posX) + (triangle->normalY * posY) + (triangle->normalZ * posZ) + triangle->distance) -
        .                   boundingBoxSize;
    5,692 ( 0.00%)      if (distanceToSurface > 0.0f) {
    5,664 ( 0.00%)          if (collision->surfaceDistance[2] > distanceToSurface) {
    1,416 ( 0.00%)              collision->unk34 = 1;
    2,124 ( 0.00%)              collision->meshIndexZX = index;
    2,124 ( 0.00%)              collision->surfaceDistance[2] = distanceToSurface;
    2,832 ( 0.00%)              collision->orientationVector[0] = triangle->normalX;
    2,832 ( 0.00%)              collision->orientationVector[1] = triangle->normalY;
    2,832 ( 0.00%)              collision->orientationVector[2] = triangle->normalZ;
        .                   }
    2,832 ( 0.00%)          return 0;
        .               }
        .           
       21 ( 0.00%)      if (distanceToSurface > -16.0f) {
       14 ( 0.00%)          collision->unk34 = 1;
       21 ( 0.00%)          collision->meshIndexZX = index;
       21 ( 0.00%)          collision->surfaceDistance[2] = distanceToSurface;
       28 ( 0.00%)          collision->orientationVector[0] = triangle->normalX;
       28 ( 0.00%)          collision->orientationVector[1] = triangle->normalY;
       28 ( 0.00%)          collision->orientationVector[2] = triangle->normalZ;
       14 ( 0.00%)          return 1;
        .               }
        .               return 0;
   10,558 ( 0.00%)  }
        .           
    8,400 ( 0.00%)  s32 check_collision_yx(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ, u16 index) {
    7,560 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED f32 pad[6];
        .               f32 x3;
        .               f32 y3;
        .               UNUSED f32 pad2[1];
        .           
        .               UNUSED f32 pad3[5];
        .               f32 x2;
        .               f32 y2;
        .               f32 x1;
        .               f32 y1;
        .               f32 distanceToSurface;
        .               f32 crossProductYX_1;
        .               f32 crossProductYX_2;
        .               f32 crossProductYX_3;
      840 ( 0.00%)      s32 b = true;
        .           
    5,040 ( 0.00%)      if (triangle->minX > posX) {
    1,238 ( 0.00%)          return 0;
        .               }
    1,547 ( 0.00%)      if (triangle->maxX < posX) {
        .                   return 0;
        .               }
    1,547 ( 0.00%)      if (triangle->maxY < posY) {
      440 ( 0.00%)          return 0;
        .               }
        6 ( 0.00%)      if (triangle->minY > posY) {
        .                   return 0;
        .               }
        .           
       10 ( 0.00%)      if ((triangle->minZ - boundingBoxSize * 3.0f) > posZ) {
        .                   return 0;
        .               }
       11 ( 0.00%)      if ((triangle->maxZ + boundingBoxSize * 3.0f) < posZ) {
        2 ( 0.00%)          return 0;
        .               }
        .           
        .               x1 = triangle->vtx1->v.ob[0];
        .               y1 = triangle->vtx1->v.ob[1];
        .           
        .               x2 = triangle->vtx2->v.ob[0];
        .               y2 = triangle->vtx2->v.ob[1];
        .           
-- line 266 ----------------------------------------
-- line 321 ----------------------------------------
        .                   collision->meshIndexYX = index;
        .                   collision->surfaceDistance[0] = distanceToSurface;
        .                   collision->unk48[0] = triangle->normalX;
        .                   collision->unk48[1] = triangle->normalY;
        .                   collision->unk48[2] = triangle->normalZ;
        .                   return 1;
        .               }
        .               return 0;
    1,680 ( 0.00%)  }
        .           
    8,400 ( 0.00%)  s32 check_collision_zy(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ, u16 index) {
    7,560 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
      840 ( 0.00%)      s32 b = true;
        .               UNUSED f32 pad[7];
        .               f32 y3;
        .               f32 z3;
        .               UNUSED f32 pad2[5];
        .               f32 y2;
        .               f32 z2;
        .               f32 y1;
        .               f32 z1;
        .               f32 distanceToSurface;
        .               f32 crossProductYZ_1;
        .               f32 crossProductYZ_2;
        .               f32 crossProductYZ_3;
    5,040 ( 0.00%)      if (triangle->minZ > posZ) {
        .                   return 0;
        .               }
    5,880 ( 0.00%)      if (triangle->maxZ < posZ) {
    1,680 ( 0.00%)          return 0;
        .               }
        .               if (triangle->maxY < posY) {
        .                   return 0;
        .               }
        .               if (triangle->minY > posY) {
        .                   return 0;
        .               }
        .               if ((triangle->minX - (boundingBoxSize * 3.0f)) > posX) {
-- line 358 ----------------------------------------
-- line 430 ----------------------------------------
        .                   collision->meshIndexZY = index;
        .                   collision->surfaceDistance[1] = distanceToSurface;
        .                   collision->unk54[0] = triangle->normalX;
        .                   collision->unk54[1] = triangle->normalY;
        .                   collision->unk54[2] = triangle->normalZ;
        .                   return 1;
        .               }
        .               return 0;
    1,680 ( 0.00%)  }
        .           
      528 ( 0.00%)  s32 check_horizontally_colliding_with_triangle(f32 posX, f32 posZ, u16 index) {
      792 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED f32 pad;
        .               f32 x3;
        .               UNUSED f32 pad2;
        .               f32 z3;
        .               f32 x2;
        .               UNUSED f32 pad3;
        .               f32 z2;
        .               f32 x1;
        .               f32 z1;
        .               UNUSED f32 pad4[4];
        .               f32 crossProductZX_1;
        .               f32 crossProductZX_3;
        .               f32 crossProductZX_2;
       88 ( 0.00%)      s32 b = true;
        .           
      528 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
      528 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
        .           
      528 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
      528 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
        .           
      528 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
      528 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
        .           
    1,056 ( 0.00%)      crossProductZX_1 = (z1 - posZ) * (x2 - posX) - (x1 - posX) * (z2 - posZ);
        .           
      528 ( 0.00%)      if (!crossProductZX_1) {
        .           
        .                   crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
        .           
        .                   crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .           
        .                   if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
        .                       b = false;
        .                   }
        .               } else {
    1,056 ( 0.00%)          crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
      528 ( 0.00%)          if (!crossProductZX_2) {
        .                       crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .                       if (crossProductZX_1 * crossProductZX_3 < 0.0f) {
        .                           b = false;
        .                       }
        .                   } else {
      440 ( 0.00%)              if ((crossProductZX_1 * crossProductZX_2) < 0.0f) {
       92 ( 0.00%)                  b = false;
        .                       } else {
      504 ( 0.00%)                  crossProductZX_3 = ((z3 - posZ) * (x1 - posX)) - ((x3 - posX) * (z1 - posZ));
      252 ( 0.00%)                  if (crossProductZX_3 != 0) {
      210 ( 0.00%)                      if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
        8 ( 0.00%)                          b = false;
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
       88 ( 0.00%)      return b;
      176 ( 0.00%)  }
        .           
    9,704 ( 0.00%)  s8 get_surface_type(u16 index) {
   21,834 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
    4,852 ( 0.00%)      return triangle->surfaceType;
    4,852 ( 0.00%)  }
        .           
   22,416 ( 0.00%)  s16 get_track_section_id(u16 index) {
   50,436 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   16,812 ( 0.00%)      return triangle->flags & 0xFF;
   11,208 ( 0.00%)  }
        .           
    8,504 ( 0.00%)  s16 func_802ABD7C(u16 index) {
   19,134 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
    6,378 ( 0.00%)      return triangle->flags & 0x1000;
    4,252 ( 0.00%)  }
        .           
    9,280 ( 0.00%)  s16 func_802ABDB8(u16 index) {
   20,880 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
    6,960 ( 0.00%)      return triangle->flags & 0x400;
    4,640 ( 0.00%)  }
        .           
    5,388 ( 0.00%)  s16 func_802ABDF4(u16 index) {
   12,123 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
    4,041 ( 0.00%)      return triangle->flags & 0x800;
    2,694 ( 0.00%)  }
        .           
   85,484 ( 0.00%)  f32 calculate_surface_height(f32 x, f32 y, f32 z, u16 index) {
  109,908 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   97,696 ( 0.00%)      if (triangle->normalY == 0.0f) {
        .                   return y;
        .               }
  183,180 ( 0.00%)      return ((triangle->normalX * x) + (triangle->normalZ * z) + triangle->distance) / -triangle->normalY;
   24,424 ( 0.00%)  }
        .           
        .           f32 func_802ABEAC(Collision* collision, Vec3f pos) {
        .               if (collision->unk34 == 1) {
        .                   return calculate_surface_height(pos[0], pos[1], pos[2], collision->meshIndexZX);
        .               }
        .               if (collision->unk30 == 1) {
        .                   return calculate_surface_height(pos[0], pos[1], pos[2], collision->meshIndexYX);
        .               }
-- line 539 ----------------------------------------
-- line 750 ----------------------------------------
        .               tyre->surfaceType = 0;
        .               //! @bug
        .               // Another function that has a return value but doesn't have an explicit return statement in one of its codepaths.
        .               // The return value at this point will be whatever was last returned by func_802AAE4C/func_802AB6C4/func_802AB288
        .               // depending on which (if any) if statements were entered on the loop's last cycle
        .           }
        .           
        .           s32 is_colliding_with_drivable_surface(Collision* collision, f32 boundingBoxSize, f32 newX, f32 newY, f32 newZ,
   43,704 ( 0.00%)                                         u16 index, f32 oldX, f32 oldY, f32 oldZ) {
   32,778 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED s32 pad;
        .               f32 x4;
        .               UNUSED f32 y4;
        .               f32 z4;
        .               f32 x3;
        .               UNUSED f32 y3;
        .               f32 z3;
        .               f32 x2;
-- line 767 ----------------------------------------
-- line 768 ----------------------------------------
        .               UNUSED f32 y2;
        .               f32 z2;
        .               f32 surfaceDistance;
        .               f32 temp;
        .               UNUSED s32 pad2[2];
        .               f32 area;
        .               f32 area2;
        .               f32 area3;
    3,642 ( 0.00%)      s32 b = 1;
        .           
   21,852 ( 0.00%)      if (triangle->minX > newX) {
        .                   return 0;
        .               }
   21,852 ( 0.00%)      if (triangle->minZ > newZ) {
       24 ( 0.00%)          return 0;
        .               }
   25,410 ( 0.00%)      if (triangle->maxX < newX) {
        .                   return 0;
        .               }
   25,410 ( 0.00%)      if (triangle->maxZ < newZ) {
        4 ( 0.00%)          return 0;
        .               }
   36,280 ( 0.00%)      if ((triangle->minY - boundingBoxSize * 3.0f) > newY) {
        .                   return 0;
        .               }
        .           
   21,768 ( 0.00%)      x2 = (f32) triangle->vtx1->v.ob[0];
   21,768 ( 0.00%)      z2 = (f32) triangle->vtx1->v.ob[2];
        .           
   21,768 ( 0.00%)      x3 = (f32) triangle->vtx2->v.ob[0];
   21,768 ( 0.00%)      z3 = (f32) triangle->vtx2->v.ob[2];
        .           
   21,768 ( 0.00%)      x4 = (f32) triangle->vtx3->v.ob[0];
   21,768 ( 0.00%)      z4 = (f32) triangle->vtx3->v.ob[2];
        .           
   43,536 ( 0.00%)      area = (z2 - newZ) * (x3 - newX) - (x2 - newX) * (z3 - newZ);
        .           
   21,768 ( 0.00%)      if (area == 0) {
        .                   area2 = (z3 - newZ) * (x4 - newX) - (x3 - newX) * (z4 - newZ);
        .                   area3 = (z4 - newZ) * (x2 - newX) - (x4 - newX) * (z2 - newZ);
        .                   if (area2 * area3 < 0.0f) {
        .                       b = 0;
        .                   }
        .               } else {
        .           
   43,536 ( 0.00%)          area2 = (z3 - newZ) * (x4 - newX) - (x3 - newX) * (z4 - newZ);
        .           
   21,768 ( 0.00%)          if (area2 == 0) {
        .           
        .                       area3 = (z4 - newZ) * (x2 - newX) - (x4 - newX) * (z2 - newZ);
        .           
        .                       if (area * area3 < 0.0f) {
        .                           b = 0;
        .                       }
        .                   } else {
   18,140 ( 0.00%)              if ((area * area2) < 0.0f) {
        .                           b = 0;
        .                       } else {
   43,536 ( 0.00%)                  area3 = (z4 - newZ) * (x2 - newX) - (x4 - newX) * (z2 - newZ);
   21,768 ( 0.00%)                  if (area3 != 0) {
   18,140 ( 0.00%)                      if (area2 * area3 < 0.0f) {
        2 ( 0.00%)                          b = 0;
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
    7,256 ( 0.00%)      if (b == 0) {
        4 ( 0.00%)          return 0;
        .               }
        .           
    7,252 ( 0.00%)      surfaceDistance =
   47,138 ( 0.00%)          (triangle->normalX * newX) + (triangle->normalY * newY) + (triangle->normalZ * newZ) + triangle->distance;
        .           
   10,878 ( 0.00%)      if (surfaceDistance > boundingBoxSize) {
        .                   if (collision->surfaceDistance[2] > surfaceDistance) {
        .                       collision->unk34 = 1;
        .                       collision->meshIndexZX = index;
        .                       collision->surfaceDistance[2] = surfaceDistance - boundingBoxSize;
        .                       collision->orientationVector[0] = triangle->normalX;
        .                       collision->orientationVector[1] = triangle->normalY;
        .                       collision->orientationVector[2] = triangle->normalZ;
        .                   }
        .                   return 0;
        .               }
        .           
   54,390 ( 0.00%)      temp = (triangle->normalX * oldX) + (triangle->normalY * oldY) + (triangle->normalZ * oldZ) + triangle->distance;
        .           
   10,878 ( 0.00%)      if (temp < 0.0f) {
        .                   return 0;
        .               }
        .           
    7,252 ( 0.00%)      collision->unk34 = 1;
   10,878 ( 0.00%)      collision->meshIndexZX = index;
   14,504 ( 0.00%)      collision->surfaceDistance[2] = surfaceDistance - boundingBoxSize;
   14,504 ( 0.00%)      collision->orientationVector[0] = triangle->normalX;
   14,504 ( 0.00%)      collision->orientationVector[1] = triangle->normalY;
   14,504 ( 0.00%)      collision->orientationVector[2] = triangle->normalZ;
    3,626 ( 0.00%)      return 1;
    7,284 ( 0.00%)  }
        .           
        .           /**
        .            * Wall collision
        .            */
        .           s32 is_colliding_with_wall2(Collision* arg, f32 boundingBoxSize, f32 x1, f32 y1, f32 z1, u16 surfaceIndex, f32 posX,
        .                                       f32 posY, f32 posZ) {
        .               if (CVarGetInteger("gNoWallColision", 0)) {
        .                   return NO_COLLISION;
-- line 875 ----------------------------------------
-- line 1233 ----------------------------------------
        .               arg->surfaceDistance[1] = distanceToSurface - boundingBoxSize;
        .               arg->unk54[0] = triangle->normalX;
        .               arg->unk54[1] = triangle->normalY;
        .               arg->unk54[2] = triangle->normalZ;
        .               return COLLISION;
        .           }
        .           
        .           u16 actor_terrain_collision(Collision* collision, f32 boundingBoxSize, f32 newX, f32 newY, f32 newZ, f32 oldX, f32 oldY,
   26,686 ( 0.00%)                              f32 oldZ) {
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               u16 numTriangles;
        .               u16 collisionIndex;
        .               s16 gridIndex;
        .           
        .               u16 sectionIndex;
        .           
    2,426 ( 0.00%)      u16 flags = 0;
        .               s32 sectionX;
        .               s32 sectionZ;
        .               u16 i;
        .           
    4,852 ( 0.00%)      collision->unk30 = 0;
    4,852 ( 0.00%)      collision->unk32 = 0;
    4,852 ( 0.00%)      collision->unk34 = 0;
    7,278 ( 0.00%)      collision->surfaceDistance[0] = 1000.0f;
    7,278 ( 0.00%)      collision->surfaceDistance[1] = 1000.0f;
    7,278 ( 0.00%)      collision->surfaceDistance[2] = 1000.0f;
        .           
        .               // Check if an intersection test has already been performed.
   14,556 ( 0.00%)      if ((s32) collision->meshIndexZX < (s32) gCollisionMeshCount) {
   55,614 ( 0.00%)          if (is_colliding_with_drivable_surface(collision, boundingBoxSize, newX, newY, newZ, collision->meshIndexZX,
  530,394 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (2,418x)
        .                                                          oldX, oldY, oldZ) == COLLISION) {
    2,408 ( 0.00%)              flags |= FACING_Y_AXIS;
        .                   }
        .               }
        .           
   14,556 ( 0.00%)      if ((s32) collision->meshIndexYX < (s32) gCollisionMeshCount) {
        .                   if (is_colliding_with_wall2(collision, boundingBoxSize, newX, newY, newZ, collision->meshIndexYX, oldX, oldY,
        .                                               oldZ) == COLLISION) {
        .                       flags |= FACING_Z_AXIS;
        .                   }
        .               }
        .           
   14,556 ( 0.00%)      if ((s32) collision->meshIndexZY < (s32) gCollisionMeshCount) {
        .                   if (is_colliding_with_wall1(collision, boundingBoxSize, newX, newY, newZ, collision->meshIndexZY, oldX, oldY,
        .                                               oldZ) == COLLISION) {
        .                       flags |= FACING_X_AXIS;
        .                   }
        .               }
        .           
    4,852 ( 0.00%)      if (flags == (FACING_Y_AXIS | FACING_Z_AXIS | FACING_X_AXIS)) {
        .                   return flags;
        .               }
        .           
   19,408 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
   19,408 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
   14,556 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
   14,556 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
   24,260 ( 0.00%)      sectionIndexX = (newX - gCourseMinX) / sectionX;
   24,260 ( 0.00%)      sectionIndexZ = (newZ - gCourseMinZ) / sectionZ;
    4,852 ( 0.00%)      if (sectionIndexX < 0) {
        .                   return 0;
        .               }
    4,852 ( 0.00%)      if (sectionIndexZ < 0) {
        .                   return 0;
        .               }
    4,852 ( 0.00%)      if (sectionIndexX >= GRID_SIZE) {
        .                   return 0;
        .               }
    4,852 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 0;
        .               }
        .           
   14,556 ( 0.00%)      gridIndex = (sectionIndexX + sectionIndexZ * GRID_SIZE);
   12,130 ( 0.00%)      numTriangles = gCollisionGrid[gridIndex].numTriangles;
        .           
    4,852 ( 0.00%)      if (numTriangles == 0) {
    1,520 ( 0.00%)          return flags;
        .               }
        .           
    8,330 ( 0.00%)      sectionIndex = gCollisionGrid[gridIndex].triangle;
        .           
   57,938 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
   16,536 ( 0.00%)          if (flags == (FACING_Y_AXIS | FACING_Z_AXIS | FACING_X_AXIS)) {
        .                       return flags;
        .                   }
        .           
   57,876 ( 0.00%)          collisionIndex = gCollisionIndices[sectionIndex];
        .           
  107,484 ( 0.00%)          if ((gCollisionMesh[collisionIndex].flags & FACING_Y_AXIS)) {
   33,072 ( 0.00%)              if ((flags & FACING_Y_AXIS) == 0) {
       88 ( 0.00%)                  if (collisionIndex != collision->meshIndexZX) {
      420 ( 0.00%)                      if (is_colliding_with_drivable_surface(collision, boundingBoxSize, newX, newY, newZ, collisionIndex,
    4,064 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (20x)
        .                                                                      oldX, oldY, oldZ) == COLLISION) {
       36 ( 0.00%)                          flags |= FACING_Y_AXIS;
        .                               }
        .                           }
        .                       }
        .                   } else if ((gCollisionMesh[collisionIndex].flags & FACING_X_AXIS) != 0) {
        .                       if ((flags & FACING_X_AXIS) == 0) {
        .                           if (collisionIndex != collision->meshIndexZY) {
        .                               if (is_colliding_with_wall1(collision, boundingBoxSize, newX, newY, newZ, collisionIndex, oldX,
        .                                                           oldY, oldZ) == COLLISION) {
-- line 1340 ----------------------------------------
-- line 1345 ----------------------------------------
        .                   } else if ((flags & FACING_Z_AXIS) == 0) {
        .                       if (collisionIndex != collision->meshIndexYX) {
        .                           if (is_colliding_with_wall2(collision, boundingBoxSize, newX, newY, newZ, collisionIndex, oldX, oldY,
        .                                                       oldZ) == COLLISION) {
        .                               flags |= FACING_Z_AXIS;
        .                           }
        .                       }
        .                   }
   24,804 ( 0.00%)          sectionIndex++;
        .               }
    1,666 ( 0.00%)      return flags;
    4,852 ( 0.00%)  }
        .           
   22,656 ( 0.00%)  u16 check_bounding_collision(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ) {
        .               u16 numTriangles;
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               u16 meshIndex;
        .               s32 sectionX;
        .               s32 sectionZ;
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               s16 gridIndex;
        .               u16 i;
        .           
        .               u16 sectionIndex;
        .               u16 flags;
        .           
    5,664 ( 0.00%)      collision->unk30 = 0;
    5,664 ( 0.00%)      collision->unk32 = 0;
    5,664 ( 0.00%)      collision->unk34 = 0;
    8,496 ( 0.00%)      collision->surfaceDistance[0] = 1000.0f;
    8,496 ( 0.00%)      collision->surfaceDistance[1] = 1000.0f;
    8,496 ( 0.00%)      collision->surfaceDistance[2] = 1000.0f;
    2,832 ( 0.00%)      flags = 0;
   16,992 ( 0.00%)      if (collision->meshIndexZX < gCollisionMeshCount) {
   14,280 ( 0.00%)          if (check_collision_zx(collision, boundingBoxSize, posX, posY, posZ, collision->meshIndexZX) == 1) {
  152,504 ( 0.00%)  => src/racing/collision.c:check_collision_zx (840x)
        .                       flags |= FACING_Y_AXIS;
        .                   }
        .               }
   16,992 ( 0.00%)      if (collision->meshIndexYX < gCollisionMeshCount) {
   14,280 ( 0.00%)          if (check_collision_yx(collision, boundingBoxSize, posX, posY, posZ, collision->meshIndexYX) == 1) {
   28,321 ( 0.00%)  => src/racing/collision.c:check_collision_yx (840x)
        .                       flags |= FACING_Z_AXIS;
        .                   }
        .               }
   16,992 ( 0.00%)      if (collision->meshIndexZY < gCollisionMeshCount) {
   14,280 ( 0.00%)          if (check_collision_zy(collision, boundingBoxSize, posX, posY, posZ, collision->meshIndexZY) == 1) {
   31,080 ( 0.00%)  => src/racing/collision.c:check_collision_zy (840x)
        .                       flags |= FACING_X_AXIS;
        .                   }
        .               }
    5,664 ( 0.00%)      if (flags == (FACING_Y_AXIS | FACING_Z_AXIS | FACING_X_AXIS)) {
        .                   return flags;
        .               }
        .           
   22,656 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
   22,656 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
   16,992 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
   16,992 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
   28,320 ( 0.00%)      sectionIndexX = (posX - gCourseMinX) / sectionX;
   28,320 ( 0.00%)      sectionIndexZ = (posZ - gCourseMinZ) / sectionZ;
        .           
    5,664 ( 0.00%)      if (sectionIndexX < 0) {
        .                   return 0;
        .               }
    5,664 ( 0.00%)      if (sectionIndexZ < 0) {
        .                   return 0;
        .               }
    5,664 ( 0.00%)      if (sectionIndexX >= GRID_SIZE) {
        .                   return 0;
        .               }
    5,664 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 0;
        .               }
        .           
   16,992 ( 0.00%)      gridIndex = sectionIndexX + sectionIndexZ * GRID_SIZE;
   14,160 ( 0.00%)      numTriangles = gCollisionGrid[gridIndex].numTriangles;
    5,664 ( 0.00%)      if (numTriangles == 0) {
    4,234 ( 0.00%)          return flags;
        .               }
    3,575 ( 0.00%)      sectionIndex = gCollisionGrid[gridIndex].triangle;
        .           
   34,679 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
   10,368 ( 0.00%)          if (flags == (FACING_X_AXIS | FACING_Y_AXIS | FACING_Z_AXIS)) {
        .                       return flags;
        .                   }
   36,288 ( 0.00%)          meshIndex = gCollisionIndices[sectionIndex];
   67,392 ( 0.00%)          if (gCollisionMesh[meshIndex].flags & FACING_Y_AXIS) {
   20,736 ( 0.00%)              if (!(flags & FACING_Y_AXIS)) {
   20,576 ( 0.00%)                  if (meshIndex != collision->meshIndexZX) {
   66,585 ( 0.00%)                      if (check_collision_zx(collision, boundingBoxSize, posX, posY, posZ, meshIndex) == 1) {
  504,467 ( 0.00%)  => src/racing/collision.c:check_collision_zx (4,439x)
       14 ( 0.00%)                          flags |= FACING_Y_AXIS;
        .                               }
        .                           }
        .                       }
        .                   } else if (gCollisionMesh[meshIndex].flags & FACING_X_AXIS) {
        .                       if (!(flags & FACING_X_AXIS)) {
        .                           if (meshIndex != collision->meshIndexZY) {
        .                               if (check_collision_zy(collision, boundingBoxSize, posX, posY, posZ, meshIndex) == 1) {
        .                                   flags |= FACING_X_AXIS;
-- line 1445 ----------------------------------------
-- line 1450 ----------------------------------------
        .                       if (!(flags & FACING_Z_AXIS)) {
        .                           if (meshIndex != collision->meshIndexYX) {
        .                               if (check_collision_yx(collision, boundingBoxSize, posX, posY, posZ, meshIndex) == 1) {
        .                                   flags |= FACING_Z_AXIS;
        .                               }
        .                           }
        .                       }
        .                   }
   15,552 ( 0.00%)          sectionIndex++;
        .               }
      715 ( 0.00%)      return flags;
    5,664 ( 0.00%)  }
        .           
        .           extern u8 D_8014F1110;
        .           
        .           /**
        .            * If unable to spawn actor on the surface set to -3000.0f or
        .            * if outside the collision grid, spawn in the air (3000.0f).
        .            */
      120 ( 0.00%)  f32 spawn_actor_on_surface(f32 posX, f32 posY, f32 posZ) {
        .               f32 height;
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               s16 gridSection;
        .           
        .               u16 index;
        .               u16 numTriangles;
        .               u16 sectionIndex;
       40 ( 0.00%)      f32 phi_f20 = -3000.0f;
        .               u16 i;
        .           
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               s32 sectionX;
        .               s32 sectionZ;
        .           
      160 ( 0.00%)      courseLengthX = (gCourseMaxX - gCourseMinX);
      160 ( 0.00%)      courseLengthZ = (gCourseMaxZ - gCourseMinZ);
      120 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
      120 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
      200 ( 0.00%)      sectionIndexX = (s16) ((posX - gCourseMinX) / sectionX);
      200 ( 0.00%)      sectionIndexZ = (s16) ((posZ - gCourseMinZ) / sectionZ);
      120 ( 0.00%)      gridSection = sectionIndexX + (sectionIndexZ * GRID_SIZE);
      100 ( 0.00%)      numTriangles = gCollisionGrid[gridSection].numTriangles;
        .           
       40 ( 0.00%)      if (sectionIndexX < 0) {
        .                   return 3000.0f;
        .               }
       40 ( 0.00%)      if (sectionIndexZ < 0) {
        .                   return 3000.0f;
        .               }
       40 ( 0.00%)      if (sectionIndexX >= GRID_SIZE) {
        .                   return 3000.0f;
        .               }
       40 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 3000.0f;
        .               }
       40 ( 0.00%)      if (numTriangles == 0) {
        6 ( 0.00%)          return 3000.0f;
        .               }
        .           
       85 ( 0.00%)      sectionIndex = gCollisionGrid[gridSection].triangle;
        .           
      625 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
        .           
      630 ( 0.00%)          index = gCollisionIndices[sectionIndex];
        .           
    1,346 ( 0.00%)          if ((gCollisionMesh[index].flags & FACING_Y_AXIS) &&
      616 ( 0.00%)              (check_horizontally_colliding_with_triangle(posX, posZ, index) == 1)) {
    9,514 ( 0.00%)  => src/racing/collision.c:check_horizontally_colliding_with_triangle (88x)
      374 ( 0.00%)              height = calculate_surface_height(posX, posY, posZ, index);
    1,394 ( 0.00%)  => src/racing/collision.c:calculate_surface_height (34x)
      204 ( 0.00%)              if ((height <= posY) && (phi_f20 < height)) {
       34 ( 0.00%)                  phi_f20 = height;
        .                       }
        .                   }
      270 ( 0.00%)          sectionIndex++;
        .               }
       17 ( 0.00%)      return phi_f20;
       40 ( 0.00%)  }
        .           
        .           #define MAX3(a, b, c, out) \
        .               if (a >= b) {          \
        .                   if (a >= c) {      \
        .                       out = a;       \
        .                   } else             \
        .                       out = c;       \
        .                                      \
-- line 1536 ----------------------------------------
-- line 1546 ----------------------------------------
        .                   } else             \
        .                       out = c;       \
        .                                      \
        .               } else if (b <= c) {   \
        .                   out = b;           \
        .               } else                 \
        .                   out = c;
        .           
    3,234 ( 0.00%)  void add_collision_triangle(Vtx* vtx1, Vtx* vtx2, Vtx* vtx3, s8 surfaceType, u16 sectionId) {
    3,234 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[gCollisionMeshCount];
        .               s16 x2;
        .               s16 z2;
        .               u16 vtx1Flag;
        .               s16 x3;
        .               s16 x1;
        .               s16 y1;
        .               s16 z1;
        .               u16 vtx2Flag;
-- line 1563 ----------------------------------------
-- line 1588 ----------------------------------------
        .           
        .               s16 maxX;
        .               s16 maxZ;
        .               s16 minY;
        .               s16 minX;
        .               s16 maxY;
        .               s16 minZ;
        .           
      882 ( 0.00%)      triangle->vtx1 = vtx1;
      882 ( 0.00%)      triangle->vtx2 = vtx2;
      882 ( 0.00%)      triangle->vtx3 = vtx3;
    1,470 ( 0.00%)      if ((triangle->vtx1->v.flag == 4) && (triangle->vtx2->v.flag == 4) && (triangle->vtx3->v.flag == 4)) {
        .           
        .                   return;
        .               }
        .           
    1,176 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
    1,176 ( 0.00%)      y1 = triangle->vtx1->v.ob[1];
    1,176 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
    1,176 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
    1,176 ( 0.00%)      y2 = triangle->vtx2->v.ob[1];
    1,176 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
    1,176 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
    1,176 ( 0.00%)      y3 = triangle->vtx3->v.ob[1];
    1,176 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
    1,026 ( 0.00%)      if ((x1 == x2) && (z1 == z2)) {
       36 ( 0.00%)          triangle->vtx1 = vtx1;
       36 ( 0.00%)          triangle->vtx3 = vtx2;
       36 ( 0.00%)          triangle->vtx2 = vtx3;
       48 ( 0.00%)          x1 = triangle->vtx1->v.ob[0];
       48 ( 0.00%)          y1 = triangle->vtx1->v.ob[1];
       48 ( 0.00%)          z1 = triangle->vtx1->v.ob[2];
       48 ( 0.00%)          x2 = triangle->vtx3->v.ob[0];
       48 ( 0.00%)          y2 = triangle->vtx3->v.ob[1];
       48 ( 0.00%)          z2 = triangle->vtx3->v.ob[2];
       48 ( 0.00%)          x3 = triangle->vtx2->v.ob[0];
       48 ( 0.00%)          y3 = triangle->vtx2->v.ob[1];
       48 ( 0.00%)          z3 = triangle->vtx2->v.ob[2];
        .               }
    2,630 ( 0.00%)      MAX3(x1, x2, x3, maxX)
        .           
    2,634 ( 0.00%)      MAX3(z1, z2, z3, maxZ)
        .           
    2,642 ( 0.00%)      MAX3(y1, y2, y3, maxY)
        .           
    2,620 ( 0.00%)      MIN3(x1, x2, x3, minX)
        .           
    2,642 ( 0.00%)      MIN3(y1, y2, y3, minY)
        .           
    2,624 ( 0.00%)      MIN3(z1, z2, z3, minZ)
        .           
    5,880 ( 0.00%)      crossProductX = (((y2 - y1) * (z3 - z2)) - ((z2 - z1) * (y3 - y2)));
    5,880 ( 0.00%)      crossProductY = (((z2 - z1) * (x3 - x2)) - ((x2 - x1) * (z3 - z2)));
    5,880 ( 0.00%)      crossProductZ = (((x2 - x1) * (y3 - y2)) - ((y2 - y1) * (x3 - x2)));
        .           
        .               // length of the cross product
      588 ( 0.00%)      magnitude =
    3,822 ( 0.00%)          sqrtf((crossProductX * crossProductX) + (crossProductY * crossProductY) + (crossProductZ * crossProductZ));
    2,352 ( 0.00%)  => ???:sqrtf (294x)
        .           
    1,764 ( 0.00%)      if (!magnitude) {
      108 ( 0.00%)          return;
        .               }
        .           
    1,200 ( 0.00%)      normalX = (f32) crossProductX / magnitude;
    1,200 ( 0.00%)      normalY = (f32) crossProductY / magnitude;
    1,200 ( 0.00%)      normalZ = (f32) crossProductZ / magnitude;
        .           
        .               // Distance from x to plane (cross product's normal).
    3,360 ( 0.00%)      distance = -((normalX * x1) + (normalY * y1) + (normalZ * z1));
        .           
        .               // Return if normalY is not vertical.
        .               // Could be checking if the surface is a floor
      960 ( 0.00%)      if (D_8015F59C) {
        .                   if (normalY < -0.9f) {
        .                       return;
        .                   } else if (normalY > 0.9f) {
        .                       return;
        .                   }
        .               }
        .           
        .               // Return if normalY is not horizontal
        .               // Could be checking if the surface is a wall
      960 ( 0.00%)      if (D_8015F5A0) {
        .                   if ((normalY < 0.1f) && (normalY > -0.1f)) {
        .                       return;
        .                   }
        .               }
        .           
      720 ( 0.00%)      triangle->maxX = maxX;
      720 ( 0.00%)      triangle->maxZ = maxZ;
      720 ( 0.00%)      triangle->minX = minX;
      720 ( 0.00%)      triangle->minZ = minZ;
      720 ( 0.00%)      triangle->minY = minY;
      720 ( 0.00%)      triangle->maxY = maxY;
        .           
        .               // Define the minimum and maximum dimensions of the course.
      960 ( 0.00%)      if (minX < gCourseMinX) {
        6 ( 0.00%)          gCourseMinX = minX;
        .               }
      960 ( 0.00%)      if (minY < gCourseMinY) {
        .                   gCourseMinY = minY;
        .               }
      960 ( 0.00%)      if (minZ < gCourseMinZ) {
       27 ( 0.00%)          gCourseMinZ = minZ;
        .               }
      960 ( 0.00%)      if (maxX > gCourseMaxX) {
       12 ( 0.00%)          gCourseMaxX = maxX;
        .               }
      960 ( 0.00%)      if (maxY > gCourseMaxY) {
        3 ( 0.00%)          gCourseMaxY = maxY;
        .               }
      960 ( 0.00%)      if (maxZ > gCourseMaxZ) {
       12 ( 0.00%)          gCourseMaxZ = maxZ;
        .               }
        .           
      720 ( 0.00%)      triangle->normalX = normalX;
      720 ( 0.00%)      triangle->normalY = normalY;
      720 ( 0.00%)      triangle->normalZ = normalZ;
      720 ( 0.00%)      triangle->distance = distance;
        .           
      720 ( 0.00%)      triangle->surfaceType = (u16) surfaceType;
        .           
        .               // Square the crossProduct to produce a magnitude
      720 ( 0.00%)      crossProductX = crossProductX * crossProductX;
      720 ( 0.00%)      crossProductY = crossProductY * crossProductY;
      720 ( 0.00%)      crossProductZ = crossProductZ * crossProductZ;
        .           
      480 ( 0.00%)      D_8015F6FA = 0;
      480 ( 0.00%)      D_8015F6FC = 0;
        .           
      960 ( 0.00%)      vtx1Flag = triangle->vtx1->v.flag;
      960 ( 0.00%)      vtx2Flag = triangle->vtx2->v.flag;
      960 ( 0.00%)      vtx3Flag = triangle->vtx3->v.flag;
        .           
      480 ( 0.00%)      flags = sectionId;
        .           
      480 ( 0.00%)      if ((vtx1Flag == 1) && (vtx2Flag == 1) && (vtx3Flag == 1)) {
        .                   flags |= 0x400;
      480 ( 0.00%)      } else if ((vtx1Flag == 2) && (vtx2Flag == 2) && (vtx3Flag == 2)) {
        .                   flags |= 0x800;
      480 ( 0.00%)      } else if ((vtx1Flag == 3) && (vtx2Flag == 3) && (vtx3Flag == 3)) {
        .                   flags |= 0x1000;
      960 ( 0.00%)      } else if (D_8015F5A4 != 0) {
        .                   flags |= 0x200;
        .               }
        .           
      720 ( 0.00%)      triangle->flags = flags;
        .           
        .               // Find the axis with the highest magnitude.
        .           
        .               // Y is the significant axis
    1,410 ( 0.00%)      if ((crossProductX <= crossProductY) && (crossProductY >= crossProductZ)) {
    1,610 ( 0.00%)          triangle->flags |= FACING_Y_AXIS;
        .                   // X is the significant axis
       60 ( 0.00%)      } else if ((crossProductX > crossProductY) && (crossProductX >= crossProductZ)) {
       70 ( 0.00%)          triangle->flags |= FACING_X_AXIS;
        .                   // Z is the significant axis
        .               } else {
        .                   triangle->flags |= FACING_Z_AXIS;
        .               }
    1,440 ( 0.00%)      gCollisionMeshCount++;
      588 ( 0.00%)  }
        .           
        .           /**
        .            * Triangle contains three indices that are used to get the actual vertices.
        .            */
       90 ( 0.00%)  void set_vtx_from_triangle(u32 triangle, s8 surfaceType, u16 sectionId) {
       50 ( 0.00%)      u32 vert1 = ((triangle & 0x00FF0000) >> 16) / 2;
       50 ( 0.00%)      u32 vert2 = ((triangle & 0x0000FF00) >> 8) / 2;
       40 ( 0.00%)      u32 vert3 = (triangle & 0x000000FF) / 2;
        .           
       40 ( 0.00%)      Vtx* vtx1 = vtxBuffer[vert1];
       40 ( 0.00%)      Vtx* vtx2 = vtxBuffer[vert2];
       40 ( 0.00%)      Vtx* vtx3 = vtxBuffer[vert3];
        .           
       80 ( 0.00%)      add_collision_triangle(vtx1, vtx2, vtx3, surfaceType, sectionId);
    3,728 ( 0.00%)  => src/racing/collision.c:add_collision_triangle (10x)
       30 ( 0.00%)  }
        .           
    1,136 ( 0.00%)  void set_vtx_from_tri2(u32 triangle1, u32 triangle2, s8 surfaceType, u16 sectionId) {
        .               UNUSED s32 pad[2];
      710 ( 0.00%)      u32 vert1 = ((triangle1 & 0x00FF0000) >> 16) / 2;
      710 ( 0.00%)      u32 vert2 = ((triangle1 & 0x0000FF00) >> 8) / 2;
      568 ( 0.00%)      u32 vert3 = (triangle1 & 0x000000FF) / 2;
        .           
        .               // This is actually triangle 2; vert 1,2,3.
      710 ( 0.00%)      u32 vert4 = ((triangle2 & 0x00FF0000) >> 16) / 2;
      710 ( 0.00%)      u32 vert5 = ((triangle2 & 0x0000FF00) >> 8) / 2;
      568 ( 0.00%)      u32 vert6 = (triangle2 & 0x000000FF) / 2;
        .           
      568 ( 0.00%)      Vtx* vtx1 = vtxBuffer[vert1];
      568 ( 0.00%)      Vtx* vtx2 = vtxBuffer[vert2];
      568 ( 0.00%)      Vtx* vtx3 = vtxBuffer[vert3];
        .           
      568 ( 0.00%)      Vtx* vtx4 = vtxBuffer[vert4];
      568 ( 0.00%)      Vtx* vtx5 = vtxBuffer[vert5];
      568 ( 0.00%)      Vtx* vtx6 = vtxBuffer[vert6];
        .           
        .               // Triangle 1
    1,136 ( 0.00%)      add_collision_triangle(vtx1, vtx2, vtx3, surfaceType, sectionId);
   49,175 ( 0.00%)  => src/racing/collision.c:add_collision_triangle (142x)
        .               // Triangle 2
    1,136 ( 0.00%)      add_collision_triangle(vtx4, vtx5, vtx6, surfaceType, sectionId);
   49,295 ( 0.00%)  => src/racing/collision.c:add_collision_triangle (142x)
      426 ( 0.00%)  }
        .           
        .           void set_vtx_from_quadrangle(u32 line, s8 surfaceType, u16 sectionId) {
        .               UNUSED s32 pad[6];
        .               Vtx* vtx1;
        .               Vtx* vtx2;
        .               Vtx* vtx3;
        .               Vtx* vtx4;
        .           
-- line 1797 ----------------------------------------
-- line 1809 ----------------------------------------
        .               add_collision_triangle(vtx1, vtx2, vtx3, surfaceType, sectionId);
        .               // Triangle 2
        .               add_collision_triangle(vtx1, vtx3, vtx4, surfaceType, sectionId);
        .           }
        .           
        .           /**
        .            * Generates a list of pointers to course vtx.
        .            */
       96 ( 0.00%)  void set_vtx_buffer(uintptr_t addr, u32 numVertices, u32 bufferIndex) {
        .               u32 i;
       32 ( 0.00%)      Vtx* vtx = (Vtx*) addr;
    1,792 ( 0.00%)      for (i = 0; i < numVertices; i++) {
        .                   // printf("VTX: 0x%llX",vtx);
      856 ( 0.00%)          if (vtx == 0) {
        .                       assert(false);
        .                   }
    1,712 ( 0.00%)          vtxBuffer[bufferIndex] = vtx;
      428 ( 0.00%)          vtx++;
      428 ( 0.00%)          bufferIndex++;
        .               }
       64 ( 0.00%)  }
        .           /**
        .            * @return 1 intersecting triangle, 0 not intersecting.
        .            */
  279,900 ( 0.00%)  s32 is_line_intersecting_rectangle(s16 minX, s16 maxX, s16 minZ, s16 maxZ, s16 x1, s16 z1, s16 x2, s16 z2) {
        .               f32 xOffset;
        .               f32 projectedPoint;
        .               f32 zOffset;
        .           
   77,750 ( 0.00%)      xOffset = x2 - x1;
   77,750 ( 0.00%)      zOffset = z2 - z1;
        .               // Line is vertical
   93,300 ( 0.00%)      if (xOffset == 0.0f) {
   10,050 ( 0.00%)          if (x1 < minX) {
    3,256 ( 0.00%)              return 0;
        .                   }
    5,166 ( 0.00%)          if (maxX < x1) {
    2,384 ( 0.00%)              return 0;
        .                   }
    2,120 ( 0.00%)          if (zOffset > 0.0f) {
    1,536 ( 0.00%)              if ((z1 < minZ) && (maxZ < z2)) {
      416 ( 0.00%)                  return 1;
        .                       }
    1,620 ( 0.00%)          } else if ((z2 < minZ) && (maxZ < z1)) {
      460 ( 0.00%)              return 1;
        .                   }
        .               } else {
        .                   // Line is horizontal
   73,200 ( 0.00%)          if (zOffset == 0.0f) {
   11,070 ( 0.00%)              if (z1 < minZ) {
    2,680 ( 0.00%)                  return 0;
        .                       }
    7,050 ( 0.00%)              if (maxZ < z1) {
    3,612 ( 0.00%)                  return 0;
        .                       }
    2,176 ( 0.00%)              if (xOffset > 0.0f) {
    1,764 ( 0.00%)                  if ((x1 < minX) && (maxX < x2)) {
      576 ( 0.00%)                      return 1;
        .                           }
    1,464 ( 0.00%)              } else if ((x2 < minX) && (maxX < x1)) {
      488 ( 0.00%)                  return 1;
        .                       }
        .                   } else {
   93,610 ( 0.00%)              projectedPoint = ((xOffset / zOffset) * (minZ - z1)) + x1;
   63,894 ( 0.00%)              if ((minX <= projectedPoint) && (projectedPoint <= maxX)) {
    2,252 ( 0.00%)                  return 1;
        .                       }
   81,224 ( 0.00%)              projectedPoint = ((xOffset / zOffset) * (maxZ - z1)) + x1;
   55,496 ( 0.00%)              if ((minX <= projectedPoint) && (projectedPoint <= maxX)) {
      996 ( 0.00%)                  return 1;
        .                       }
   75,746 ( 0.00%)              projectedPoint = ((zOffset / xOffset) * (minX - x1)) + z1;
   47,214 ( 0.00%)              if ((minZ <= projectedPoint) && (projectedPoint <= maxZ)) {
      972 ( 0.00%)                  return 1;
        .                       }
   70,400 ( 0.00%)              projectedPoint = ((zOffset / xOffset) * (maxX - x1)) + z1;
   42,840 ( 0.00%)              if ((minZ <= projectedPoint) && (projectedPoint <= maxZ)) {
        .                           return 1;
        .                       }
        .                   }
        .               }
    6,504 ( 0.00%)      return 0;
   31,100 ( 0.00%)  }
        .           
   92,376 ( 0.00%)  s32 is_triangle_intersecting_bounding_box(s16 minX, s16 maxX, s16 minZ, s16 maxZ, u16 index) {
   69,282 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               s16 x1;
        .               s16 z1;
        .               s16 x2;
        .               s16 z2;
        .               s16 x3;
        .               s16 z3;
        .           
   30,792 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
   30,792 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
   30,792 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
   30,792 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
   30,792 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
   30,792 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
   45,030 ( 0.00%)      if ((x1 >= minX) && (maxX >= x1) && (z1 >= minZ) && (maxZ >= z1)) {
    1,212 ( 0.00%)          return 1;
        .               }
   44,346 ( 0.00%)      if ((x2 >= minX) && (maxX >= x2) && (z2 >= minZ) && (maxZ >= z2)) {
      916 ( 0.00%)          return 1;
        .               }
   37,332 ( 0.00%)      if ((x3 >= minX) && (maxX >= x3) && (z3 >= minZ) && (maxZ >= z3)) {
      724 ( 0.00%)          return 1;
        .               }
  100,352 ( 0.00%)      if (is_line_intersecting_rectangle(minX, maxX, minZ, maxZ, x1, z1, x2, z2) == 1) {
  509,372 ( 0.00%)  => src/racing/collision.c:is_line_intersecting_rectangle (6,272x)
    2,512 ( 0.00%)          return 1;
        .               }
   80,256 ( 0.00%)      if (is_line_intersecting_rectangle(minX, maxX, minZ, maxZ, x2, z2, x3, z3) == 1) {
  308,412 ( 0.00%)  => src/racing/collision.c:is_line_intersecting_rectangle (5,016x)
    1,508 ( 0.00%)          return 1;
        .               }
   68,192 ( 0.00%)      if (is_line_intersecting_rectangle(minX, maxX, minZ, maxZ, x3, z3, x1, z1) == 1) {
  414,252 ( 0.00%)  => src/racing/collision.c:is_line_intersecting_rectangle (4,262x)
    2,140 ( 0.00%)          return 1;
        .               }
    3,192 ( 0.00%)      return 0;
   15,396 ( 0.00%)  }
        .           
        .           /**
        .            * Splits the collision mesh into 32x32 sections. This allows the game to check only
        .            * nearby geography for a collision rather than checking against the whole collision mesh.
        .            * (checking against the whole mesh for every actor would be expensive)
        .            */
        3 ( 0.00%)  void generate_collision_grid(void) {
        .               CollisionTriangle* triangle;
        .               s32 i, j, k;
        .               UNUSED s32 pad[5];
        .               s16 maxX;
        .               s16 maxZ;
        .               s16 minX;
        .               s16 minZ;
        .               s32 sectionZ;
        .               s32 sectionX;
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               s32 index;
        .           
        8 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
        8 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
        .               // Separate the course into 32 sections
        6 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
        6 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
        .               // Reset the collision grid
    3,076 ( 0.00%)      for (i = 0; i < 1024; i++) {
    4,096 ( 0.00%)          gCollisionGrid[i].numTriangles = 0;
        .               }
        .           
        2 ( 0.00%)      gNumCollisionTriangles = 0;
        .           
        .               // 32x32 grid
      100 ( 0.00%)      for (j = 0; j < GRID_SIZE; j++) {
    3,200 ( 0.00%)          for (k = 0; k < GRID_SIZE; k++) {
    6,144 ( 0.00%)              index = k + j * GRID_SIZE;
        .           
        .                       // Select a section of the course using min/max akin to drawing a bounding-box
    9,216 ( 0.00%)              minX = (gCourseMinX + (sectionX * k)) - 20;
    9,216 ( 0.00%)              minZ = (gCourseMinZ + (sectionZ * j)) - 20;
        .           
    6,144 ( 0.00%)              maxX = minX + sectionX + 40;
    6,144 ( 0.00%)              maxZ = minZ + sectionZ + 40;
        .           
1,481,728 ( 0.00%)              for (i = 0; i < gCollisionMeshCount; i++) {
2,457,600 ( 0.00%)                  triangle = gCollisionMesh + i;
  983,040 ( 0.00%)                  if (triangle->maxZ < minZ) {
  218,752 ( 0.00%)                      continue;
        .                           }
  545,536 ( 0.00%)                  if (triangle->minZ > maxZ) {
  198,016 ( 0.00%)                      continue;
        .                           }
  149,504 ( 0.00%)                  if (triangle->maxX < minX) {
   27,476 ( 0.00%)                      continue;
        .                           }
   94,552 ( 0.00%)                  if (triangle->minX > maxX) {
   15,940 ( 0.00%)                      continue;
        .                           }
        .           
        .                           // Add the collision triangle to the list if it's inside the bounding-box
   84,678 ( 0.00%)                  if (is_triangle_intersecting_bounding_box(minX, maxX, minZ, maxZ, (u16) i) == 1) {
1,981,554 ( 0.00%)  => src/racing/collision.c:is_triangle_intersecting_bounding_box (7,698x)
        .                               // Point this grid section to the first triangle in the section
   27,036 ( 0.00%)                      if (gCollisionGrid[index].numTriangles == 0) {
    4,098 ( 0.00%)                          gCollisionGrid[index].triangle = gNumCollisionTriangles;
        .                               }
   40,554 ( 0.00%)                      gCollisionGrid[index].numTriangles++;
   40,554 ( 0.00%)                      gCollisionIndices[gNumCollisionTriangles] = (u16) i;
   27,036 ( 0.00%)                      gNumCollisionTriangles++;
        .                           }
        .                       }
        .                   }
        .               }
        4 ( 0.00%)  }
        .           
        .           /**
        .            * Recursive search for vtx and set surfaceTypes to -1 and sectionId's to 0xFF
        .            */
        4 ( 0.00%)  void generate_collision_mesh_with_defaults(Gfx* gfx) {
        5 ( 0.00%)      generate_collision_mesh(gfx, SURFACE_DEFAULT, 0xFF);
   64,098 ( 0.00%)  => src/racing/collision.c:generate_collision_mesh (1x)
        3 ( 0.00%)  }
        .           
        .           /**
        .            * Recursive search for vtx and set sectionId's to 0xFF
        .            */
        .           void generate_collision_mesh_with_default_section_id(Gfx* gfx, s8 surfaceType) {
        .               generate_collision_mesh(gfx, surfaceType, 0xFF);
        .           }
        .           
        .           extern u32 D_8015F58C;
        .           u32 numTimes = 0;
        .           
        .           /**
        .            * Generate via a recursive search and set for vertex data.
        .            */
      126 ( 0.00%)  void generate_collision_mesh(Gfx* addr, s8 surfaceType, u16 sectionId) {
        .               s32 opcode;
        .               uintptr_t lo;
        .               uintptr_t hi;
        .               s32 i;
       70 ( 0.00%)      numTimes++;
        .               // printf("Initial\n");
        .               // printf("ptr 0x%llX\n", &addr);
        .               // printf("w0 0x%llX\n", addr->words.w0);
        .               // printf("w1 0x%llX\n", addr->words.w1);
        .               // printf("----loop----\n");
       28 ( 0.00%)      Gfx* gfx = (Gfx*) addr;
       28 ( 0.00%)      D_8015F6FA = 0;
       28 ( 0.00%)      D_8015F6FC = 0;
        .           
        .               // u8 *orig = segmented_gfx_to_virtual(0x07000000);
        .           
        .               // printf("\n\nORIG:\n");
        .               // for (size_t i = 0; i < 100; i++) {
        .               //     printf(" 0x%X ", orig[i]);
        .               // }
        .           
      836 ( 0.00%)      for (i = 0; i < 0x1FFF; i++) {
      822 ( 0.00%)          lo = gfx->words.w0;
      822 ( 0.00%)          hi = gfx->words.w1;
      822 ( 0.00%)          opcode = GFX_GET_OPCODE(lo);
        .           
        .                   //  printf("ptr 0x%llX\n", &addr);
        .                   //  printf("op 0x%llX\n", opcode);
        .                   //   printf("w0 0x%llX\n", lo);
        .                   //   printf("w1 0x%llX\n", hi);
        .           
      548 ( 0.00%)          if (opcode == (G_DL << 24)) {
        .                       // G_DL's hi contains an addr to another DL.
       84 ( 0.00%)              generate_collision_mesh((Gfx*) hi, surfaceType, sectionId);
  127,088 ( 0.00%)  => src/racing/collision.c:generate_collision_mesh'2 (12x)
        .           
      524 ( 0.00%)          } else if (opcode == (G_VTX << 24)) {
      208 ( 0.00%)              set_vtx_buffer((hi), (lo >> 10) & 0x3F, ((lo >> 16) & 0xFF) >> 1);
      226 ( 0.00%)  => src/racing/collision.c:set_vtx_buffer (2x)
        .           
      492 ( 0.00%)          } else if (opcode == (G_TRI1 << 24)) {
       50 ( 0.00%)              D_8015F58C += 1;
       70 ( 0.00%)              set_vtx_from_triangle(hi, surfaceType, sectionId);
    4,188 ( 0.00%)  => src/racing/collision.c:set_vtx_from_triangle (10x)
        .           
      472 ( 0.00%)          } else if (opcode == (G_TRI2 << 24)) {
      710 ( 0.00%)              D_8015F58C += 2;
        .           
    1,420 ( 0.00%)              set_vtx_from_tri2(lo, hi, surfaceType, sectionId);
  109,688 ( 0.00%)  => src/racing/collision.c:set_vtx_from_tri2 (142x)
        .           
      188 ( 0.00%)          } else if (opcode == (G_QUAD << 24)) {
        .                       D_8015F58C += 2;
        .                       set_vtx_from_quadrangle(hi, surfaceType, sectionId);
        .           
      188 ( 0.00%)          } else if (opcode == (int32_t) (G_ENDDL << 24)) {
       14 ( 0.00%)              break;
        .                   }
        .           
      260 ( 0.00%)          gfx++;
        .               }
       42 ( 0.00%)  }
        .           
        .           /**
        .            * Search for G_SETTILESIZE and set its args.
        .            */
        .           void find_and_set_tile_size(uintptr_t addr, s32 uls, s32 ult) {
        .               Gfx* gfx = (Gfx*) addr;
        .               u32 opcode;
        .           
-- line 2090 ----------------------------------------
-- line 2141 ----------------------------------------
        .                   } else if (opcode == (G_VTX << 24)) {
        .                       // G_VTX contains an addr hi
        .                       set_vertex_colours(hi, (lo >> 10) & 0x3F, ((lo >> 16) & 0xFF) >> 1, alpha, red, green, blue);
        .                   }
        .                   gfx++;
        .               }
        .           }
        .           
    6,000 ( 0.00%)  void subtract_scaled_vector(Vec3f pos1, f32 boundingBoxSize, Vec3f pos2) {
    9,600 ( 0.00%)      pos2[0] -= pos1[0] * boundingBoxSize;
   13,200 ( 0.00%)      pos2[1] -= pos1[1] * boundingBoxSize;
   13,200 ( 0.00%)      pos2[2] -= pos1[2] * boundingBoxSize;
    3,600 ( 0.00%)  }
        .           
    9,600 ( 0.00%)  u16 player_terrain_collision(Player* player, KartTyre* tyre, f32 tyre2X, f32 tyre2Y, f32 tyre2Z) {
        .               Collision wtf;
    2,400 ( 0.00%)      Collision* collision = &wtf;
        .               UNUSED s32 pad;
        .               u16 i;
        .               u16 meshIndex;
        .               u16 numTriangles;
        .               u16 sectionIndex;
        .               f32 tyreX;
        .               f32 tyreY;
        .               f32 tyreZ;
-- line 2165 ----------------------------------------
-- line 2172 ----------------------------------------
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               s16 gridIndex;
        .           
        .               s32 sectionX;
        .               s32 sectionZ;
        .               UNUSED s32 pad2[9];
        .           
    3,600 ( 0.00%)      collision->surfaceDistance[0] = 1000.0f;
    3,600 ( 0.00%)      collision->surfaceDistance[1] = 1000.0f;
    3,600 ( 0.00%)      collision->surfaceDistance[2] = 1000.0f;
    3,600 ( 0.00%)      boundingBoxSize = player->boundingBoxSize;
    2,400 ( 0.00%)      collision->meshIndexYX = 5000;
    2,400 ( 0.00%)      collision->meshIndexZY = 5000;
    2,400 ( 0.00%)      collision->meshIndexZX = 5000;
    2,400 ( 0.00%)      collision->unk30 = 0;
    2,400 ( 0.00%)      collision->unk32 = 0;
    2,400 ( 0.00%)      collision->unk34 = 0;
    3,600 ( 0.00%)      tyreX = tyre->pos[0];
    3,600 ( 0.00%)      tyreY = tyre->pos[1];
    3,600 ( 0.00%)      tyreZ = tyre->pos[2];
   10,816 ( 0.00%)      switch (tyre->surfaceFlags) {
        .                   case 0x80:
        .                       if (is_colliding_with_wall1(collision, boundingBoxSize, tyreX, tyreY, tyreZ, tyre->collisionMeshIndex,
        .                                                   tyre2X, tyre2Y, tyre2Z) == 1) {
        .                           height = calculate_surface_height(tyreX, tyreY, tyreZ, tyre->collisionMeshIndex);
        .                           if ((!(height > player->pos[1])) && !((player->pos[1] - height) > (2 * boundingBoxSize))) {
        .                               tyre->baseHeight = height;
        .                               subtract_scaled_vector(collision->unk54, collision->surfaceDistance[1], tyre->pos);
        .                               return 1;
        .                           }
        .                       }
        .                       break;
        .                   case 0x40:
   25,116 ( 0.00%)              if (is_colliding_with_drivable_surface(collision, boundingBoxSize, tyreX, tyreY, tyreZ,
  262,392 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (1,196x)
    2,392 ( 0.00%)                                                     tyre->collisionMeshIndex, tyre2X, tyre2Y, tyre2Z) == 1) {
   15,496 ( 0.00%)                  height = calculate_surface_height(tyreX, tyreY, tyreZ, tyre->collisionMeshIndex);
   48,872 ( 0.00%)  => src/racing/collision.c:calculate_surface_height (1,192x)
   21,456 ( 0.00%)                  if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
    3,576 ( 0.00%)                      tyre->baseHeight = height;
   10,728 ( 0.00%)                      subtract_scaled_vector(collision->orientationVector, collision->surfaceDistance[2], tyre->pos);
   45,296 ( 0.00%)  => src/racing/collision.c:subtract_scaled_vector (1,192x)
    2,384 ( 0.00%)                      return 1;
        .                           }
        .                       }
        8 ( 0.00%)              break;
        .                   case 0x20:
        .                       if (is_colliding_with_wall2(collision, boundingBoxSize, tyreX, tyreY, tyreZ, tyre->collisionMeshIndex,
        .                                                   tyre2X, tyre2Y, tyre2Z) == 1) {
        .                           height = calculate_surface_height(tyreX, tyreY, tyreZ, tyre->collisionMeshIndex);
        .                           if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
        .                               tyre->baseHeight = height;
        .                               subtract_scaled_vector(collision->unk48, collision->surfaceDistance[0], tyre->pos);
        .                               return 1;
        .                           }
        .                       }
        .                       break;
        .                   case 0:
        8 ( 0.00%)              break;
        .               }
        .           
        .               // If the surface flags are not set then try setting them.
        .           
       64 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
       64 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
       48 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
       48 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
       80 ( 0.00%)      sectionIndexX = (tyreX - gCourseMinX) / sectionX;
       80 ( 0.00%)      sectionIndexZ = (tyreZ - gCourseMinZ) / sectionZ;
        .           
       16 ( 0.00%)      if (sectionIndexX < 0) {
        .                   return 0;
        .               }
       16 ( 0.00%)      if (sectionIndexZ < 0) {
        .                   return 0;
        .               }
       16 ( 0.00%)      if (sectionIndexX >= GRID_SIZE) {
        .                   return 0;
        .               }
       16 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 0;
        .               }
        .           
       48 ( 0.00%)      gridIndex = sectionIndexX + sectionIndexZ * GRID_SIZE;
       40 ( 0.00%)      numTriangles = gCollisionGrid[gridIndex].numTriangles;
        .           
       16 ( 0.00%)      if (numTriangles == 0) {
        .                   return 0;
        .               }
        .           
       40 ( 0.00%)      sectionIndex = gCollisionGrid[gridIndex].triangle;
        .           
       40 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
       56 ( 0.00%)          meshIndex = gCollisionIndices[sectionIndex];
      104 ( 0.00%)          if (gCollisionMesh[meshIndex].flags & FACING_Y_AXIS) {
       32 ( 0.00%)              if (meshIndex != tyre->collisionMeshIndex) {
      168 ( 0.00%)                  if (is_colliding_with_drivable_surface(collision, boundingBoxSize, tyreX, tyreY, tyreZ, meshIndex,
    1,760 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (8x)
        .                                                                  tyre2X, tyre2Y, tyre2Z) == 1) {
       88 ( 0.00%)                      height = calculate_surface_height(tyreX, tyreY, tyreZ, meshIndex);
      328 ( 0.00%)  => src/racing/collision.c:calculate_surface_height (8x)
        .           
      144 ( 0.00%)                      if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
       72 ( 0.00%)                          subtract_scaled_vector(collision->orientationVector, collision->surfaceDistance[2], tyre->pos);
      304 ( 0.00%)  => src/racing/collision.c:subtract_scaled_vector (8x)
       24 ( 0.00%)                          tyre->baseHeight = height;
       96 ( 0.00%)                          tyre->surfaceType = (u8) gCollisionMesh[meshIndex].surfaceType;
       16 ( 0.00%)                          tyre->surfaceFlags = 0x40;
       24 ( 0.00%)                          tyre->collisionMeshIndex = meshIndex;
      104 ( 0.00%)                          if (gCollisionMesh[meshIndex].flags & 0x1000) {
        .                                       tyre->unk_14 = 1;
        .                                   } else {
       16 ( 0.00%)                              tyre->unk_14 = 0;
        .                                   }
       16 ( 0.00%)                          return 1;
        .                               }
        .                           }
        .                       }
        .                   } else if (gCollisionMesh[meshIndex].flags & FACING_X_AXIS) {
        .                       if (gCollisionMesh[meshIndex].normalY != 0.0f) {
        .                           if (meshIndex != tyre->collisionMeshIndex) {
        .                               if (is_colliding_with_wall1(collision, boundingBoxSize, tyreX, tyreY, tyreZ, meshIndex, tyre2X,
        .                                                           tyre2Y, tyre2Z) == 1) {
-- line 2291 ----------------------------------------
-- line 2320 ----------------------------------------
        .                           }
        .                       }
        .                   }
        .                   sectionIndex++;
        .               }
        .               tyre->baseHeight = tyreY;
        .               tyre->surfaceType = 0;
        .               return 0;
    2,400 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/racing/actors.c
--------------------------------------------------------------------------------
Ir                 

-- line 119 ----------------------------------------
        .                               destroy_actor((struct Actor*) compare);
        .                               return;
        .                       }
        .                   }
        .               }
        .           }
        .           
        .           // Sets introductory values for a new actor (ex. Banana).
      261 ( 0.00%)  void actor_init(struct Actor* actor, Vec3f startingPos, Vec3s startingRot, Vec3f startingVelocity, s16 actorType) {
      174 ( 0.00%)      vec3f_copy_return(actor->pos, startingPos);
      609 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_copy_return (29x)
      174 ( 0.00%)      vec3s_copy(actor->rot, startingRot);
      609 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3s_copy (29x)
      174 ( 0.00%)      vec3f_copy_return(actor->velocity, startingVelocity);
      609 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_copy_return (29x)
       87 ( 0.00%)      actor->type = actorType;
       58 ( 0.00%)      actor->flags = -0x8000;
       58 ( 0.00%)      actor->unk_04 = 0;
       58 ( 0.00%)      actor->state = 0;
       87 ( 0.00%)      actor->unk_08 = 0.0f;
       87 ( 0.00%)      actor->boundingBoxSize = 0.0f;
      116 ( 0.00%)      func_802AAAAC(&actor->unk30);
    3,248 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/collision.c:func_802AAAAC (29x)
      319 ( 0.00%)      switch (actorType) {
        .                   case ACTOR_BOX_TRUCK:
        .                       if ((s32) D_802BA260 >= 3) {
        .                           D_802BA260 = 0;
        .                       }
        .                       actor->state = (s16) D_802BA260;
        .                       D_802BA260 += 1;
        .                       break;
        .                   case ACTOR_YOSHI_EGG:
-- line 146 ----------------------------------------
-- line 154 ----------------------------------------
        .                   case ACTOR_KIWANO_FRUIT:
        .                       actor->state = 0;
        .                       actor->rot[0] = 0;
        .                       actor->rot[1] = 0;
        .                       actor->rot[2] = 0;
        .                       actor->boundingBoxSize = 2.0f;
        .                       break;
        .                   case ACTOR_FALLING_ROCK:
       18 ( 0.00%)              actor->flags |= 0x4000;
        9 ( 0.00%)              actor->boundingBoxSize = 10.0f;
        3 ( 0.00%)              break;
        .                   case ACTOR_TRAIN_ENGINE:
        6 ( 0.00%)              actor->unk_08 = 10.0f;
        2 ( 0.00%)              break;
        .                   case ACTOR_BANANA:
        .                       actor->flags = actor->flags | 0x4000 | 0x1000;
        .                       actor->boundingBoxSize = 2.0f;
        .                       break;
        .                   case ACTOR_GREEN_SHELL:
        .                       gNumSpawnedShells += 1;
        .                       actor->unk_04 = 0;
        .                       actor->boundingBoxSize = 4.0f;
-- line 175 ----------------------------------------
-- line 268 ----------------------------------------
        .                       break;
        .                   case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
        .                       actor->flags |= 0x4000;
        .                       actor->unk_04 = 0;
        .                       actor->state = 5;
        .                       actor->boundingBoxSize = 5.5f;
        .                       break;
        .                   case ACTOR_ITEM_BOX:
       66 ( 0.00%)              actor->flags |= 0x4000;
       22 ( 0.00%)              actor->unk_04 = 0;
       22 ( 0.00%)              actor->state = 0;
       33 ( 0.00%)              actor->boundingBoxSize = 5.5f;
       11 ( 0.00%)              break;
        .                   case ACTOR_PIRANHA_PLANT:
        .                       actor->flags |= 0x4000;
        .                       actor->state = 0x001E;
        .                       actor->boundingBoxSize = 5.0f;
        .                       break;
        .                   default:
       26 ( 0.00%)              break;
        .               }
       87 ( 0.00%)  }
        .           
        .           void actor_not_rendered(Camera* arg0, struct Actor* arg1) {
        .               switch (arg0 - camera1) {
        .                   case PLAYER_ONE:
        .                       arg1->flags &= ~(1 << PLAYER_ONE);
        .                       break;
        .                   case PLAYER_TWO:
        .                       arg1->flags &= ~(1 << PLAYER_TWO);
-- line 297 ----------------------------------------
-- line 317 ----------------------------------------
        .                       arg1->flags |= 1 << PLAYER_THREE;
        .                       break;
        .                   case PLAYER_FOUR:
        .                       arg1->flags |= 1 << PLAYER_FOUR;
        .                       break;
        .               }
        .           }
        .           
    1,328 ( 0.00%)  void func_80297340(Camera* arg0) {
        .               Mat4 sp38;
    1,328 ( 0.00%)      s16 temp = D_8015F8D0[2];
        .               s32 maxObjectsReached;
        .           
    1,328 ( 0.00%)      if (gGamestate == CREDITS_SEQUENCE) {
        .                   return;
        .               }
        .           
    1,660 ( 0.00%)      mtxf_translate(sp38, D_8015F8D0);
   93,292 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:mtxf_translate (332x)
        .           
    2,656 ( 0.00%)      maxObjectsReached = render_set_position(sp38, 0) == 0;
  187,580 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:render_set_position (332x)
      664 ( 0.00%)      if (maxObjectsReached) {
        .                   return;
        .               }
        .           
    1,992 ( 0.00%)      if (temp < arg0->pos[2]) {
    1,328 ( 0.00%)          if (D_800DC5BC != 0) {
        .           
        .                       gDPSetFogColor(gDisplayListHead++, D_801625EC, D_801625F4, D_801625F0, 0xFF);
        .                       gSPDisplayList(gDisplayListHead++, D_0D001C20);
        .                   } else {
    3,320 ( 0.00%)              gSPDisplayList(gDisplayListHead++, D_0D001B90);
4,001,870 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (332x)
        .                   }
        .               } else if (D_800DC5BC != 0) {
        .           
        .                   gDPSetFogColor(gDisplayListHead++, D_801625EC, D_801625F4, D_801625F0, 0xFF);
        .                   gSPDisplayList(gDisplayListHead++, D_0D001C88);
        .               } else {
        .                   gSPDisplayList(gDisplayListHead++, D_0D001BD8);
        .               }
      664 ( 0.00%)  }
        .           
        .           UNUSED void func_80297524(uintptr_t addr, s32 width, s32 height) {
        .               gDPLoadTextureBlock(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(addr), G_IM_FMT_RGBA, G_IM_SIZ_16b, width, height, 0,
        .                                   G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
        .                                   G_TX_NOLOD);
        .           }
        .           
        .           void func_802976D8(Vec3s arg0) {
-- line 364 ----------------------------------------
-- line 394 ----------------------------------------
        .           
        .           void func_802977B0(Player* arg0) {
        .               arg0->tyres[FRONT_RIGHT].unk_14 |= 2;
        .               arg0->tyres[FRONT_LEFT].unk_14 |= 2;
        .               arg0->tyres[BACK_RIGHT].unk_14 |= 2;
        .               arg0->tyres[BACK_LEFT].unk_14 |= 2;
        .           }
        .           
   15,936 ( 0.00%)  void func_802977E4(Player* arg0) {
   31,872 ( 0.00%)      arg0->tyres[FRONT_RIGHT].unk_14 &= ~2 & 0xFFFF;
   31,872 ( 0.00%)      arg0->tyres[FRONT_LEFT].unk_14 &= ~2 & 0xFFFF;
   31,872 ( 0.00%)      arg0->tyres[BACK_RIGHT].unk_14 &= ~2 & 0xFFFF;
   31,872 ( 0.00%)      arg0->tyres[BACK_LEFT].unk_14 &= ~2 & 0xFFFF;
   15,936 ( 0.00%)  }
        .           
        .           // Generate the red shell tlut by invert green the green one
        3 ( 0.00%)  void init_red_shell_texture(void) {
       10 ( 0.00%)      s16* tlut = (s16*) LOAD_ASSET(common_tlut_green_shell);
   13,367 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (1x)
       64 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (1x)
        2 ( 0.00%)      s16* red_shell_texture = (s16*) &gTLUTRedShell[0];
        2 ( 0.00%)      s16* green_shell_texture = (s16*) tlut;
        .               s16 color_pixel, red_color, green_color, blue_color, alpha_color;
        .               s32 i;
        .           
      772 ( 0.00%)      for (i = 0; i < 256; i++) {
    2,304 ( 0.00%)          color_pixel = BSWAP16(*green_shell_texture);
    1,024 ( 0.00%)          red_color = BSWAP16(color_pixel & 0xF800);
    2,304 ( 0.00%)          green_color = BSWAP16(color_pixel & 0x7C0);
    1,024 ( 0.00%)          blue_color = BSWAP16(color_pixel & 0x3E);
    1,024 ( 0.00%)          alpha_color = BSWAP16(color_pixel & 0x1);
        .           
    2,816 ( 0.00%)          *red_shell_texture = (red_color >> 5) | (green_color << 5) | blue_color | alpha_color; // Invert green to red
      256 ( 0.00%)          green_shell_texture++;
      256 ( 0.00%)          red_shell_texture++;
        .               }
        4 ( 0.00%)  }
        .           
        .           UNUSED void func_80297944(void) {};
        .           
        .           void func_8029794C(Vec3f pos, Vec3s rot, f32 scale) {
        .               Mat4 sp20;
        .               pos[1] += 2.0f;
        .           
        .               mtxf_pos_rotation_xyz(sp20, pos, rot);
-- line 436 ----------------------------------------
-- line 940 ----------------------------------------
        .                                                                      temp_s0->unk30.meshIndexZX);
        .                       }
        .                       func_802976EC(&temp_s0->unk30, temp_s0->rot);
        .                   }
        .                   var_s3++;
        .               }
        .           }
        .           
        4 ( 0.00%)  void spawn_all_item_boxes(struct ActorSpawnData* spawnData) {
        .               s16 temp_s1;
        .               f32 temp_f0;
        .               Vec3f startingPos;
        .               Vec3f startingVelocity;
        .               Vec3s startingRot;
        2 ( 0.00%)      struct ActorSpawnData* temp_s0 = spawnData;
        .               // struct ItemBox *itemBox;
        .           
        8 ( 0.00%)      if ((gModeSelection == TIME_TRIALS) || (gPlaceItemBoxes == 0)) {
        .                   return;
        .               }
        .           
        7 ( 0.00%)      vec3f_set(startingVelocity, 0, 0, 0);
       20 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (1x)
       50 ( 0.00%)      while (temp_s0->pos[0] != END_OF_SPAWN_DATA) {
       88 ( 0.00%)          startingPos[0] = temp_s0->pos[0] * gCourseDirection;
       55 ( 0.00%)          startingPos[1] = temp_s0->pos[1];
       55 ( 0.00%)          startingPos[2] = temp_s0->pos[2];
       22 ( 0.00%)          startingRot[0] = random_u16();
      474 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_u16 (11x)
       22 ( 0.00%)          startingRot[1] = random_u16();
      489 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_u16 (11x)
       22 ( 0.00%)          startingRot[2] = random_u16();
      477 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_u16 (11x)
       77 ( 0.00%)          temp_s1 = add_actor_to_empty_slot(startingPos, startingRot, startingVelocity, ACTOR_ITEM_BOX);
    4,136 ( 0.00%)  => src/racing/actors.c:add_actor_to_empty_slot (11x)
      110 ( 0.00%)          temp_f0 = spawn_actor_on_surface(startingPos[0], startingPos[1] + 10.0f, startingPos[2]);
    9,005 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/collision.c:spawn_actor_on_surface (11x)
        .           
        .                   // Should be struct ItemBox but not enough space in the stack.
        .                   // It's either the ItemBox or the SEGMENT/OFFSET variables.
        .                   // itemBox = (struct ItemBox *) &gActorList[temp_s1];
        .           
      121 ( 0.00%)          gActorList[temp_s1].unk_08 = temp_f0;
        .                   // itemBox->resetDistance = temp_f0;
        .           
      121 ( 0.00%)          gActorList[temp_s1].velocity[0] = startingPos[1];
        .                   // itemBox->origY = startingPos[1];
        .           
      143 ( 0.00%)          gActorList[temp_s1].pos[1] = temp_f0 - 20.0f;
        .                   // itemBox->pos[1] = temp_f0 - 20.0f;
        .           
       11 ( 0.00%)          temp_s0++;
        .               }
        2 ( 0.00%)  }
        .           
        .           void init_kiwano_fruit(void) {
        .               Vec3f sp64;
        .               Vec3f sp58;
        .               Vec3s sp50;
        .               Player* phi_s1;
        .               struct Actor* actor;
        .               s16 phi_s0;
-- line 995 ----------------------------------------
-- line 1012 ----------------------------------------
        .               }
        .           }
        .           
        .           /**
        .            * Destroys actors via zeroing some of the member data
        .            * Key word some. When spawning a new actor,
        .            * members such as pos and rot should be set to prevent using expired data
        .            **/
        2 ( 0.00%)  void destroy_all_actors(void) {
        .               s32 i;
        2 ( 0.00%)      gNumActors = 0;
      304 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
    1,000 ( 0.00%)          gActorList[i].flags = 0;
      900 ( 0.00%)          gActorList[i].type = 0;
    1,000 ( 0.00%)          gActorList[i].unk_04 = 0;
    1,000 ( 0.00%)          gActorList[i].state = 0;
    1,100 ( 0.00%)          gActorList[i].unk_08 = 0.0f;
    1,100 ( 0.00%)          gActorList[i].boundingBoxSize = 0.0f;
        .               }
        4 ( 0.00%)  }
        .           
        3 ( 0.00%)  void spawn_course_actors(void) {
        .               UNUSED s32 pad;
        .               Vec3f position;
        6 ( 0.00%)      Vec3f velocity = { 0.0f, 0.0f, 0.0f };
        3 ( 0.00%)      Vec3s rotation = { 0, 0, 0 };
        .               struct Actor* actor;
        .               struct RailroadCrossing* rrxing;
        .           
        2 ( 0.00%)      gNumPermanentActors = 0;
        2 ( 0.00%)      CourseManager_SpawnActors();
  169,143 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_SpawnActors (1x)
        .           
        .               // switch (gCurrentCourseId) {
        .               //     case COURSE_MARIO_RACEWAY:
        .               //         // spawn_foliage(d_course_mario_raceway_tree_spawns);
        .               //         // spawn_piranha_plants(d_course_mario_raceway_piranha_plant_spawns);
        .               //         // spawn_all_item_boxes(d_course_mario_raceway_item_box_spawns);
        .               //         // vec3f_set(position, 150.0f, 40.0f, -1300.0f);
        .               //         // position[0] *= gCourseDirection;
-- line 1050 ----------------------------------------
-- line 1155 ----------------------------------------
        .               //         spawn_all_item_boxes(d_course_dks_jungle_parkway_item_box_spawns);
        .               //         init_kiwano_fruit();
        .               //         func_80298D10();
        .               //         break;
        .               //     case COURSE_BIG_DONUT:
        .               //         spawn_all_item_boxes(d_course_big_donut_item_box_spawns);
        .               //         break;
        .               // }
        4 ( 0.00%)      gNumPermanentActors = gNumActors;
        3 ( 0.00%)  }
        .           
        .           /**
        .            * @brief Loads actor textures, course specific actor textures.
        .            * Calls to spawn_course_vehicles and place_course_actors
        .            *
        .            */
        2 ( 0.00%)  void init_actors_and_load_textures(void) {
        5 ( 0.00%)      set_segment_base_addr_x64(3, (void*) gNextFreeMemoryAddress);
       15 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:set_segment_base_addr_x64 (1x)
        7 ( 0.00%)      D_802BA050 = dma_textures(gTextureGreenShell0, 0x00000257U, 0x00000400U);
   13,759 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell1, 0x00000242U, 0x00000400U);
   13,688 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell2, 0x00000259U, 0x00000400U);
   14,629 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell3, 0x00000256U, 0x00000400U);
   12,794 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell4, 0x00000246U, 0x00000400U);
   13,371 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell5, 0x0000025EU, 0x00000400U);
   14,876 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell6, 0x0000025CU, 0x00000400U);
   12,780 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureGreenShell7, 0x00000254U, 0x00000400U);
   13,933 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        7 ( 0.00%)      D_802BA054 = dma_textures(gTextureBlueShell0, 0x0000022AU, 0x00000400U);
   13,659 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell1, 0x00000237U, 0x00000400U);
   12,784 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell2, 0x0000023EU, 0x00000400U);
   14,015 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell3, 0x00000243U, 0x00000400U);
   13,616 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell4, 0x00000255U, 0x00000400U);
   13,671 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell5, 0x00000259U, 0x00000400U);
   13,772 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell6, 0x00000239U, 0x00000400U);
   13,268 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureBlueShell7, 0x00000236U, 0x00000400U);
   14,024 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner1, 0x0000028EU, 0x00000800U);
   13,969 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner2, 0x000002FBU, 0x00000800U);
   13,561 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner3, 0x00000302U, 0x00000800U);
   14,592 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner4, 0x000003B4U, 0x00000800U);
   12,983 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner5, 0x0000031EU, 0x00000800U);
   14,057 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner6, 0x0000036EU, 0x00000800U);
   12,971 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner7, 0x0000029CU, 0x00000800U);
   13,917 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTextureFinishLineBanner8, 0x0000025BU, 0x00000800U);
   14,927 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTexture671A88, 0x00000400U, 0x00000800U);
   13,778 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        5 ( 0.00%)      dma_textures(gTexture6774D8, 0x00000400U, 0x00000800U);
   13,725 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        .           
        2 ( 0.00%)      CourseManager_LoadTextures();
  137,877 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_LoadTextures (1x)
        .           
        1 ( 0.00%)      init_red_shell_texture();
   25,232 ( 0.00%)  => src/racing/actors.c:init_red_shell_texture (1x)
        1 ( 0.00%)      destroy_all_actors();
    6,412 ( 0.00%)  => src/racing/actors.c:destroy_all_actors (1x)
        1 ( 0.00%)      spawn_course_actors();
  169,166 ( 0.00%)  => src/racing/actors.c:spawn_course_actors (1x)
        .           
        2 ( 0.00%)      CourseManager_VehiclesSpawn();
   20,528 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_VehiclesSpawn (1x)
        .           
        .               // spawn_course_vehicles();
        3 ( 0.00%)  }
        .           
        .           void play_sound_before_despawn(struct Actor* actor) {
        .               s16 flags = actor->flags;
        .           
        .               if ((flags & 0x200) != 0) {
        .                   func_800C99E0(actor->pos, SOUND_ARG_LOAD(0x19, 0x01, 0x90, 0x53));
        .                   return;
        .               }
-- line 1217 ----------------------------------------
-- line 1359 ----------------------------------------
        .                           break;
        .                   }
        .               }
        .           
        .               return -1;
        .           }
        .           
        .           // returns actor index if any slot avaible returns -1
      232 ( 0.00%)  s16 add_actor_to_empty_slot(Vec3f pos, Vec3s rot, Vec3f velocity, s16 actorType) {
        .               s32 index;
        .           
      116 ( 0.00%)      if (gNumActors >= ACTOR_LIST_SIZE) {
        .                   return try_remove_destructable_item(pos, rot, velocity, actorType);
        .               }
    1,334 ( 0.00%)      for (index = 0; index < ACTOR_LIST_SIZE; index++) {
    5,220 ( 0.00%)          if (gActorList[index].flags == 0) {
      145 ( 0.00%)              gNumActors++;
      435 ( 0.00%)              actor_init(&gActorList[index], pos, rot, velocity, actorType);
    7,033 ( 0.00%)  => src/racing/actors.c:actor_init (29x)
       58 ( 0.00%)              return index;
        .                   }
        .               }
        .               return -1;
       58 ( 0.00%)  }
        .           
        .           UNUSED s16 spawn_actor_at_pos(Vec3f pos, s16 actorType) {
        .               Vec3f vel;
        .               Vec3s rot;
        .           
        .               vec3f_set(vel, 0.0f, 0.0f, 0.0f);
        .               vec3s_set(rot, 0, 0, 0);
        .               return add_actor_to_empty_slot(pos, rot, vel, actorType);
-- line 1389 ----------------------------------------
-- line 1680 ----------------------------------------
        .                   player->velocity[2] -= z_dist * temp_f12;
        .                   temp_f2 = xz_dist - var_f16;
        .                   player->pos[0] += x_dist * temp_f2 * 0.5f;
        .                   player->pos[2] += z_dist * temp_f2 * 0.5f;
        .               }
        .               return true;
        .           }
        .           
  279,852 ( 0.00%)  bool query_collision_player_vs_actor_item(Player* arg0, struct Actor* arg1) {
        .               f32 temp_f0;
        .               f32 dist;
        .               f32 yDist;
        .               f32 zDist;
        .               f32 xDist;
        .           
  419,778 ( 0.00%)      temp_f0 = arg0->boundingBoxSize + arg1->boundingBoxSize;
  419,778 ( 0.00%)      xDist = arg1->pos[0] - arg0->pos[0];
  209,889 ( 0.00%)      if (temp_f0 < xDist) {
  125,200 ( 0.00%)          return NO_COLLISION;
        .               }
   36,815 ( 0.00%)      if (xDist < -temp_f0) {
   13,968 ( 0.00%)          return NO_COLLISION;
        .               }
    2,274 ( 0.00%)      yDist = arg1->pos[1] - arg0->pos[1];
    1,137 ( 0.00%)      if (temp_f0 < yDist) {
        .                   return NO_COLLISION;
        .               }
    1,895 ( 0.00%)      if (yDist < -temp_f0) {
        .                   return NO_COLLISION;
        .               }
    2,274 ( 0.00%)      zDist = arg1->pos[2] - arg0->pos[2];
    1,137 ( 0.00%)      if (temp_f0 < zDist) {
        .                   return NO_COLLISION;
        .               }
    1,895 ( 0.00%)      if (zDist < -temp_f0) {
      758 ( 0.00%)          return NO_COLLISION;
        .               }
        .               dist = (xDist * xDist) + (yDist * yDist) + (zDist * zDist);
        .               if (dist < 0.1f) {
        .                   return NO_COLLISION;
        .               }
        .               if ((temp_f0 * temp_f0) < dist) {
        .                   return NO_COLLISION;
        .               }
        .               return COLLISION;
  139,926 ( 0.00%)  }
        .           
        .           bool query_collision_actor_vs_actor(struct Actor* arg0, struct Actor* arg1) {
        .               f32 temp_f0;
        .               f32 dist;
        .               f32 dist_y;
        .               f32 dist_z;
        .               f32 dist_x;
        .           
-- line 1733 ----------------------------------------
-- line 1972 ----------------------------------------
        .                       }
        .                   } else {
        .                       destroy_destructable_actor(actor2); // automatically destroy if it's something different of a blueshell
        .                   }
        .                   play_sound_on_destructible_actor_collision(actor1, actor2);
        .               }
        .           }
        .           
  349,815 ( 0.00%)  void evaluate_collision_between_player_actor(Player* player, struct Actor* actor) {
        .               UNUSED s32 pad;
        .               s16 temp_lo;
        .               UNUSED s32 pad2[2];
        .               s16 temp_v1;
        .               Player* owner;
        .               f32 temp_f0;
        .               f32 temp_f2;
        .           
  559,704 ( 0.00%)      temp_lo = player - gPlayerOne;
  909,519 ( 0.00%)      switch (actor->type) {
        .                   case ACTOR_YOSHI_EGG:
        .                       if (!(player->effects & BOO_EFFECT) && !(player->type & PLAYER_INVISIBLE_OR_BOMB)) {
        .                           collision_yoshi_egg(player, (struct YoshiValleyEgg*) actor);
        .                       }
        .                       break;
        .                   case ACTOR_BANANA:
        .                       if (player->effects & (BOO_EFFECT | 0x8C0)) {
        .                           break;
-- line 1998 ----------------------------------------
-- line 2108 ----------------------------------------
        .                   case ACTOR_CACTUS2_KALAMARI_DESERT:
        .                   case ACTOR_CACTUS3_KALAMARI_DESERT:
        .                   case ACTOR_BUSH_BOWSERS_CASTLE:
        .                       if (!(player->effects & BOO_EFFECT)) {
        .                           collision_tree(player, actor);
        .                       }
        .                       break;
        .                   case ACTOR_FALLING_ROCK:
  159,360 ( 0.00%)              if (!(player->effects & BOO_EFFECT) && !(player->type & PLAYER_INVISIBLE_OR_BOMB)) {
  111,552 ( 0.00%)                  if (query_collision_player_vs_actor_item(player, actor) == COLLISION) {
  366,528 ( 0.00%)  => src/racing/actors.c:query_collision_player_vs_actor_item (15,936x)
        .                               func_800C98B8(actor->pos, actor->velocity, SOUND_ACTION_EXPLOSION);
        .                               if ((gModeSelection == TIME_TRIALS) && !(player->type & PLAYER_KART_AI)) {
        .                                   D_80162DF8 = 1;
        .                               }
        .                               if (player->effects & STAR_EFFECT) {
        .                                   actor->velocity[1] = 10.0f;
        .                               } else {
        .                                   apply_hit_sound_effect(player, player - gPlayerOne);
        .                               }
        .                           }
        .                       }
   31,872 ( 0.00%)              break;
        .                   case ACTOR_FAKE_ITEM_BOX:
        .                       temp_v1 = actor->velocity[0];
        .                       if (player->effects & BOO_EFFECT) {
        .                           break;
        .                       }
        .                       temp_v1 = actor->velocity[0];
        .                       if (((temp_lo == temp_v1) && (actor->flags & 0x1000)) ||
        .                           (query_collision_player_vs_actor_item(player, actor) != COLLISION)) {
-- line 2137 ----------------------------------------
-- line 2168 ----------------------------------------
        .                               func_8007ABFC(player - gPlayerOne, 7);
        .                           }
        .                       } else if (actor->state == 0) {
        .                           actor->state = 1;
        .                           actor->flags = -0x8000;
        .                       }
        .                       break;
        .                   case ACTOR_ITEM_BOX:
  378,189 ( 0.00%)              if (query_collision_player_vs_actor_item(player, actor) == COLLISION) {
1,290,048 ( 0.00%)  => src/racing/actors.c:query_collision_player_vs_actor_item (54,027x)
        .                           actor->state = 3;
        .                           actor->flags = -0x8000;
        .                           actor->unk_04 = 0;
        .                           if (player->type & PLAYER_HUMAN) {
        .                               func_8007ABFC(player - gPlayerOne, 0);
        .                           }
  216,108 ( 0.00%)              } else if (actor->state == 0) {
       22 ( 0.00%)                  actor->state = 1;
       22 ( 0.00%)                  actor->flags = -0x8000;
        .                       }
   54,038 ( 0.00%)              break;
        .                   default:
        .                       break;
        .               }
  209,889 ( 0.00%)  }
        .           
    1,992 ( 0.00%)  void evaluate_collision_for_players_and_actors(void) {
        .               struct Actor* temp_a1;
        .               s32 i, j;
        .               Player* phi_s1;
        .           
   18,592 ( 0.00%)      for (i = 0; i < NUM_PLAYERS; i++) {
   31,872 ( 0.00%)          phi_s1 = &gPlayers[i];
        .           
   47,808 ( 0.00%)          if (((phi_s1->type & 0x8000) != 0) && ((phi_s1->effects & 0x4000000) == 0)) {
   15,936 ( 0.00%)              func_802977E4(phi_s1);
  159,360 ( 0.00%)  => src/racing/actors.c:func_802977E4 (5,312x)
1,614,848 ( 0.00%)              for (j = 0; j < ACTOR_LIST_SIZE; j++) {
4,780,800 ( 0.00%)                  temp_a1 = &gActorList[j];
        .           
2,656,000 ( 0.00%)                  if ((phi_s1->effects & 0x4000000) == 0) {
        .                               // temp_v0 = temp_a1->unk2;
3,049,088 ( 0.00%)                      if (((temp_a1->flags & 0x8000) != 0) && ((temp_a1->flags & 0x4000) != 0)) {
  349,815 ( 0.00%)                          evaluate_collision_between_player_actor(phi_s1, temp_a1);
4,636,666 ( 0.00%)  => src/racing/actors.c:evaluate_collision_between_player_actor (69,963x)
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
    2,656 ( 0.00%)  }
        .           
        .           // It's look like to check collision between item and other different item
    1,992 ( 0.00%)  void evaluate_collision_for_destructible_actors(void) {
        .               struct Actor* actor1;
        .               struct Actor* actor2;
        .               s32 i, j;
        .               UNUSED s32 pad;
        .           
  171,976 ( 0.00%)      for (i = gNumPermanentActors; i < (ACTOR_LIST_SIZE - 1); i++) {
  501,984 ( 0.00%)          actor1 = &gActorList[i];
        .           
  223,104 ( 0.00%)          if ((actor1->flags & 0x8000) == 0) {
   92,960 ( 0.00%)              continue;
        .                   }
   55,776 ( 0.00%)          if ((actor1->flags & 0x4000) == 0) {
    9,296 ( 0.00%)              continue;
        .                   }
        .           
        .                   switch (actor1->type) {
        .                       case ACTOR_BANANA:
        .                       case ACTOR_GREEN_SHELL:
        .                       case ACTOR_RED_SHELL:
        .                       case ACTOR_BLUE_SPINY_SHELL:
        .                       case ACTOR_FAKE_ITEM_BOX:
-- line 2239 ----------------------------------------
-- line 2283 ----------------------------------------
        .                                       evaluate_actor_collision_between_two_destructible_actors(actor1, actor2);
        .                                       break;
        .                               }
        .                           }
        .           
        .                           break;
        .                   }
        .               }
    2,656 ( 0.00%)  }
        .           
        .           void func_802A1064(struct FakeItemBox* fake_item_box) {
        .               if ((u32) (fake_item_box - (struct FakeItemBox*) gActorList) <= (u32) ACTOR_LIST_SIZE) {
        .                   if (((fake_item_box->flags & 0x8000) != 0) && (fake_item_box->type == ACTOR_FAKE_ITEM_BOX)) {
        .                       fake_item_box->state = 1;
        .                       fake_item_box->targetY = func_802ABEAC(&fake_item_box->unk30, fake_item_box->pos) + 8.66f;
        .                       fake_item_box->someTimer = 100;
        .                   }
-- line 2299 ----------------------------------------
-- line 2332 ----------------------------------------
        .           #include "actors/yoshi_egg/render.inc.c"
        .           
        .           #include "actors/mario_sign/render.inc.c"
        .           
        .           #include "actors/railroad_crossing/render.inc.c"
        .           
        .           #include "actors/palm_tree/render.inc.c"
        .           
    1,328 ( 0.00%)  void render_item_boxes(struct UnkStruct_800DC5EC* arg0) {
      996 ( 0.00%)      Camera* camera = arg0->camera;
        .               struct Actor* actor;
        .               s32 i;
      664 ( 0.00%)      D_8015F8DC = 0;
        .           
  100,928 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
  298,800 ( 0.00%)          actor = &gActorList[i];
        .           
  132,800 ( 0.00%)          if (actor->flags == 0) {
   23,572 ( 0.00%)              continue;
        .                   }
        .           
   98,604 ( 0.00%)          switch (actor->type) {
        .                       case ACTOR_FAKE_ITEM_BOX:
        .                           render_actor_fake_item_box(camera, (struct FakeItemBox*) actor);
        .                           break;
        .                       case ACTOR_ITEM_BOX:
   18,260 ( 0.00%)                  render_actor_item_box(camera, (struct ItemBox*) actor);
9,960,261 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/item_box/render.inc.c:render_actor_item_box (3,652x)
    3,652 ( 0.00%)                  break;
        .                       case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
        .                           render_actor_item_box(camera, (struct ItemBox*) actor);
        .                           break;
        .                   }
        .               }
    1,328 ( 0.00%)  }
        .           
    1,660 ( 0.00%)  void render_course_actors(struct UnkStruct_800DC5EC* arg0) {
      996 ( 0.00%)      Camera* camera = arg0->camera;
      996 ( 0.00%)      u16 pathCounter = arg0->pathCounter;
        .               UNUSED s32 pad[12];
        .               s32 i;
        .           
        .               struct Actor* actor;
    1,992 ( 0.00%)      UNUSED Vec3f sp4C = { 0.0f, 5.0f, 10.0f };
    2,656 ( 0.00%)      f32 sp48 = sins(camera->rot[1] - 0x8000); // unk26;
    3,984 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (332x)
    2,656 ( 0.00%)      f32 temp_f0 = coss(camera->rot[1] - 0x8000);
    4,648 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (332x)
        .           
      996 ( 0.00%)      D_801502C0[0][0] = temp_f0;
    1,660 ( 0.00%)      D_801502C0[0][2] = -sp48;
      996 ( 0.00%)      D_801502C0[2][2] = temp_f0;
      996 ( 0.00%)      D_801502C0[1][0] = 0.0f;
      996 ( 0.00%)      D_801502C0[0][1] = 0.0f;
      996 ( 0.00%)      D_801502C0[2][1] = 0.0f;
      996 ( 0.00%)      D_801502C0[1][2] = 0.0f;
      996 ( 0.00%)      D_801502C0[0][3] = 0.0f;
      996 ( 0.00%)      D_801502C0[1][3] = 0.0f;
      996 ( 0.00%)      D_801502C0[2][3] = 0.0f; // 2c
      996 ( 0.00%)      D_801502C0[2][0] = sp48;
      996 ( 0.00%)      D_801502C0[1][1] = 1.0f;
      996 ( 0.00%)      D_801502C0[3][3] = 1.0f; // unk3c
        .           
    3,652 ( 0.00%)      gSPClearGeometryMode(gDisplayListHead++, G_LIGHTING);
   11,952 ( 0.00%)      gSPSetLights1(gDisplayListHead++, D_800DC610[1]);
    3,984 ( 0.00%)      gSPTexture(gDisplayListHead++, 0xFFFF, 0xFFFF, 0, G_TX_RENDERTILE, G_ON);
        .           
    1,660 ( 0.00%)      CourseManager_DrawActors(D_800DC5EC->camera);
26,783,436 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_DrawActors (332x)
        .           
    1,328 ( 0.00%)      if (gModeSelection != BATTLE) {
      996 ( 0.00%)          func_80297340(camera);
4,299,010 ( 0.00%)  => src/racing/actors.c:func_80297340 (332x)
        .               }
      664 ( 0.00%)      D_8015F8E0 = 0;
        .           
  100,928 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
  298,800 ( 0.00%)          actor = &gActorList[i];
        .           
  132,800 ( 0.00%)          if (actor->flags == 0) {
   23,572 ( 0.00%)              continue;
        .                   }
  125,164 ( 0.00%)          switch (actor->type) {
        .                       case ACTOR_TREE_MARIO_RACEWAY:
        .                           render_actor_tree_mario_raceway(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_TREE_YOSHI_VALLEY:
        .                           render_actor_tree_yoshi_valley(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_TREE_ROYAL_RACEWAY:
        .                           render_actor_tree_royal_raceway(camera, D_801502C0, actor);
-- line 2417 ----------------------------------------
-- line 2436 ----------------------------------------
        .                           break;
        .                       case ACTOR_CACTUS2_KALAMARI_DESERT:
        .                           render_actor_tree_cactus2_kalimari_desert(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_CACTUS3_KALAMARI_DESERT:
        .                           render_actor_tree_cactus3_kalimari_desert(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_FALLING_ROCK:
    4,980 ( 0.00%)                  render_actor_falling_rock(camera, (struct FallingRock*) actor);
2,076,546 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/falling_rock/render.inc.c:render_actor_falling_rock (996x)
      996 ( 0.00%)                  break;
        .                       case ACTOR_KIWANO_FRUIT:
        .                           render_actor_kiwano_fruit(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_BANANA:
        .                           render_actor_banana(camera, D_801502C0, (struct BananaActor*) actor);
        .                           break;
        .                       case ACTOR_GREEN_SHELL:
        .                           render_actor_green_shell(camera, D_801502C0, (struct ShellActor*) actor);
-- line 2453 ----------------------------------------
-- line 2457 ----------------------------------------
        .                           break;
        .                       case ACTOR_BLUE_SPINY_SHELL:
        .                           render_actor_blue_shell(camera, D_801502C0, (struct ShellActor*) actor);
        .                           break;
        .                       case ACTOR_PIRANHA_PLANT:
        .                           render_actor_piranha_plant(camera, D_801502C0, (struct PiranhaPlant*) actor);
        .                           break;
        .                       case ACTOR_TRAIN_ENGINE:
    3,320 ( 0.00%)                  render_actor_train_engine(camera, (struct TrainCar*) actor);
17,835,844 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/render.inc.c:render_actor_train_engine (664x)
      664 ( 0.00%)                  break;
        .                       case ACTOR_TRAIN_TENDER:
    3,320 ( 0.00%)                  render_actor_train_tender(camera, (struct TrainCar*) actor);
15,206,297 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/render.inc.c:render_actor_train_tender (664x)
      664 ( 0.00%)                  break;
        .                       case ACTOR_TRAIN_PASSENGER_CAR:
   16,600 ( 0.00%)                  render_actor_train_passenger_car(camera, (struct TrainCar*) actor);
114,868,456 ( 0.10%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/render.inc.c:render_actor_train_passenger_car (3,320x)
    3,320 ( 0.00%)                  break;
        .                       case ACTOR_COW:
        .                           render_actor_cow(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_UNKNOWN_0x14:
        .                           func_8029AC18(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_MARIO_SIGN:
        .                           render_actor_mario_sign(camera, D_801502C0, actor);
-- line 2480 ----------------------------------------
-- line 2496 ----------------------------------------
        .                           break;
        .                       case ACTOR_TANKER_TRUCK:
        .                           render_actor_tanker_truck(camera, actor);
        .                           break;
        .                       case ACTOR_CAR:
        .                           render_actor_car(camera, actor);
        .                           break;
        .                       case ACTOR_RAILROAD_CROSSING:
    1,660 ( 0.00%)                  render_actor_railroad_crossing(camera, (struct RailroadCrossing*) actor);
4,973,660 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/railroad_crossing/render.inc.c:render_actor_railroad_crossing (332x)
      332 ( 0.00%)                  break;
        .                       case ACTOR_YOSHI_EGG:
        .                           render_actor_yoshi_egg(camera, D_801502C0, (struct YoshiValleyEgg*) actor, pathCounter);
        .                           break;
        .                   }
        .               }
    1,660 ( 0.00%)      if (GetCourse() == GetMooMooFarm()) {
    1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (332x)
    1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetMooMooFarm (332x)
        .                   render_cows(camera, D_801502C0, actor);
    1,660 ( 0.00%)      } else if (GetCourse() == GetDkJungle()) {
    1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (332x)
    1,992 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetDkJungle (332x)
        .                   render_palm_trees(camera, D_801502C0, actor);
        .               }
    1,328 ( 0.00%)  }
        .           
    1,992 ( 0.00%)  void update_course_actors(void) {
        .               struct Actor* actor;
        .               s32 i;
  201,856 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
        .           
  597,600 ( 0.00%)          actor = &gActorList[i];
  265,600 ( 0.00%)          if (actor->flags == 0) {
   47,144 ( 0.00%)              continue;
        .                   }
        .           
  250,328 ( 0.00%)          switch (actor->type) {
        .                       case ACTOR_FALLING_ROCK:
    5,976 ( 0.00%)                  update_actor_falling_rocks((struct FallingRock*) actor);
  465,957 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/falling_rock/update.inc.c:update_actor_falling_rocks (1,992x)
    1,992 ( 0.00%)                  break;
        .                       case ACTOR_GREEN_SHELL:
        .                           update_actor_green_shell((struct ShellActor*) actor);
        .                           break;
        .                       case ACTOR_RED_SHELL:
        .                           update_actor_red_blue_shell((struct ShellActor*) actor);
        .                           break;
        .                       case ACTOR_BLUE_SPINY_SHELL:
        .                           update_actor_red_blue_shell((struct ShellActor*) actor);
-- line 2539 ----------------------------------------
-- line 2543 ----------------------------------------
        .                           break;
        .                       case ACTOR_BANANA:
        .                           update_actor_banana((struct BananaActor*) actor);
        .                           break;
        .                       case ACTOR_PADDLE_BOAT:
        .                           update_actor_paddle_boat((struct PaddleWheelBoat*) actor);
        .                           break;
        .                       case ACTOR_TRAIN_ENGINE:
    3,984 ( 0.00%)                  update_actor_train_engine((struct TrainCar*) actor);
   28,632 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/update.inc.c:update_actor_train_engine (1,328x)
    1,328 ( 0.00%)                  break;
        .                       case ACTOR_TRAIN_TENDER:
    3,984 ( 0.00%)                  update_actor_train_tender((struct TrainCar*) actor);
   15,936 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/update.inc.c:update_actor_train_tender (1,328x)
    1,328 ( 0.00%)                  break;
        .                       case ACTOR_TRAIN_PASSENGER_CAR:
   19,920 ( 0.00%)                  update_actor_train_passenger_car((struct TrainCar*) actor);
   79,680 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/update.inc.c:update_actor_train_passenger_car (6,640x)
    6,640 ( 0.00%)                  break;
        .                       case ACTOR_ITEM_BOX:
   21,912 ( 0.00%)                  update_actor_item_box((struct ItemBox*) actor);
  249,484 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/item_box/update.inc.c:update_actor_item_box (7,304x)
    7,304 ( 0.00%)                  break;
        .                       case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
        .                           update_actor_item_box_hot_air_balloon((struct ItemBox*) actor);
        .                           break;
        .                       case ACTOR_FAKE_ITEM_BOX:
        .                           update_actor_fake_item_box((struct FakeItemBox*) actor);
        .                           break;
        .                       case ACTOR_PIRANHA_PLANT:
        .                           update_actor_piranha_plant((struct PiranhaPlant*) actor);
-- line 2569 ----------------------------------------
-- line 2579 ----------------------------------------
        .                           break;
        .                       case ACTOR_MARIO_SIGN:
        .                           update_actor_mario_sign(actor);
        .                           break;
        .                       case ACTOR_WARIO_SIGN:
        .                           update_actor_wario_sign(actor);
        .                           break;
        .                       case ACTOR_RAILROAD_CROSSING:
    1,992 ( 0.00%)                  update_actor_railroad_crossing((struct RailroadCrossing*) actor);
   22,086 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/railroad_crossing/update.inc.c:update_actor_railroad_crossing (664x)
      664 ( 0.00%)                  break;
        .                       case ACTOR_TREE_MARIO_RACEWAY:
        .                       case ACTOR_TREE_YOSHI_VALLEY:
        .                       case ACTOR_TREE_ROYAL_RACEWAY:
        .                       case ACTOR_TREE_MOO_MOO_FARM:
        .                       case ACTOR_PALM_TREE:
        .                       case ACTOR_UNKNOWN_0x1A: // A plant?
        .                       case ACTOR_UNKNOWN_0x1B:
        .                       case ACTOR_TREE_BOWSERS_CASTLE:
-- line 2596 ----------------------------------------
-- line 2601 ----------------------------------------
        .                       case ACTOR_BUSH_BOWSERS_CASTLE:
        .                           update_actor_static_plant(actor);
        .                           break;
        .                       case ACTOR_YOSHI_EGG:
        .                           update_actor_yoshi_egg((struct YoshiValleyEgg*) actor);
        .                           break;
        .                   }
        .               }
      664 ( 0.00%)      evaluate_collision_for_destructible_actors();
1,059,744 ( 0.00%)  => src/racing/actors.c:evaluate_collision_for_destructible_actors (664x)
      664 ( 0.00%)      check_player_use_item();
  221,776 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/actors_extended.c:check_player_use_item (664x)
    1,992 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/ext/atomicity.h
--------------------------------------------------------------------------------
Ir                  

-- line 44 ----------------------------------------
         .           
         .             __attribute__((__always_inline__))
         .             inline bool
         .             __is_single_threaded() _GLIBCXX_NOTHROW
         .             {
         .           #ifndef __GTHREADS
         .               return true;
         .           #elif __has_include(<sys/single_threaded.h>)
13,733,377 ( 0.01%)      return ::__libc_single_threaded;
         .           #else
         .               return !__gthread_active_p();
         .           #endif
         .             }
         .           
         .             // Functions for portable atomic access.
         .             // To abstract locking primitives across all thread policies, use:
         .             // __exchange_and_add_dispatch
         .             // __atomic_add_dispatch
         .           #ifdef _GLIBCXX_ATOMIC_BUILTINS
         .             inline _Atomic_word
         .             __attribute__((__always_inline__))
         .             __exchange_and_add(volatile _Atomic_word* __mem, int __val)
 7,638,164 ( 0.01%)    { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
         .           
         .             inline void
         .             __attribute__((__always_inline__))
         .             __atomic_add(volatile _Atomic_word* __mem, int __val)
 6,099,142 ( 0.01%)    { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
         .           #else
         .             _Atomic_word
         .             __exchange_and_add(volatile _Atomic_word*, int) _GLIBCXX_NOTHROW;
         .           
         .             void
         .             __atomic_add(volatile _Atomic_word*, int) _GLIBCXX_NOTHROW;
         .           #endif
         .           
         .             inline _Atomic_word
         .             __attribute__((__always_inline__))
         .             __exchange_and_add_single(_Atomic_word* __mem, int __val)
         .             {
         3 ( 0.00%)      _Atomic_word __result = *__mem;
         6 ( 0.00%)      *__mem += __val;
         1 ( 0.00%)      return __result;
         .             }
         .           
         .             inline void
         .             __attribute__((__always_inline__))
         .             __atomic_add_single(_Atomic_word* __mem, int __val)
 6,099,171 ( 0.01%)    { *__mem += __val; }
         .           
         .             inline _Atomic_word
         .             __attribute__ ((__always_inline__))
         .             __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
         .             {
 3,823,034 ( 0.00%)      if (__is_single_threaded())
 7,630,273 ( 0.01%)        return __exchange_and_add_single(__mem, __val);
         .               else
 1,911,513 ( 0.00%)        return __exchange_and_add(__mem, __val);
         .             }
         .           
         .             inline void
         .             __attribute__ ((__always_inline__))
         .             __atomic_add_dispatch(_Atomic_word* __mem, int __val)
         .             {
 3,049,604 ( 0.00%)      if (__is_single_threaded())
         .                 __atomic_add_single(__mem, __val);
         .               else
         .                 __atomic_add(__mem, __val);
 1,524,789 ( 0.00%)    }
         .           
         .           _GLIBCXX_END_NAMESPACE_VERSION
         .           } // namespace
         .           
         .           // Even if the CPU doesn't need a memory barrier, we need to ensure
         .           // that the compiler doesn't reorder memory accesses across the
         .           // barriers.
         .           #ifndef _GLIBCXX_READ_MEM_BARRIER
-- line 120 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_tree.h
--------------------------------------------------------------------------------
Ir                 

-- line 100 ----------------------------------------
        .               typedef const _Rb_tree_node_base* _Const_Base_ptr;
        .           
        .               _Rb_tree_color	_M_color;
        .               _Base_ptr		_M_parent;
        .               _Base_ptr		_M_left;
        .               _Base_ptr		_M_right;
        .           
        .               static _Base_ptr
      342 ( 0.00%)      _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
        .               {
    1,291 ( 0.00%)        while (__x->_M_left != 0) __x = __x->_M_left;
      114 ( 0.00%)        return __x;
      228 ( 0.00%)      }
        .           
        .               static _Const_Base_ptr
        .               _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
        .               {
        .                 while (__x->_M_left != 0) __x = __x->_M_left;
        .                 return __x;
        .               }
        .           
        .               static _Base_ptr
      342 ( 0.00%)      _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
        .               {
    1,781 ( 0.00%)        while (__x->_M_right != 0) __x = __x->_M_right;
      114 ( 0.00%)        return __x;
      228 ( 0.00%)      }
        .           
        .               static _Const_Base_ptr
        .               _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
        .               {
        .                 while (__x->_M_right != 0) __x = __x->_M_right;
        .                 return __x;
        .               }
        .             };
        .           
        .             // Helper type offering value initialization guarantee on the compare functor.
        .             template<typename _Key_compare>
        .               struct _Rb_tree_key_compare
        .               {
        .                 _Key_compare		_M_key_compare;
        .           
    2,223 ( 0.00%)        _Rb_tree_key_compare()
        .                 _GLIBCXX_NOEXCEPT_IF(
        .           	is_nothrow_default_constructible<_Key_compare>::value)
        .                 : _M_key_compare()
    2,223 ( 0.00%)        { }
        .           
      456 ( 0.00%)        _Rb_tree_key_compare(const _Key_compare& __comp)
        .                 : _M_key_compare(__comp)
      342 ( 0.00%)        { }
        .           
        .           #if __cplusplus >= 201103L
        .                 // Copy constructor added for consistency with C++98 mode.
        .                 _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;
        .           
        .                 _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
        .           	noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
        .                 : _M_key_compare(__x._M_key_compare)
-- line 158 ----------------------------------------
-- line 161 ----------------------------------------
        .               };
        .           
        .             // Helper type to manage default initialization of node count and header.
        .             struct _Rb_tree_header
        .             {
        .               _Rb_tree_node_base	_M_header;
        .               size_t		_M_node_count; // Keeps track of size of tree.
        .           
    3,420 ( 0.00%)      _Rb_tree_header() _GLIBCXX_NOEXCEPT
        .               {
    1,710 ( 0.00%)        _M_header._M_color = _S_red;
    2,565 ( 0.00%)        _M_reset();
   13,680 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_header::_M_reset() (855x)
    2,565 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201103L
        .               _Rb_tree_header(_Rb_tree_header&& __x) noexcept
        .               {
        .                 if (__x._M_header._M_parent != nullptr)
        .           	_M_move_data(__x);
        .                 else
        .           	{
-- line 181 ----------------------------------------
-- line 194 ----------------------------------------
        .                 _M_header._M_right = __from._M_header._M_right;
        .                 _M_header._M_parent->_M_parent = &_M_header;
        .                 _M_node_count = __from._M_node_count;
        .           
        .                 __from._M_reset();
        .               }
        .           
        .               void
    6,039 ( 0.00%)      _M_reset()
        .               {
    4,026 ( 0.00%)        _M_header._M_parent = 0;
    6,039 ( 0.00%)        _M_header._M_left = &_M_header;
    6,039 ( 0.00%)        _M_header._M_right = &_M_header;
    4,026 ( 0.00%)        _M_node_count = 0;
    6,039 ( 0.00%)      }
        .             };
        .           
        .             template<typename _Val>
        .               struct _Rb_tree_node : public _Rb_tree_node_base
        .               {
        .                 typedef _Rb_tree_node<_Val>* _Link_type;
        .           
        .           #if __cplusplus < 201103L
-- line 216 ----------------------------------------
-- line 222 ----------------------------------------
        .           
        .                 const _Val*
        .                 _M_valptr() const
        .                 { return std::__addressof(_M_value_field); }
        .           #else
        .                 __gnu_cxx::__aligned_membuf<_Val> _M_storage;
        .           
        .                 _Val*
4,664,228 ( 0.00%)        _M_valptr()
6,996,342 ( 0.01%)        { return _M_storage._M_ptr(); }
  479,595 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_ptr() (31,973x)
        .           
        .                 const _Val*
  611,256 ( 0.00%)        _M_valptr() const
  916,884 ( 0.00%)        { return _M_storage._M_ptr(); }
    3,090 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_membuf<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >::_M_ptr() const (206x)
        .           #endif
        .               };
        .           
        .             _GLIBCXX_PURE _Rb_tree_node_base*
        .             _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
        .           
        .             _GLIBCXX_PURE const _Rb_tree_node_base*
        .             _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
-- line 243 ----------------------------------------
-- line 257 ----------------------------------------
        .           
        .                 typedef bidirectional_iterator_tag iterator_category;
        .                 typedef ptrdiff_t			 difference_type;
        .           
        .                 typedef _Rb_tree_iterator<_Tp>		_Self;
        .                 typedef _Rb_tree_node_base::_Base_ptr	_Base_ptr;
        .                 typedef _Rb_tree_node<_Tp>*		_Link_type;
        .           
      315 ( 0.00%)        _Rb_tree_iterator() _GLIBCXX_NOEXCEPT
      525 ( 0.00%)        : _M_node() { }
        .           
        .                 explicit
3,720,308 ( 0.00%)        _Rb_tree_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
5,580,462 ( 0.00%)        : _M_node(__x) { }
        .           
        .                 reference
   74,780 ( 0.00%)        operator*() const _GLIBCXX_NOEXCEPT
  112,170 ( 0.00%)        { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
  121,825 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >::_M_valptr() (4,873x)
        .           
        .                 pointer
4,559,580 ( 0.00%)        operator->() const _GLIBCXX_NOEXCEPT
6,839,370 ( 0.01%)        { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
  273,650 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_valptr() (10,946x)
        .           
        .                 _Self&
   39,096 ( 0.00%)        operator++() _GLIBCXX_NOEXCEPT
        .                 {
   68,422 ( 0.00%)  	_M_node = _Rb_tree_increment(_M_node);
   76,701 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++98/../../../../../libstdc++-v3/src/c++98/tree.cc:std::_Rb_tree_increment(std::_Rb_tree_node_base*) (5,729x)
    1,404 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    9,774 ( 0.00%)  	return *this;
   19,548 ( 0.00%)        }
        .           
        .                 _Self
        .                 operator++(int) _GLIBCXX_NOEXCEPT
        .                 {
        .           	_Self __tmp = *this;
        .           	_M_node = _Rb_tree_increment(_M_node);
        .           	return __tmp;
        .                 }
        .           
        .                 _Self&
      120 ( 0.00%)        operator--() _GLIBCXX_NOEXCEPT
        .                 {
      214 ( 0.00%)  	_M_node = _Rb_tree_decrement(_M_node);
    1,399 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       74 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++98/../../../../../libstdc++-v3/src/c++98/tree.cc:std::_Rb_tree_decrement(std::_Rb_tree_node_base*) (5x)
       30 ( 0.00%)  	return *this;
       60 ( 0.00%)        }
        .           
        .                 _Self
        .                 operator--(int) _GLIBCXX_NOEXCEPT
        .                 {
        .           	_Self __tmp = *this;
        .           	_M_node = _Rb_tree_decrement(_M_node);
        .           	return __tmp;
        .                 }
        .           
        .                 friend bool
3,058,624 ( 0.00%)        operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
6,117,248 ( 0.01%)        { return __x._M_node == __y._M_node; }
        .           
        .           #if ! __cpp_lib_three_way_comparison
        .                 friend bool
        .                 operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
        .                 { return __x._M_node != __y._M_node; }
        .           #endif
        .           
        .                 _Base_ptr _M_node;
-- line 320 ----------------------------------------
-- line 335 ----------------------------------------
        .                 typedef _Rb_tree_const_iterator<_Tp>		_Self;
        .                 typedef _Rb_tree_node_base::_Const_Base_ptr	_Base_ptr;
        .                 typedef const _Rb_tree_node<_Tp>*			_Link_type;
        .           
        .                 _Rb_tree_const_iterator() _GLIBCXX_NOEXCEPT
        .                 : _M_node() { }
        .           
        .                 explicit
    9,144 ( 0.00%)        _Rb_tree_const_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
   13,716 ( 0.00%)        : _M_node(__x) { }
        .           
   13,044 ( 0.00%)        _Rb_tree_const_iterator(const iterator& __it) _GLIBCXX_NOEXCEPT
   22,827 ( 0.00%)        : _M_node(__it._M_node) { }
        .           
        .                 iterator
   13,048 ( 0.00%)        _M_const_cast() const _GLIBCXX_NOEXCEPT
   29,358 ( 0.00%)        { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }
      140 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<unsigned short>::_Rb_tree_iterator(std::_Rb_tree_node_base*) (14x)
        .           
        .                 reference
        .                 operator*() const _GLIBCXX_NOEXCEPT
        .                 { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
        .           
        .                 pointer
    9,360 ( 0.00%)        operator->() const _GLIBCXX_NOEXCEPT
   14,040 ( 0.00%)        { return static_cast<_Link_type>(_M_node)->_M_valptr(); }
   58,500 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_valptr() const (2,340x)
        .           
        .                 _Self&
    4,680 ( 0.00%)        operator++() _GLIBCXX_NOEXCEPT
        .                 {
    8,194 ( 0.00%)  	_M_node = _Rb_tree_increment(_M_node);
   14,920 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++98/../../../../../libstdc++-v3/src/c++98/tree.cc:std::_Rb_tree_increment(std::_Rb_tree_node_base const*) (1,170x)
    1,442 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,170 ( 0.00%)  	return *this;
    2,340 ( 0.00%)        }
        .           
        .                 _Self
        .                 operator++(int) _GLIBCXX_NOEXCEPT
        .                 {
        .           	_Self __tmp = *this;
        .           	_M_node = _Rb_tree_increment(_M_node);
        .           	return __tmp;
        .                 }
-- line 374 ----------------------------------------
-- line 384 ----------------------------------------
        .                 operator--(int) _GLIBCXX_NOEXCEPT
        .                 {
        .           	_Self __tmp = *this;
        .           	_M_node = _Rb_tree_decrement(_M_node);
        .           	return __tmp;
        .                 }
        .           
        .                 friend bool
    6,108 ( 0.00%)        operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
   12,216 ( 0.00%)        { return __x._M_node == __y._M_node; }
        .           
        .           #if ! __cpp_lib_three_way_comparison
        .                 friend bool
        .                 operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
        .                 { return __x._M_node != __y._M_node; }
        .           #endif
        .           
        .                 _Base_ptr _M_node;
-- line 401 ----------------------------------------
-- line 433 ----------------------------------------
        .                 typedef _Rb_tree_node<_Val>* 		_Link_type;
        .                 typedef const _Rb_tree_node<_Val>*	_Const_Link_type;
        .           
        .               private:
        .                 // Functor recycling a pool of nodes and using allocation once the pool
        .                 // is empty.
        .                 struct _Reuse_or_alloc_node
        .                 {
       10 ( 0.00%)  	_Reuse_or_alloc_node(_Rb_tree& __t)
       30 ( 0.00%)  	: _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_rightmost() (2x)
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_root() (2x)
        .           	{
        8 ( 0.00%)  	  if (_M_root)
        .           	    {
        .           	      _M_root->_M_parent = 0;
        .           
        .           	      if (_M_nodes->_M_left)
        .           		_M_nodes = _M_nodes->_M_left;
        .           	    }
        .           	  else
        4 ( 0.00%)  	    _M_nodes = 0;
        6 ( 0.00%)  	}
        .           
        .           #if __cplusplus >= 201103L
        .           	_Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;
        .           #endif
        .           
        8 ( 0.00%)  	~_Reuse_or_alloc_node()
       20 ( 0.00%)  	{ _M_t._M_erase(static_cast<_Link_type>(_M_root)); }
       24 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_erase(std::_Rb_tree_node<unsigned short>*) (2x)
        .           
        .           	template<typename _Arg>
        .           	  _Link_type
       84 ( 0.00%)  	  operator()(_GLIBCXX_FWDREF(_Arg) __arg)
        .           	  {
       56 ( 0.00%)  	    _Link_type __node = static_cast<_Link_type>(_M_extract());
      168 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node::_M_extract() (14x)
       28 ( 0.00%)  	    if (__node)
        .           	      {
        .           		_M_t._M_destroy_node(__node);
        .           		_M_t._M_construct_node(__node, _GLIBCXX_FORWARD(_Arg, __arg));
        .           		return __node;
        .           	      }
        .           
      126 ( 0.00%)  	    return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg));
    5,224 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<unsigned short>* std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_create_node<unsigned short const&>(unsigned short const&) (14x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned short const& std::forward<unsigned short const&>(std::remove_reference<unsigned short const&>::type&) (14x)
       42 ( 0.00%)  	  }
        .           
        .                 private:
        .           	_Base_ptr
       42 ( 0.00%)  	_M_extract()
        .           	{
       56 ( 0.00%)  	  if (!_M_nodes)
       42 ( 0.00%)  	    return _M_nodes;
        .           
        .           	  _Base_ptr __node = _M_nodes;
        .           	  _M_nodes = _M_nodes->_M_parent;
        .           	  if (_M_nodes)
        .           	    {
        .           	      if (_M_nodes->_M_right == __node)
        .           		{
        .           		  _M_nodes->_M_right = 0;
-- line 490 ----------------------------------------
-- line 502 ----------------------------------------
        .           		}
        .           	      else // __node is on the left.
        .           		_M_nodes->_M_left = 0;
        .           	    }
        .           	  else
        .           	    _M_root = 0;
        .           
        .           	  return __node;
       28 ( 0.00%)  	}
        .           
        .           	_Base_ptr _M_root;
        .           	_Base_ptr _M_nodes;
        .           	_Rb_tree& _M_t;
        .                 };
        .           
        .                 // Functor similar to the previous one but without any pool of nodes to
        .                 // recycle.
        .                 struct _Alloc_node
        .                 {
      456 ( 0.00%)  	_Alloc_node(_Rb_tree& __t)
      684 ( 0.00%)  	: _M_t(__t) { }
        .           
        .           	template<typename _Arg>
        .           	  _Link_type
    2,640 ( 0.00%)  	  operator()(_GLIBCXX_FWDREF(_Arg) __arg) const
    4,840 ( 0.00%)  	  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }
  783,387 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_create_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&) (125x)
      750 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const& std::forward<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&>(std::remove_reference<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&>::type&) (125x)
        .           
        .                 private:
        .           	_Rb_tree& _M_t;
        .                 };
        .           
        .               public:
        .                 typedef _Key 				key_type;
        .                 typedef _Val 				value_type;
-- line 535 ----------------------------------------
-- line 537 ----------------------------------------
        .                 typedef const value_type* 		const_pointer;
        .                 typedef value_type& 			reference;
        .                 typedef const value_type& 		const_reference;
        .                 typedef size_t 				size_type;
        .                 typedef ptrdiff_t 			difference_type;
        .                 typedef _Alloc 				allocator_type;
        .           
        .                 _Node_allocator&
   42,162 ( 0.00%)        _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
   42,162 ( 0.00%)        { return this->_M_impl; }
        .           
        .                 const _Node_allocator&
        .                 _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
        .                 { return this->_M_impl; }
        .           
        .                 allocator_type
        .                 get_allocator() const _GLIBCXX_NOEXCEPT
        .                 { return allocator_type(_M_get_Node_allocator()); }
        .           
        .               protected:
        .                 _Link_type
   14,608 ( 0.00%)        _M_get_node()
   40,172 ( 0.00%)        { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }
       36 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > >::_M_get_Node_allocator() (6x)
        .           
        .                 void
   16,875 ( 0.00%)        _M_put_node(_Link_type __p) _GLIBCXX_NOEXCEPT
   54,000 ( 0.00%)        { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
      108 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_get_Node_allocator() (18x)
        .           
        .           #if __cplusplus < 201103L
        .                 void
        .                 _M_construct_node(_Link_type __node, const value_type& __x)
        .                 {
        .           	__try
        .           	  { get_allocator().construct(__node->_M_valptr(), __x); }
        .           	__catch(...)
-- line 571 ----------------------------------------
-- line 580 ----------------------------------------
        .                 {
        .           	_Link_type __tmp = _M_get_node();
        .           	_M_construct_node(__tmp, __x);
        .           	return __tmp;
        .                 }
        .           #else
        .                 template<typename... _Args>
        .           	void
   36,190 ( 0.00%)  	_M_construct_node(_Link_type __node, _Args&&... __args)
        .           	{
        .           	  __try
        .           	    {
   14,608 ( 0.00%)  	      ::new(__node) _Rb_tree_node<_Val>;
       98 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (14x)
   68,563 ( 0.00%)  	      _Alloc_traits::construct(_M_get_Node_allocator(),
      350 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<unsigned short>::_M_valptr() (14x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned short const& std::forward<unsigned short const&>(std::remove_reference<unsigned short const&>::type&) (14x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_get_Node_allocator() (14x)
        .           				       __node->_M_valptr(),
        .           				       std::forward<_Args>(__args)...);
        .           	    }
        .           	  __catch(...)
        .           	    {
        .           	      __node->~_Rb_tree_node<_Val>();
        .           	      _M_put_node(__node);
        .           	      __throw_exception_again;
        .           	    }
   25,399 ( 0.00%)  	}
        .           
        .                 template<typename... _Args>
        .           	_Link_type
   25,234 ( 0.00%)  	_M_create_node(_Args&&... __args)
        .           	{
   14,608 ( 0.00%)  	  _Link_type __tmp = _M_get_node();
    2,964 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_M_get_node() (20x)
   47,125 ( 0.00%)  	  _M_construct_node(__tmp, std::forward<_Args>(__args)...);
    3,360 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:void std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_M_construct_node<std::pair<ColorCombinerKey, ColorCombiner> >(std::_Rb_tree_node<std::pair<ColorCombinerKey const, ColorCombiner> >*, std::pair<ColorCombinerKey, ColorCombiner>&&) (20x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<ColorCombinerKey, ColorCombiner>&& std::forward<std::pair<ColorCombinerKey, ColorCombiner> >(std::remove_reference<std::pair<ColorCombinerKey, ColorCombiner> >::type&) (20x)
    3,652 ( 0.00%)  	  return __tmp;
   11,100 ( 0.00%)  	}
        .           #endif
        .           
        .                 void
   20,250 ( 0.00%)        _M_destroy_node(_Link_type __p) _GLIBCXX_NOEXCEPT
        .                 {
        .           #if __cplusplus < 201103L
        .           	get_allocator().destroy(__p->_M_valptr());
        .           #else
   30,375 ( 0.00%)  	_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
      500 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<ColorCombinerKey const, ColorCombiner> >::_M_valptr() (20x)
      120 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_M_get_Node_allocator() (20x)
        .           	__p->~_Rb_tree_node<_Val>();
        .           #endif
   13,500 ( 0.00%)        }
        .           
        .                 void
   16,875 ( 0.00%)        _M_drop_node(_Link_type __p) _GLIBCXX_NOEXCEPT
        .                 {
   16,875 ( 0.00%)  	_M_destroy_node(__p);
1,238,027 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_destroy_node(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*) (3,337x)
   16,875 ( 0.00%)  	_M_put_node(__p);
  589,313 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_put_node(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*) (3,337x)
   10,125 ( 0.00%)        }
        .           
        .                 template<bool _MoveValue, typename _NodeGen>
        .           	_Link_type
    2,640 ( 0.00%)  	_M_clone_node(_Link_type __x, _NodeGen& __node_gen)
        .           	{
        .           #if __cplusplus >= 201103L
        .           	  using _Vp = __conditional_t<_MoveValue,
        .           				      value_type&&,
        .           				      const value_type&>;
        .           #endif
        .           	  _Link_type __tmp
    4,840 ( 0.00%)  	    = __node_gen(_GLIBCXX_FORWARD(_Vp, *__x->_M_valptr()));
  786,262 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node::operator()<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&) const (125x)
    3,125 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_valptr() (125x)
      750 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const& std::forward<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&>(std::remove_reference<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&>::type&) (125x)
    1,760 ( 0.00%)  	  __tmp->_M_color = __x->_M_color;
      880 ( 0.00%)  	  __tmp->_M_left = 0;
      880 ( 0.00%)  	  __tmp->_M_right = 0;
      440 ( 0.00%)  	  return __tmp;
      880 ( 0.00%)  	}
        .           
        .               protected:
        .           #if _GLIBCXX_INLINE_VERSION
        .                 template<typename _Key_compare>
        .           #else
        .                 // Unused _Is_pod_comparator is kept as it is part of mangled name.
        .                 template<typename _Key_compare,
        .           	       bool /* _Is_pod_comparator */ = __is_pod(_Key_compare)>
        .           #endif
    6,528 ( 0.00%)  	struct _Rb_tree_impl
        .           	: public _Node_allocator
        .           	, public _Rb_tree_key_compare<_Key_compare>
        .           	, public _Rb_tree_header
        .           	{
        .           	  typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;
        .           
    5,928 ( 0.00%)  	  _Rb_tree_impl()
        .           	    _GLIBCXX_NOEXCEPT_IF(
        .           		is_nothrow_default_constructible<_Node_allocator>::value
        .           		&& is_nothrow_default_constructible<_Base_key_compare>::value )
    5,187 ( 0.00%)  	  : _Node_allocator()
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_header::_Rb_tree_header() (1x)
        6 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_key_compare<std::less<std::pair<unsigned long, unsigned int> > >::_Rb_tree_key_compare() (1x)
    2,223 ( 0.00%)  	  { }
        .           
    1,938 ( 0.00%)  	  _Rb_tree_impl(const _Rb_tree_impl& __x)
        .           	  : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
      114 ( 0.00%)  	  , _Base_key_compare(__x._M_key_compare)
      912 ( 0.00%)  	  , _Rb_tree_header()
    3,192 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_header::_Rb_tree_header() (114x)
      798 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_key_compare<std::less<void> >::_Rb_tree_key_compare(std::less<void> const&) (114x)
      342 ( 0.00%)  	  { }
        .           
        .           #if __cplusplus < 201103L
        .           	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
        .           	  : _Node_allocator(__a), _Base_key_compare(__comp)
        .           	  { }
        .           #else
        .           	  _Rb_tree_impl(_Rb_tree_impl&&)
        .           	    noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
-- line 684 ----------------------------------------
-- line 700 ----------------------------------------
        .           	  { }
        .           #endif
        .           	};
        .           
        .                 _Rb_tree_impl<_Compare> _M_impl;
        .           
        .               protected:
        .                 _Base_ptr&
      348 ( 0.00%)        _M_root() _GLIBCXX_NOEXCEPT
      464 ( 0.00%)        { return this->_M_impl._M_header._M_parent; }
        .           
        .                 _Const_Base_ptr
      342 ( 0.00%)        _M_root() const _GLIBCXX_NOEXCEPT
      456 ( 0.00%)        { return this->_M_impl._M_header._M_parent; }
        .           
        .                 _Base_ptr&
      558 ( 0.00%)        _M_leftmost() _GLIBCXX_NOEXCEPT
      744 ( 0.00%)        { return this->_M_impl._M_header._M_left; }
        .           
        .                 _Const_Base_ptr
        .                 _M_leftmost() const _GLIBCXX_NOEXCEPT
        .                 { return this->_M_impl._M_header._M_left; }
        .           
        .                 _Base_ptr&
   14,916 ( 0.00%)        _M_rightmost() _GLIBCXX_NOEXCEPT
   19,888 ( 0.00%)        { return this->_M_impl._M_header._M_right; }
        .           
        .                 _Const_Base_ptr
        .                 _M_rightmost() const _GLIBCXX_NOEXCEPT
        .                 { return this->_M_impl._M_header._M_right; }
        .           
        .                 _Link_type
  304,467 ( 0.00%)        _M_mbegin() const _GLIBCXX_NOEXCEPT
  405,956 ( 0.00%)        { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
        .           
        .                 _Link_type
  405,500 ( 0.00%)        _M_begin() _GLIBCXX_NOEXCEPT
  506,875 ( 0.00%)        { return _M_mbegin(); }
      301 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<Ship::ShipDeviceIndex, std::pair<Ship::ShipDeviceIndex const, bool>, std::_Select1st<std::pair<Ship::ShipDeviceIndex const, bool> >, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::_M_mbegin() const (43x)
        .           
        .                 _Const_Link_type
    1,443 ( 0.00%)        _M_begin() const _GLIBCXX_NOEXCEPT
        .                 {
        .           	return static_cast<_Const_Link_type>
      962 ( 0.00%)  	  (this->_M_impl._M_header._M_parent);
      962 ( 0.00%)        }
        .           
        .                 _Base_ptr
  317,733 ( 0.00%)        _M_end() _GLIBCXX_NOEXCEPT
  423,644 ( 0.00%)        { return &this->_M_impl._M_header; }
        .           
        .                 _Const_Base_ptr
    1,443 ( 0.00%)        _M_end() const _GLIBCXX_NOEXCEPT
    1,924 ( 0.00%)        { return &this->_M_impl._M_header; }
        .           
        .                 static const _Key&
  601,896 ( 0.00%)        _S_key(_Const_Link_type __x)
        .                 {
        .           #if __cplusplus >= 201103L
        .           	// If we're asking for the key we're presumably using the comparison
        .           	// object, and so this is a good place to sanity check it.
        .           	static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
        .           		      "comparison object must be invocable "
        .           		      "with two arguments of key type");
        .           # if __cplusplus >= 201703L
-- line 763 ----------------------------------------
-- line 765 ----------------------------------------
        .           	// 2542. Missing const requirements for associative containers
        .           	if constexpr (__is_invocable<_Compare&, const _Key&, const _Key&>{})
        .           	  static_assert(
        .           	      is_invocable_v<const _Compare&, const _Key&, const _Key&>,
        .           	      "comparison object must be invocable as const");
        .           # endif // C++17
        .           #endif // C++11
        .           
1,203,792 ( 0.00%)  	return _KeyOfValue()(*__x->_M_valptr());
  812,150 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_valptr() const (32,486x)
  227,402 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::operator()(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > const&) const (32,486x)
  300,948 ( 0.00%)        }
        .           
        .                 static _Link_type
  160,215 ( 0.00%)        _S_left(_Base_ptr __x) _GLIBCXX_NOEXCEPT
  213,620 ( 0.00%)        { return static_cast<_Link_type>(__x->_M_left); }
        .           
        .                 static _Const_Link_type
    3,768 ( 0.00%)        _S_left(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
    5,024 ( 0.00%)        { return static_cast<_Const_Link_type>(__x->_M_left); }
        .           
        .                 static _Link_type
  209,826 ( 0.00%)        _S_right(_Base_ptr __x) _GLIBCXX_NOEXCEPT
  279,768 ( 0.00%)        { return static_cast<_Link_type>(__x->_M_right); }
        .           
        .                 static _Const_Link_type
    1,680 ( 0.00%)        _S_right(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
    2,240 ( 0.00%)        { return static_cast<_Const_Link_type>(__x->_M_right); }
        .           
        .                 static const _Key&
  108,136 ( 0.00%)        _S_key(_Const_Base_ptr __x)
  135,170 ( 0.00%)        { return _S_key(static_cast<_Const_Link_type>(__x)); }
   20,470 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_S_key(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const*) (445x)
        .           
        .                 static _Base_ptr
      456 ( 0.00%)        _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      570 ( 0.00%)        { return _Rb_tree_node_base::_S_minimum(__x); }
    1,975 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node_base::_S_minimum(std::_Rb_tree_node_base*) (114x)
        .           
        .                 static _Const_Base_ptr
        .                 _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
        .                 { return _Rb_tree_node_base::_S_minimum(__x); }
        .           
        .                 static _Base_ptr
      456 ( 0.00%)        _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      570 ( 0.00%)        { return _Rb_tree_node_base::_S_maximum(__x); }
    2,465 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node_base::_S_maximum(std::_Rb_tree_node_base*) (114x)
        .           
        .                 static _Const_Base_ptr
        .                 _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
        .                 { return _Rb_tree_node_base::_S_maximum(__x); }
        .           
        .               public:
        .                 typedef _Rb_tree_iterator<value_type>       iterator;
        .                 typedef _Rb_tree_const_iterator<value_type> const_iterator;
-- line 814 ----------------------------------------
-- line 877 ----------------------------------------
        .                 enum { __as_lvalue, __as_rvalue };
        .           
        .                 template<bool _MoveValues, typename _NodeGen>
        .           	_Link_type
        .           	_M_copy(_Link_type, _Base_ptr, _NodeGen&);
        .           
        .                 template<bool _MoveValues, typename _NodeGen>
        .           	_Link_type
      798 ( 0.00%)  	_M_copy(const _Rb_tree& __x, _NodeGen& __gen)
        .           	{
        .           	  _Link_type __root =
    1,710 ( 0.00%)  	    _M_copy<_MoveValues>(__x._M_mbegin(), _M_end(), __gen);
  799,577 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_copy<false, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node>(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree_node_base*, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node&) (34x)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_end() (34x)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_mbegin() const (34x)
      912 ( 0.00%)  	  _M_leftmost() = _S_minimum(__root);
      869 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_minimum(std::_Rb_tree_node_base*) (34x)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_leftmost() (34x)
      912 ( 0.00%)  	  _M_rightmost() = _S_maximum(__root);
    1,030 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_maximum(std::_Rb_tree_node_base*) (34x)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_rightmost() (34x)
      456 ( 0.00%)  	  _M_impl._M_node_count = __x._M_impl._M_node_count;
      114 ( 0.00%)  	  return __root;
      342 ( 0.00%)  	}
        .           
        .                 _Link_type
      570 ( 0.00%)        _M_copy(const _Rb_tree& __x)
        .                 {
      570 ( 0.00%)  	_Alloc_node __an(*this);
      340 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node::_Alloc_node(std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >&) (34x)
      684 ( 0.00%)  	return _M_copy<__as_lvalue>(__x, __an);
  803,992 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_copy<false, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node>(std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node&) (34x)
      228 ( 0.00%)        }
        .           
        .                 void
        .                 _M_erase(_Link_type __x);
        .           
        .                 iterator
        .                 _M_lower_bound(_Link_type __x, _Base_ptr __y,
        .           		     const _Key& __k);
        .           
-- line 908 ----------------------------------------
-- line 918 ----------------------------------------
        .                 _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
        .           		     const _Key& __k) const;
        .           
        .               public:
        .                 // allocation/deallocation
        .           #if __cplusplus < 201103L
        .                 _Rb_tree() { }
        .           #else
    7,410 ( 0.00%)        _Rb_tree() = default;
       54 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<int, std::pair<int const, FBInfo>, std::_Select1st<std::pair<int const, FBInfo> >, std::less<int>, std::allocator<std::pair<int const, FBInfo> > >::_Rb_tree_impl<std::less<int>, true>::_Rb_tree_impl() (1x)
        .           #endif
        .           
        .                 _Rb_tree(const _Compare& __comp,
        .           	       const allocator_type& __a = allocator_type())
        .                 : _M_impl(__comp, _Node_allocator(__a)) { }
        .           
      684 ( 0.00%)        _Rb_tree(const _Rb_tree& __x)
      570 ( 0.00%)        : _M_impl(__x._M_impl)
    2,618 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Rb_tree_impl<std::less<void>, true>::_Rb_tree_impl(std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Rb_tree_impl<std::less<void>, true> const&) (34x)
        .                 {
      798 ( 0.00%)  	if (__x._M_root() != 0)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_root() const (34x)
    1,140 ( 0.00%)  	  _M_root() = _M_copy(__x);
  804,944 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_copy(std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&) (34x)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_root() (34x)
      570 ( 0.00%)        }
        .           
        .           #if __cplusplus >= 201103L
        .                 _Rb_tree(const allocator_type& __a)
        .                 : _M_impl(_Node_allocator(__a))
        .                 { }
        .           
        .                 _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
        .                 : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
-- line 946 ----------------------------------------
-- line 973 ----------------------------------------
        .                 noexcept( noexcept(
        .           	_Rb_tree(std::declval<_Rb_tree&&>(), std::declval<_Node_allocator&&>(),
        .           		 std::declval<typename _Alloc_traits::is_always_equal>())) )
        .                 : _Rb_tree(std::move(__x), std::move(__a),
        .           		 typename _Alloc_traits::is_always_equal{})
        .                 { }
        .           #endif
        .           
    3,264 ( 0.00%)        ~_Rb_tree() _GLIBCXX_NOEXCEPT
   11,424 ( 0.00%)        { _M_erase(_M_begin()); }
       16 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::_M_begin() (1x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::_M_erase(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >*) (1x)
        9 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> > >::_Rb_tree_impl<std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true>::~_Rb_tree_impl() (1x)
        .           
        .                 _Rb_tree&
        .                 operator=(const _Rb_tree& __x);
        .           
        .                 // Accessors.
        .                 _Compare
   24,933 ( 0.00%)        key_comp() const
   24,933 ( 0.00%)        { return _M_impl._M_key_compare; }
        .           
        .                 iterator
   17,804 ( 0.00%)        begin() _GLIBCXX_NOEXCEPT
   40,059 ( 0.00%)        { return iterator(this->_M_impl._M_header._M_left); }
       10 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<Ship::ShipDeviceIndex const, bool> >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (1x)
        .           
        .                 const_iterator
    1,160 ( 0.00%)        begin() const _GLIBCXX_NOEXCEPT
    2,610 ( 0.00%)        { return const_iterator(this->_M_impl._M_header._M_left); }
    2,900 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_const_iterator(std::_Rb_tree_node_base const*) (290x)
        .           
        .                 iterator
3,278,940 ( 0.00%)        end() _GLIBCXX_NOEXCEPT
7,377,615 ( 0.01%)        { return iterator(&this->_M_impl._M_header); }
1,965,600 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, MaskedTextureEntry> >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (196,560x)
        .           
        .                 const_iterator
    6,060 ( 0.00%)        end() const _GLIBCXX_NOEXCEPT
   13,635 ( 0.00%)        { return const_iterator(&this->_M_impl._M_header); }
    6,340 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_const_iterator(std::_Rb_tree_node_base const*) (634x)
        .           
        .                 reverse_iterator
        .                 rbegin() _GLIBCXX_NOEXCEPT
        .                 { return reverse_iterator(end()); }
        .           
        .                 const_reverse_iterator
        .                 rbegin() const _GLIBCXX_NOEXCEPT
        .                 { return const_reverse_iterator(end()); }
-- line 1014 ----------------------------------------
-- line 1017 ----------------------------------------
        .                 rend() _GLIBCXX_NOEXCEPT
        .                 { return reverse_iterator(begin()); }
        .           
        .                 const_reverse_iterator
        .                 rend() const _GLIBCXX_NOEXCEPT
        .                 { return const_reverse_iterator(begin()); }
        .           
        .                 _GLIBCXX_NODISCARD bool
    1,044 ( 0.00%)        empty() const _GLIBCXX_NOEXCEPT
    2,088 ( 0.00%)        { return _M_impl._M_node_count == 0; }
        .           
        .                 size_type
   15,531 ( 0.00%)        size() const _GLIBCXX_NOEXCEPT
   20,708 ( 0.00%)        { return _M_impl._M_node_count; }
        .           
        .                 size_type
        .                 max_size() const _GLIBCXX_NOEXCEPT
        .                 { return _Alloc_traits::max_size(_M_get_Node_allocator()); }
        .           
        .                 void
        .                 swap(_Rb_tree& __t)
        .                 _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value);
-- line 1038 ----------------------------------------
-- line 1241 ----------------------------------------
        .                 { _M_erase_aux(__first, __last); }
        .           
        .                 void
        .                 erase(const_iterator __first, const_iterator __last)
        .                 { _M_erase_aux(__first, __last); }
        .           #endif
        .           
        .                 void
    4,624 ( 0.00%)        clear() _GLIBCXX_NOEXCEPT
        .                 {
    9,248 ( 0.00%)  	_M_erase(_M_begin());
       16 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<Ship::ShipDeviceIndex, std::pair<Ship::ShipDeviceIndex const, bool>, std::_Select1st<std::pair<Ship::ShipDeviceIndex const, bool> >, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::_M_begin() (1x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<Ship::ShipDeviceIndex, std::pair<Ship::ShipDeviceIndex const, bool>, std::_Select1st<std::pair<Ship::ShipDeviceIndex const, bool> >, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::_M_erase(std::_Rb_tree_node<std::pair<Ship::ShipDeviceIndex const, bool> >*) (1x)
    4,624 ( 0.00%)  	_M_impl._M_reset();
       16 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_header::_M_reset() (1x)
    3,468 ( 0.00%)        }
        .           
        .                 // Set operations.
        .                 iterator
        .                 find(const key_type& __k);
        .           
        .                 const_iterator
        .                 find(const key_type& __k) const;
        .           
        .                 size_type
        .                 count(const key_type& __k) const;
        .           
        .                 iterator
   68,790 ( 0.00%)        lower_bound(const key_type& __k)
  194,905 ( 0.00%)        { return _M_lower_bound(_M_begin(), _M_end(), __k); }
7,139,401 ( 0.01%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_lower_bound(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree_node_base*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (10,958x)
  175,328 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_begin() (10,958x)
   76,706 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_end() (10,958x)
        .           
        .                 const_iterator
        .                 lower_bound(const key_type& __k) const
        .                 { return _M_lower_bound(_M_begin(), _M_end(), __k); }
        .           
        .                 iterator
        .                 upper_bound(const key_type& __k)
        .                 { return _M_upper_bound(_M_begin(), _M_end(), __k); }
-- line 1275 ----------------------------------------
-- line 1283 ----------------------------------------
        .           
        .                 pair<const_iterator, const_iterator>
        .                 equal_range(const key_type& __k) const;
        .           
        .           #if __cplusplus >= 201402L
        .                 template<typename _Kt,
        .           	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
        .           	iterator
      250 ( 0.00%)  	_M_find_tr(const _Kt& __k)
        .           	{
      100 ( 0.00%)  	  const _Rb_tree* __const_this = this;
      450 ( 0.00%)  	  return __const_this->_M_find_tr(__k)._M_const_cast();
   47,262 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_find_tr<char [5], void>(char const (&) [5]) const (50x)
    1,150 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_M_const_cast() const (50x)
      100 ( 0.00%)  	}
        .           
        .                 template<typename _Kt,
        .           	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
        .           	const_iterator
      300 ( 0.00%)  	_M_find_tr(const _Kt& __k) const
        .           	{
      300 ( 0.00%)  	  auto __j = _M_lower_bound_tr(__k);
   42,654 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_lower_bound_tr<char [5], void>(char const (&) [5]) const (50x)
      798 ( 0.00%)  	  if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
    1,150 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() const (50x)
      932 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<char const (&) [5]>)({parm#1}))<((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#2}))) std::less<void>::operator()<char const (&) [5], std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(char const (&) [5], std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (4x)
      600 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&, std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (50x)
      220 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_key(std::_Rb_tree_node_base const*) (4x)
       16 ( 0.00%)  	    __j = end();
       92 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() const (4x)
       50 ( 0.00%)  	  return __j;
      150 ( 0.00%)  	}
        .           
        .                 template<typename _Kt,
        .           	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
        .           	size_type
        .           	_M_count_tr(const _Kt& __k) const
        .           	{
        .           	  auto __p = _M_equal_range_tr(__k);
        .           	  return std::distance(__p.first, __p.second);
-- line 1314 ----------------------------------------
-- line 1321 ----------------------------------------
        .           	{
        .           	  const _Rb_tree* __const_this = this;
        .           	  return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
        .           	}
        .           
        .                 template<typename _Kt,
        .           	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
        .           	const_iterator
      300 ( 0.00%)  	_M_lower_bound_tr(const _Kt& __k) const
        .           	{
      200 ( 0.00%)  	  auto __x = _M_begin();
      350 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_begin() const (50x)
      200 ( 0.00%)  	  auto __y = _M_end();
      350 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_end() const (50x)
      414 ( 0.00%)  	  while (__x != 0)
    1,716 ( 0.00%)  	    if (!_M_impl._M_key_compare(_S_key(__x), __k))
   30,638 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#1}))<((forward<char const (&) [5]>)({parm#2}))) std::less<void>::operator()<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const (&) [5]>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const (&) [5]) const (132x)
    6,072 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_key(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const*) (132x)
        .           	      {
        8 ( 0.00%)  		__y = __x;
       20 ( 0.00%)  		__x = _S_left(__x);
       28 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_left(std::_Rb_tree_node_base const*) (4x)
        .           	      }
        .           	    else
      512 ( 0.00%)  	      __x = _S_right(__x);
      896 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_right(std::_Rb_tree_node_base const*) (128x)
      300 ( 0.00%)  	  return const_iterator(__y);
      500 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_const_iterator(std::_Rb_tree_node_base const*) (50x)
      150 ( 0.00%)  	}
        .           
        .                 template<typename _Kt,
        .           	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
        .           	iterator
        .           	_M_upper_bound_tr(const _Kt& __k)
        .           	{
        .           	  const _Rb_tree* __const_this = this;
        .           	  return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
-- line 1350 ----------------------------------------
-- line 1623 ----------------------------------------
        .           #endif
        .           
        .               private:
        .           #if __cplusplus >= 201103L
        .                 // An RAII _Node handle
        .                 struct _Auto_node
        .                 {
        .           	template<typename... _Args>
   26,162 ( 0.00%)  	  _Auto_node(_Rb_tree& __t, _Args&&... __args)
    9,594 ( 0.00%)  	  : _M_t(__t),
   49,106 ( 0.00%)  	    _M_node(__t._M_create_node(std::forward<_Args>(__args)...))
  305,300 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_create_node<std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>, std::tuple<> >(std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>&&, std::tuple<>&&) (234x)
    1,404 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>&& std::forward<std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&> >(std::remove_reference<std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&> >::type&) (234x)
    1,404 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<>&& std::forward<std::tuple<> >(std::remove_reference<std::tuple<> >::type&) (234x)
    1,404 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::piecewise_construct_t const& std::forward<std::piecewise_construct_t const&>(std::remove_reference<std::piecewise_construct_t const&>::type&) (234x)
   13,390 ( 0.00%)  	  { }
        .           
   12,792 ( 0.00%)  	~_Auto_node()
        .           	{
   12,792 ( 0.00%)  	  if (_M_node)
        .           	    _M_t._M_drop_node(_M_node);
    9,594 ( 0.00%)  	}
        .           
        .           	_Auto_node(_Auto_node&& __n)
        .           	: _M_t(__n._M_t), _M_node(__n._M_node)
        .           	{ __n._M_node = nullptr; }
        .           
        .           	const _Key&
   12,792 ( 0.00%)  	_M_key() const
   19,188 ( 0.00%)  	{ return _S_key(_M_node); }
    1,886 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<Ship::ShipDeviceIndex, std::pair<Ship::ShipDeviceIndex const, bool>, std::_Select1st<std::pair<Ship::ShipDeviceIndex const, bool> >, std::less<Ship::ShipDeviceIndex>, std::allocator<std::pair<Ship::ShipDeviceIndex const, bool> > >::_S_key(std::_Rb_tree_node<std::pair<Ship::ShipDeviceIndex const, bool> > const*) (41x)
        .           
        .           	iterator
   35,178 ( 0.00%)  	_M_insert(pair<_Base_ptr, _Base_ptr> __p)
        .           	{
   28,782 ( 0.00%)  	  auto __it = _M_t._M_insert_node(__p.first, __p.second, _M_node);
    1,200 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> > >::_M_insert_node(std::_Rb_tree_node_base*, std::_Rb_tree_node_base*, std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, Ship::CommandEntry> >*) (6x)
    6,396 ( 0.00%)  	  _M_node = nullptr;
    3,198 ( 0.00%)  	  return __it;
    6,396 ( 0.00%)  	}
        .           
        .           	iterator
        .           	_M_insert_equal_lower()
        .           	{
        .           	  auto __it = _M_t._M_insert_equal_lower_node(_M_node);
        .           	  _M_node = nullptr;
        .           	  return __it;
        .           	}
-- line 1664 ----------------------------------------
-- line 1740 ----------------------------------------
        .                 _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
        .                 return *this;
        .               }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               template<typename _Iterator>
        .                 void
       14 ( 0.00%)        _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .                 _M_assign_unique(_Iterator __first, _Iterator __last)
        .                 {
       10 ( 0.00%)  	_Reuse_or_alloc_node __roan(*this);
       86 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node::_Reuse_or_alloc_node(std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >&) (2x)
        8 ( 0.00%)  	_M_impl._M_reset();
       32 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_header::_M_reset() (2x)
       64 ( 0.00%)  	for (; __first != __last; ++__first)
      210 ( 0.00%)  	  _M_insert_unique_(end(), *__first, __roan);
   16,234 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<unsigned short> std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_insert_unique_<unsigned short const&, std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node>(std::_Rb_tree_const_iterator<unsigned short>, unsigned short const&, std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node&) (14x)
      322 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::end() (14x)
      154 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<unsigned short>::_Rb_tree_const_iterator(std::_Rb_tree_iterator<unsigned short> const&) (14x)
       14 ( 0.00%)        }
       52 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node::~_Reuse_or_alloc_node() (2x)
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               template<typename _Iterator>
        .                 void
        .                 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .                 _M_assign_equal(_Iterator __first, _Iterator __last)
        .                 {
-- line 1763 ----------------------------------------
-- line 1806 ----------------------------------------
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .           #if __cplusplus >= 201103L
        .               template<typename _Arg, typename _NodeGen>
        .           #else
        .               template<typename _NodeGen>
        .           #endif
        .                 typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      140 ( 0.00%)        _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .                 _M_insert_(_Base_ptr __x, _Base_ptr __p,
        .           #if __cplusplus >= 201103L
        .           		 _Arg&& __v,
        .           #else
        .           		 const _Val& __v,
        .           #endif
        .           		 _NodeGen& __node_gen)
        .                 {
       84 ( 0.00%)  	bool __insert_left = (__x != 0 || __p == _M_end()
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_end() (14x)
      247 ( 0.00%)  			      || _M_impl._M_key_compare(_KeyOfValue()(__v),
      660 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_S_key(std::_Rb_tree_node_base const*) (12x)
      156 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<unsigned short>::operator()(unsigned short const&, unsigned short const&) const (12x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::_Identity<unsigned short>::operator()(unsigned short const&) const (12x)
        .           							_S_key(__p)));
        .           
      126 ( 0.00%)  	_Link_type __z = __node_gen(_GLIBCXX_FORWARD(_Arg, __v));
    5,812 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<unsigned short>* std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node::operator()<unsigned short const&>(unsigned short const&) (14x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned short const& std::forward<unsigned short const&>(std::remove_reference<unsigned short const&>::type&) (14x)
        .           
       84 ( 0.00%)  	_Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
      605 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++98/../../../../../libstdc++-v3/src/c++98/tree.cc:std::_Rb_tree_insert_and_rebalance(bool, std::_Rb_tree_node_base*, std::_Rb_tree_node_base*, std::_Rb_tree_node_base&) (14x)
       28 ( 0.00%)  				      this->_M_impl._M_header);
       70 ( 0.00%)  	++_M_impl._M_node_count;
       84 ( 0.00%)  	return iterator(__z);
      140 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<unsigned short>::_Rb_tree_iterator(std::_Rb_tree_node_base*) (14x)
       70 ( 0.00%)        }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .           #if __cplusplus >= 201103L
        .               template<typename _Arg>
        .           #endif
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
-- line 1841 ----------------------------------------
-- line 1880 ----------------------------------------
        .           	}
        .                 return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));
        .               }
        .           
        .             template<typename _Key, typename _Val, typename _KoV,
        .           	   typename _Compare, typename _Alloc>
        .               template<bool _MoveValues, typename _NodeGen>
        .                 typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    2,408 ( 0.00%)        _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
        .                 _M_copy(_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
        .                 {
        .           	// Structural copy. __x and __p must be non-null.
    2,107 ( 0.00%)  	_Link_type __top = _M_clone_node<_MoveValues>(__x, __node_gen);
  379,435 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_clone_node<false, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node>(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node&) (34x)
      903 ( 0.00%)  	__top->_M_parent = __p;
        .           
        .           	__try
        .           	  {
    1,204 ( 0.00%)  	    if (__x->_M_right)
      346 ( 0.00%)  	      __top->_M_right =
    1,557 ( 0.00%)  		_M_copy<_MoveValues>(_S_right(__x), __top, __node_gen);
  281,166 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_copy<false, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node>(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree_node_base*, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node&)'2 (34x)
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_right(std::_Rb_tree_node_base*) (34x)
      602 ( 0.00%)  	    __p = __top;
    1,204 ( 0.00%)  	    __x = _S_left(__x);
      238 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_left(std::_Rb_tree_node_base*) (34x)
        .           
    1,181 ( 0.00%)  	    while (__x != 0)
        .           	      {
      973 ( 0.00%)  		_Link_type __y = _M_clone_node<_MoveValues>(__x, __node_gen);
  125,784 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_clone_node<false, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node>(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node&) (27x)
      417 ( 0.00%)  		__p->_M_left = __y;
      417 ( 0.00%)  		__y->_M_parent = __p;
      556 ( 0.00%)  		if (__x->_M_right)
      154 ( 0.00%)  		  __y->_M_right = _M_copy<_MoveValues>(_S_right(__x),
   10,218 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_copy<false, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node>(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree_node_base*, std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_Alloc_node&)'2 (2x)
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_right(std::_Rb_tree_node_base*) (2x)
        .           						       __y, __node_gen);
      278 ( 0.00%)  		__p = __y;
      556 ( 0.00%)  		__x = _S_left(__x);
      189 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_left(std::_Rb_tree_node_base*) (27x)
        .           	      }
        .           	  }
        .           	__catch(...)
        .           	  {
        .           	    _M_erase(__top);
        .           	    __throw_exception_again;
        .           	  }
      602 ( 0.00%)  	return __top;
      903 ( 0.00%)        }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               void
   26,745 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_erase(_Link_type __x)
        .               {
        .                 // Erase without rebalancing.
   22,797 ( 0.00%)        while (__x != 0)
        .           	{
   27,000 ( 0.00%)  	  _M_erase(_S_right(__x));
1,111,674 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_erase(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*)'2 (1,591x)
   11,137 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_right(std::_Rb_tree_node_base*) (1,591x)
   13,500 ( 0.00%)  	  _Link_type __y = _S_left(__x);
   11,137 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_left(std::_Rb_tree_node_base*) (1,591x)
   16,875 ( 0.00%)  	  _M_drop_node(__x);
  876,886 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_drop_node(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*) (1,591x)
    6,750 ( 0.00%)  	  __x = __y;
        .           	}
   21,396 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           		      _Compare, _Alloc>::iterator
  789,144 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_lower_bound(_Link_type __x, _Base_ptr __y,
        .           		   const _Key& __k)
        .               {
  527,535 ( 0.00%)        while (__x != 0)
1,505,439 ( 0.00%)  	if (!_M_impl._M_key_compare(_S_key(__x), __k))
5,219,954 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#1}))<((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#2}))) std::less<void>::operator()<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (21,941x)
1,009,286 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_key(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const*) (21,941x)
  346,577 ( 0.00%)  	  __y = __x, __x = _S_left(__x);
   64,610 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_left(std::_Rb_tree_node_base*) (9,230x)
        .           	else
  265,168 ( 0.00%)  	  __x = _S_right(__x);
   88,977 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_right(std::_Rb_tree_node_base*) (12,711x)
  591,858 ( 0.00%)        return iterator(__y);
  109,860 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (10,986x)
  295,929 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           		      _Compare, _Alloc>::const_iterator
    3,448 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
        .           		   const _Key& __k) const
        .               {
    4,661 ( 0.00%)        while (__x != 0)
   21,892 ( 0.00%)  	if (!_M_impl._M_key_compare(_S_key(__x), __k))
  319,601 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (1,684x)
   77,464 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_S_key(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const*) (1,684x)
    8,764 ( 0.00%)  	  __y = __x, __x = _S_left(__x);
    8,764 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_S_left(std::_Rb_tree_node_base const*) (1,252x)
        .           	else
    1,728 ( 0.00%)  	  __x = _S_right(__x);
    3,024 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_S_right(std::_Rb_tree_node_base const*) (432x)
    2,586 ( 0.00%)        return const_iterator(__y);
    4,310 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >::_Rb_tree_const_iterator(std::_Rb_tree_node_base const*) (431x)
    1,293 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           		      _Compare, _Alloc>::iterator
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_upper_bound(_Link_type __x, _Base_ptr __y,
        .           		   const _Key& __k)
-- line 1977 ----------------------------------------
-- line 2001 ----------------------------------------
        .               }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::iterator,
        .           	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::iterator>
       84 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               equal_range(const _Key& __k)
        .               {
       56 ( 0.00%)        _Link_type __x = _M_begin();
      224 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_begin() (14x)
       56 ( 0.00%)        _Base_ptr __y = _M_end();
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_end() (14x)
      254 ( 0.00%)        while (__x != 0)
        .           	{
    1,272 ( 0.00%)  	  if (_M_impl._M_key_compare(_S_key(__x), __k))
   24,356 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#1}))<((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#2}))) std::less<void>::operator()<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (106x)
    4,876 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_key(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const*) (106x)
      280 ( 0.00%)  	    __x = _S_right(__x);
      392 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_right(std::_Rb_tree_node_base*) (56x)
      550 ( 0.00%)  	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
   11,321 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#1}))<((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#2}))) std::less<void>::operator()<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (50x)
    2,300 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_key(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const*) (50x)
      350 ( 0.00%)  	    __y = __x, __x = _S_left(__x);
      350 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_left(std::_Rb_tree_node_base*) (50x)
        .           	  else
        .           	    {
        .           	      _Link_type __xu(__x);
        .           	      _Base_ptr __yu(__y);
        .           	      __y = __x, __x = _S_left(__x);
        .           	      __xu = _S_right(__xu);
        .           	      return pair<iterator,
        .           			  iterator>(_M_lower_bound(__x, __y, __k),
        .           				    _M_upper_bound(__xu, __yu, __k));
        .           	    }
        .           	}
      154 ( 0.00%)        return pair<iterator, iterator>(iterator(__y),
      462 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&&, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >&&) (14x)
      140 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (14x)
       98 ( 0.00%)  				      iterator(__y));
      140 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (14x)
       42 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::const_iterator,
        .           	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::const_iterator>
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
-- line 2041 ----------------------------------------
-- line 2096 ----------------------------------------
        .               }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr,
        .           	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr>
    4,476 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_get_insert_unique_pos(const key_type& __k)
        .               {
        .                 typedef pair<_Base_ptr, _Base_ptr> _Res;
    2,984 ( 0.00%)        _Link_type __x = _M_begin();
       16 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_begin() (1x)
    2,984 ( 0.00%)        _Base_ptr __y = _M_end();
        7 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_end() (1x)
      746 ( 0.00%)        bool __comp = true;
    3,077 ( 0.00%)        while (__x != 0)
        .           	{
       62 ( 0.00%)  	  __y = __x;
      310 ( 0.00%)  	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
    1,426 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_S_key(std::_Rb_tree_node<unsigned short> const*) (31x)
      403 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<unsigned short>::operator()(unsigned short const&, unsigned short const&) const (31x)
      215 ( 0.00%)  	  __x = __comp ? _S_left(__x) : _S_right(__x);
      203 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_S_left(std::_Rb_tree_node_base*) (29x)
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_S_right(std::_Rb_tree_node_base*) (2x)
        .           	}
    3,730 ( 0.00%)        iterator __j = iterator(__y);
       10 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (1x)
    1,492 ( 0.00%)        if (__comp)
        .           	{
    8,195 ( 0.00%)  	  if (__j == begin())
       23 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::begin() (1x)
       12 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > const&, std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > const&) (1x)
    6,705 ( 0.00%)  	    return _Res(__x, __y);
       33 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>::pair<std::_Rb_tree_node<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >*&, std::_Rb_tree_node_base*&>(std::_Rb_tree_node<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >*&, std::_Rb_tree_node_base*&) (1x)
        .           	  else
        .           	    --__j;
        .           	}
       12 ( 0.00%)        if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
       13 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<unsigned short>::operator()(unsigned short const&, unsigned short const&) const (1x)
       55 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_S_key(std::_Rb_tree_node_base const*) (1x)
        9 ( 0.00%)  	return _Res(__x, __y);
       33 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>::pair<std::_Rb_tree_node<unsigned short>*&, std::_Rb_tree_node_base*&>(std::_Rb_tree_node<unsigned short>*&, std::_Rb_tree_node_base*&) (1x)
        .                 return _Res(__j._M_node, 0);
    2,238 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr,
        .           	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr>
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
-- line 2136 ----------------------------------------
-- line 2198 ----------------------------------------
        .               }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr,
        .           	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr>
   22,484 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_get_insert_hint_unique_pos(const_iterator __position,
        .           				  const key_type& __k)
        .               {
   12,848 ( 0.00%)        iterator __pos = __position._M_const_cast();
      414 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >::_M_const_cast() const (18x)
        .                 typedef pair<_Base_ptr, _Base_ptr> _Res;
        .           
        .                 // end()
   25,696 ( 0.00%)        if (__pos._M_node == _M_end())
      126 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_end() (18x)
        .           	{
   15,840 ( 0.00%)  	  if (size() > 0
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::size() const (2x)
   48,436 ( 0.00%)  	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
       72 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::pair<unsigned long, unsigned int> >::operator()(std::pair<unsigned long, unsigned int> const&, std::pair<unsigned long, unsigned int> const&) const (1x)
       55 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_S_key(std::_Rb_tree_node_base const*) (1x)
        7 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_rightmost() (1x)
   31,486 ( 0.00%)  	    return _Res(0, _M_rightmost());
       16 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>::pair(std::_Rb_tree_node_base* const&, std::_Rb_tree_node_base* const&) (1x)
        7 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_rightmost() (1x)
        .           	  else
    4,476 ( 0.00%)  	    return _M_get_insert_unique_pos(__k);
      150 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_get_insert_unique_pos(std::pair<unsigned long, unsigned int> const&) (1x)
        .           	}
      484 ( 0.00%)        else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
    1,212 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::pair<unsigned long, unsigned int> >::operator()(std::pair<unsigned long, unsigned int> const&, std::pair<unsigned long, unsigned int> const&) const (16x)
      880 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_S_key(std::_Rb_tree_node_base const*) (16x)
        .           	{
        .           	  // First, try before...
       88 ( 0.00%)  	  iterator __before = __pos;
      396 ( 0.00%)  	  if (__pos._M_node == _M_leftmost()) // begin()
      112 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_leftmost() (16x)
      224 ( 0.00%)  	    return _Res(_M_leftmost(), _M_leftmost());
      231 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>::pair<std::_Rb_tree_node_base*&, std::_Rb_tree_node_base*&>(std::_Rb_tree_node_base*&, std::_Rb_tree_node_base*&) (7x)
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_leftmost() (14x)
      450 ( 0.00%)  	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
      688 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::pair<unsigned long, unsigned int> >::operator()(std::pair<unsigned long, unsigned int> const&, std::pair<unsigned long, unsigned int> const&) const (9x)
      495 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_S_key(std::_Rb_tree_node_base const*) (9x)
      257 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >::operator--() (9x)
        .           	    {
      210 ( 0.00%)  	      if (_S_right(__before._M_node) == 0)
       63 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_S_right(std::_Rb_tree_node_base*) (9x)
      140 ( 0.00%)  		return _Res(0, __before._M_node);
       64 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>::pair(std::_Rb_tree_node_base* const&, std::_Rb_tree_node_base* const&) (4x)
        .           	      else
      144 ( 0.00%)  		return _Res(__pos._M_node, __pos._M_node);
      165 ( 0.00%)  => /usr/include/c++/14/bits/stl_pair.h:std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>::pair<std::_Rb_tree_node_base*&, std::_Rb_tree_node_base*&>(std::_Rb_tree_node_base*&, std::_Rb_tree_node_base*&) (5x)
        .           	    }
        .           	  else
        .           	    return _M_get_insert_unique_pos(__k);
        .           	}
        .                 else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
        .           	{
        .           	  // ... then try after.
        .           	  iterator __after = __pos;
-- line 2241 ----------------------------------------
-- line 2249 ----------------------------------------
        .           		return _Res(__after._M_node, __after._M_node);
        .           	    }
        .           	  else
        .           	    return _M_get_insert_unique_pos(__k);
        .           	}
        .                 else
        .           	// Equivalent keys.
        .           	return _Res(__pos._M_node, 0);
    9,636 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .           #if __cplusplus >= 201103L
        .               template<typename _Arg, typename _NodeGen>
        .           #else
        .               template<typename _NodeGen>
        .           #endif
        .                 typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
       98 ( 0.00%)        _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .                 _M_insert_unique_(const_iterator __position,
        .           #if __cplusplus >= 201103L
        .           			_Arg&& __v,
        .           #else
        .           			const _Val& __v,
        .           #endif
        .           			_NodeGen& __node_gen)
        .               {
        .                 pair<_Base_ptr, _Base_ptr> __res
      182 ( 0.00%)  	= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
    6,962 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_get_insert_hint_unique_pos(std::_Rb_tree_const_iterator<unsigned short>, unsigned short const&) (14x)
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::_Identity<unsigned short>::operator()(unsigned short const&) const (14x)
        .           
       42 ( 0.00%)        if (__res.second)
      154 ( 0.00%)  	return _M_insert_(__res.first, __res.second,
    8,572 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<unsigned short> std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_M_insert_<unsigned short const&, std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node>(std::_Rb_tree_node_base*, std::_Rb_tree_node_base*, unsigned short const&, std::_Rb_tree<unsigned short, unsigned short, std::_Identity<unsigned short>, std::less<unsigned short>, std::allocator<unsigned short> >::_Reuse_or_alloc_node&) (14x)
       84 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned short const& std::forward<unsigned short const&>(std::remove_reference<unsigned short const&>::type&) (14x)
        .           			  _GLIBCXX_FORWARD(_Arg, __v),
       14 ( 0.00%)  			  __node_gen);
        .                 return iterator(__res.first);
       28 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr,
        .           	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           			   _Compare, _Alloc>::_Base_ptr>
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
-- line 2292 ----------------------------------------
-- line 2365 ----------------------------------------
        .           
        .           	return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));
        .                 }
        .           
        .           #if __cplusplus >= 201103L
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               auto
   28,782 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
        .               -> iterator
        .               {
   19,038 ( 0.00%)        bool __insert_left = (__x != 0 || __p == _M_end()
       84 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_M_end() (12x)
   44,460 ( 0.00%)  			    || _M_impl._M_key_compare(_S_key(__z),
      634 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<ColorCombinerKey>::operator()(ColorCombinerKey const&, ColorCombinerKey const&) const (11x)
      605 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_S_key(std::_Rb_tree_node_base const*) (11x)
      506 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<ColorCombinerKey, std::pair<ColorCombinerKey const, ColorCombiner>, std::_Select1st<std::pair<ColorCombinerKey const, ColorCombiner> >, std::less<ColorCombinerKey>, std::allocator<std::pair<ColorCombinerKey const, ColorCombiner> > >::_S_key(std::_Rb_tree_node<std::pair<ColorCombinerKey const, ColorCombiner> > const*) (11x)
        .           						      _S_key(__p)));
        .           
   19,192 ( 0.00%)        _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
      947 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++98/../../../../../libstdc++-v3/src/c++98/tree.cc:std::_Rb_tree_insert_and_rebalance(bool, std::_Rb_tree_node_base*, std::_Rb_tree_node_base*, std::_Rb_tree_node_base&) (20x)
    6,396 ( 0.00%)  				    this->_M_impl._M_header);
   15,990 ( 0.00%)        ++_M_impl._M_node_count;
   19,188 ( 0.00%)        return iterator(__z);
      200 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_iterator<std::pair<ColorCombinerKey const, ColorCombiner> >::_Rb_tree_iterator(std::_Rb_tree_node_base*) (20x)
   15,990 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               auto
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
        .               -> iterator
        .               {
-- line 2393 ----------------------------------------
-- line 2446 ----------------------------------------
        .           	auto __res = _M_get_insert_equal_pos(__z._M_key());
        .           	return __z._M_insert(__res);
        .                 }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               template<typename... _Args>
        .                 auto
   26,182 ( 0.00%)        _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .                 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
        .                 -> iterator
        .                 {
   43,039 ( 0.00%)  	_Auto_node __z(*this, std::forward<_Args>(__args)...);
   13,595 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_Auto_node::_Auto_node<std::piecewise_construct_t const&, std::tuple<std::pair<unsigned long, unsigned int>&&>, std::tuple<> >(std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >&, std::piecewise_construct_t const&, std::tuple<std::pair<unsigned long, unsigned int>&&>&&, std::tuple<>&&) (18x)
      108 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<std::pair<unsigned long, unsigned int>&&>&& std::forward<std::tuple<std::pair<unsigned long, unsigned int>&&> >(std::remove_reference<std::tuple<std::pair<unsigned long, unsigned int>&&> >::type&) (18x)
      108 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::tuple<>&& std::forward<std::tuple<> >(std::remove_reference<std::tuple<> >::type&) (18x)
      108 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::piecewise_construct_t const& std::forward<std::piecewise_construct_t const&>(std::remove_reference<std::piecewise_construct_t const&>::type&) (18x)
   35,178 ( 0.00%)  	auto __res = _M_get_insert_hint_unique_pos(__pos, __z._M_key());
    6,320 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_M_get_insert_hint_unique_pos(std::_Rb_tree_const_iterator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::pair<unsigned long, unsigned int> const&) (18x)
    1,008 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_Auto_node::_M_key() const (18x)
    9,594 ( 0.00%)  	if (__res.second)
   25,584 ( 0.00%)  	  return __z._M_insert(__res);
    3,257 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_Auto_node::_M_insert(std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>) (18x)
        .           	return iterator(__res.first);
   26,202 ( 0.00%)        }
      198 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::pair<unsigned long, unsigned int>, std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram>, std::_Select1st<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> >, std::less<std::pair<unsigned long, unsigned int> >, std::allocator<std::pair<std::pair<unsigned long, unsigned int> const, ShaderProgram> > >::_Auto_node::~_Auto_node() (18x)
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               template<typename... _Args>
        .                 auto
        .                 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .                 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
        .                 -> iterator
-- line 2471 ----------------------------------------
-- line 2491 ----------------------------------------
        .           				 this->_M_impl._M_header));
        .                 _M_drop_node(__y);
        .                 --_M_impl._M_node_count;
        .               }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               void
       84 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               _M_erase_aux(const_iterator __first, const_iterator __last)
        .               {
      378 ( 0.00%)        if (__first == begin() && __last == end())
      252 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&, std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (21x)
      322 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::begin() (14x)
      231 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_const_iterator(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (21x)
      161 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() (7x)
        .           	clear();
        .                 else
      112 ( 0.00%)  	while (__first != __last)
      168 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&, std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (14x)
        .           	  _M_erase_aux(__first++);
       42 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
       70 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               erase(const _Key& __x)
        .               {
       98 ( 0.00%)        pair<iterator, iterator> __p = equal_range(__x);
   47,855 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::equal_range(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (14x)
       56 ( 0.00%)        const size_type __old_size = size();
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::size() const (14x)
      238 ( 0.00%)        _M_erase_aux(__p.first, __p.second);
    1,750 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_erase_aux(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >) (14x)
      308 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >::_Rb_tree_const_iterator(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (28x)
       84 ( 0.00%)        return __old_size - size();
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::size() const (14x)
       28 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           		      _Compare, _Alloc>::iterator
  523,068 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               find(const _Key& __k)
        .               {
1,307,670 ( 0.00%)        iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
   17,575 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_lower_bound(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >*, std::_Rb_tree_node_base*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (28x)
      448 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_begin() (28x)
      196 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_M_end() (28x)
  784,602 ( 0.00%)        return (__j == end()
      644 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() (28x)
      336 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&, std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > const&) (28x)
  216,440 ( 0.00%)  	      || _M_impl._M_key_compare(__k,
    5,305 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:decltype (((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#1}))<((forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>)({parm#2}))) std::less<void>::operator()<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (22x)
    1,210 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::_S_key(std::_Rb_tree_node_base const*) (22x)
  479,906 ( 0.00%)  					_S_key(__j._M_node))) ? end() : __j;
      414 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > >, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >::end() (18x)
  261,534 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue,
        .           		      _Compare, _Alloc>::const_iterator
    2,586 ( 0.00%)      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               find(const _Key& __k) const
        .               {
    6,465 ( 0.00%)        const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
  457,535 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_M_lower_bound(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const*, std::_Rb_tree_node_base const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (431x)
    3,017 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_M_end() const (431x)
    3,017 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_M_begin() const (431x)
    3,879 ( 0.00%)        return (__j == end()
    9,913 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::end() const (431x)
    5,172 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::operator==(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const&, std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > const&) (431x)
    4,719 ( 0.00%)  	      || _M_impl._M_key_compare(__k,
   84,685 ( 0.00%)  => /usr/include/c++/14/bits/stl_function.h:std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const (429x)
   23,595 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::_S_key(std::_Rb_tree_node_base const*) (429x)
    1,350 ( 0.00%)  					_S_key(__j._M_node))) ? end() : __j;
      437 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> >, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::GuiWindow> > > >::end() const (19x)
    1,293 ( 0.00%)      }
        .           
        .             template<typename _Key, typename _Val, typename _KeyOfValue,
        .           	   typename _Compare, typename _Alloc>
        .               typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
        .               _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
        .               count(const _Key& __k) const
        .               {
        .                 pair<const_iterator, const_iterator> __p = equal_range(__k);
-- line 2553 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/stormlib-src/src/SBaseFileTable.cpp
--------------------------------------------------------------------------------
Ir               

-- line 308 ----------------------------------------
      .                   }
      .               }
      .           
      .               // Return the returned archive size
      .               return (EndOfMpq - MpqOffset);
      .           }
      .           
      .           static ULONGLONG DetermineBlockTableSize_V2(TMPQHeader * pHeader, ULONGLONG MpqHeaderPos, ULONGLONG FileSize)
     15 ( 0.00%)  {
     30 ( 0.00%)      ULONGLONG BlockTablePos = MAKE_OFFSET64(pHeader->wBlockTablePosHi, pHeader->dwBlockTablePos);
      9 ( 0.00%)      ULONGLONG ArchiveSize = FileSize - MpqHeaderPos;
      .           
      .               // If there is a hi-block table and it is beyond the block table,
      .               // we can determine the block table size from it
     12 ( 0.00%)      if(pHeader->HiBlockTablePos64 != 0)
      .               {
      .                   if(pHeader->HiBlockTablePos64 > BlockTablePos)
      .                   {
      .                       return (pHeader->HiBlockTablePos64 - BlockTablePos);
      .                   }
      .               }
      .           
      .               // If we have valid archive size, we can determine the block table size from the archive size
      .               else
      .               {
     24 ( 0.00%)          if((BlockTablePos >> 0x20) == 0 && (ArchiveSize >> 0x20) == 0)
      .                   {
      6 ( 0.00%)              DWORD dwBlockTablePos32 = (DWORD)(BlockTablePos);
      6 ( 0.00%)              DWORD dwArchiveSize32 = (DWORD)(ArchiveSize);
      .           
     12 ( 0.00%)              if(pHeader->dwArchiveSize == dwArchiveSize32)
      .                       {
     12 ( 0.00%)                  return (dwArchiveSize32 - dwBlockTablePos32);
      .                       }
      .                   }
      .               }
      .           
      .               // Default is the block table size from MPQ header
      .               return (ULONGLONG)(pHeader->dwBlockTableSize) * sizeof(TMPQBlock);
      6 ( 0.00%)  }
      .           
      .           static ULONGLONG DetermineArchiveSize_V4(
      .               TMPQHeader * pHeader,
      .               ULONGLONG /* MpqOffset */,
      .               ULONGLONG /* FileSize */)
      .           {
      .               ULONGLONG ArchiveSize = 0;
      .               ULONGLONG EndOfTable;
-- line 355 ----------------------------------------
-- line 381 ----------------------------------------
      .               if(EndOfTable > ArchiveSize)
      .                   ArchiveSize = EndOfTable;
      .           
      .               // Return the calculated archive size
      .               return ArchiveSize;
      .           }
      .           
      .           ULONGLONG FileOffsetFromMpqOffset(TMPQArchive * ha, ULONGLONG MpqOffset)
 68,928 ( 0.00%)  {
 86,160 ( 0.00%)      if(ha->pHeader->wFormatVersion == MPQ_FORMAT_VERSION_1)
      .               {
      .                   // For MPQ archive v1, any file offset is only 32-bit
      .                   return (ULONGLONG)((DWORD)ha->MpqPos + (DWORD)MpqOffset);
      .               }
      .               else
      .               {
      .                   // For MPQ archive v2+, file offsets are full 64-bit
 68,928 ( 0.00%)          return ha->MpqPos + MpqOffset;
      .               }
 34,464 ( 0.00%)  }
      .           
      .           ULONGLONG CalculateRawSectorOffset(
      .               TMPQFile * hf,
      .               DWORD dwSectorOffset)
  3,905 ( 0.00%)  {
      .               ULONGLONG RawFilePos;
      .           
      .               // Must be used for files within a MPQ
  3,124 ( 0.00%)      assert(hf->ha != NULL);
  3,905 ( 0.00%)      assert(hf->ha->pHeader != NULL);
      .           
      .               //
      .               // Some MPQ protectors place the sector offset table after the actual file data.
      .               // Sector offsets in the sector offset table are negative. When added
      .               // to MPQ file offset from the block table entry, the result is a correct
      .               // position of the file data in the MPQ.
      .               //
      .               // For MPQs version 1.0, the offset is purely 32-bit
      .               //
      .           
  3,905 ( 0.00%)      RawFilePos = hf->RawFilePos + dwSectorOffset;
  4,686 ( 0.00%)      if(hf->ha->pHeader->wFormatVersion == MPQ_FORMAT_VERSION_1)
      .                   RawFilePos = (DWORD)hf->ha->MpqPos + (DWORD)hf->pFileEntry->ByteOffset + dwSectorOffset;
      .           
      .               // We also have to add patch header size, if patch header is present
  3,124 ( 0.00%)      if(hf->pPatchInfo != NULL)
      .                   RawFilePos += hf->pPatchInfo->dwLength;
      .           
      .               // Return the result offset
    781 ( 0.00%)      return RawFilePos;
  1,562 ( 0.00%)  }
      .           
      .           // This function converts the MPQ header so it always looks like version 4
      .           DWORD ConvertMpqHeaderToFormat4(
      .               TMPQArchive * ha,
      .               ULONGLONG ByteOffset,
      .               ULONGLONG FileSize,
      .               DWORD dwFlags,
      .               MTYPE MapType)
     24 ( 0.00%)  {
      9 ( 0.00%)      TMPQHeader * pHeader = (TMPQHeader *)ha->HeaderData;
      3 ( 0.00%)      ULONGLONG BlockTablePos64 = 0;
      3 ( 0.00%)      ULONGLONG HashTablePos64 = 0;
      3 ( 0.00%)      ULONGLONG BlockTableMask = (ULONGLONG)-1;
      .               ULONGLONG MaxOffset;
      9 ( 0.00%)      USHORT wFormatVersion = BSWAP_INT16_UNSIGNED(pHeader->wFormatVersion);
      3 ( 0.00%)      bool bHashBlockOffsetOK = false;
      3 ( 0.00%)      bool bHetBetOffsetOK = false;
      3 ( 0.00%)      DWORD dwErrCode = ERROR_SUCCESS;
      .           
      .               // If version 1.0 is forced, then the format version is forced to be 1.0
      .               // Reason: Storm.dll in Warcraft III ignores format version value
     18 ( 0.00%)      if((MapType == MapTypeWarcraft3) || (dwFlags & MPQ_OPEN_FORCE_MPQ_V1))
      .                   wFormatVersion = MPQ_FORMAT_VERSION_1;
      .           
      .               // Don't accept format 3 for Starcraft II maps
      6 ( 0.00%)      if((MapType == MapTypeStarcraft2) && (pHeader->wFormatVersion > MPQ_FORMAT_VERSION_2))
      .                   wFormatVersion = MPQ_FORMAT_VERSION_4;
      .           
      .               // Format-specific fixes
     39 ( 0.00%)      switch(wFormatVersion)
      .               {
      .                   case MPQ_FORMAT_VERSION_1:
      .           
      .                       // Check for malformed MPQ header version 1.0
      .                       BSWAP_TMPQHEADER(pHeader, MPQ_FORMAT_VERSION_1);
      .                       if(pHeader->wFormatVersion != MPQ_FORMAT_VERSION_1 || pHeader->dwHeaderSize != MPQ_HEADER_SIZE_V1)
      .                       {
      .                           pHeader->wFormatVersion = MPQ_FORMAT_VERSION_1;
-- line 469 ----------------------------------------
-- line 518 ----------------------------------------
      .                           pHeader->BlockTableSize64 = pHeader->dwBlockTableSize * sizeof(TMPQBlock);
      .                       }
      .                       break;
      .           
      .                   case MPQ_FORMAT_VERSION_2:
      .           
      .                       // Check for malformed MPQ header version 1.0
      .                       BSWAP_TMPQHEADER(pHeader, MPQ_FORMAT_VERSION_2);
     24 ( 0.00%)              if(pHeader->wFormatVersion != MPQ_FORMAT_VERSION_2 || pHeader->dwHeaderSize != MPQ_HEADER_SIZE_V2)
      .                       {
      .                           pHeader->wFormatVersion = MPQ_FORMAT_VERSION_1;
      .                           pHeader->dwHeaderSize = MPQ_HEADER_SIZE_V1;
      .                           ha->dwFlags |= MPQ_FLAG_MALFORMED;
      .                           goto Label_ArchiveVersion1;
      .                       }
      .           
      .                       // Fill the rest of the header with zeros
     21 ( 0.00%)              memset((LPBYTE)pHeader + MPQ_HEADER_SIZE_V2, 0, sizeof(TMPQHeader) - MPQ_HEADER_SIZE_V2);
     78 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (3x)
      .           
      .                       // Calculate the expected hash table size
     21 ( 0.00%)              pHeader->HashTableSize64 = (pHeader->dwHashTableSize * sizeof(TMPQHash));
     30 ( 0.00%)              HashTablePos64 = MAKE_OFFSET64(pHeader->wHashTablePosHi, pHeader->dwHashTablePos);
      .           
      .                       // Calculate the expected block table size
     21 ( 0.00%)              pHeader->BlockTableSize64 = (pHeader->dwBlockTableSize * sizeof(TMPQBlock));
     30 ( 0.00%)              BlockTablePos64 = MAKE_OFFSET64(pHeader->wBlockTablePosHi, pHeader->dwBlockTablePos);
      .           
      .                       // We require the block table to follow hash table
      9 ( 0.00%)              if(BlockTablePos64 >= HashTablePos64)
      .                       {
      .                           // Determine whether the hash table is compressed. This can be detected
      .                           // by subtracting hash table position from the block table position.
     15 ( 0.00%)                  pHeader->HashTableSize64 = BlockTablePos64 - HashTablePos64;
      .           
      .                           // Also, block table may be compressed. We check whether the HiBlockTable is there.
      .                           // If not, we try to use the archive size. Note that ArchiveSize may have
      .                           // an arbitrary value, because it is not tested by Blizzard games anymore
     27 ( 0.00%)                  pHeader->BlockTableSize64 = DetermineBlockTableSize_V2(pHeader, ByteOffset, FileSize);
    132 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:DetermineBlockTableSize_V2(_TMPQHeader*, unsigned long long, unsigned long long) (3x)
      .                       }
      .                       else
      .                       {
      .                           pHeader->ArchiveSize64 = pHeader->dwArchiveSize;
      .                           ha->dwFlags |= MPQ_FLAG_MALFORMED;
      .                       }
      .           
      .                       // Add the MPQ Offset
      6 ( 0.00%)              BlockTablePos64 += ByteOffset;
      3 ( 0.00%)              break;
      .           
      .                   case MPQ_FORMAT_VERSION_3:
      .           
      .                       // In MPQ format 3.0, the entire header is optional
      .                       // and the size of the header can actually be identical
      .                       // to size of header 2.0
      .                       BSWAP_TMPQHEADER(pHeader, MPQ_FORMAT_VERSION_3);
      .                       if(pHeader->dwHeaderSize < MPQ_HEADER_SIZE_V3)
-- line 573 ----------------------------------------
-- line 700 ----------------------------------------
      .           
      .                       // Calculate the block table position
      .                       BlockTablePos64 = ByteOffset + MAKE_OFFSET64(pHeader->wBlockTablePosHi, pHeader->dwBlockTablePos);
      .                       break;
      .               }
      .           
      .               // Handle case when block table is placed before the MPQ header
      .               // Used by BOBA protector
      9 ( 0.00%)      if(BlockTablePos64 < ByteOffset)
      .                   ha->dwFlags |= MPQ_FLAG_MALFORMED;
      3 ( 0.00%)      return dwErrCode;
      6 ( 0.00%)  }
      .           
      .           //-----------------------------------------------------------------------------
      .           // Support for hash table
      .           
      .           // Hash entry verification when the file table does not exist yet
      .           bool IsValidHashEntry(TMPQArchive * ha, TMPQHash * pHash)
      .           {
      .               TFileEntry * pFileEntry = ha->pFileTable + MPQ_BLOCK_INDEX(pHash);
      .           
      .               return ((MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize) && (pFileEntry->dwFlags & MPQ_FILE_EXISTS)) ? true : false;
      .           }
      .           
      .           // Hash entry verification when the file table does not exist yet
      .           static bool IsValidHashEntry1(TMPQArchive * ha, TMPQHash * pHash, TMPQBlock * pBlockTable)
589,824 ( 0.00%)  {
      .               ULONGLONG ByteOffset;
      .               TMPQBlock * pBlock;
      .           
      .               // The block index is considered valid if it's less than block table size
884,736 ( 0.00%)      if(MPQ_BLOCK_INDEX(pHash) < ha->pHeader->dwBlockTableSize)
      .               {
      .                   // Calculate the block table position
149,013 ( 0.00%)          pBlock = pBlockTable + MPQ_BLOCK_INDEX(pHash);
      .           
      .                   // Check whether this is an existing file
      .                   // Also we do not allow to be file size greater than 2GB
132,456 ( 0.00%)          if((pBlock->dwFlags & MPQ_FILE_EXISTS) && (pBlock->dwFSize & 0x80000000) == 0)
      .                   {
      .                       // The begin of the file must be within the archive
132,456 ( 0.00%)              ByteOffset = FileOffsetFromMpqOffset(ha, pBlock->dwFilePos);
248,355 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:FileOffsetFromMpqOffset(_TMPQArchive*, unsigned long long) (16,557x)
 82,785 ( 0.00%)              return (ByteOffset < ha->FileSize);
      .                   }
      .               }
      .           
 81,747 ( 0.00%)      return false;
196,608 ( 0.00%)  }
      .           
      .           // Returns a hash table entry in the following order:
      .           // 1) A hash table entry with the preferred locale and platform
      .           // 2) A hash table entry with the neutral|matching locale and neutral|matching platform
      .           // 3) NULL
      .           // Storm_2016.dll: 15020940
      .           static TMPQHash * GetHashEntryLocale(TMPQArchive * ha, const char * szFileName, LCID lcFileLocale)
  7,950 ( 0.00%)  {
  7,950 ( 0.00%)      TMPQHash * pFirstHash = GetFirstHashEntry(ha, szFileName);
6,054,222 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetFirstHashEntry(_TMPQArchive*, char const*) (1,325x)
  1,325 ( 0.00%)      TMPQHash * pBestEntry = NULL;
  2,650 ( 0.00%)      TMPQHash * pHash = pFirstHash;
  2,650 ( 0.00%)      USHORT Locale = SFILE_LOCALE(lcFileLocale);
  3,975 ( 0.00%)      BYTE Platform = SFILE_PLATFORM(lcFileLocale);
      .           
      .               // Parse the found hashes
  5,313 ( 0.00%)      while(pHash != NULL)
      .               {
      .                   // Storm_2016.dll: 150209CB
      .                   // If the hash entry matches both locale and platform, return it immediately
      .                   // Only do that for non-0 locale&platform, because for loc&plat=0, there's different
      .                   // processing in Warcraft III vs. Starcraft, which is abused by some protectors.
  2,676 ( 0.00%)          if((Locale || Platform) && pHash->Locale == Locale && pHash->Platform == Platform)
      .                       return pHash;
      .           
      .                   // Storm_2016.dll: 150209D9
      .                   // If (locale matches or is neutral) AND (platform matches or is neutral), remember this as the best entry
      .                   // Also remember the first matching entry for Starcraft maps
  2,676 ( 0.00%)          if(pHash->Locale == 0 || pHash->Locale == Locale)
      .                   {
  2,676 ( 0.00%)              if(pHash->Platform == 0 || pHash->Platform == Platform)
      .                       {
  1,338 ( 0.00%)                  pBestEntry = pHash;
      .                       }
      .                   }
      .           
      .                   // Get the next hash entry for that file
  4,683 ( 0.00%)          pHash = GetNextHashEntry(ha, pFirstHash, pHash);
 68,910 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetNextHashEntry(_TMPQArchive*, _TMPQHash*, _TMPQHash*) (669x)
      .               }
      .           
      .               // Return the best entry that we found
  1,325 ( 0.00%)      return pBestEntry;
  2,650 ( 0.00%)  }
      .           
      .           // Returns a hash table entry in the following order:
      .           // 1) A hash table entry with the preferred locale&platform
      .           // 2) NULL
      .           // In case there are multiple items with the same locale&platform,
      .           // we need to return the last one. This is because it must correspond to SFileOpenFileEx
      .           static TMPQHash * GetHashEntryExact(TMPQArchive * ha, const char * szFileName, LCID lcFileLocale)
      .           {
-- line 797 ----------------------------------------
-- line 876 ----------------------------------------
      .           
      .               return pHashTable;
      .           }
      .           */
      .           
      .           static DWORD BuildFileTableFromBlockTable(
      .               TMPQArchive * ha,
      .               TMPQBlock * pBlockTable)
     15 ( 0.00%)  {
      .               TFileEntry * pFileEntry;
      9 ( 0.00%)      TMPQHeader * pHeader = ha->pHeader;
      .               TMPQBlock * pBlock;
      .               TMPQHash * pHashTableEnd;
      .               TMPQHash * pHash;
      3 ( 0.00%)      LPDWORD DefragmentTable = NULL;
      3 ( 0.00%)      DWORD dwItemCount = 0;
      .           
      .               // Sanity checks
     12 ( 0.00%)      assert(ha->pFileTable != NULL);
     18 ( 0.00%)      assert(ha->dwFileTableSize >= ha->dwMaxFileCount);
      .           
      .               //
      .               // Defragmentation of the hash table was removed. The reason is a MPQ protector,
      .               // two hash entries with the same name, where only the second one is valid.
      .               // The index of the first entry (HashString(szFileName, 0)) points to the second one:
      .               //
      .               //      NameA     NameB     BlkIdx    Name
      .               //      B701656E  FCFB1EED  0000001C  staredit\scenario.chk (correct one)
-- line 903 ----------------------------------------
-- line 910 ----------------------------------------
      .               //if(ha->dwFlags & MPQ_FLAG_HASH_TABLE_CUT)
      .               //{
      .               //    ha->pHashTable = DefragmentHashTable(ha, ha->pHashTable, pBlockTable);
      .               //    ha->dwMaxFileCount = pHeader->dwHashTableSize;
      .               //}
      .           
      .               // If the hash table or block table is cut,
      .               // we will defragment the block table
     15 ( 0.00%)      if(ha->dwFlags & (MPQ_FLAG_HASH_TABLE_CUT | MPQ_FLAG_BLOCK_TABLE_CUT))
      .               {
      .                   // Sanity checks
      .                   assert(pHeader->HiBlockTablePos64 == 0);
      .           
      .                   // Allocate the translation table
      .                   DefragmentTable = STORM_ALLOC(DWORD, pHeader->dwBlockTableSize);
      .                   if(DefragmentTable == NULL)
      .                       return ERROR_NOT_ENOUGH_MEMORY;
      .           
      .                   // Fill the translation table
      .                   memset(DefragmentTable, 0xFF, pHeader->dwBlockTableSize * sizeof(DWORD));
      .               }
      .           
      .               // Parse the entire hash table
     24 ( 0.00%)      pHashTableEnd = ha->pHashTable + pHeader->dwHashTableSize;
393,237 ( 0.00%)      for(pHash = ha->pHashTable; pHash < pHashTableEnd; pHash++)
      .               {
      .                   //
      .                   // We need to properly handle these cases:
      .                   // - Multiple hash entries (same file name) point to the same block entry
      .                   // - Multiple hash entries (different file name) point to the same block entry
      .                   //
      .                   // Ignore all hash table entries where:
      .                   // - Block Index >= BlockTableSize
      .                   // - Flags of the appropriate block table entry
      .                   //
      .           
786,432 ( 0.00%)          if(IsValidHashEntry1(ha, pHash, pBlockTable))
2,497,980 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:IsValidHashEntry1(_TMPQArchive*, _TMPQHash*, _TMPQBlock*) (98,304x)
      .                   {
 66,228 ( 0.00%)              DWORD dwOldIndex = MPQ_BLOCK_INDEX(pHash);
 66,228 ( 0.00%)              DWORD dwNewIndex = MPQ_BLOCK_INDEX(pHash);
      .           
      .                       // Determine the new block index
 33,114 ( 0.00%)              if(DefragmentTable != NULL)
      .                       {
      .                           // Need to handle case when multiple hash
      .                           // entries point to the same block entry
      .                           if(DefragmentTable[dwOldIndex] == HASH_ENTRY_FREE)
      .                           {
      .                               DefragmentTable[dwOldIndex] = dwItemCount;
      .                               dwNewIndex = dwItemCount++;
      .                           }
-- line 960 ----------------------------------------
-- line 966 ----------------------------------------
      .                           // Fix the pointer in the hash entry
      .                           pHash->dwBlockIndex = dwNewIndex;
      .           
      .                           // Dump the relocation entry
      .           //              printf("Relocating hash entry %08X-%08X: %08X -> %08X\n", pHash->dwName1, pHash->dwName2, dwBlockIndex, dwNewIndex);
      .                       }
      .           
      .                       // Get the pointer to the file entry and the block entry
 99,342 ( 0.00%)              pFileEntry = ha->pFileTable + dwNewIndex;
 99,342 ( 0.00%)              pBlock = pBlockTable + dwOldIndex;
      .           
      .                       // ByteOffset is only valid if file size is not zero
 82,785 ( 0.00%)              pFileEntry->ByteOffset = pBlock->dwFilePos;
 66,228 ( 0.00%)              if(pFileEntry->ByteOffset == 0 && pBlock->dwFSize == 0)
      .                           pFileEntry->ByteOffset = ha->pHeader->dwHeaderSize;
      .           
      .                       // Clear file flags that are unknown to this type of map.
115,899 ( 0.00%)              pFileEntry->dwFlags = pBlock->dwFlags & ha->dwValidFileFlags;
      .           
      .                       // Fill the rest of the file entry
 66,228 ( 0.00%)              pFileEntry->dwFileSize = pBlock->dwFSize;
 66,228 ( 0.00%)              pFileEntry->dwCmpSize  = pBlock->dwCSize;
      .                   }
      .               }
      .           
      .               // Free the translation table
      6 ( 0.00%)      if(DefragmentTable != NULL)
      .               {
      .                   // If we defragmented the block table in the process,
      .                   // free some memory by shrinking the file table
      .                   if(ha->dwFileTableSize > ha->dwMaxFileCount)
      .                   {
      .                       ha->pFileTable = STORM_REALLOC(TFileEntry, ha->pFileTable, ha->dwMaxFileCount);
      .                       ha->pHeader->BlockTableSize64 = ha->dwMaxFileCount * sizeof(TMPQBlock);
      .                       ha->pHeader->dwBlockTableSize = ha->dwMaxFileCount;
-- line 1000 ----------------------------------------
-- line 1002 ----------------------------------------
      .                   }
      .           
      .           //      DumpFileTable(ha->pFileTable, ha->dwFileTableSize);
      .           
      .                   // Free the translation table
      .                   STORM_FREE(DefragmentTable);
      .               }
      .           
      3 ( 0.00%)      return ERROR_SUCCESS;
      6 ( 0.00%)  }
      .           
      .           static TMPQHash * TranslateHashTable(
      .               TMPQArchive * ha,
      .               ULONGLONG * pcbTableSize)
      .           {
      .               TMPQHash * pHashTable;
      .               size_t HashTableSize;
      .           
-- line 1019 ----------------------------------------
-- line 1955 ----------------------------------------
      .                   STORM_FREE(pBetTable);
      .               }
      .           }
      .           
      .           //-----------------------------------------------------------------------------
      .           // Support for file table
      .           
      .           TFileEntry * GetFileEntryLocale(TMPQArchive * ha, const char * szFileName, LCID lcFileLocale, LPDWORD PtrHashIndex)
  9,275 ( 0.00%)  {
      .               TMPQHash * pHash;
      .               DWORD dwFileIndex;
      .           
      .               // First, we have to search the classic hash table
      .               // This is because on renaming, deleting, or changing locale,
      .               // we will need the pointer to hash table entry
  5,300 ( 0.00%)      if(ha->pHashTable != NULL)
      .               {
  9,275 ( 0.00%)          pHash = GetHashEntryLocale(ha, szFileName, lcFileLocale);
6,172,969 ( 0.01%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:GetHashEntryLocale(_TMPQArchive*, char const*, unsigned int) (1,325x)
  8,002 ( 0.00%)          if(pHash != NULL && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
      .                   {
  1,338 ( 0.00%)              if(PtrHashIndex != NULL)
  5,967 ( 0.00%)                  PtrHashIndex[0] = (DWORD)(pHash - ha->pHashTable);
  6,021 ( 0.00%)              return ha->pFileTable + MPQ_BLOCK_INDEX(pHash);
      .                   }
      .               }
      .           
      .               // If we have HET table in the MPQ, try to find the file in HET table
  2,624 ( 0.00%)      if(ha->pHetTable != NULL)
      .               {
      .                   dwFileIndex = GetFileIndex_Het(ha, szFileName);
      .                   if(dwFileIndex != HASH_ENTRY_FREE)
      .                       return ha->pFileTable + dwFileIndex;
      .               }
      .           
      .               // Not found
    656 ( 0.00%)      return NULL;
  2,650 ( 0.00%)  }
      .           
      .           TFileEntry * GetFileEntryExact(TMPQArchive * ha, const char * szFileName, LCID lcFileLocale, LPDWORD PtrHashIndex)
      .           {
      .               TMPQHash * pHash;
      .               DWORD dwFileIndex;
      .           
      .               // If the hash table is present, find the entry from hash table
      .               if(ha->pHashTable != NULL)
-- line 1999 ----------------------------------------
-- line 2019 ----------------------------------------
      .                   }
      .               }
      .           
      .               // Not found
      .               return NULL;
      .           }
      .           
      .           void AllocateFileName(TMPQArchive * ha, TFileEntry * pFileEntry, const char * szFileName)
103,320 ( 0.00%)  {
      .               // Sanity check
 34,440 ( 0.00%)      assert(pFileEntry != NULL);
      .           
      .               // If the file name is pseudo file name, free it at this point
120,540 ( 0.00%)      if(IsPseudoFileName(pFileEntry->szFileName, NULL))
227,185 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:IsPseudoFileName(char const*, unsigned int*) (17,220x)
      .               {
      .                   if(pFileEntry->szFileName != NULL)
      .                       STORM_FREE(pFileEntry->szFileName);
      .                   pFileEntry->szFileName = NULL;
      .               }
      .           
      .               // Only allocate new file name if it's not there yet
 68,880 ( 0.00%)      if(pFileEntry->szFileName == NULL)
      .               {
182,127 ( 0.00%)          pFileEntry->szFileName = STORM_ALLOC(char, strlen(szFileName) + 1);
3,415,796 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (16,557x)
284,199 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (16,557x)
 66,228 ( 0.00%)          if(pFileEntry->szFileName != NULL)
115,903 ( 0.00%)              strcpy(pFileEntry->szFileName, szFileName);
388,953 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcpy-avx2.S:__strcpy_avx2 (16,557x)
  1,368 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      .               }
      .           
      .               // We also need to create the file name hash
 68,880 ( 0.00%)      if(ha->pHetTable != NULL)
      .               {
      .                   ULONGLONG AndMask64 = ha->pHetTable->AndMask64;
      .                   ULONGLONG OrMask64 = ha->pHetTable->OrMask64;
      .           
      .                   pFileEntry->FileNameHash = (HashStringJenkins(szFileName) & AndMask64) | OrMask64;
      .               }
 51,660 ( 0.00%)  }
      .           
      .           TFileEntry * AllocateFileEntry(TMPQArchive * ha, const char * szFileName, LCID lcFileLocale, LPDWORD PtrHashIndex)
      .           {
      .               TFileEntry * pFileTableEnd = ha->pFileTable + ha->dwFileTableSize;
      .               TFileEntry * pFreeEntry = NULL;
      .               TFileEntry * pFileEntry;
      .               TMPQHash * pHash = NULL;
      .               DWORD dwReservedFiles = ha->dwReservedFiles;
-- line 2063 ----------------------------------------
-- line 2306 ----------------------------------------
      .               memset(pHashTable, 0xFF, dwHashTableSize * sizeof(TMPQHash));
      .               ha->pHeader->dwHashTableSize = dwHashTableSize;
      .               ha->dwMaxFileCount = dwHashTableSize;
      .               ha->pHashTable = pHashTable;
      .               return ERROR_SUCCESS;
      .           }
      .           
      .           static TMPQHash * LoadHashTable(TMPQArchive * ha)
     12 ( 0.00%)  {
      9 ( 0.00%)      TMPQHeader * pHeader = ha->pHeader;
      .               ULONGLONG ByteOffset;
      3 ( 0.00%)      TMPQHash * pHashTable = NULL;
      .               DWORD dwTableSize;
      .               DWORD dwCmpSize;
      3 ( 0.00%)      DWORD dwRealTableSize = 0;
      .           
      .               // Note: It is allowed to load hash table if it is at offset 0.
      .               // Example: MPQ_2016_v1_ProtectedMap_HashOffsIsZero.w3x
      .           //  if(pHeader->dwHashTablePos == 0 && pHeader->wHashTablePosHi == 0)
      .           //      return NULL;
      .           
      .               // If the hash table size is zero, do nothing
     12 ( 0.00%)      if(pHeader->dwHashTableSize == 0)
      .                   return NULL;
      .           
      .               // Load the hash table for MPQ variations
     24 ( 0.00%)      switch(ha->dwSubType)
      .               {
      .                   case MPQ_SUBTYPE_MPQ:
      .           
      .                       // Calculate the position and size of the hash table
     42 ( 0.00%)              ByteOffset = FileOffsetFromMpqOffset(ha, MAKE_OFFSET64(pHeader->wHashTablePosHi, pHeader->dwHashTablePos));
     45 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:FileOffsetFromMpqOffset(_TMPQArchive*, unsigned long long) (3x)
     12 ( 0.00%)              dwTableSize = pHeader->dwHashTableSize * sizeof(TMPQHash);
      9 ( 0.00%)              dwCmpSize = (DWORD)pHeader->HashTableSize64;
      .           
      .                       // Read, decrypt and uncompress the hash table
     48 ( 0.00%)              pHashTable = (TMPQHash *)LoadMpqTable(ha, ByteOffset, pHeader->MD5_HashTable, dwCmpSize, dwTableSize, g_dwHashTableKey, &dwRealTableSize);
16,517,090 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:LoadMpqTable(_TMPQArchive*, unsigned long long, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int*) (3x)
      .           //          DumpHashTable(pHashTable, pHeader->dwHashTableSize);
      .           
      .                       // If the hash table was cut, we can/have to defragment it
     24 ( 0.00%)              if(pHashTable != NULL && dwRealTableSize != 0 && dwRealTableSize < dwTableSize)
      .                       {
      .                           ha->dwRealHashTableSize = dwRealTableSize;
      .                           ha->dwFlags |= (MPQ_FLAG_MALFORMED | MPQ_FLAG_HASH_TABLE_CUT);
      .                       }
      3 ( 0.00%)              break;
      .           
      .                   case MPQ_SUBTYPE_SQP:
      .                       pHashTable = LoadSqpHashTable(ha);
      .                       break;
      .           
      .                   case MPQ_SUBTYPE_MPK:
      .                       pHashTable = LoadMpkHashTable(ha);
      .                       break;
      .               }
      .           
      .               // Return the loaded hash table
      3 ( 0.00%)      return pHashTable;
      6 ( 0.00%)  }
      .           
      .           DWORD CreateFileTable(TMPQArchive * ha, DWORD dwFileTableSize)
      .           {
      .               ha->pFileTable = STORM_ALLOC(TFileEntry, dwFileTableSize);
      .               if(ha->pFileTable == NULL)
      .                   return ERROR_NOT_ENOUGH_MEMORY;
      .           
      .               memset(ha->pFileTable, 0x00, sizeof(TFileEntry) * dwFileTableSize);
      .               ha->dwFileTableSize = dwFileTableSize;
      .               return ERROR_SUCCESS;
      .           }
      .           
      .           TMPQBlock * LoadBlockTable(TMPQArchive * ha, bool /* bDontFixEntries */)
     18 ( 0.00%)  {
      9 ( 0.00%)      TMPQHeader * pHeader = ha->pHeader;
      3 ( 0.00%)      TMPQBlock * pBlockTable = NULL;
      .               ULONGLONG ByteOffset;
      .               DWORD dwTableSize;
      .               DWORD dwCmpSize;
      .               DWORD dwRealTableSize;
      .           
      .               // Note: It is possible that the block table starts at offset 0
      .               // Example: MPQ_2016_v1_ProtectedMap_HashOffsIsZero.w3x
      .           //  if(pHeader->dwBlockTablePos == 0 && pHeader->wBlockTablePosHi == 0)
      .           //      return NULL;
      .           
      .               // Do nothing if the block table size is zero
     12 ( 0.00%)      if(pHeader->dwBlockTableSize == 0)
      .                   return NULL;
      .           
      .               // Load the block table for MPQ variations
     24 ( 0.00%)      switch(ha->dwSubType)
      .               {
      .                   case MPQ_SUBTYPE_MPQ:
      .           
      .                       // Calculate byte position of the block table
     42 ( 0.00%)              ByteOffset = FileOffsetFromMpqOffset(ha, MAKE_OFFSET64(pHeader->wBlockTablePosHi, pHeader->dwBlockTablePos));
     45 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:FileOffsetFromMpqOffset(_TMPQArchive*, unsigned long long) (3x)
     12 ( 0.00%)              dwTableSize = pHeader->dwBlockTableSize * sizeof(TMPQBlock);
      9 ( 0.00%)              dwCmpSize = (DWORD)pHeader->BlockTableSize64;
      .           
      .                       // Read, decrypt and uncompress the block table
     48 ( 0.00%)              pBlockTable = (TMPQBlock * )LoadMpqTable(ha, ByteOffset, NULL, dwCmpSize, dwTableSize, g_dwBlockTableKey, &dwRealTableSize);
2,782,923 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:LoadMpqTable(_TMPQArchive*, unsigned long long, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int*) (3x)
      .           
      .                       // If the block table was cut, we need to remember it
     24 ( 0.00%)              if(pBlockTable != NULL && dwRealTableSize && dwRealTableSize < dwTableSize)
      .                           ha->dwFlags |= (MPQ_FLAG_MALFORMED | MPQ_FLAG_BLOCK_TABLE_CUT);
      3 ( 0.00%)              break;
      .           
      .                   case MPQ_SUBTYPE_SQP:
      .                       pBlockTable = LoadSqpBlockTable(ha);
      .                       break;
      .           
      .                   case MPQ_SUBTYPE_MPK:
      .                       pBlockTable = LoadMpkBlockTable(ha);
      .                       break;
      .               }
      .           
      3 ( 0.00%)      return pBlockTable;
      6 ( 0.00%)  }
      .           
      .           TMPQHetTable * LoadHetTable(TMPQArchive * ha)
      .           {
      .               TMPQExtHeader * pExtTable;
      .               TMPQHetTable * pHetTable = NULL;
      .               TMPQHeader * pHeader = ha->pHeader;
      .           
      .               // If the HET table position is not 0, we expect the table to be present
-- line 2431 ----------------------------------------
-- line 2463 ----------------------------------------
      .                       STORM_FREE(pExtTable);
      .                   }
      .               }
      .           
      .               return pBetTable;
      .           }
      .           
      .           DWORD LoadAnyHashTable(TMPQArchive * ha)
     12 ( 0.00%)  {
      9 ( 0.00%)      TMPQHeader * pHeader = ha->pHeader;
      .           
      .               // If the MPQ archive is empty, don't bother trying to load anything
     12 ( 0.00%)      if(pHeader->dwHashTableSize == 0 && pHeader->HetTableSize64 == 0)
      .                   return CreateHashTable(ha, HASH_TABLE_SIZE_DEFAULT);
      .           
      .               // Try to load HET table
     12 ( 0.00%)      if(pHeader->HetTablePos64 != 0)
      .                   ha->pHetTable = LoadHetTable(ha);
      .           
      .               // Try to load classic hash table
      .               // Note that we load the classic hash table even when HET table exists,
      .               // because if the MPQ gets modified and saved, hash table must be there
     12 ( 0.00%)      if(pHeader->dwHashTableSize)
     15 ( 0.00%)          ha->pHashTable = LoadHashTable(ha);
16,517,345 ( 0.01%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:LoadHashTable(_TMPQArchive*) (3x)
      .           
      .               // At least one of the tables must be present
     24 ( 0.00%)      if(ha->pHetTable == NULL && ha->pHashTable == NULL)
      .                   return ERROR_FILE_CORRUPT;
      .           
      .               // Set the maximum file count to the size of the hash table.
      .               // Note: We don't care about HET table limits, because HET table is rebuilt
      .               // after each file add/rename/delete.
     27 ( 0.00%)      ha->dwMaxFileCount = (ha->pHashTable != NULL) ? pHeader->dwHashTableSize : HASH_TABLE_SIZE_MAX;
      3 ( 0.00%)      return ERROR_SUCCESS;
      6 ( 0.00%)  }
      .           
      .           static DWORD BuildFileTable_Classic(TMPQArchive * ha)
     12 ( 0.00%)  {
      9 ( 0.00%)      TMPQHeader * pHeader = ha->pHeader;
      .               TMPQBlock * pBlockTable;
      3 ( 0.00%)      DWORD dwErrCode = ERROR_SUCCESS;
      .           
      .               // Sanity checks
     12 ( 0.00%)      assert(ha->pHashTable != NULL);
     12 ( 0.00%)      assert(ha->pFileTable != NULL);
      .           
      .               // If the MPQ has no block table, do nothing
     12 ( 0.00%)      if(pHeader->dwBlockTableSize == 0)
      .                   return ERROR_SUCCESS;
     18 ( 0.00%)      assert(ha->dwFileTableSize >= pHeader->dwBlockTableSize);
      .           
      .               // Load the block table
      .               // WARNING! ha->pFileTable can change in the process!!
     15 ( 0.00%)      pBlockTable = (TMPQBlock *)LoadBlockTable(ha);
2,783,181 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:LoadBlockTable(_TMPQArchive*, bool) (3x)
      6 ( 0.00%)      if(pBlockTable != NULL)
      .               {
     18 ( 0.00%)          dwErrCode = BuildFileTableFromBlockTable(ha, pBlockTable);
4,439,385 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:BuildFileTableFromBlockTable(_TMPQArchive*, _TMPQBlock*) (3x)
     19 ( 0.00%)          STORM_FREE(pBlockTable);
  1,280 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    242 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (3x)
      .               }
      .               else
      .               {
      .                   dwErrCode = ERROR_NOT_ENOUGH_MEMORY;
      .               }
      .           
      .               // Load the hi-block table
     18 ( 0.00%)      if(dwErrCode == ERROR_SUCCESS && pHeader->HiBlockTablePos64 != 0)
      .               {
      .                   ULONGLONG ByteOffset;
      .                   USHORT * pHiBlockTable = NULL;
      .                   DWORD dwTableSize = pHeader->dwBlockTableSize * sizeof(USHORT);
      .           
      .                   // Allocate space for the hi-block table
      .                   // Note: pHeader->dwBlockTableSize can be zero !!!
      .                   pHiBlockTable = STORM_ALLOC(USHORT, pHeader->dwBlockTableSize + 1);
-- line 2536 ----------------------------------------
-- line 2558 ----------------------------------------
      .                       STORM_FREE(pHiBlockTable);
      .                   }
      .                   else
      .                   {
      .                       dwErrCode = ERROR_NOT_ENOUGH_MEMORY;
      .                   }
      .               }
      .           
      3 ( 0.00%)      return dwErrCode;
      6 ( 0.00%)  }
      .           
      .           static DWORD BuildFileTable_HetBet(TMPQArchive * ha)
      .           {
      .               TMPQHetTable * pHetTable = ha->pHetTable;
      .               TMPQBetTable * pBetTable;
      .               TFileEntry * pFileEntry = ha->pFileTable;
      .               TMPQBits * pBitArray;
      .               DWORD dwBitPosition = 0;
-- line 2575 ----------------------------------------
-- line 2673 ----------------------------------------
      .               {
      .                   dwErrCode = ERROR_FILE_CORRUPT;
      .               }
      .           
      .               return dwErrCode;
      .           }
      .           
      .           DWORD BuildFileTable(TMPQArchive * ha)
     12 ( 0.00%)  {
      .               DWORD dwFileTableSize;
      3 ( 0.00%)      bool bFileTableCreated = false;
      .           
      .               // Sanity checks
     12 ( 0.00%)      assert(ha->pFileTable == NULL);
     12 ( 0.00%)      assert(ha->dwFileTableSize == 0);
     12 ( 0.00%)      assert(ha->dwMaxFileCount != 0);
      .           
      .               // Determine the allocation size for the file table
     30 ( 0.00%)      dwFileTableSize = STORMLIB_MAX(ha->pHeader->dwBlockTableSize, ha->dwMaxFileCount);
      .           
      .               // Allocate the file table with size determined before
     24 ( 0.00%)      ha->pFileTable = STORM_ALLOC(TFileEntry, dwFileTableSize);
  1,033 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (3x)
     12 ( 0.00%)      if(ha->pFileTable == NULL)
      .                   return ERROR_NOT_ENOUGH_MEMORY;
      .           
      .               // Fill the table with zeros
     27 ( 0.00%)      memset(ha->pFileTable, 0, dwFileTableSize * sizeof(TFileEntry));
6,291,507 ( 0.01%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (3x)
      9 ( 0.00%)      ha->dwFileTableSize = dwFileTableSize;
      .           
      .               // If we have HET table, we load file table from the BET table
      .               // Note: If BET table is corrupt or missing, we set the archive as read only
     12 ( 0.00%)      if(ha->pHetTable != NULL)
      .               {
      .                   if(BuildFileTable_HetBet(ha) != ERROR_SUCCESS)
      .                       ha->dwFlags |= MPQ_FLAG_READ_ONLY;
      .                   else
      .                       bFileTableCreated = true;
      .               }
      .           
      .               // If we have hash table, we load the file table from the block table
      .               // Note: If block table is corrupt or missing, we set the archive as read only
     12 ( 0.00%)      if(ha->pHashTable != NULL)
      .               {
     21 ( 0.00%)          if(BuildFileTable_Classic(ha) != ERROR_SUCCESS)
7,224,251 ( 0.01%)  => build/_deps/stormlib-src/src/SBaseFileTable.cpp:BuildFileTable_Classic(_TMPQArchive*) (3x)
      .                       ha->dwFlags |= MPQ_FLAG_READ_ONLY;
      .                   else
      3 ( 0.00%)              bFileTableCreated = true;
      .               }
      .           
      .               // Return result
     15 ( 0.00%)      return bFileTableCreated ? ERROR_SUCCESS : ERROR_FILE_CORRUPT;
      6 ( 0.00%)  }
      .           
      .           /*
      .           void UpdateBlockTableSize(TMPQArchive * ha)
      .           {
      .               TFileEntry * pFileTableEnd = ha->pFileTable + ha->dwFileTableSize;
      .               TFileEntry * pFileEntry;
      .               DWORD dwBlockTableSize = 0;
      .           
-- line 2732 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/future
--------------------------------------------------------------------------------
Ir                 

-- line 228 ----------------------------------------
        .                 _Result_base(const _Result_base&) = delete;
        .                 _Result_base& operator=(const _Result_base&) = delete;
        .           
        .                 // _M_destroy() allows derived classes to control deallocation
        .                 virtual void _M_destroy() = 0;
        .           
        .                 struct _Deleter
        .                 {
1,374,296 ( 0.00%)  	void operator()(_Result_base* __fr) const { __fr->_M_destroy(); }
25,427,043 ( 0.02%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_destroy() (98,164x)
        .                 };
        .           
        .               protected:
        .                 _Result_base();
        .                 virtual ~_Result_base();
        .               };
        .           
        .               /// A unique_ptr for result objects.
-- line 244 ----------------------------------------
-- line 251 ----------------------------------------
        .                 {
        .                 private:
        .           	__gnu_cxx::__aligned_buffer<_Res>	_M_storage;
        .           	bool 					_M_initialized;
        .           
        .                 public:
        .           	typedef _Res result_type;
        .           
1,570,628 ( 0.00%)  	_Result() noexcept : _M_initialized() { }
  588,984 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/future.cc:std::__future_base::_Result_base::_Result_base() (98,164x)
    1,383 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           
  785,312 ( 0.00%)  	~_Result()
        .           	{
  392,656 ( 0.00%)  	  if (_M_initialized)
  490,820 ( 0.00%)  	    _M_value().~_Res();
8,049,448 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (98,164x)
2,454,100 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_value() (98,164x)
1,963,284 ( 0.00%)  	}
13,449,943 ( 0.01%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::~_Result()'2 (98,164x)
9,130,344 ( 0.01%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/del_ops.cc:operator delete(void*, unsigned long) (98,164x)
        .           
        .           	// Return lvalue, future will add const or rvalue-reference
        .           	_Res&
1,963,280 ( 0.00%)  	_M_value() noexcept { return *_M_storage._M_ptr(); }
2,944,920 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::shared_ptr<Ship::IResource> >::_M_ptr() (196,328x)
        .           
        .           	void
  488,155 ( 0.00%)  	_M_set(const _Res& __res)
        .           	{
1,171,572 ( 0.00%)  	  ::new (_M_storage._M_addr()) _Res(__res);
7,517,587 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource> const&) (97,631x)
  683,417 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (97,631x)
  585,786 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::shared_ptr<Ship::IResource> >::_M_addr() (97,631x)
  195,262 ( 0.00%)  	  _M_initialized = true;
  292,893 ( 0.00%)  	}
        .           
        .           	void
    3,198 ( 0.00%)  	_M_set(_Res&& __res)
        .           	{
    7,462 ( 0.00%)  	  ::new (_M_storage._M_addr()) _Res(std::move(__res));
   38,909 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource>&&) (533x)
    3,731 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&& std::move<std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::shared_ptr<Ship::IResource> >::_M_addr() (533x)
    1,066 ( 0.00%)  	  _M_initialized = true;
    2,132 ( 0.00%)  	}
        .           
        .                 private:
1,472,460 ( 0.00%)  	void _M_destroy() { delete this; }
23,954,583 ( 0.02%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::~_Result() (98,164x)
        .               };
        .           
        .               /// A result object that uses an allocator.
        .               template<typename _Res, typename _Alloc>
        .                 struct _Result_alloc final : _Result<_Res>, _Alloc
        .                 {
        .           	using __allocator_type = __alloc_rebind<_Alloc, _Result_alloc>;
        .           
-- line 294 ----------------------------------------
-- line 339 ----------------------------------------
        .                 };
        .           
        .                 _Ptr_type			_M_result;
        .                 __atomic_futex_unsigned<>	_M_status;
        .                 atomic_flag         	_M_retrieved = ATOMIC_FLAG_INIT;
        .                 once_flag			_M_once;
        .           
        .               public:
2,454,100 ( 0.00%)        _State_baseV2() noexcept : _M_result(), _M_status(_Status::__not_ready)
7,754,956 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::unique_ptr<std::__future_base::_Result_base::_Deleter, void>() (98,164x)
3,533,904 ( 0.00%)  => /usr/include/c++/14/bits/atomic_futex.h:std::__atomic_futex_unsigned<2147483648u>::__atomic_futex_unsigned(unsigned int) (98,164x)
2,454,100 ( 0.00%)  => /usr/include/c++/14/bits/atomic_base.h:std::atomic_flag::atomic_flag(bool) (98,164x)
  785,312 ( 0.00%)  => /usr/include/c++/14/mutex:std::once_flag::once_flag() (98,164x)
  294,492 ( 0.00%)  	{ }
        .                 _State_baseV2(const _State_baseV2&) = delete;
        .                 _State_baseV2& operator=(const _State_baseV2&) = delete;
1,374,296 ( 0.00%)        virtual ~_State_baseV2() = default;
39,464,495 ( 0.03%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr() (98,164x)
        .           
        .                 _Result_base&
  392,656 ( 0.00%)        wait()
        .                 {
        .           	// Run any deferred function or join any asynchronous thread:
  687,148 ( 0.00%)  	_M_complete_async();
  588,984 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_complete_async() (98,164x)
        .           	// Acquire MO makes sure this synchronizes with the thread that made
        .           	// the future ready.
  883,476 ( 0.00%)  	_M_status._M_load_when_equal(_Status::__ready, memory_order_acquire);
  392,656 ( 0.00%)  	return *_M_result;
6,282,496 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::operator*() const (98,164x)
  196,328 ( 0.00%)        }
        .           
        .                 template<typename _Rep, typename _Period>
        .                   future_status
        .                   wait_for(const chrono::duration<_Rep, _Period>& __rel)
        .                   {
        .           	  // First, check if the future has been made ready.  Use acquire MO
        .           	  // to synchronize with the thread that made it ready.
        .           	  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)
-- line 370 ----------------------------------------
-- line 422 ----------------------------------------
        .           	      return future_status::ready;
        .           	    }
        .           	  return future_status::timeout;
        .           	}
        .           
        .                 // Provide a result to the shared state and make it ready.
        .                 // Calls at most once: _M_result = __res();
        .                 void
  883,476 ( 0.00%)        _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)
        .                 {
   98,164 ( 0.00%)  	bool __did_set = false;
        .                   // all calls to this function are serialized,
        .                   // side-effects of invoking __res only happen once
1,472,460 ( 0.00%)  	call_once(_M_once, &_State_baseV2::_M_do_set, this,
164,534,016 ( 0.14%)  => /usr/include/c++/14/mutex:void std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*>(std::once_flag&, void (std::__future_base::_State_baseV2::*&&)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*), std::__future_base::_State_baseV2*&&, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*&&, bool*&&) (98,164x)
  785,312 ( 0.00%)  		  std::__addressof(__res), std::__addressof(__did_set));
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>* std::__addressof<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()> >(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:bool* std::__addressof<bool>(bool&) (98,164x)
  294,492 ( 0.00%)  	if (__did_set)
        .           	  // Use release MO to synchronize with observers of the ready state.
  490,820 ( 0.00%)  	  _M_status._M_store_notify_all(_Status::__ready,
        .           					memory_order_release);
        .           	else if (!__ignore_failure)
        .                     __throw_future_error(int(future_errc::promise_already_satisfied));
  588,984 ( 0.00%)        }
        .           
        .                 // Provide a result to the shared state but delay making it ready
        .                 // until the calling thread exits.
        .                 // Calls at most once: _M_result = __res();
        .                 void
        .                 _M_set_delayed_result(function<_Ptr_type()> __res,
        .           			    weak_ptr<_State_baseV2> __self)
        .                 {
-- line 451 ----------------------------------------
-- line 459 ----------------------------------------
        .                     __throw_future_error(int(future_errc::promise_already_satisfied));
        .           	__mr->_M_shared_state = std::move(__self);
        .           	__mr->_M_set();
        .           	__mr.release();
        .                 }
        .           
        .                 // Abandon this shared state.
        .                 void
  490,410 ( 0.00%)        _M_break_promise(_Ptr_type __res)
        .                 {
  490,410 ( 0.00%)  	if (static_cast<bool>(__res))
6,179,166 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::operator bool() const (98,082x)
        .           	  {
        .           	    __res->_M_error =
        .           	      make_exception_ptr(future_error(future_errc::broken_promise));
        .           	    // This function is only called when the last asynchronous result
        .           	    // provider is abandoning this shared state, so noone can be
        .           	    // trying to make the shared state ready at the same time, and
        .           	    // we can access _M_result directly instead of through call_once.
        .           	    _M_result.swap(__res);
        .           	    // Use release MO to synchronize with observers of the ready state.
        .           	    _M_status._M_store_notify_all(_Status::__ready,
        .           					  memory_order_release);
        .           	  }
  294,246 ( 0.00%)        }
        .           
        .                 // Called when this object is first passed to a future.
        .                 void
  392,656 ( 0.00%)        _M_set_retrieved_flag()
        .                 {
  588,984 ( 0.00%)  	if (_M_retrieved.test_and_set())
        .           	  __throw_future_error(int(future_errc::future_already_retrieved));
  294,492 ( 0.00%)        }
        .           
        .                 template<typename _Res, typename _Arg>
        .                   struct _Setter;
        .           
        .                 // set lvalues
        .                 template<typename _Res, typename _Arg>
        .                   struct _Setter<_Res, _Arg&>
        .                   {
        .                     // check this is only used by promise<R>::set_value(const R&)
        .                     // or promise<R&>::set_value(R&)
        .                     static_assert(is_same<_Res, _Arg&>::value  // promise<R&>
        .                         || is_same<const _Res, _Arg>::value,   // promise<R>
        .                         "Invalid specialisation");
        .           
        .           	  // Used by std::promise to copy construct the result.
  488,155 ( 0.00%)            typename promise<_Res>::_Ptr_type operator()() const
        .                     {
1,073,941 ( 0.00%)              _M_promise->_M_storage->_M_set(*_M_arg);
10,934,672 ( 0.01%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_set(std::shared_ptr<Ship::IResource> const&) (97,631x)
5,955,491 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::operator->() const (97,631x)
  976,310 ( 0.00%)              return std::move(_M_promise->_M_storage);
12,887,292 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::unique_ptr(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&&) (97,631x)
  585,786 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&>::type&& std::move<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&>(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&) (97,631x)
  292,893 ( 0.00%)            }
        .                     promise<_Res>*    _M_promise;
        .                     _Arg*             _M_arg;
        .                   };
        .           
        .                 // set rvalues
        .                 template<typename _Res>
        .                   struct _Setter<_Res, _Res&&>
        .                   {
        .           	  // Used by std::promise to move construct the result.
    3,198 ( 0.00%)            typename promise<_Res>::_Ptr_type operator()() const
        .                     {
    6,929 ( 0.00%)              _M_promise->_M_storage->_M_set(std::move(*_M_arg));
   62,894 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_set(std::shared_ptr<Ship::IResource>&&) (533x)
   32,513 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::operator->() const (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&& std::move<std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) (533x)
    5,330 ( 0.00%)              return std::move(_M_promise->_M_storage);
   70,356 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::unique_ptr(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&&) (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&>::type&& std::move<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&>(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&) (533x)
    2,132 ( 0.00%)            }
        .                     promise<_Res>*    _M_promise;
        .                     _Res*             _M_arg;
        .                   };
        .           
        .                 // set void
        .                 template<typename _Res>
        .           	struct _Setter<_Res, void>
        .           	{
-- line 532 ----------------------------------------
-- line 555 ----------------------------------------
        .                     exception_ptr*    _M_ex;
        .                   };
        .           
        .                 template<typename _Res, typename _Arg>
        .           	__attribute__((__always_inline__))
        .                   static _Setter<_Res, _Arg&&>
        .                   __setter(promise<_Res>* __prom, _Arg&& __arg) noexcept
        .                   {
  687,148 ( 0.00%)            return _Setter<_Res, _Arg&&>{ __prom, std::__addressof(__arg) };
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::IResource>* std::__addressof<std::shared_ptr<Ship::IResource> >(std::shared_ptr<Ship::IResource>&) (533x)
        .                   }
        .           
        .                 template<typename _Res>
        .           	__attribute__((__always_inline__))
        .                   static _Setter<_Res, __exception_ptr_tag>
        .                   __setter(exception_ptr& __ex, promise<_Res>* __prom) noexcept
        .                   {
        .                     __glibcxx_assert(__ex != nullptr); // LWG 2276
-- line 571 ----------------------------------------
-- line 577 ----------------------------------------
        .           	static _Setter<_Res, void>
        .           	__setter(promise<_Res>* __prom) noexcept
        .           	{
        .           	  return _Setter<_Res, void>{ __prom };
        .           	}
        .           
        .                 template<typename _Tp>
        .                   static void
1,177,968 ( 0.00%)          _S_check(const shared_ptr<_Tp>& __p)
        .                   {
1,766,952 ( 0.00%)            if (!static_cast<bool>(__p))
2,650,428 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::operator bool() const (294,492x)
        .                       __throw_future_error((int)future_errc::no_state);
  883,476 ( 0.00%)          }
        .           
        .               private:
        .                 // The function invoked with std::call_once(_M_once, ...).
        .                 void
  588,984 ( 0.00%)        _M_do_set(function<_Ptr_type()>* __f, bool* __did_set)
        .                 {
  490,820 ( 0.00%)          _Ptr_type __res = (*__f)();
88,552,456 ( 0.07%)  => /usr/include/c++/14/bits/std_function.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::operator()() const (98,164x)
        .                   // Notify the caller that we did try to set; if we do not throw an
        .                   // exception, the caller will be aware that it did set (e.g., see
        .                   // _M_set_result).
  196,328 ( 0.00%)  	*__did_set = true;
  588,984 ( 0.00%)          _M_result.swap(__res); // nothrow
28,369,396 ( 0.02%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::swap(std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>&) (98,164x)
  490,820 ( 0.00%)        }
5,988,004 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr() (98,164x)
        .           
        .                 // Wait for completion of async function.
  588,984 ( 0.00%)        virtual void _M_complete_async() { }
        .           
        .                 // Return true if state corresponds to a deferred function.
        .                 virtual bool _M_is_deferred_future() const { return false; }
        .           
        .                 struct _Make_ready final : __at_thread_exit_elt
        .                 {
        .           	weak_ptr<_State_baseV2> _M_shared_state;
        .           	static void _S_run(void*);
-- line 613 ----------------------------------------
-- line 694 ----------------------------------------
        .             template<typename _Res_ptr, typename _Fn, typename _Res>
        .               struct __is_location_invariant
        .               <__future_base::_Task_setter<_Res_ptr, _Fn, _Res>>
        .               : true_type { };
        .             /// @endcond
        .           
        .             /// Common implementation for future and shared_future.
        .             template<typename _Res>
1,963,280 ( 0.00%)      class __basic_future : public __future_base
83,379,696 ( 0.07%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr() (196,328x)
        .               {
        .               protected:
        .                 typedef shared_ptr<_State_base>		__state_type;
        .                 typedef __future_base::_Result<_Res>&	__result_type;
        .           
        .               private:
        .                 __state_type 		_M_state;
        .           
-- line 710 ----------------------------------------
-- line 737 ----------------------------------------
        .                   {
        .                     _State_base::_S_check(_M_state);
        .                     return _M_state->wait_until(__abs);
        .                   }
        .           
        .               protected:
        .                 /// Wait for the state to be ready and rethrow any stored exception
        .                 __result_type
  490,820 ( 0.00%)        _M_get_result() const
        .                 {
  294,492 ( 0.00%)          _State_base::_S_check(_M_state);
2,159,608 ( 0.00%)  => /usr/include/c++/14/future:void std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2>(std::shared_ptr<std::__future_base::_State_baseV2> const&) (98,164x)
  588,984 ( 0.00%)          _Result_base& __res = _M_state->wait();
12,744,893 ( 0.01%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::wait() (98,164x)
2,454,100 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (98,164x)
1,668,788 ( 0.00%)          if (!(__res._M_error == nullptr))
1,276,132 ( 0.00%)  => /usr/include/c++/14/bits/exception_ptr.h:std::__exception_ptr::operator==(std::__exception_ptr::exception_ptr const&, std::__exception_ptr::exception_ptr const&) (98,164x)
1,079,804 ( 0.00%)  => /usr/include/c++/14/bits/exception_ptr.h:std::__exception_ptr::exception_ptr::~exception_ptr() (98,164x)
  883,476 ( 0.00%)  => /usr/include/c++/14/bits/exception_ptr.h:std::__exception_ptr::exception_ptr::exception_ptr(decltype(nullptr)) (98,164x)
        .                     rethrow_exception(__res._M_error);
  196,328 ( 0.00%)          return static_cast<__result_type>(__res);
  294,492 ( 0.00%)        }
        .           
        .                 void _M_swap(__basic_future& __that) noexcept
        .                 {
        .                   _M_state.swap(__that._M_state);
        .                 }
        .           
        .                 // Construction of a future by promise::get_future()
        .                 explicit
1,079,804 ( 0.00%)        __basic_future(const __state_type& __state) : _M_state(__state)
7,558,628 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr(std::shared_ptr<std::__future_base::_State_baseV2> const&) (98,164x)
        .                 {
  294,492 ( 0.00%)          _State_base::_S_check(_M_state);
2,159,608 ( 0.00%)  => /usr/include/c++/14/future:void std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2>(std::shared_ptr<std::__future_base::_State_baseV2> const&) (98,164x)
  490,820 ( 0.00%)          _M_state->_M_set_retrieved_flag();
2,454,100 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (98,164x)
1,668,788 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_set_retrieved_flag() (98,164x)
  392,656 ( 0.00%)        }
        .           
        .                 // Copy construction from a shared_future
        .                 explicit
        .                 __basic_future(const shared_future<_Res>&) noexcept;
        .           
        .                 // Move construction from a shared_future
        .                 explicit
        .                 __basic_future(shared_future<_Res>&&) noexcept;
-- line 773 ----------------------------------------
-- line 784 ----------------------------------------
        .                   ~_Reset() { _M_fut._M_state.reset(); }
        .                   __basic_future& _M_fut;
        .                 };
        .               };
        .           
        .           
        .             /// Primary template for future.
        .             template<typename _Res>
  981,640 ( 0.00%)      class future : public __basic_future<_Res>
4,122,888 ( 0.00%)  => /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::~__basic_future() (98,164x)
        .               {
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 3458. Is shared_future intended to work with arrays or function types?
        .                 static_assert(!is_array<_Res>{}, "result type must not be an array");
        .                 static_assert(!is_function<_Res>{}, "result type must not be a function");
        .                 static_assert(is_destructible<_Res>{},
        .           		    "result type must be destructible");
        .           
-- line 800 ----------------------------------------
-- line 803 ----------------------------------------
        .                 template<typename _Fn, typename... _Args>
        .                   friend future<__async_result_of<_Fn, _Args...>>
        .                   async(launch, _Fn&&, _Args&&...);
        .           
        .                 typedef __basic_future<_Res> _Base_type;
        .                 typedef typename _Base_type::__state_type __state_type;
        .           
        .                 explicit
1,276,132 ( 0.00%)        future(const __state_type& __state) : _Base_type(__state) { }
16,098,896 ( 0.01%)  => /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::__basic_future(std::shared_ptr<std::__future_base::_State_baseV2> const&) (98,164x)
        .           
        .               public:
        .                 constexpr future() noexcept : _Base_type() { }
        .           
        .                 /// Move constructor
        .                 future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        .           
        .                 // Disable copying
-- line 819 ----------------------------------------
-- line 921 ----------------------------------------
        .                 }
        .           
        .                 shared_future<void> share() noexcept;
        .               };
        .           
        .           
        .             /// Primary template for shared_future.
        .             template<typename _Res>
  981,640 ( 0.00%)      class shared_future : public __basic_future<_Res>
81,220,088 ( 0.07%)  => /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::~__basic_future() (98,164x)
        .               {
        .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .                 // 3458. Is shared_future intended to work with arrays or function types?
        .                 static_assert(!is_array<_Res>{}, "result type must not be an array");
        .                 static_assert(!is_function<_Res>{}, "result type must not be a function");
        .                 static_assert(is_destructible<_Res>{},
        .           		    "result type must be destructible");
        .           
-- line 937 ----------------------------------------
-- line 939 ----------------------------------------
        .           
        .               public:
        .                 constexpr shared_future() noexcept : _Base_type() { }
        .           
        .                 /// Copy constructor
        .                 shared_future(const shared_future& __sf) noexcept : _Base_type(__sf) { }
        .           
        .                 /// Construct from a future rvalue
  588,984 ( 0.00%)        shared_future(future<_Res>&& __uf) noexcept
  687,148 ( 0.00%)        : _Base_type(std::move(__uf))
9,423,744 ( 0.01%)  => /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::__basic_future(std::future<std::shared_ptr<Ship::IResource> >&&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::future<std::shared_ptr<Ship::IResource> >&>::type&& std::move<std::future<std::shared_ptr<Ship::IResource> >&>(std::future<std::shared_ptr<Ship::IResource> >&) (98,164x)
  392,656 ( 0.00%)        { }
        .           
        .                 /// Construct from a shared_future rvalue
        .                 shared_future(shared_future&& __sf) noexcept
        .                 : _Base_type(std::move(__sf))
        .                 { }
        .           
        .                 shared_future& operator=(const shared_future& __sf) noexcept
        .                 {
-- line 957 ----------------------------------------
-- line 962 ----------------------------------------
        .                 shared_future& operator=(shared_future&& __sf) noexcept
        .                 {
        .                   shared_future(std::move(__sf))._M_swap(*this);
        .                   return *this;
        .                 }
        .           
        .                 /// Retrieving the value
        .                 const _Res&
1,079,804 ( 0.00%)        get() const { return this->_M_get_result()._M_value(); }
24,131,917 ( 0.02%)  => /usr/include/c++/14/future:std::__basic_future<std::shared_ptr<Ship::IResource> >::_M_get_result() const (98,164x)
2,454,100 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_value() (98,164x)
        .               };
        .           
        .             /// Partial specialization for shared_future<R&>
        .             template<typename _Res>
        .               class shared_future<_Res&> : public __basic_future<_Res&>
        .               {
        .                 typedef __basic_future<_Res&>           _Base_type;
        .           
-- line 978 ----------------------------------------
-- line 1057 ----------------------------------------
        .           
        .             template<typename _Res>
        .               inline __basic_future<_Res>::
        .               __basic_future(shared_future<_Res>&& __sf) noexcept
        .               : _M_state(std::move(__sf._M_state))
        .               { }
        .           
        .             template<typename _Res>
  588,984 ( 0.00%)      inline __basic_future<_Res>::
        .               __basic_future(future<_Res>&& __uf) noexcept
  687,148 ( 0.00%)      : _M_state(std::move(__uf._M_state))
7,165,972 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr(std::shared_ptr<std::__future_base::_State_baseV2>&&) (98,164x)
  588,984 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<std::__future_base::_State_baseV2>&>::type&& std::move<std::shared_ptr<std::__future_base::_State_baseV2>&>(std::shared_ptr<std::__future_base::_State_baseV2>&) (98,164x)
  392,656 ( 0.00%)      { }
        .           
        .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .             // 2556. Wide contract for future::share()
        .             template<typename _Res>
        .               inline shared_future<_Res>
  488,155 ( 0.00%)      future<_Res>::share() noexcept
1,073,941 ( 0.00%)      { return shared_future<_Res>(std::move(*this)); }
11,618,089 ( 0.01%)  => /usr/include/c++/14/future:std::shared_future<std::shared_ptr<Ship::IResource> >::shared_future(std::future<std::shared_ptr<Ship::IResource> >&&) (97,631x)
  585,786 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::future<std::shared_ptr<Ship::IResource> >&>::type&& std::move<std::future<std::shared_ptr<Ship::IResource> >&>(std::future<std::shared_ptr<Ship::IResource> >&) (97,631x)
        .           
        .             template<typename _Res>
        .               inline shared_future<_Res&>
        .               future<_Res&>::share() noexcept
        .               { return shared_future<_Res&>(std::move(*this)); }
        .           
        .             inline shared_future<void>
        .             future<void>::share() noexcept
-- line 1083 ----------------------------------------
-- line 1099 ----------------------------------------
        .                 typedef __future_base::_Ptr<_Res_type>	_Ptr_type;
        .                 template<typename, typename> friend struct _State::_Setter;
        .                 friend _State;
        .           
        .                 shared_ptr<_State>                        _M_future;
        .                 _Ptr_type                                 _M_storage;
        .           
        .               public:
  588,984 ( 0.00%)        promise()
  294,492 ( 0.00%)        : _M_future(std::make_shared<_State>()),
58,542,753 ( 0.05%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::__future_base::_State_baseV2> std::make_shared<std::__future_base::_State_baseV2>() (98,164x)
1,079,804 ( 0.00%)  	_M_storage(new _Res_type())
13,055,812 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::unique_ptr<std::__future_base::_Result_base::_Deleter, void>(std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*) (98,164x)
5,845,828 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (98,164x)
2,160,995 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_Result() (98,164x)
  588,984 ( 0.00%)        { }
        .           
        .                 promise(promise&& __rhs) noexcept
        .                 : _M_future(std::move(__rhs._M_future)),
        .           	_M_storage(std::move(__rhs._M_storage))
        .                 { }
        .           
        .                 template<typename _Allocator>
        .                   promise(allocator_arg_t, const _Allocator& __a)
-- line 1118 ----------------------------------------
-- line 1123 ----------------------------------------
        .                 template<typename _Allocator>
        .                   promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        .                   : _M_future(std::move(__rhs._M_future)),
        .           	  _M_storage(std::move(__rhs._M_storage))
        .                   { }
        .           
        .                 promise(const promise&) = delete;
        .           
  490,820 ( 0.00%)        ~promise()
        .                 {
1,472,378 ( 0.00%)          if (static_cast<bool>(_M_future) && !_M_future.unique())
4,417,380 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::unique() const (98,164x)
  883,476 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2>::operator bool() const (98,164x)
1,961,640 ( 0.00%)            _M_future->_M_break_promise(std::move(_M_storage));
36,192,258 ( 0.03%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter, void>(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&&) (98,082x)
7,454,232 ( 0.01%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_break_promise(std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>) (98,082x)
5,983,002 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr() (98,082x)
2,452,050 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (98,082x)
  588,492 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&>::type&& std::move<std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&>(std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>&) (98,082x)
1,079,804 ( 0.00%)        }
8,112,129 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr() (98,164x)
5,988,004 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::~unique_ptr() (98,164x)
        .           
        .                 // Assignment
        .                 promise&
        .                 operator=(promise&& __rhs) noexcept
        .                 {
        .                   promise(std::move(__rhs)).swap(*this);
        .                   return *this;
        .                 }
-- line 1143 ----------------------------------------
-- line 1148 ----------------------------------------
        .                 swap(promise& __rhs) noexcept
        .                 {
        .                   _M_future.swap(__rhs._M_future);
        .                   _M_storage.swap(__rhs._M_storage);
        .                 }
        .           
        .                 // Retrieving the result
        .                 future<_Res>
  490,820 ( 0.00%)        get_future()
  785,312 ( 0.00%)        { return future<_Res>(_M_future); }
17,375,028 ( 0.01%)  => /usr/include/c++/14/future:std::future<std::shared_ptr<Ship::IResource> >::future(std::shared_ptr<std::__future_base::_State_baseV2> const&) (98,164x)
        .           
        .                 // Setting the result
        .                 void
  781,048 ( 0.00%)        set_value(const _Res& __r)
2,928,930 ( 0.00%)        { _M_state()._M_set_result(_State::__setter(this, __r)); }
171,049,512 ( 0.14%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_set_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>, bool) (97,631x)
11,910,982 ( 0.01%)  => /usr/include/c++/14/bits/std_function.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::function<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>, void>(std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource> const&>&&) (97,631x)
9,274,945 ( 0.01%)  => /usr/include/c++/14/bits/std_function.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::~function() (97,631x)
6,053,122 ( 0.01%)  => /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::_M_state() (97,631x)
        .           
        .                 void
    4,264 ( 0.00%)        set_value(_Res&& __r)
   17,056 ( 0.00%)        { _M_state()._M_set_result(_State::__setter(this, std::move(__r))); }
  959,196 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_set_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>, bool) (533x)
   65,026 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::function<std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>, void>(std::__future_base::_State_baseV2::_Setter<std::shared_ptr<Ship::IResource>, std::shared_ptr<Ship::IResource>&&>&&) (533x)
   50,635 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::~function() (533x)
   33,046 ( 0.00%)  => /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::_M_state() (533x)
    3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::shared_ptr<Ship::IResource>&>::type&& std::move<std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) (533x)
        .           
        .                 void
        .                 set_exception(exception_ptr __p)
        .                 { _M_state()._M_set_result(_State::__setter(__p, this)); }
        .           
        .                 void
        .                 set_value_at_thread_exit(const _Res& __r)
        .                 {
-- line 1174 ----------------------------------------
-- line 1187 ----------------------------------------
        .                 set_exception_at_thread_exit(exception_ptr __p)
        .                 {
        .           	_M_state()._M_set_delayed_result(_State::__setter(__p, this),
        .           					 _M_future);
        .                 }
        .           
        .               private:
        .                 _State&
  392,656 ( 0.00%)        _M_state()
        .                 {
  294,492 ( 0.00%)  	__future_base::_State_base::_S_check(_M_future);
2,159,608 ( 0.00%)  => /usr/include/c++/14/future:void std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2>(std::shared_ptr<std::__future_base::_State_baseV2> const&) (98,164x)
  294,492 ( 0.00%)  	return *_M_future;
2,748,592 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2, false, false>::operator*() const (98,164x)
  196,328 ( 0.00%)        }
        .               };
        .           
        .             template<typename _Res>
        .               inline void
        .               swap(promise<_Res>& __x, promise<_Res>& __y) noexcept
        .               { __x.swap(__y); }
        .           
        .             template<typename _Res, typename _Alloc>
-- line 1207 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/tuple
--------------------------------------------------------------------------------
Ir                  

-- line 81 ----------------------------------------
         .             template<size_t _Idx, typename _Head,
         .           	   bool = __empty_not_final<_Head>::value>
         .               struct _Head_base;
         .           
         .           #if __has_cpp_attribute(__no_unique_address__)
         .             template<size_t _Idx, typename _Head>
         .               struct _Head_base<_Idx, _Head, true>
         .               {
   589,299 ( 0.00%)        constexpr _Head_base()
   589,299 ( 0.00%)        : _M_head_impl() { }
         .           
         .                 constexpr _Head_base(const _Head& __h)
         .                 : _M_head_impl(__h) { }
         .           
         .                 constexpr _Head_base(const _Head_base&) = default;
         .                 constexpr _Head_base(_Head_base&&) = default;
         .           
         .                 template<typename _UHead>
   981,734 ( 0.00%)  	constexpr _Head_base(_UHead&& __h)
 1,178,400 ( 0.00%)  	: _M_head_impl(std::forward<_UHead>(__h)) { }
 1,177,476 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__future_base::_Result_base::_Deleter&& std::forward<std::__future_base::_Result_base::_Deleter>(std::remove_reference<std::__future_base::_Result_base::_Deleter>::type&) (196,246x)
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 _Head_base(allocator_arg_t, __uses_alloc0)
         .                 : _M_head_impl() { }
         .           
         .                 template<typename _Alloc>
         .           	_GLIBCXX20_CONSTEXPR
         .           	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
-- line 108 ----------------------------------------
-- line 125 ----------------------------------------
         .           	{ }
         .           
         .                 template<typename _Alloc, typename _UHead>
         .           	_GLIBCXX20_CONSTEXPR
         .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
         .           	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
         .           
         .                 static constexpr _Head&
 2,946,876 ( 0.00%)        _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
         .           
         .                 static constexpr const _Head&
         .                 _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
         .           
         .                 [[__no_unique_address__]] _Head _M_head_impl;
         .               };
         .           #else
         .             template<size_t _Idx, typename _Head>
-- line 141 ----------------------------------------
-- line 188 ----------------------------------------
         .                 _M_head(_Head_base& __b) noexcept { return __b; }
         .           
         .                 static constexpr const _Head&
         .                 _M_head(const _Head_base& __b) noexcept { return __b; }
         .               };
         .           #endif
         .           
         .             template<size_t _Idx, typename _Head>
    31,980 ( 0.00%)      struct _Head_base<_Idx, _Head, false>
   247,745 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1,599x)
         .               {
   589,299 ( 0.00%)        constexpr _Head_base()
   982,165 ( 0.00%)        : _M_head_impl() { }
         .           
   148,445 ( 0.00%)        constexpr _Head_base(const _Head& __h)
   225,299 ( 0.00%)        : _M_head_impl(__h) { }
     4,260 ( 0.00%)  => /usr/include/c++/14/bits/std_function.h:std::function<void ()>::function(std::function<void ()> const&) (20x)
         .           
         .                 constexpr _Head_base(const _Head_base&) = default;
    27,716 ( 0.00%)        constexpr _Head_base(_Head_base&&) = default;
    77,818 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData>&&) (1,066x)
         .           
         .                 template<typename _UHead>
 1,086,173 ( 0.00%)          constexpr _Head_base(_UHead&& __h)
 1,938,505 ( 0.00%)  	: _M_head_impl(std::forward<_UHead>(__h)) { }
     5,046 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*& std::forward<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*&>(std::remove_reference<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*&>::type&) (841x)
         .           
         .                 _GLIBCXX20_CONSTEXPR
         .                 _Head_base(allocator_arg_t, __uses_alloc0)
         .                 : _M_head_impl() { }
         .           
         .                 template<typename _Alloc>
         .           	_GLIBCXX20_CONSTEXPR
         .           	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
-- line 217 ----------------------------------------
-- line 234 ----------------------------------------
         .           	{ }
         .           
         .                 template<typename _Alloc, typename _UHead>
         .           	_GLIBCXX20_CONSTEXPR
         .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
         .           	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
         .           
         .                 static constexpr _Head&
 8,060,963 ( 0.01%)        _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
         .           
         .                 static constexpr const _Head&
 2,325,972 ( 0.00%)        _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
         .           
         .                 _Head _M_head_impl;
         .               };
         .           
         .           #if __cpp_lib_tuple_like // >= C++23
         .             struct __tuple_like_tag_t { explicit __tuple_like_tag_t() = default; };
         .           
         .             // These forward declarations are used by the operator<=> overload for
-- line 253 ----------------------------------------
-- line 275 ----------------------------------------
         .               struct _Tuple_impl;
         .           
         .             /**
         .              * Recursive tuple implementation. Here we store the @c Head element
         .              * and derive from a @c Tuple_impl containing the remaining elements
         .              * (which contains the @c Tail).
         .              */
         .             template<size_t _Idx, typename _Head, typename... _Tail>
    54,366 ( 0.00%)      struct _Tuple_impl<_Idx, _Head, _Tail...>
    83,148 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<3ul, std::shared_ptr<Ship::ResourceInitData> >::~_Tuple_impl() (1,599x)
         .               : public _Tuple_impl<_Idx + 1, _Tail...>,
         .                 private _Head_base<_Idx, _Head>
         .               {
         .                 template<size_t, typename...> friend struct _Tuple_impl;
         .           
         .                 typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
         .                 typedef _Head_base<_Idx, _Head> _Base;
         .           
         .                 static constexpr _Head&
11,564,475 ( 0.01%)        _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
    27,252 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<0ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, false>::_M_head(std::_Head_base<0ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, false>&) (4,542x)
         .           
         .                 static constexpr const _Head&
 3,490,470 ( 0.00%)        _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
     8,724 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<0ul, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*, false>::_M_head(std::_Head_base<0ul, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*, false> const&) (1,454x)
         .           
         .                 static constexpr _Inherited&
         .                 _M_tail(_Tuple_impl& __t) noexcept { return __t; }
         .           
         .                 static constexpr const _Inherited&
         .                 _M_tail(const _Tuple_impl& __t) noexcept { return __t; }
         .           
   785,732 ( 0.00%)        constexpr _Tuple_impl()
 1,767,897 ( 0.00%)        : _Inherited(), _Base() { }
        32 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<1ul, std::default_delete<ATrain> >::_Tuple_impl() (2x)
        16 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<0ul, ATrain*, false>::_Head_base() (2x)
         .           
         .                 explicit constexpr
         .                 _Tuple_impl(const _Head& __head, const _Tail&... __tail)
         .                 : _Inherited(__tail...), _Base(__head)
         .                 { }
         .           
         .                 template<typename _UHead, typename... _UTail,
         .           	       typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
         .           	explicit constexpr
 1,405,726 ( 0.00%)  	_Tuple_impl(_UHead&& __head, _UTail&&... __tail)
         .           	: _Inherited(std::forward<_UTail>(__tail)...),
 3,013,455 ( 0.00%)  	  _Base(std::forward<_UHead>(__head))
   450,671 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<1ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >::_Tuple_impl<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool&, std::shared_ptr<Ship::ResourceInitData>&, void>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool&, std::shared_ptr<Ship::ResourceInitData>&) (533x)
    10,660 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<0ul, Ship::ResourceManager*, false>::_Head_base<Ship::ResourceManager*>(Ship::ResourceManager*&&) (533x)
     3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type&) (533x)
     3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:bool& std::forward<bool&>(std::remove_reference<bool&>::type&) (533x)
     3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ResourceManager*&& std::forward<Ship::ResourceManager*>(std::remove_reference<Ship::ResourceManager*>::type&) (533x)
     3,198 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::shared_ptr<Ship::ResourceInitData>& std::forward<std::shared_ptr<Ship::ResourceInitData>&>(std::remove_reference<std::shared_ptr<Ship::ResourceInitData>&>::type&) (533x)
   804,141 ( 0.00%)  	{ }
         .           
         .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2729. Missing SFINAE on std::pair::operator=
         .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
         .           
 1,730,326 ( 0.00%)        _Tuple_impl(_Tuple_impl&&) = default;
   542,594 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<1ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >::_Tuple_impl(std::_Tuple_impl<1ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >&&) (1,066x)
         .           
         .                 template<typename... _UElements>
         .           	constexpr
         .           	_Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
         .           	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
         .           	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
         .           	{ }
         .           
-- line 334 ----------------------------------------
-- line 540 ----------------------------------------
         .           	swap(_M_head(*this), _M_head(__in));
         .           	_Inherited::_M_swap(_M_tail(__in));
         .                 }
         .           #endif // C++23
         .               };
         .           
         .             // Basis case of inheritance recursion.
         .             template<size_t _Idx, typename _Head>
    15,990 ( 0.00%)      struct _Tuple_impl<_Idx, _Head>
    67,158 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<3ul, std::shared_ptr<Ship::ResourceInitData>, false>::~_Head_base() (1,599x)
         .               : private _Head_base<_Idx, _Head>
         .               {
         .                 template<size_t, typename...> friend struct _Tuple_impl;
         .           
         .                 typedef _Head_base<_Idx, _Head> _Base;
         .           
         .                 static constexpr _Head&
 4,878,135 ( 0.00%)        _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
       392 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<0ul, unsigned short&&, false>::_M_head(std::_Head_base<0ul, unsigned short&&, false>&) (56x)
         .           
         .                 static constexpr const _Head&
     4,797 ( 0.00%)        _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
     3,198 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<3ul, std::shared_ptr<Ship::ResourceInitData>, false>::_M_head(std::_Head_base<3ul, std::shared_ptr<Ship::ResourceInitData>, false> const&) (533x)
         .           
         .                 constexpr
   785,732 ( 0.00%)        _Tuple_impl()
 1,178,598 ( 0.00%)        : _Base() { }
        12 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<1ul, std::default_delete<ATrain>, true>::_Head_base() (2x)
         .           
         .                 explicit constexpr
   182,200 ( 0.00%)        _Tuple_impl(const _Head& __head)
   182,200 ( 0.00%)        : _Base(__head)
    16,654 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<1ul, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}, false>::_Head_base(nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&) (1,514x)
   109,320 ( 0.00%)        { }
         .           
         .                 template<typename _UHead>
         .           	explicit constexpr
 1,085,552 ( 0.00%)  	_Tuple_impl(_UHead&& __head)
 1,691,859 ( 0.00%)  	: _Base(std::forward<_UHead>(__head))
     1,064 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<0ul, unsigned short&&, false>::_Head_base<unsigned short>(unsigned short&&) (56x)
       336 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned short&& std::forward<unsigned short>(std::remove_reference<unsigned short>::type&) (56x)
   658,258 ( 0.00%)  	{ }
         .           
         .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2729. Missing SFINAE on std::pair::operator=
         .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
         .           
         .           #if _GLIBCXX_INLINE_VERSION
         .                 _Tuple_impl(_Tuple_impl&&) = default;
         .           #else
         .                 constexpr
   602,258 ( 0.00%)        _Tuple_impl(_Tuple_impl&& __in)
         .                 noexcept(is_nothrow_move_constructible<_Head>::value)
   208,726 ( 0.00%)        : _Base(static_cast<_Base&&>(__in))
    91,676 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Head_base<3ul, std::shared_ptr<Ship::ResourceInitData>, false>::_Head_base(std::_Head_base<3ul, std::shared_ptr<Ship::ResourceInitData>, false>&&) (1,066x)
   473,280 ( 0.00%)        { }
   574,574 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >::tuple(std::tuple<Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >&&) (1,066x)
         .           #endif
         .           
         .                 template<typename _UHead>
         .           	constexpr
         .           	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
         .           	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
         .           	{ }
         .           
-- line 597 ----------------------------------------
-- line 826 ----------------------------------------
         .           
         .                 template<typename... _UTypes>
         .           	static constexpr bool __is_explicitly_constructible()
         .           	{ return false; }
         .               };
         .           
         .             /// Primary class template, tuple
         .             template<typename... _Elements>
    15,990 ( 0.00%)      class tuple : public _Tuple_impl<0, _Elements...>
   401,249 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >::~_Tuple_impl() (1,599x)
         .               {
         .                 using _Inherited = _Tuple_impl<0, _Elements...>;
         .           
         .           #if __cpp_concepts && __cpp_consteval && __cpp_conditional_explicit // >= C++20
         .                 template<typename... _UTypes>
         .           	static consteval bool
         .           	__constructible()
         .           	{
-- line 842 ----------------------------------------
-- line 956 ----------------------------------------
         .           	    return __convertible<decltype(std::get<_Is>(std::declval<_UTuple>()))...>();
         .           	  }(index_sequence_for<_Elements...>{});
         .           	}
         .           #endif // C++23
         .           
         .               public:
         .                 constexpr
         .                 explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
   785,732 ( 0.00%)        tuple()
         .                 noexcept((is_nothrow_default_constructible_v<_Elements> && ...))
         .                 requires (is_default_constructible_v<_Elements> && ...)
   589,299 ( 0.00%)        : _Inherited()
 3,632,068 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, std::__future_base::_Result<std::shared_ptr<Ship::IResource> >*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl() (98,164x)
   589,299 ( 0.00%)        { }
         .           
         .                 constexpr explicit(!__convertible<const _Elements&...>())
   170,325 ( 0.00%)        tuple(const _Elements&... __elements)
         .                 noexcept(__nothrow_constructible<const _Elements&...>())
         .                 requires (__constructible<const _Elements&...>())
   170,325 ( 0.00%)        : _Inherited(__elements...)
   761,346 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, unsigned long const&>::_Tuple_impl(unsigned long const&) (33,102x)
   102,195 ( 0.00%)        { }
         .           
         .                 template<typename... _UTypes>
         .           	requires (__disambiguating_constraint<_UTypes...>())
         .           	  && (__constructible<_UTypes...>())
         .           	  && (!__dangles<_UTypes...>())
         .           	constexpr explicit(!__convertible<_UTypes...>())
 1,696,820 ( 0.00%)  	tuple(_UTypes&&... __u)
         .           	noexcept(__nothrow_constructible<_UTypes...>())
 2,513,874 ( 0.00%)  	: _Inherited(std::forward<_UTypes>(__u)...)
     1,722 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, Ship::ShipDeviceIndex&&>::_Tuple_impl<Ship::ShipDeviceIndex>(Ship::ShipDeviceIndex&&) (41x)
       246 ( 0.00%)  => /usr/include/c++/14/bits/move.h:Ship::ShipDeviceIndex&& std::forward<Ship::ShipDeviceIndex>(std::remove_reference<Ship::ShipDeviceIndex>::type&) (41x)
 1,263,670 ( 0.00%)  	{ }
         .           
         .                 template<typename... _UTypes>
         .           	requires (__disambiguating_constraint<_UTypes...>())
         .           	  && (__constructible<_UTypes...>())
         .           	  && (__dangles<_UTypes...>())
         .           	tuple(_UTypes&&...) = delete;
         .           
         .                 constexpr tuple(const tuple&) = default;
         .           
 1,953,874 ( 0.00%)        constexpr tuple(tuple&&) = default;
       352 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, Ship::Direction const&>::_Tuple_impl(std::_Tuple_impl<0ul, Ship::Direction const&>&&) (32x)
         .           
         .                 template<typename... _UTypes>
         .           	requires (__constructible<const _UTypes&...>())
         .           	  && (!__use_other_ctor<const tuple<_UTypes...>&>())
         .           	  && (!__dangles<const _UTypes&...>())
         .           	constexpr explicit(!__convertible<const _UTypes&...>())
         .           	tuple(const tuple<_UTypes...>& __u)
         .           	noexcept(__nothrow_constructible<const _UTypes&...>())
-- line 1003 ----------------------------------------
-- line 2419 ----------------------------------------
         .               {
         .                 static_assert(__i < sizeof...(_Types), "tuple index must be in range");
         .           
         .                 using type = typename _Nth_type<__i, _Types...>::type;
         .               };
         .           
         .             template<size_t __i, typename _Head, typename... _Tail>
         .               constexpr _Head&
 7,304,660 ( 0.01%)      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 9,130,825 ( 0.01%)      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
       320 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<2ul, unsigned int, std::function<void ()> >::_M_head(std::_Tuple_impl<2ul, unsigned int, std::function<void ()> >&) (20x)
         .           
         .             template<size_t __i, typename _Head, typename... _Tail>
         .               constexpr const _Head&
 1,550,648 ( 0.00%)      __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
 1,938,310 ( 0.00%)      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 2,943,690 ( 0.00%)  => /usr/include/c++/14/tuple:std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_head(std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> const&) (196,246x)
         .           
         .             // Deleted overload to improve diagnostics for invalid indices
         .             template<size_t __i, typename... _Types>
         .               __enable_if_t<(__i >= sizeof...(_Types))>
         .               __get_helper(const tuple<_Types...>&) = delete;
         .           
         .             /// Return a reference to the ith element of a tuple.
         .             template<size_t __i, typename... _Elements>
         .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&
 7,304,340 ( 0.01%)      get(tuple<_Elements...>& __t) noexcept
 9,130,425 ( 0.01%)      { return std::__get_helper<__i>(__t); }
     2,875 ( 0.00%)  => /usr/include/c++/14/tuple:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >& std::__get_helper<0ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>(std::_Tuple_impl<0ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>&) (115x)
         .           
         .             /// Return a const reference to the ith element of a const tuple.
         .             template<size_t __i, typename... _Elements>
         .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
 1,550,648 ( 0.00%)      get(const tuple<_Elements...>& __t) noexcept
 1,938,310 ( 0.00%)      { return std::__get_helper<__i>(__t); }
    13,325 ( 0.00%)  => /usr/include/c++/14/tuple:Ship::ResourceManager* const& std::__get_helper<0ul, Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> >(std::_Tuple_impl<0ul, Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData> > const&) (533x)
         .           
         .             /// Return an rvalue reference to the ith element of a tuple rvalue.
         .             template<size_t __i, typename... _Elements>
         .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
       320 ( 0.00%)      get(tuple<_Elements...>&& __t) noexcept
         .               {
         .                 typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
       400 ( 0.00%)        return std::forward<__element_type>(std::__get_helper<__i>(__t));
       500 ( 0.00%)  => /usr/include/c++/14/tuple:void (BS::thread_pool::*&std::__get_helper<0ul, void (BS::thread_pool::*)(unsigned int, std::function<void ()> const&), BS::thread_pool*, unsigned int, std::function<void ()> >(std::_Tuple_impl<0ul, void (BS::thread_pool::*)(unsigned int, std::function<void ()> const&), BS::thread_pool*, unsigned int, std::function<void ()> >&))(unsigned int, std::function<void ()> const&) (20x)
       120 ( 0.00%)  => /usr/include/c++/14/bits/move.h:void (BS::thread_pool::*&&std::forward<void (BS::thread_pool::*)(unsigned int, std::function<void ()> const&)>(std::remove_reference<void (BS::thread_pool::*)(unsigned int, std::function<void ()> const&)>::type&))(unsigned int, std::function<void ()> const&) (20x)
       160 ( 0.00%)      }
         .           
         .             /// Return a const rvalue reference to the ith element of a const tuple rvalue.
         .             template<size_t __i, typename... _Elements>
         .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
         .               get(const tuple<_Elements...>&& __t) noexcept
         .               {
         .                 typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
         .                 return std::forward<const __element_type>(std::__get_helper<__i>(__t));
-- line 2467 ----------------------------------------
-- line 2642 ----------------------------------------
         .                 return __result_type(std::forward<_Elements>(__args)...);
         .               }
         .           
         .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .             // 2275. Why is forward_as_tuple not constexpr?
         .             /// Create a tuple of lvalue or rvalue references to the arguments
         .             template<typename... _Elements>
         .               constexpr tuple<_Elements&&...>
    84,986 ( 0.00%)      forward_as_tuple(_Elements&&... __args) noexcept
   186,223 ( 0.00%)      { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }
     7,475 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&>::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (115x)
       690 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&& std::forward<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::type&) (115x)
         .           
         .             /// @cond undocumented
         .             template<size_t, typename, typename, size_t>
         .               struct __make_tuple_impl;
         .           
         .             template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
         .               struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
         .               : __make_tuple_impl<_Idx + 1,
-- line 2659 ----------------------------------------
-- line 2864 ----------------------------------------
         .              *
         .              * The elements of each tuple will be used as the constructor arguments
         .              * for the data members of the pair.
         .             */
         .             template<class _T1, class _T2>
         .               template<typename... _Args1, typename... _Args2>
         .                 _GLIBCXX20_CONSTEXPR
         .                 inline
   254,245 ( 0.00%)        pair<_T1, _T2>::
         .                 pair(piecewise_construct_t,
         .           	   tuple<_Args1...> __first, tuple<_Args2...> __second)
         .                 : pair(__first, __second,
         .           	     typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
   305,094 ( 0.00%)  	     typename _Build_index_tuple<sizeof...(_Args2)>::__type())
     8,002 ( 0.00%)  => /usr/include/c++/14/tuple:std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, 0ul>(std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>&, std::tuple<>&, std::_Index_tuple<0ul>, std::_Index_tuple<>) (19x)
   152,547 ( 0.00%)        { }
         .           
         .             template<class _T1, class _T2>
         .               template<typename... _Args1, size_t... _Indexes1,
         .           	     typename... _Args2, size_t... _Indexes2>
         .                 _GLIBCXX20_CONSTEXPR inline
   306,120 ( 0.00%)        pair<_T1, _T2>::
         .                 pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
         .           	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
   407,897 ( 0.00%)        : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
   562,836 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple_element<0ul, std::tuple<unsigned long&&> >::type& std::get<0ul, unsigned long&&>(std::tuple<unsigned long&&>&) (16,554x)
    99,324 ( 0.00%)  => /usr/include/c++/14/bits/move.h:unsigned long&& std::forward<unsigned long&&>(std::remove_reference<unsigned long&&>::type&) (16,554x)
   206,312 ( 0.00%)  	second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
 2,615,532 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string() (16,554x)
   153,573 ( 0.00%)        { }
         .           
         .           #if defined(__cpp_lib_apply) || defined(__cpp_lib_make_from_tuple) // C++ >= 17
         .             // Unpack a std::tuple into a type trait and use its value.
         .             // For cv std::tuple<_Up> the result is _Trait<_Tp, cv _Up...>::value.
         .             // For cv std::tuple<_Up>& the result is _Trait<_Tp, cv _Up&...>::value.
         .             // Otherwise the result is false (because we don't know if std::get throws).
         .             template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
         .               inline constexpr bool __unpack_std_tuple = false;
-- line 2897 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/stormlib-src/src/SBaseCommon.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 212 ----------------------------------------
         .           
         .           #define STORM_BUFFER_SIZE       0x500
         .           #define HASH_INDEX_MASK(ha) (ha->pHeader->dwHashTableSize ? (ha->pHeader->dwHashTableSize - 1) : 0)
         .           
         .           static DWORD StormBuffer[STORM_BUFFER_SIZE];    // Buffer for the decryption engine
         .           static bool  bMpqCryptographyInitialized = false;
         .           
         .           void InitializeMpqCryptography()
         9 ( 0.00%)  {
         3 ( 0.00%)      DWORD dwSeed = 0x00100001;
         3 ( 0.00%)      DWORD index1 = 0;
         3 ( 0.00%)      DWORD index2 = 0;
         .               int   i;
         .           
         .               // Initialize the decryption buffer.
         .               // Do nothing if already done.
        12 ( 0.00%)      if(bMpqCryptographyInitialized == false)
         .               {
       772 ( 0.00%)          for(index1 = 0; index1 < 0x100; index1++)
         .                   {
     6,656 ( 0.00%)              for(index2 = index1, i = 0; i < 5; i++, index2 += 0x100)
         .                       {
         .                           DWORD temp1, temp2;
         .           
    20,480 ( 0.00%)                  dwSeed = (dwSeed * 125 + 3) % 0x2AAAAB;
     3,840 ( 0.00%)                  temp1  = (dwSeed & 0xFFFF) << 0x10;
         .           
    20,480 ( 0.00%)                  dwSeed = (dwSeed * 125 + 3) % 0x2AAAAB;
     3,840 ( 0.00%)                  temp2  = (dwSeed & 0xFFFF);
         .           
     6,400 ( 0.00%)                  StormBuffer[index2] = (temp1 | temp2);
         .                       }
         .                   }
         .           
         .                   // Also register both MD5 and SHA1 hash algorithms
         2 ( 0.00%)          register_hash(&md5_desc);
     1,163 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/libtomcrypt/src/misc/crypt_register_hash.c:register_hash (1x)
         2 ( 0.00%)          register_hash(&sha1_desc);
     1,178 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/libtomcrypt/src/misc/crypt_register_hash.c:register_hash (1x)
         .           
         .                   // Use LibTomMath as support math library for LibTomCrypt
        26 ( 0.00%)          ltc_mp = ltm_desc;
         .           
         .                   // Don't do that again
         1 ( 0.00%)          bMpqCryptographyInitialized = true;
         .               }
         9 ( 0.00%)  }
         .           
         .           //
         .           // Note: Implementation of this function in WorldEdit.exe and storm.dll
         .           // incorrectly treats the character as signed, which leads to the
         .           // a buffer underflow if the character in the file name >= 0x80:
         .           // The following steps happen when *pbKey == 0xBF and dwHashType == 0x0000
         .           // (calculating hash index)
         .           //
-- line 264 ----------------------------------------
-- line 287 ----------------------------------------
         .                   dwSeed1 = StormBuffer[dwHashType + ch] ^ (dwSeed1 + dwSeed2);
         .                   dwSeed2 = ch + dwSeed1 + dwSeed2 + (dwSeed2 << 5) + 3;
         .               }
         .           
         .               return dwSeed1;
         .           }
         .           
         .           DWORD HashStringSlash(const char * szFileName, DWORD dwHashType)
   347,136 ( 0.00%)  {
   173,568 ( 0.00%)      LPBYTE pbKey   = (BYTE *)szFileName;
    86,784 ( 0.00%)      DWORD  dwSeed1 = 0x7FED7FED;
    86,784 ( 0.00%)      DWORD  dwSeed2 = 0xEEEEEEEE;
         .               DWORD  ch;
         .           
12,119,788 ( 0.01%)      while(*pbKey != 0)
         .               {
         .                   // Convert the input character to uppercase
         .                   // DON'T convert slash (0x2F) to backslash (0x5C)
26,293,203 ( 0.02%)          ch = AsciiToUpperTable_Slash[*pbKey++];
         .           
29,214,670 ( 0.02%)          dwSeed1 = StormBuffer[dwHashType + ch] ^ (dwSeed1 + dwSeed2);
29,214,670 ( 0.02%)          dwSeed2 = ch + dwSeed1 + dwSeed2 + (dwSeed2 << 5) + 3;
         .               }
         .           
    86,784 ( 0.00%)      return dwSeed1;
   173,568 ( 0.00%)  }
         .           
         .           DWORD HashStringLower(const char * szFileName, DWORD dwHashType)
         .           {
         .               LPBYTE pbKey   = (BYTE *)szFileName;
         .               DWORD  dwSeed1 = 0x7FED7FED;
         .               DWORD  dwSeed2 = 0xEEEEEEEE;
         .               DWORD  ch;
         .           
-- line 320 ----------------------------------------
-- line 487 ----------------------------------------
         .               // Retrieve the value
         .               return ((DWORD)pbDataPointer[0] << 0x00) |
         .                      ((DWORD)pbDataPointer[1] << 0x08) |
         .                      ((DWORD)pbDataPointer[2] << 0x10) |
         .                      ((DWORD)pbDataPointer[3] << 0x18);
         .           }
         .           
         .           void DecryptMpqBlock(void * pvDataBlock, DWORD dwLength, DWORD dwKey1)
        36 ( 0.00%)  {
        12 ( 0.00%)      LPDWORD DataPointer = (LPDWORD)pvDataBlock;
         .               DWORD dwValue32;
         6 ( 0.00%)      DWORD dwKey2 = 0xEEEEEEEE;
         .           
         .               // Round to DWORDs
         6 ( 0.00%)      dwLength >>= 2;
         .           
         .               // We need different approach on non-aligned buffers
        24 ( 0.00%)      if(STORMLIB_DWORD_ALIGNED(DataPointer))
         .               {
 1,837,806 ( 0.00%)          for(DWORD i = 0; i < dwLength; i++)
         .                   {
         .                       // Modify the second key
 2,756,664 ( 0.00%)              dwKey2 += StormBuffer[MPQ_HASH_KEY2_MIX + (dwKey1 & 0xFF)];
         .           
         .                       // We can use 32-bit approach, when the buffer is aligned
 7,351,104 ( 0.01%)              DataPointer[i] = dwValue32 = DataPointer[i] ^ (dwKey1 + dwKey2);
         .           
 3,675,552 ( 0.00%)              dwKey1 = ((~dwKey1 << 0x15) + 0x11111111) | (dwKey1 >> 0x0B);
 3,675,552 ( 0.00%)              dwKey2 = dwValue32 + dwKey2 + (dwKey2 << 5) + 3;
         .                   }
         .               }
         .               else
         .               {
         .                   for(DWORD i = 0; i < dwLength; i++)
         .                   {
         .                       // Modify the second key
         .                       dwKey2 += StormBuffer[MPQ_HASH_KEY2_MIX + (dwKey1 & 0xFF)];
-- line 523 ----------------------------------------
-- line 524 ----------------------------------------
         .           
         .                       // The data are unaligned. Make sure we don't cause data misalignment error
         .                       dwValue32 = DecryptUInt32Unaligned(DataPointer, i, (dwKey1 + dwKey2));
         .           
         .                       dwKey1 = ((~dwKey1 << 0x15) + 0x11111111) | (dwKey1 >> 0x0B);
         .                       dwKey2 = dwValue32 + dwKey2 + (dwKey2 << 5) + 3;
         .                   }
         .               }
        24 ( 0.00%)  }
         .           
         .           /**
         .            * Functions tries to get file decryption key. This comes from these facts
         .            *
         .            * - We know the decrypted value of the first DWORD in the encrypted data
         .            * - We know the decrypted value of the second DWORD (at least aproximately)
         .            * - There is only 256 variants of how the second key is modified
         .            *
-- line 540 ----------------------------------------
-- line 702 ----------------------------------------
         .               // Return the key
         .               return dwFileKey;
         .           }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Handle validation functions
         .           
         .           TMPQArchive * IsValidMpqHandle(HANDLE hMpq)
     9,915 ( 0.00%)  {
     6,610 ( 0.00%)      TMPQArchive * ha = (TMPQArchive *)hMpq;
         .           
    46,270 ( 0.00%)      return (ha != NULL && ha->pHeader != NULL && ha->pHeader->dwID == g_dwMpqSignature) ? ha : NULL;
     6,610 ( 0.00%)  }
         .           
         .           TMPQFile * IsValidFileHandle(HANDLE hFile)
     7,956 ( 0.00%)  {
     3,978 ( 0.00%)      TMPQFile * hf = (TMPQFile *)hFile;
         .           
         .               // Must not be NULL
    11,934 ( 0.00%)      if(hf != NULL && hf->dwMagic == ID_MPQ_FILE)
         .               {
         .                   // Local file handle?
     7,956 ( 0.00%)          if(hf->pStream != NULL)
         .                       return hf;
         .           
         .                   // Also verify the MPQ handle within the file handle
    15,912 ( 0.00%)          if(IsValidMpqHandle(hf->ha))
    41,769 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:IsValidMpqHandle(void*) (1,989x)
     3,978 ( 0.00%)              return hf;
         .               }
         .           
         .               return NULL;
     3,978 ( 0.00%)  }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Hash table and block table manipulation
         .           
         .           // Attempts to search a free hash entry, or an entry whose names and locale matches
         .           TMPQHash * FindFreeHashEntry(TMPQArchive * ha, DWORD dwStartIndex, DWORD dwName1, DWORD dwName2, LCID lcFileLocale)
         .           {
         .               TMPQHash * pDeletedEntry = NULL;            // If a deleted entry was found in the continuous hash range
-- line 741 ----------------------------------------
-- line 780 ----------------------------------------
         .           
         .               // If we found a deleted entry, return that one preferentially
         .               return (pDeletedEntry != NULL) ? pDeletedEntry : pFreeEntry;
         .           }
         .           
         .           // Retrieves the first hash entry for the given file.
         .           // Every locale version of a file has its own hash entry
         .           TMPQHash * GetFirstHashEntry(TMPQArchive * ha, const char * szFileName)
    89,440 ( 0.00%)  {
   196,768 ( 0.00%)      DWORD dwHashIndexMask = HASH_INDEX_MASK(ha);
   125,216 ( 0.00%)      DWORD dwStartIndex = ha->pfnHashString(szFileName, MPQ_HASH_TABLE_INDEX);
20,352,155 ( 0.02%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (17,888x)
   125,216 ( 0.00%)      DWORD dwName1 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_A);
20,352,155 ( 0.02%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (17,888x)
   125,216 ( 0.00%)      DWORD dwName2 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_B);
20,352,155 ( 0.02%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (17,888x)
         .               DWORD dwIndex;
         .           
         .               // Set the initial index
    89,440 ( 0.00%)      dwStartIndex = dwIndex = (dwStartIndex & dwHashIndexMask);
         .           
         .               // Search the hash table
         .               for(;;)
         .               {
   167,184 ( 0.00%)          TMPQHash * pHash = ha->pHashTable + dwIndex;
         .           
         .                   // If the entry matches, we found it.
   318,204 ( 0.00%)          if(pHash->dwName1 == dwName1 && pHash->dwName2 == dwName2 && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
    34,458 ( 0.00%)              return pHash;
         .           
         .                   // If that hash entry is a free entry, it means we haven't found the file
    42,540 ( 0.00%)          if(pHash->dwBlockIndex == HASH_ENTRY_FREE)
     1,318 ( 0.00%)              return NULL;
         .           
         .                   // Move to the next hash entry. Stop searching
         .                   // if we got reached the original hash entry
    39,904 ( 0.00%)          dwIndex = (dwIndex + 1) & dwHashIndexMask;
    29,928 ( 0.00%)          if(dwIndex == dwStartIndex)
         .                       return NULL;
         .               }
    35,776 ( 0.00%)  }
         .           
         .           TMPQHash * GetNextHashEntry(TMPQArchive * ha, TMPQHash * pFirstHash, TMPQHash * pHash)
    86,145 ( 0.00%)  {
   189,519 ( 0.00%)      DWORD dwHashIndexMask = HASH_INDEX_MASK(ha);
   120,603 ( 0.00%)      DWORD dwStartIndex = (DWORD)(pFirstHash - ha->pHashTable);
    51,687 ( 0.00%)      DWORD dwName1 = pHash->dwName1;
    51,687 ( 0.00%)      DWORD dwName2 = pHash->dwName2;
   120,603 ( 0.00%)      DWORD dwIndex = (DWORD)(pHash - ha->pHashTable);
         .           
         .               // Now go for any next entry that follows the pHash,
         .               // until either free hash entry was found, or the start entry was reached
         .               for(;;)
         .               {
         .                   // Move to the next hash entry. Stop searching
         .                   // if we got reached the original hash entry
   212,712 ( 0.00%)          dwIndex = (dwIndex + 1) & dwHashIndexMask;
   159,534 ( 0.00%)          if(dwIndex == dwStartIndex)
         .                       return NULL;
   319,068 ( 0.00%)          pHash = ha->pHashTable + dwIndex;
         .           
         .                   // If the entry matches, we found it.
   212,712 ( 0.00%)          if(pHash->dwName1 == dwName1 && pHash->dwName2 == dwName2 && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
         .                       return pHash;
         .           
         .                   // If that hash entry is a free entry, it means we haven't found the file
   212,712 ( 0.00%)          if(pHash->dwBlockIndex == HASH_ENTRY_FREE)
    17,229 ( 0.00%)              return NULL;
         .               }
    34,458 ( 0.00%)  }
         .           
         .           // Allocates an entry in the hash table
         .           TMPQHash * AllocateHashEntry(
         .               TMPQArchive * ha,
         .               TFileEntry * pFileEntry,
         .               LCID lcFileLocale)
         .           {
         .               TMPQHash * pHash;
-- line 854 ----------------------------------------
-- line 917 ----------------------------------------
         .               // Give the free space position to the caller
         .               return FreeSpacePos;
         .           }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Common functions - MPQ File
         .           
         .           TMPQFile * CreateFileHandle(TMPQArchive * ha, TFileEntry * pFileEntry)
     3,315 ( 0.00%)  {
         .               TMPQFile * hf;
         .           
         .               // Allocate space for TMPQFile
     2,652 ( 0.00%)      hf = STORM_ALLOC(TMPQFile, 1);
    35,225 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (663x)
     1,326 ( 0.00%)      if(hf != NULL)
         .               {
         .                   // Fill the file structure
     3,978 ( 0.00%)          memset(hf, 0, sizeof(TMPQFile));
    17,238 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (663x)
     1,326 ( 0.00%)          hf->dwMagic = ID_MPQ_FILE;
     1,326 ( 0.00%)          hf->pStream = NULL;
     1,989 ( 0.00%)          hf->ha = ha;
         .           
         .                   // If the called entered a file entry, we also copy informations from the file entry
     2,652 ( 0.00%)          if(ha != NULL && pFileEntry != NULL)
         .                   {
         .                       // Set the raw position and MPQ position
     5,304 ( 0.00%)              hf->RawFilePos = FileOffsetFromMpqOffset(ha, pFileEntry->ByteOffset);
     9,945 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseFileTable.cpp:FileOffsetFromMpqOffset(_TMPQArchive*, unsigned long long) (663x)
     2,652 ( 0.00%)              hf->MpqFilePos = pFileEntry->ByteOffset;
         .           
         .                       // Set the data size
     2,652 ( 0.00%)              hf->dwDataSize = pFileEntry->dwFileSize;
     1,989 ( 0.00%)              hf->pFileEntry = pFileEntry;
         .                   }
         .               }
         .           
       663 ( 0.00%)      return hf;
     1,326 ( 0.00%)  }
         .           
         .           TMPQFile * CreateWritableHandle(TMPQArchive * ha, DWORD dwFileSize)
         .           {
         .               ULONGLONG FreeMpqSpace;
         .               ULONGLONG TempPos;
         .               TMPQFile * hf;
         .           
         .               // We need to find the position in the MPQ where we save the file data
-- line 960 ----------------------------------------
-- line 993 ----------------------------------------
         .           void * LoadMpqTable(
         .               TMPQArchive * ha,
         .               ULONGLONG ByteOffset,
         .               LPBYTE pbTableHash,
         .               DWORD dwCompressedSize,
         .               DWORD dwTableSize,
         .               DWORD dwKey,
         .               DWORD * PtrRealTableSize)
        81 ( 0.00%)  {
         9 ( 0.00%)      ULONGLONG FileSize = 0;
         9 ( 0.00%)      LPBYTE pbCompressed = NULL;
         .               LPBYTE pbMpqTable;
         .               LPBYTE pbToRead;
        18 ( 0.00%)      DWORD dwBytesToRead = dwCompressedSize;
         9 ( 0.00%)      DWORD dwErrCode = ERROR_SUCCESS;
         .           
         .               // Allocate the MPQ table
        63 ( 0.00%)      pbMpqTable = pbToRead = STORM_ALLOC(BYTE, dwTableSize);
     2,268 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (9x)
        18 ( 0.00%)      if(pbMpqTable != NULL)
         .               {
         .                   // Check if the MPQ table is encrypted
        27 ( 0.00%)          if(dwCompressedSize < dwTableSize)
         .                   {
         .                       // Allocate temporary buffer for holding compressed data
         7 ( 0.00%)              pbCompressed = pbToRead = STORM_ALLOC(BYTE, dwCompressedSize);
       204 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (1x)
         2 ( 0.00%)              if(pbCompressed == NULL)
         .                       {
         .                           STORM_FREE(pbMpqTable);
         .                           return NULL;
         .                       }
         .                   }
         .           
         .                   // Get the file offset from which we will read the table
         .                   // Note: According to Storm.dll from Warcraft III (version 2002),
         .                   // if the hash table position is 0xFFFFFFFF, no SetFilePointer call is done
         .                   // and the table is loaded from the current file offset
        36 ( 0.00%)          if(ByteOffset == SFILE_INVALID_POS)
         .                       FileStream_GetPos(ha->pStream, &ByteOffset);
         .           
         .                   // On archives v 1.0, hash table and block table can go beyond EOF.
         .                   // Storm.dll reads as much as possible, then fills the missing part with zeros.
         .                   // Abused by Spazzler map protector which sets hash table size to 0x00100000
         .                   // Abused by NP_Protect in MPQs v4 as well
        45 ( 0.00%)          if(ha->pHeader->wFormatVersion == MPQ_FORMAT_VERSION_1)
         .                   {
         .                       // Cut the table size
         .                       FileStream_GetSize(ha->pStream, &FileSize);
         .                       if((ByteOffset + dwBytesToRead) > FileSize)
         .                       {
         .                           // Fill the extra data with zeros
         .                           dwBytesToRead = (DWORD)(FileSize - ByteOffset);
         .                           memset(pbMpqTable + dwBytesToRead, 0, (dwTableSize - dwBytesToRead));
         .                       }
         .                   }
         .           
         .                   // Give the caller information that the table was cut
        18 ( 0.00%)          if(PtrRealTableSize != NULL)
         .                   {
        18 ( 0.00%)              PtrRealTableSize[0] = dwBytesToRead;
         .                   }
         .           
         .                   // If everything succeeded, read the raw table from the MPQ
        81 ( 0.00%)          if(FileStream_Read(ha->pStream, &ByteOffset, pbToRead, dwBytesToRead))
     1,233 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/FileStream.cpp:FileStream_Read (9x)
         .                   {
         .                       // Verify the MD5 of the table, if present
        81 ( 0.00%)              if(!VerifyDataBlockHash(pbToRead, dwBytesToRead, pbTableHash))
       273 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:VerifyDataBlockHash(void*, unsigned int, unsigned char*) (9x)
         .                       {
         .                           dwErrCode = ERROR_FILE_CORRUPT;
         .                       }
         .                   }
         .                   else
         .                   {
         .                       dwErrCode = GetLastError();
         .                   }
         .           
        18 ( 0.00%)          if(dwErrCode == ERROR_SUCCESS)
         .                   {
         .                       // First of all, decrypt the table
        18 ( 0.00%)              if(dwKey != 0)
         .                       {
         .                           BSWAP_ARRAY32_UNSIGNED(pbToRead, dwCompressedSize);
        36 ( 0.00%)                  DecryptMpqBlock(pbToRead, dwCompressedSize, dwKey);
19,296,786 ( 0.02%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:DecryptMpqBlock(void*, unsigned int, unsigned int) (6x)
         .                           BSWAP_ARRAY32_UNSIGNED(pbToRead, dwCompressedSize);
         .                       }
         .           
         .                       // If the table is compressed, decompress it
        27 ( 0.00%)              if(dwCompressedSize < dwTableSize)
         .                       {
         2 ( 0.00%)                  int cbOutBuffer = (int)dwTableSize;
         2 ( 0.00%)                  int cbInBuffer = (int)dwCompressedSize;
         .           
        10 ( 0.00%)                  if(!SCompDecompress2(pbMpqTable, &cbOutBuffer, pbCompressed, cbInBuffer))
    18,854 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SCompression.cpp:SCompDecompress2 (1x)
         .                               dwErrCode = GetLastError();
         .                       }
         .           
         .                       // Make sure that the table is properly byte-swapped
         .                       BSWAP_ARRAY32_UNSIGNED(pbMpqTable, dwTableSize);
         .                   }
         .           
         .                   // If read failed, free the table and return
        18 ( 0.00%)          if(dwErrCode != ERROR_SUCCESS)
         .                   {
         .                       STORM_FREE(pbMpqTable);
         .                       pbMpqTable = NULL;
         .                   }
         .           
         .                   // Free the compression buffer, if any
        18 ( 0.00%)          if(pbCompressed != NULL)
         4 ( 0.00%)              STORM_FREE(pbCompressed);
        85 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (1x)
         .               }
         .           
         .               // Return the MPQ table
         9 ( 0.00%)      return pbMpqTable;
        18 ( 0.00%)  }
         .           
         .           unsigned char * AllocateMd5Buffer(
         .               DWORD dwRawDataSize,
         .               DWORD dwChunkSize,
         .               LPDWORD pcbMd5Size)
         .           {
         .               unsigned char * md5_array;
         .               DWORD cbMd5Size;
-- line 1114 ----------------------------------------
-- line 1126 ----------------------------------------
         .               // Give the size of the MD5 array
         .               if(pcbMd5Size != NULL)
         .                   *pcbMd5Size = cbMd5Size;
         .               return md5_array;
         .           }
         .           
         .           // Allocates sector buffer and sector offset table
         .           DWORD AllocateSectorBuffer(TMPQFile * hf)
     2,652 ( 0.00%)  {
     1,989 ( 0.00%)      TMPQArchive * ha = hf->ha;
         .           
         .               // Caller of AllocateSectorBuffer must ensure these
     2,652 ( 0.00%)      assert(hf->pbFileSector == NULL);
     2,652 ( 0.00%)      assert(hf->pFileEntry != NULL);
     2,652 ( 0.00%)      assert(hf->ha != NULL);
         .           
         .               // Don't allocate anything if the file has zero size
     5,967 ( 0.00%)      if(hf->pFileEntry->dwFileSize == 0 || hf->dwDataSize == 0)
         .                   return ERROR_SUCCESS;
         .           
         .               // Determine the file sector size and allocate buffer for it
     6,636 ( 0.00%)      hf->dwSectorSize = (hf->pFileEntry->dwFlags & MPQ_FILE_SINGLE_UNIT) ? hf->dwDataSize : ha->dwSectorSize;
     5,967 ( 0.00%)      hf->pbFileSector = STORM_ALLOC(BYTE, hf->dwSectorSize);
   170,322 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (663x)
     1,326 ( 0.00%)      hf->dwSectorOffs = SFILE_INVALID_POS;
         .           
         .               // Return result
     4,641 ( 0.00%)      return (hf->pbFileSector != NULL) ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
     1,326 ( 0.00%)  }
         .           
         .           // Allocates sector offset table
         .           DWORD AllocatePatchInfo(TMPQFile * hf, bool bLoadFromFile)
         .           {
         .               TMPQArchive * ha = hf->ha;
         .               DWORD dwLength = sizeof(TPatchInfo);
         .           
         .               // The following conditions must be true
-- line 1161 ----------------------------------------
-- line 1213 ----------------------------------------
         .               // Save the final length to the patch header
         .               hf->pPatchInfo->dwLength = dwLength;
         .               hf->pPatchInfo->dwFlags  = 0x80000000;
         .               return ERROR_SUCCESS;
         .           }
         .           
         .           // Allocates sector offset table
         .           DWORD AllocateSectorOffsets(TMPQFile * hf, bool bLoadFromFile)
     3,942 ( 0.00%)  {
     1,971 ( 0.00%)      TMPQArchive * ha = hf->ha;
     1,971 ( 0.00%)      TFileEntry * pFileEntry = hf->pFileEntry;
         .               DWORD dwSectorOffsLen;
       657 ( 0.00%)      bool bSectorOffsetTableCorrupt = false;
         .           
         .               // Caller of AllocateSectorOffsets must ensure these
     2,628 ( 0.00%)      assert(hf->SectorOffsets == NULL);
     2,628 ( 0.00%)      assert(hf->pFileEntry != NULL);
     2,628 ( 0.00%)      assert(hf->dwDataSize != 0);
     2,628 ( 0.00%)      assert(hf->ha != NULL);
         .           
         .               // If the file is stored as single unit, just set number of sectors to 1
     3,285 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_SINGLE_UNIT)
         .               {
         .                   hf->dwSectorCount = 1;
         .                   return ERROR_SUCCESS;
         .               }
         .           
         .               // Calculate the number of data sectors
         .               // Note that this doesn't work if the file size is zero
     7,227 ( 0.00%)      hf->dwSectorCount = ((hf->dwDataSize - 1) / hf->dwSectorSize) + 1;
         .           
         .               // Calculate the number of file sectors
     3,285 ( 0.00%)      dwSectorOffsLen = (hf->dwSectorCount + 1) * sizeof(DWORD);
         .           
         .               // If MPQ_FILE_SECTOR_CRC flag is set, there will either be extra DWORD
         .               // or an array of MD5's. Either way, we read at least 4 bytes more
         .               // in order to save additional read from the file.
     3,285 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_SECTOR_CRC)
         3 ( 0.00%)          dwSectorOffsLen += sizeof(DWORD);
         .           
         .               // Only allocate and load the table if the file is compressed
     3,285 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_COMPRESS_MASK)
         .               {
       657 ( 0.00%)          __LoadSectorOffsets:
         .           
         .                   // Allocate the sector offset table
     5,256 ( 0.00%)          hf->SectorOffsets = STORM_ALLOC(DWORD, (dwSectorOffsLen / sizeof(DWORD)));
    33,555 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (657x)
     2,628 ( 0.00%)          if(hf->SectorOffsets == NULL)
         .                       return ERROR_NOT_ENOUGH_MEMORY;
         .           
         .                   // Only read from the file if we are supposed to do so
     1,314 ( 0.00%)          if(bLoadFromFile)
         .                   {
     1,971 ( 0.00%)              ULONGLONG RawFilePos = hf->RawFilePos;
         .           
         .                       // Append the length of the patch info, if any
     2,628 ( 0.00%)              if(hf->pPatchInfo != NULL)
         .                       {
         .                           if((RawFilePos + hf->pPatchInfo->dwLength) < RawFilePos)
         .                               return ERROR_FILE_CORRUPT;
         .                           RawFilePos += hf->pPatchInfo->dwLength;
         .                       }
         .           
         .                       // Load the sector offsets from the file
     7,227 ( 0.00%)              if(!FileStream_Read(ha->pStream, &RawFilePos, hf->SectorOffsets, dwSectorOffsLen))
    91,269 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/FileStream.cpp:FileStream_Read (657x)
         .                       {
         .                           // Free the sector offsets
         .                           STORM_FREE(hf->SectorOffsets);
         .                           hf->SectorOffsets = NULL;
         .                           return GetLastError();
         .                       }
         .           
         .                       // Swap the sector positions
         .                       BSWAP_ARRAY32_UNSIGNED(hf->SectorOffsets, dwSectorOffsLen);
         .           
         .                       // Decrypt loaded sector positions if necessary
     3,285 ( 0.00%)              if(pFileEntry->dwFlags & MPQ_FILE_ENCRYPTED)
         .                       {
         .                           // If we don't know the file key, try to find it.
         .                           if(hf->dwFileKey == 0)
         .                           {
         .                               hf->dwFileKey = DetectFileKeyBySectorSize(hf->SectorOffsets, ha->dwSectorSize, dwSectorOffsLen);
         .                               if(hf->dwFileKey == 0)
         .                               {
         .                                   STORM_FREE(hf->SectorOffsets);
-- line 1297 ----------------------------------------
-- line 1306 ----------------------------------------
         .           
         .                       //
         .                       // Validate the sector offset table
         .                       //
         .                       // Note: Some MPQ protectors put the actual file data before the sector offset table.
         .                       // In this case, the sector offsets are negative (> 0x80000000).
         .                       //
         .           
    10,137 ( 0.00%)              for(DWORD i = 0; i < hf->dwSectorCount; i++)
         .                       {
    11,151 ( 0.00%)                  DWORD dwSectorOffset1 = hf->SectorOffsets[i+1];
     8,673 ( 0.00%)                  DWORD dwSectorOffset0 = hf->SectorOffsets[i];
         .           
         .                           // Every following sector offset must be bigger than the previous one
     3,717 ( 0.00%)                  if(dwSectorOffset1 < dwSectorOffset0)
         .                           {
         .                               bSectorOffsetTableCorrupt = true;
         .                               break;
         .                           }
         .           
         .                           // The sector size must not be bigger than compressed file size
         .                           // Edit: Yes, but apparently, in original Storm.dll, the compressed
         .                           // size is not checked anywhere. However, we need to do this check
         .                           // in order to sector offset table malformed by MPQ protectors
     7,434 ( 0.00%)                  if((dwSectorOffset1 - dwSectorOffset0) > ha->dwSectorSize)
         .                           {
         .                               bSectorOffsetTableCorrupt = true;
         .                               break;
         .                           }
         .                       }
         .           
         .                       // If data corruption detected, free the sector offset table
     1,314 ( 0.00%)              if(bSectorOffsetTableCorrupt)
         .                       {
         .                           STORM_FREE(hf->SectorOffsets);
         .                           hf->SectorOffsets = NULL;
         .                           return ERROR_FILE_CORRUPT;
         .                       }
         .           
         .                       //
         .                       // There may be various extra DWORDs loaded after the sector offset table.
-- line 1346 ----------------------------------------
-- line 1347 ----------------------------------------
         .                       // They are mostly empty on WoW release MPQs, but on MPQs from PTR,
         .                       // they contain random non-zero data. Their meaning is unknown.
         .                       //
         .                       // These extra values are, however, included in the dwCmpSize in the file
         .                       // table. We cannot ignore them, because compacting archive would fail
         .                       //
         .           
         .                       // Clear the lower 2 bits in order to make sure that the value is aligned to 4 bytes
     3,942 ( 0.00%)              if((hf->SectorOffsets[0] & 0xFFFFFFFC) > dwSectorOffsLen)
         .                       {
         .                           // MPQ protectors put some ridiculous values there. We must limit the extra bytes
         .                           if(hf->SectorOffsets[0] > (dwSectorOffsLen + 0x400))
         .                               return ERROR_FILE_CORRUPT;
         .           
         .                           // Free the old sector offset table
         .                           dwSectorOffsLen = hf->SectorOffsets[0];
         .                           STORM_FREE(hf->SectorOffsets);
-- line 1363 ----------------------------------------
-- line 1366 ----------------------------------------
         .                   }
         .                   else
         .                   {
         .                       memset(hf->SectorOffsets, 0, dwSectorOffsLen);
         .                       hf->SectorOffsets[0] = dwSectorOffsLen;
         .                   }
         .               }
         .           
       657 ( 0.00%)      return ERROR_SUCCESS;
     1,314 ( 0.00%)  }
         .           
         .           DWORD AllocateSectorChecksums(TMPQFile * hf, bool bLoadFromFile)
        18 ( 0.00%)  {
         9 ( 0.00%)      TMPQArchive * ha = hf->ha;
         9 ( 0.00%)      TFileEntry * pFileEntry = hf->pFileEntry;
         .               ULONGLONG RawFilePos;
         3 ( 0.00%)      DWORD dwCompressedSize = 0;
         .               DWORD dwExpectedSize;
         .               DWORD dwCrcOffset;                      // Offset of the CRC table, relative to file offset in the MPQ
         .               DWORD dwCrcSize;
         .           
         .               // Caller of AllocateSectorChecksums must ensure these
        12 ( 0.00%)      assert(hf->SectorChksums == NULL);
        12 ( 0.00%)      assert(hf->SectorOffsets != NULL);
        12 ( 0.00%)      assert(hf->pFileEntry != NULL);
        12 ( 0.00%)      assert(hf->ha != NULL);
         .           
         .               // Single unit files don't have sector checksums
        15 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_SINGLE_UNIT)
         .                   return ERROR_SUCCESS;
         .           
         .               // Caller must ensure that we are only called when we have sector checksums
        15 ( 0.00%)      assert(pFileEntry->dwFlags & MPQ_FILE_SECTOR_CRC);
         .           
         .               //
         .               // Older MPQs store an array of CRC32's after
         .               // the raw file data in the MPQ.
         .               //
         .               // In newer MPQs, the (since Cataclysm BETA) the (attributes) file
         .               // contains additional 32-bit values beyond the sector table.
         .               // Their number depends on size of the (attributes), but their
         .               // meaning is unknown. They are usually zeroed in retail game files,
         .               // but contain some sort of checksum in BETA MPQs
         .               //
         .           
         .               // Does the size of the file table match with the CRC32-based checksums?
        15 ( 0.00%)      dwExpectedSize = (hf->dwSectorCount + 2) * sizeof(DWORD);
        30 ( 0.00%)      if(hf->SectorOffsets[0] != 0 && hf->SectorOffsets[0] == dwExpectedSize)
         .               {
         .                   // If we are not loading from the MPQ file, we just allocate the sector table
         .                   // In that case, do not check any sizes
         9 ( 0.00%)          if(bLoadFromFile == false)
         .                   {
         .                       hf->SectorChksums = STORM_ALLOC(DWORD, hf->dwSectorCount);
         .                       if(hf->SectorChksums == NULL)
         .                           return ERROR_NOT_ENOUGH_MEMORY;
         .           
         .                       // Fill the checksum table with zeros
         .                       memset(hf->SectorChksums, 0, hf->dwSectorCount * sizeof(DWORD));
         .                       return ERROR_SUCCESS;
         .                   }
         .                   else
         .                   {
         .                       // Is there valid size of the sector checksums?
        57 ( 0.00%)              if(hf->SectorOffsets[hf->dwSectorCount + 1] >= hf->SectorOffsets[hf->dwSectorCount])
        57 ( 0.00%)                  dwCompressedSize = hf->SectorOffsets[hf->dwSectorCount + 1] - hf->SectorOffsets[hf->dwSectorCount];
         .           
         .                       // Ignore cases when the length is too small or too big.
        18 ( 0.00%)              if(dwCompressedSize < sizeof(DWORD) || dwCompressedSize > hf->dwSectorSize)
         .                           return ERROR_SUCCESS;
         .           
         .                       // Calculate offset of the CRC table
        12 ( 0.00%)              dwCrcSize = hf->dwSectorCount * sizeof(DWORD);
        27 ( 0.00%)              dwCrcOffset = hf->SectorOffsets[hf->dwSectorCount];
        18 ( 0.00%)              RawFilePos = CalculateRawSectorOffset(hf, dwCrcOffset);
        96 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseFileTable.cpp:CalculateRawSectorOffset(_TMPQFile*, unsigned int) (3x)
         .           
         .                       // Now read the table from the MPQ
        45 ( 0.00%)              hf->SectorChksums = (DWORD *)LoadMpqTable(ha, RawFilePos, NULL, dwCompressedSize, dwCrcSize, 0, NULL);
    20,392 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:LoadMpqTable(_TMPQArchive*, unsigned long long, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int*) (3x)
        12 ( 0.00%)              if(hf->SectorChksums == NULL)
         .                           return ERROR_NOT_ENOUGH_MEMORY;
         .                   }
         .               }
         .           
         .               // If the size doesn't match, we ignore sector checksums
         .           //  assert(false);
         3 ( 0.00%)      return ERROR_SUCCESS;
         6 ( 0.00%)  }
         .           
         .           DWORD WritePatchInfo(TMPQFile * hf)
         .           {
         .               TMPQArchive * ha = hf->ha;
         .               TPatchInfo * pPatchInfo = hf->pPatchInfo;
         .           
         .               // The caller must make sure that this function is only called
         .               // when the following is true.
-- line 1460 ----------------------------------------
-- line 1667 ----------------------------------------
         .               // Free buffers and exit
         .               STORM_FREE(pbFileChunk);
         .               STORM_FREE(md5_array);
         .               return dwErrCode;
         .           }
         .           
         .           // Frees the structure for MPQ file
         .           void FreeFileHandle(TMPQFile *& hf)
     2,652 ( 0.00%)  {
     2,652 ( 0.00%)      if(hf != NULL)
         .               {
         .                   // If we have patch file attached to this one, free it first
     3,315 ( 0.00%)          if(hf->hfPatch != NULL)
         .                       FreeFileHandle(hf->hfPatch);
         .           
         .                   // Then free all buffers allocated in the file structure
     3,315 ( 0.00%)          if(hf->pbFileData != NULL)
         .                       STORM_FREE(hf->pbFileData);
     3,315 ( 0.00%)          if(hf->pPatchInfo != NULL)
         .                       STORM_FREE(hf->pPatchInfo);
     3,315 ( 0.00%)          if(hf->SectorOffsets != NULL)
     3,942 ( 0.00%)              STORM_FREE(hf->SectorOffsets);
    58,083 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (657x)
     3,315 ( 0.00%)          if(hf->SectorChksums != NULL)
        18 ( 0.00%)              STORM_FREE(hf->SectorChksums);
       255 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (3x)
     3,315 ( 0.00%)          if(hf->hctx != NULL)
         .                       STORM_FREE(hf->hctx);
     3,315 ( 0.00%)          if(hf->pbFileSector != NULL)
     3,978 ( 0.00%)              STORM_FREE(hf->pbFileSector);
   137,679 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (663x)
     3,315 ( 0.00%)          if(hf->pStream != NULL)
         .                       FileStream_Close(hf->pStream);
     3,315 ( 0.00%)          STORM_FREE(hf);
    60,619 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (663x)
     1,326 ( 0.00%)          hf = NULL;
         .               }
     1,989 ( 0.00%)  }
         .           
         .           // Frees the MPQ archive
         .           void FreeArchiveHandle(TMPQArchive *& ha)
         .           {
         .               if(ha != NULL)
         .               {
         .                   // First of all, free the patch archive, if any
         .                   if(ha->haPatch != NULL)
-- line 1708 ----------------------------------------
-- line 1751 ----------------------------------------
         .                   }
         .               }
         .           
         .               return false;
         .           }
         .           
         .           // Verifies if the file name is a pseudo-name
         .           bool IsPseudoFileName(const char * szFileName, DWORD * pdwFileIndex)
    89,365 ( 0.00%)  {
    17,873 ( 0.00%)      DWORD dwFileIndex = 0;
         .           
    35,746 ( 0.00%)      if(szFileName != NULL)
         .               {
         .                   // Must be "File########.ext"
    10,528 ( 0.00%)          if(!_strnicmp(szFileName, "File", 4))
    65,159 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncasecmp_avx2 (1,316x)
         .                   {
         .                       // Check 8 digits
         .                       for(int i = 4; i < 4+8; i++)
         .                       {
         .                           if(szFileName[i] < '0' || szFileName[i] > '9')
         .                               return false;
         .                           dwFileIndex = (dwFileIndex * 10) + (szFileName[i] - '0');
         .                       }
-- line 1773 ----------------------------------------
-- line 1778 ----------------------------------------
         .                           if(pdwFileIndex != NULL)
         .                               *pdwFileIndex = dwFileIndex;
         .                           return true;
         .                       }
         .                   }
         .               }
         .           
         .               // Not a pseudo-name
    17,873 ( 0.00%)      return false;
    35,746 ( 0.00%)  }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Functions calculating and verifying the MD5 signature
         .           
         .           bool IsValidMD5(LPBYTE pbMd5)
        27 ( 0.00%)  {
        18 ( 0.00%)      LPDWORD Md5 = (LPDWORD)pbMd5;
         .           
        75 ( 0.00%)      return ((Md5 != NULL) && (Md5[0] | Md5[1] | Md5[2] | Md5[3])) ? true : false;
        18 ( 0.00%)  }
         .           
         .           bool IsValidSignature(LPBYTE pbSignature)
         .           {
         .               LPDWORD Signature = (LPDWORD)pbSignature;
         .               DWORD SigValid = 0;
         .           
         .               for(int i = 0; i < MPQ_WEAK_SIGNATURE_SIZE / sizeof(DWORD); i++)
         .                   SigValid |= Signature[i];
         .           
         .               return (SigValid != 0) ? true : false;
         .           }
         .           
         .           
         .           bool VerifyDataBlockHash(void * pvDataBlock, DWORD cbDataBlock, LPBYTE expected_md5)
        54 ( 0.00%)  {
         .               hash_state md5_state;
         .               BYTE md5_digest[MD5_DIGEST_SIZE];
         9 ( 0.00%)      bool bResult = true;
         .           
         .               // Don't verify the block if the MD5 is not valid.
        45 ( 0.00%)      if(IsValidMD5(expected_md5))
       138 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:IsValidMD5(unsigned char*) (9x)
         .               {
         .                   // Calculate the MD5 of the data block
         .                   md5_init(&md5_state);
         .                   md5_process(&md5_state, (unsigned char *)pvDataBlock, cbDataBlock);
         .                   md5_done(&md5_state, md5_digest);
         .           
         .                   // Does the MD5's match?
         .                   bResult = (memcmp(md5_digest, expected_md5, MD5_DIGEST_SIZE) == 0);
         .               }
         .           
         9 ( 0.00%)      return bResult;
        18 ( 0.00%)  }
         .           
         .           void CalculateDataBlockHash(void * pvDataBlock, DWORD cbDataBlock, LPBYTE md5_hash)
         .           {
         .               hash_state md5_state;
         .           
         .               md5_init(&md5_state);
         .               md5_process(&md5_state, (unsigned char *)pvDataBlock, cbDataBlock);
         .               md5_done(&md5_state, md5_hash);
-- line 1838 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/Context.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 14 ----------------------------------------
        .           
        .           #ifdef __APPLE__
        .           #include "utils/AppleFolderManager.h"
        .           #endif
        .           
        .           namespace Ship {
        .           std::weak_ptr<Context> Context::mContext;
        .           
1,597,352 ( 0.00%)  std::shared_ptr<Context> Context::GetInstance() {
1,597,352 ( 0.00%)      return mContext.lock();
55,907,320 ( 0.05%)  => /usr/include/c++/14/bits/shared_ptr.h:std::weak_ptr<Ship::Context>::lock() const (399,338x)
1,198,014 ( 0.00%)  }
        .           
        .           Context::~Context() {
        .               SPDLOG_TRACE("destruct context");
        .               GetWindow()->SaveWindowToConfig();
        .           
        .               // Explicitly destructing everything so that logging is done last.
        .               mAudio = nullptr;
        .               mWindow = nullptr;
-- line 32 ----------------------------------------
-- line 35 ----------------------------------------
        .               mControlDeck = nullptr;
        .               mResourceManager = nullptr;
        .               mConsoleVariables = nullptr;
        .               GetConfig()->Save();
        .               mConfig = nullptr;
        .               spdlog::shutdown();
        .           }
        .           
        1 ( 0.00%)  std::shared_ptr<Context> Context::CreateInstance(const std::string name, const std::string shortName,
        .                                                            const std::string configFilePath,
        .                                                            const std::vector<std::string>& otrFiles,
        .                                                            const std::unordered_set<uint32_t>& validHashes,
       11 ( 0.00%)                                                   uint32_t reservedThreadCount, AudioSettings audioSettings) {
        4 ( 0.00%)      if (mContext.expired()) {
       23 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__weak_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>::expired() const (1x)
        8 ( 0.00%)          auto shared = std::make_shared<Context>(name, shortName, configFilePath);
    4,173 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Context> std::make_shared<Ship::Context, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (1x)
        4 ( 0.00%)          mContext = shared;
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::enable_if<std::is_assignable<std::__weak_ptr<Ship::Context, (__gnu_cxx::_Lock_policy)2>&, std::shared_ptr<Ship::Context> const&>::value, std::weak_ptr<Ship::Context>&>::type std::weak_ptr<Ship::Context>::operator=<Ship::Context>(std::shared_ptr<Ship::Context> const&) (1x)
       15 ( 0.00%)          shared->Init(otrFiles, validHashes, reservedThreadCount, audioSettings);
595,716,712 ( 0.49%)  => libultraship/src/Context.cpp:Ship::Context::Init(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> > const&, unsigned int, Ship::AudioSettings) (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Context, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        1 ( 0.00%)          return shared;
        .               }
        .           
        .               SPDLOG_DEBUG("Trying to create a context when it already exists. Returning existing.");
        .           
        .               return GetInstance();
        6 ( 0.00%)  }
        .           
        .           std::shared_ptr<Context> Context::CreateUninitializedInstance(const std::string name, const std::string shortName,
        .                                                                         const std::string configFilePath) {
        .               if (mContext.expired()) {
        .                   auto shared = std::make_shared<Context>(name, shortName, configFilePath);
        .                   mContext = shared;
        .                   return shared;
        .               }
        .           
        .               SPDLOG_DEBUG("Trying to create an uninitialized context when it already exists. Returning existing.");
        .           
        .               return GetInstance();
        .           }
        .           
        8 ( 0.00%)  Context::Context(std::string name, std::string shortName, std::string configFilePath)
       71 ( 0.00%)      : mConfigFilePath(std::move(configFilePath)), mName(std::move(name)), mShortName(std::move(shortName)) {
    1,138 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (3x)
      316 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string() (2x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ConsoleVariable>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ControlDeck>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CrashHandler>::shared_ptr() (1x)
       18 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type&& std::move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (3x)
        4 ( 0.00%)  }
        .           
        .           void Context::Init(const std::vector<std::string>& otrFiles, const std::unordered_set<uint32_t>& validHashes,
       15 ( 0.00%)                     uint32_t reservedThreadCount, AudioSettings audioSettings) {
        3 ( 0.00%)      InitLogging();
  581,716 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::InitLogging() (1x)
        3 ( 0.00%)      InitConfiguration();
4,408,862 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::InitConfiguration() (1x)
        3 ( 0.00%)      InitConsoleVariables();
7,256,720 ( 0.01%)  => libultraship/src/Context.cpp:Ship::Context::InitConsoleVariables() (1x)
        6 ( 0.00%)      InitResourceManager(otrFiles, validHashes, reservedThreadCount);
333,687,234 ( 0.28%)  => libultraship/src/Context.cpp:Ship::Context::InitResourceManager(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> > const&, unsigned int) (1x)
       14 ( 0.00%)      InitControlDeck();
  212,633 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::InitControlDeck(std::vector<unsigned short, std::allocator<unsigned short> >) (1x)
       98 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<unsigned short, std::allocator<unsigned short> >::~vector() (1x)
       48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<unsigned short, std::allocator<unsigned short> >::vector() (1x)
        3 ( 0.00%)      InitCrashHandler();
    1,583 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::InitCrashHandler() (1x)
        3 ( 0.00%)      InitConsole();
    1,290 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::InitConsole() (1x)
       14 ( 0.00%)      InitWindow();
236,737,176 ( 0.20%)  => libultraship/src/Context.cpp:Ship::Context::InitWindow(std::vector<std::shared_ptr<Ship::GuiWindow>, std::allocator<std::shared_ptr<Ship::GuiWindow> > >) (1x)
      104 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<Ship::GuiWindow>, std::allocator<std::shared_ptr<Ship::GuiWindow> > >::~vector() (1x)
       48 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<Ship::GuiWindow>, std::allocator<std::shared_ptr<Ship::GuiWindow> > >::vector() (1x)
        6 ( 0.00%)      InitAudio(audioSettings);
12,828,243 ( 0.01%)  => libultraship/src/Context.cpp:Ship::Context::InitAudio(Ship::AudioSettings) (1x)
        3 ( 0.00%)      InitGfxDebugger();
      880 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::InitGfxDebugger() (1x)
        4 ( 0.00%)  }
        .           
        6 ( 0.00%)  void Context::InitLogging() {
       16 ( 0.00%)      if (GetLogger() != nullptr) {
       61 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetLogger() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::~shared_ptr() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<spdlog::logger>(std::shared_ptr<spdlog::logger> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
        .               try {
        .                   // Setup Logging
        3 ( 0.00%)          spdlog::init_thread_pool(8192, 1);
  520,967 ( 0.00%)  => /usr/include/spdlog/async.h:spdlog::init_thread_pool(unsigned long, unsigned long) (1x)
        3 ( 0.00%)          std::vector<spdlog::sink_ptr> sinks;
        .           
        .           #if (!defined(_WIN32)) || defined(_DEBUG)
        .           #if defined(_DEBUG) && defined(_WIN32)
        .                   // LLVM on Windows allocs a hidden console in its entrypoint function.
        .                   // We free that console here to create our own.
        .                   FreeConsole();
        .                   if (AllocConsole() == 0) {
        .                       throw std::system_error(GetLastError(), std::generic_category(), "Failed to create debug console");
-- line 107 ----------------------------------------
-- line 125 ----------------------------------------
        .                   SetStdHandle(STD_OUTPUT_HANDLE, hConOut);
        .                   SetStdHandle(STD_ERROR_HANDLE, hConOut);
        .                   SetStdHandle(STD_INPUT_HANDLE, hConIn);
        .                   std::wcout.clear();
        .                   std::wclog.clear();
        .                   std::wcerr.clear();
        .                   std::wcin.clear();
        .           #endif
        3 ( 0.00%)          auto systemConsoleSink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
    4,093 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex> > std::make_shared<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>>() (1x)
        .                   // systemConsoleSink->set_level(spdlog::level::trace);
       15 ( 0.00%)          sinks.push_back(systemConsoleSink);
    1,029 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::push_back(std::shared_ptr<spdlog::sinks::sink>&&) (1x)
       77 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::sink>::shared_ptr<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>, void>(std::shared_ptr<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex> > const&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::sink>::~shared_ptr() (1x)
        .           #endif
        .           
       31 ( 0.00%)          auto logPath = GetPathRelativeToAppDirectory(("logs/" + GetName() + ".log"));
    4,053 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetPathRelativeToAppDirectory(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (1x)
    1,345 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
      463 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
      372 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetName[abi:cxx11]() (1x)
      740 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, char const*) (1x)
        8 ( 0.00%)          auto fileSink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(logPath, 1024 * 1024 * 10, 10);
    6,716 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::rotating_file_sink<std::mutex> > std::make_shared<spdlog::sinks::rotating_file_sink<std::mutex>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, int, int>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, int&&, int&&) (1x)
        .           #ifdef _DEBUG
       11 ( 0.00%)          fileSink->set_level(spdlog::level::trace);
    1,268 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<spdlog::sinks::rotating_file_sink<std::mutex>, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        3 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/sinks/sink-inl.h:spdlog::sinks::sink::set_level(spdlog::level::level_enum) (1x)
        .           #else
        .                   fileSink->set_level(spdlog::level::debug);
        .           #endif
       13 ( 0.00%)          sinks.push_back(fileSink);
    1,246 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::push_back(std::shared_ptr<spdlog::sinks::sink>&&) (1x)
       77 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::sink>::shared_ptr<spdlog::sinks::rotating_file_sink<std::mutex>, void>(std::shared_ptr<spdlog::sinks::rotating_file_sink<std::mutex> > const&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::sink>::~shared_ptr() (1x)
        .           
       35 ( 0.00%)          mLogger = std::make_shared<spdlog::async_logger>(GetName(), sinks.begin(), sinks.end(), spdlog::thread_pool(),
    3,936 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::async_logger> std::make_shared<spdlog::async_logger, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, __gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >, __gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >, std::shared_ptr<spdlog::details::thread_pool>, spdlog::async_overflow_policy>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, __gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >&&, __gnu_cxx::__normal_iterator<std::shared_ptr<spdlog::sinks::sink>*, std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > > >&&, std::shared_ptr<spdlog::details::thread_pool>&&, spdlog::async_overflow_policy&&) (1x)
    1,318 ( 0.00%)  => /usr/include/spdlog/async.h:spdlog::thread_pool() (1x)
      100 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
      372 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetName[abi:cxx11]() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::details::thread_pool>::~shared_ptr() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::async_logger>::~shared_ptr() (1x)
       24 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::end() (1x)
       23 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::begin() (1x)
        6 ( 0.00%)                                                           spdlog::async_overflow_policy::block);
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::enable_if<std::is_assignable<std::__shared_ptr<spdlog::logger, (__gnu_cxx::_Lock_policy)2>&, std::shared_ptr<spdlog::async_logger> >::value, std::shared_ptr<spdlog::logger>&>::type std::shared_ptr<spdlog::logger>::operator=<spdlog::async_logger>(std::shared_ptr<spdlog::async_logger>&&) (1x)
        .           #ifdef _DEBUG
       19 ( 0.00%)          GetLogger()->set_level(spdlog::level::trace);
    1,268 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       90 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetLogger() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<spdlog::logger, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        3 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/logger-inl.h:spdlog::logger::set_level(spdlog::level::level_enum) (1x)
        .           #else
        .                   GetLogger()->set_level(spdlog::level::debug);
        .           #endif
        .           
        .           #if defined(_DEBUG)
       19 ( 0.00%)          GetLogger()->flush_on(spdlog::level::trace);
    1,248 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       90 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetLogger() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<spdlog::logger, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        3 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/logger-inl.h:spdlog::logger::flush_on(spdlog::level::level_enum) (1x)
        .           #endif
        .           
       32 ( 0.00%)          GetLogger()->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%@] [%l] %v");
   21,134 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/logger-inl.h:spdlog::logger::set_pattern(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, spdlog::pattern_time_type) (1x)
    1,662 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      100 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
      538 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (1x)
       90 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetLogger() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<spdlog::logger, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        .           
       16 ( 0.00%)          spdlog::register_logger(GetLogger());
    1,317 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      617 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::register_logger(std::shared_ptr<spdlog::logger>) (1x)
       90 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetLogger() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::~shared_ptr() (1x)
       16 ( 0.00%)          spdlog::set_default_logger(GetLogger());
    1,330 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,330 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::set_default_logger(std::shared_ptr<spdlog::logger>) (1x)
       90 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetLogger() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::~shared_ptr() (1x)
       12 ( 0.00%)      } catch (const spdlog::spdlog_ex& ex) { std::cout << "Log initialization failed: " << ex.what() << std::endl; }
      263 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
      469 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::shared_ptr<spdlog::sinks::sink>, std::allocator<std::shared_ptr<spdlog::sinks::sink> > >::~vector() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex> >::~shared_ptr() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::sinks::rotating_file_sink<std::mutex> >::~shared_ptr() (1x)
        6 ( 0.00%)  }
        .           
        5 ( 0.00%)  void Context::InitConfiguration() {
       18 ( 0.00%)      if (GetConfig() != nullptr) {
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::~shared_ptr() (1x)
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConfig() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::Config>(std::shared_ptr<Ship::Config> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       31 ( 0.00%)      mConfig = std::make_shared<Config>(GetPathRelativeToAppDirectory(GetConfigFilePath()));
4,403,050 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config> std::make_shared<Ship::Config, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
    4,053 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetPathRelativeToAppDirectory(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (1x)
      569 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConfigFilePath[abi:cxx11]() (1x)
      363 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (2x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::operator=(std::shared_ptr<Ship::Config>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::~shared_ptr() (1x)
        3 ( 0.00%)  }
        .           
        5 ( 0.00%)  void Context::InitConsoleVariables() {
       16 ( 0.00%)      if (GetConsoleVariables() != nullptr) {
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ConsoleVariable>::~shared_ptr() (1x)
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConsoleVariables() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::ConsoleVariable>(std::shared_ptr<Ship::ConsoleVariable> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       13 ( 0.00%)      mConsoleVariables = std::make_shared<ConsoleVariable>();
7,256,332 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ConsoleVariable> std::make_shared<Ship::ConsoleVariable>() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ConsoleVariable>::operator=(std::shared_ptr<Ship::ConsoleVariable>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ConsoleVariable>::~shared_ptr() (1x)
        3 ( 0.00%)  }
        .           
        .           void Context::InitResourceManager(const std::vector<std::string>& otrFiles,
        9 ( 0.00%)                                    const std::unordered_set<uint32_t>& validHashes, uint32_t reservedThreadCount) {
       16 ( 0.00%)      if (GetResourceManager() != nullptr) {
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::ResourceManager>(std::shared_ptr<Ship::ResourceManager> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       47 ( 0.00%)      mMainPath = GetConfig()->GetString("Game.Main Archive", GetAppDirectoryPath());
3,577,540 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/config/Config.cpp:Ship::Config::GetString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (1x)
    1,354 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetAppDirectoryPath(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (1x)
      493 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
      529 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (1x)
      427 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConfig() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Config, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
       56 ( 0.00%)      mPatchesPath = GetConfig()->GetString("Game.Patches Archive", GetAppDirectoryPath() + "/mods");
3,578,851 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/config/Config.cpp:Ship::Config::GetString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (1x)
    1,354 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetAppDirectoryPath(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (1x)
      593 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (4x)
      529 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (1x)
      450 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
      775 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, char const*) (1x)
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConfig() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Config, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        5 ( 0.00%)      if (otrFiles.empty()) {
       97 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::empty() const (1x)
        .                   std::vector<std::string> paths = std::vector<std::string>();
        .                   paths.push_back(mMainPath);
        .                   paths.push_back(mPatchesPath);
        .           
        .                   mResourceManager = std::make_shared<ResourceManager>();
        .                   GetResourceManager()->Init(paths, validHashes, reservedThreadCount);
        .               } else {
       12 ( 0.00%)          mResourceManager = std::make_shared<ResourceManager>();
      878 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager> std::make_shared<Ship::ResourceManager>() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::operator=(std::shared_ptr<Ship::ResourceManager>&&) (1x)
       17 ( 0.00%)          GetResourceManager()->Init(otrFiles, validHashes, reservedThreadCount);
326,521,016 ( 0.27%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::Init(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> > const&, int) (1x)
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        .               }
        .           
       17 ( 0.00%)      if (!GetResourceManager()->DidLoadSuccessfully()) {
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetResourceManager() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::~shared_ptr() (1x)
      176 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::DidLoadSuccessfully() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        .                   SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "OTR file not found",
        .                                            "Main OTR file not found. Please generate one", nullptr);
        .                   SPDLOG_ERROR("Main OTR file not found!");
        .           #ifdef __IOS__
        .                   // We need this exit to close the app when we dismiss the dialog
        .                   exit(0);
        .           #endif
        .                   return;
        .               }
        6 ( 0.00%)  }
        .           
        6 ( 0.00%)  void Context::InitControlDeck(std::vector<CONTROLLERBUTTONS_T> additionalBitmasks) {
       16 ( 0.00%)      if (GetControlDeck() != nullptr) {
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ControlDeck>::~shared_ptr() (1x)
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetControlDeck() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::ControlDeck>(std::shared_ptr<Ship::ControlDeck> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       15 ( 0.00%)      mControlDeck = std::make_shared<ControlDeck>(additionalBitmasks);
  212,242 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ControlDeck> std::make_shared<Ship::ControlDeck, std::vector<unsigned short, std::allocator<unsigned short> >&>(std::vector<unsigned short, std::allocator<unsigned short> >&) (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ControlDeck>::operator=(std::shared_ptr<Ship::ControlDeck>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ControlDeck>::~shared_ptr() (1x)
        3 ( 0.00%)  }
        .           
        5 ( 0.00%)  void Context::InitCrashHandler() {
       16 ( 0.00%)      if (GetCrashHandler() != nullptr) {
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CrashHandler>::~shared_ptr() (1x)
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetCrashHandler() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::CrashHandler>(std::shared_ptr<Ship::CrashHandler> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       13 ( 0.00%)      mCrashHandler = std::make_shared<CrashHandler>();
    1,195 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CrashHandler> std::make_shared<Ship::CrashHandler>() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CrashHandler>::operator=(std::shared_ptr<Ship::CrashHandler>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CrashHandler>::~shared_ptr() (1x)
        3 ( 0.00%)  }
        .           
        9 ( 0.00%)  void Context::InitAudio(AudioSettings settings) {
       16 ( 0.00%)      if (GetAudio() != nullptr) {
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetAudio() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio>::~shared_ptr() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::Audio>(std::shared_ptr<Ship::Audio> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       14 ( 0.00%)      mAudio = std::make_shared<Audio>(settings);
      600 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio> std::make_shared<Ship::Audio, Ship::AudioSettings&>(Ship::AudioSettings&) (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio>::operator=(std::shared_ptr<Ship::Audio>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio>::~shared_ptr() (1x)
       13 ( 0.00%)      GetAudio()->Init();
12,827,038 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/audio/Audio.cpp:Ship::Audio::Init() (1x)
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetAudio() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Audio, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        4 ( 0.00%)  }
        .           
       10 ( 0.00%)  void Context::InitGfxDebugger() {
       32 ( 0.00%)      if (GetGfxDebugger() != nullptr) {
      153 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetGfxDebugger() (2x)
      114 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger>::~shared_ptr() (2x)
       40 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Fast::GfxDebugger>(std::shared_ptr<Fast::GfxDebugger> const&, decltype(nullptr)) (2x)
        1 ( 0.00%)          return;
        .               }
        .           
       13 ( 0.00%)      mGfxDebugger = std::make_shared<Fast::GfxDebugger>();
      492 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger> std::make_shared<Fast::GfxDebugger>() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger>::operator=(std::shared_ptr<Fast::GfxDebugger>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger>::~shared_ptr() (1x)
        6 ( 0.00%)  }
        .           
        5 ( 0.00%)  void Context::InitConsole() {
       16 ( 0.00%)      if (GetConsole() != nullptr) {
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConsole() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console>::~shared_ptr() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::Console>(std::shared_ptr<Ship::Console> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       12 ( 0.00%)      mConsole = std::make_shared<Console>();
      685 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console> std::make_shared<Ship::Console>() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console>::operator=(std::shared_ptr<Ship::Console>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console>::~shared_ptr() (1x)
       13 ( 0.00%)      GetConsole()->Init();
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetConsole() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Console, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        6 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/debug/Console.cpp:Ship::Console::Init() (1x)
        4 ( 0.00%)  }
        .           
        6 ( 0.00%)  void Context::InitWindow(std::vector<std::shared_ptr<GuiWindow>> guiWindows) {
       16 ( 0.00%)      if (GetWindow() != nullptr) {
       62 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetWindow() (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::~shared_ptr() (1x)
       20 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::Window>(std::shared_ptr<Ship::Window> const&, decltype(nullptr)) (1x)
        .                   return;
        .               }
        .           
       14 ( 0.00%)      mWindow = std::make_shared<Fast::Fast3dWindow>(guiWindows);
  393,003 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::Fast3dWindow> std::make_shared<Fast::Fast3dWindow, std::vector<std::shared_ptr<Ship::GuiWindow>, std::allocator<std::shared_ptr<Ship::GuiWindow> > >&>(std::vector<std::shared_ptr<Ship::GuiWindow>, std::allocator<std::shared_ptr<Ship::GuiWindow> > >&) (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::enable_if<std::is_assignable<std::__shared_ptr<Ship::Window, (__gnu_cxx::_Lock_policy)2>&, std::shared_ptr<Fast::Fast3dWindow> >::value, std::shared_ptr<Ship::Window>&>::type std::shared_ptr<Ship::Window>::operator=<Fast::Fast3dWindow>(std::shared_ptr<Fast::Fast3dWindow>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::Fast3dWindow>::~shared_ptr() (1x)
       15 ( 0.00%)      GetWindow()->Init();
236,343,569 ( 0.20%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/Fast3dWindow.cpp:Fast::Fast3dWindow::Init() (1x)
       91 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetWindow() (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::~shared_ptr() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::Window, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        4 ( 0.00%)  }
        .           
  183,535 ( 0.00%)  std::shared_ptr<ConsoleVariable> Context::GetConsoleVariables() {
  220,242 ( 0.00%)      return mConsoleVariables;
2,826,410 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ConsoleVariable>::shared_ptr(std::shared_ptr<Ship::ConsoleVariable> const&) (36,707x)
  110,121 ( 0.00%)  }
        .           
       30 ( 0.00%)  std::shared_ptr<spdlog::logger> Context::GetLogger() {
       30 ( 0.00%)      return mLogger;
      433 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<spdlog::logger>::shared_ptr(std::shared_ptr<spdlog::logger> const&) (6x)
       18 ( 0.00%)  }
        .           
    2,225 ( 0.00%)  std::shared_ptr<Config> Context::GetConfig() {
    2,670 ( 0.00%)      return mConfig;
   34,236 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Config>::shared_ptr(std::shared_ptr<Ship::Config> const&) (445x)
    1,335 ( 0.00%)  }
        .           
1,717,110 ( 0.00%)  std::shared_ptr<ResourceManager> Context::GetResourceManager() {
2,060,532 ( 0.00%)      return mResourceManager;
26,443,465 ( 0.02%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceManager>::shared_ptr(std::shared_ptr<Ship::ResourceManager> const&) (343,422x)
1,030,266 ( 0.00%)  }
        .           
   39,915 ( 0.00%)  std::shared_ptr<ControlDeck> Context::GetControlDeck() {
   47,898 ( 0.00%)      return mControlDeck;
  614,662 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ControlDeck>::shared_ptr(std::shared_ptr<Ship::ControlDeck> const&) (7,983x)
   23,949 ( 0.00%)  }
        .           
        5 ( 0.00%)  std::shared_ptr<CrashHandler> Context::GetCrashHandler() {
        6 ( 0.00%)      return mCrashHandler;
       48 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::CrashHandler>::shared_ptr(std::shared_ptr<Ship::CrashHandler> const&) (1x)
        3 ( 0.00%)  }
        .           
   53,915 ( 0.00%)  std::shared_ptr<Window> Context::GetWindow() {
   64,698 ( 0.00%)      return mWindow;
  830,262 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Window>::shared_ptr(std::shared_ptr<Ship::Window> const&) (10,783x)
   32,349 ( 0.00%)  }
        .           
       40 ( 0.00%)  std::shared_ptr<Console> Context::GetConsole() {
       48 ( 0.00%)      return mConsole;
      587 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Console>::shared_ptr(std::shared_ptr<Ship::Console> const&) (8x)
       24 ( 0.00%)  }
        .           
       10 ( 0.00%)  std::shared_ptr<Audio> Context::GetAudio() {
       12 ( 0.00%)      return mAudio;
      125 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::Audio>::shared_ptr(std::shared_ptr<Ship::Audio> const&) (2x)
        6 ( 0.00%)  }
        .           
    6,050 ( 0.00%)  std::shared_ptr<Fast::GfxDebugger> Context::GetGfxDebugger() {
    7,260 ( 0.00%)      return mGfxDebugger;
   93,141 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Fast::GfxDebugger>::shared_ptr(std::shared_ptr<Fast::GfxDebugger> const&) (1,210x)
    3,630 ( 0.00%)  }
        .           
        5 ( 0.00%)  std::string Context::GetConfigFilePath() {
        6 ( 0.00%)      return mConfigFilePath;
      555 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (1x)
        3 ( 0.00%)  }
        .           
       15 ( 0.00%)  std::string Context::GetName() {
       18 ( 0.00%)      return mName;
    1,074 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (3x)
        9 ( 0.00%)  }
        .           
        .           std::string Context::GetShortName() {
        .               return mShortName;
        .           }
        .           
       14 ( 0.00%)  std::string Context::GetAppBundlePath() {
        .           #if defined(__ANDROID__)
        .               const char* externaldir = SDL_AndroidGetExternalStoragePath();
        .               if (externaldir != NULL) {
        .                   return externaldir;
        .               }
        .           #endif
        .           
        .           #ifdef __IOS__
-- line 325 ----------------------------------------
-- line 331 ----------------------------------------
        .               return CMAKE_INSTALL_PREFIX;
        .           #else
        .           #ifdef __APPLE__
        .               FolderManager folderManager;
        .               return folderManager.getMainBundlePath();
        .           #endif
        .           
        .           #ifdef __linux__
       14 ( 0.00%)      std::string progpath(PATH_MAX, '\0');
  109,708 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(unsigned long, char, std::allocator<char> const&) (2x)
       32 ( 0.00%)      int len = readlink("/proc/self/exe", &progpath[0], progpath.size() - 1);
    1,177 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       44 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator[](unsigned long) (2x)
       14 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const (2x)
       12 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/io/../sysdeps/unix/sysv/linux/readlink.c:readlink (2x)
        4 ( 0.00%)      if (len != -1) {
       12 ( 0.00%)          progpath.resize(len);
      202 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::resize(unsigned long) (2x)
        .           
        .                   // Find the last '/' and remove everything after it
       12 ( 0.00%)          int lastSlash = progpath.find_last_of("/");
    3,048 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::find_last_of(char const*, unsigned long) const (2x)
        8 ( 0.00%)          if (lastSlash != std::string::npos) {
       14 ( 0.00%)              progpath.erase(lastSlash);
      202 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::erase(unsigned long, unsigned long) (2x)
        .                   }
        .           
       12 ( 0.00%)          return progpath;
      720 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (2x)
        .               }
        .           #endif
        .           
        .               return ".";
        .           #endif
       16 ( 0.00%)  }
      200 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (2x)
        .           
       50 ( 0.00%)  std::string Context::GetAppDirectoryPath(std::string appName) {
        .           #if defined(__ANDROID__)
        .               const char* externaldir = SDL_AndroidGetExternalStoragePath();
        .               if (externaldir != NULL) {
        .                   return externaldir;
        .               }
        .           #endif
        .           
        .           #ifdef __IOS__
        .               const char* home = getenv("HOME");
        .               return std::string(home) + "/Documents";
        .           #endif
        .           
        .           #if defined(__linux__) || defined(__APPLE__)
       44 ( 0.00%)      char* fpath = std::getenv("SHIP_HOME");
   10,190 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/getenv.c:getenv (10x)
    1,242 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       20 ( 0.00%)      if (fpath != NULL) {
        .                   return std::string(fpath);
        .               }
        .           #endif
        .           
        .           #ifdef NON_PORTABLE
        .               if (appName.empty()) {
        .                   appName = GetInstance()->mShortName;
        .               }
-- line 381 ----------------------------------------
-- line 382 ----------------------------------------
        .               char* prefpath = SDL_GetPrefPath(NULL, appName.c_str());
        .               if (prefpath != NULL) {
        .                   std::string ret(prefpath);
        .                   SDL_free(prefpath);
        .                   return ret;
        .               }
        .           #endif
        .           
       50 ( 0.00%)      return ".";
    3,110 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::allocator<char> >(char const*, std::allocator<char> const&) (10x)
       30 ( 0.00%)  }
        .           
       12 ( 0.00%)  std::string Context::GetPathRelativeToAppBundle(const std::string path) {
       46 ( 0.00%)      return GetAppBundlePath() + "/" + path;
  115,471 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetAppBundlePath[abi:cxx11]() (2x)
    1,484 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (2x)
    1,434 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, char const*) (2x)
      400 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (4x)
        8 ( 0.00%)  }
        .           
       56 ( 0.00%)  std::string Context::GetPathRelativeToAppDirectory(const std::string path, std::string appName) {
      264 ( 0.00%)      return GetAppDirectoryPath(appName) + "/" + path;
   12,078 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetAppDirectoryPath(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (8x)
    7,678 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (8x)
    6,040 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&, char const*) (8x)
    2,672 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (8x)
    2,400 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (24x)
       32 ( 0.00%)  }
        .           
        7 ( 0.00%)  std::string Context::LocateFileAcrossAppDirs(const std::string path, std::string appName) {
        3 ( 0.00%)      std::string fpath;
      158 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string() (1x)
        .           
        .               // app configuration dir
       30 ( 0.00%)      fpath = GetPathRelativeToAppDirectory(path, appName);
    4,053 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetPathRelativeToAppDirectory(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (1x)
      889 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (2x)
      463 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (3x)
      464 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
       15 ( 0.00%)      if (std::filesystem::exists(fpath)) {
    1,546 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::path<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::filesystem::__cxx11::path>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::filesystem::__cxx11::path::format) (1x)
      675 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (1x)
      141 ( 0.00%)  => /usr/include/c++/14/bits/fs_ops.h:std::filesystem::exists(std::filesystem::__cxx11::path const&) (1x)
        .                   return fpath;
        .               }
        .               // app install dir
       21 ( 0.00%)      fpath = GetPathRelativeToAppBundle(path);
  108,186 ( 0.00%)  => libultraship/src/Context.cpp:Ship::Context::GetPathRelativeToAppBundle(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (1x)
      555 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (1x)
      526 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (2x)
      436 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
       15 ( 0.00%)      if (std::filesystem::exists(fpath)) {
    2,585 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::path<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::filesystem::__cxx11::path>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::filesystem::__cxx11::path::format) (1x)
      783 ( 0.00%)  => /usr/include/c++/14/bits/fs_path.h:std::filesystem::__cxx11::path::~path() (1x)
      141 ( 0.00%)  => /usr/include/c++/14/bits/fs_ops.h:std::filesystem::exists(std::filesystem::__cxx11::path const&) (1x)
        .                   return fpath;
        .               }
        .               // current dir
       14 ( 0.00%)      return "./" + std::string(path);
      555 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (1x)
    1,501 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (1x)
      100 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
        8 ( 0.00%)  }
      375 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
        .           
       10 ( 0.00%)  } // namespace Ship
       95 ( 0.00%)  => libultraship/src/Context.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/resource/ResourceManager.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 6 ----------------------------------------
        .           #include <thread>
        .           #include "utils/StringHelper.h"
        .           #include "utils/glob.h"
        .           #include "public/bridge/consolevariablebridge.h"
        .           #include "Context.h"
        .           
        .           namespace Ship {
        .           
       25 ( 0.00%)  ResourceManager::ResourceManager() {
      120 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > > >::unordered_map() (1x)
       34 ( 0.00%)  => /usr/include/c++/14/bits/std_mutex.h:std::mutex::mutex() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<BS::thread_pool>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager>::shared_ptr() (1x)
       31 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceLoader>::shared_ptr() (1x)
        3 ( 0.00%)  }
        .           
        .           void ResourceManager::Init(const std::vector<std::string>& otrFiles, const std::unordered_set<uint32_t>& validHashes,
        8 ( 0.00%)                             int32_t reservedThreadCount) {
       12 ( 0.00%)      mResourceLoader = std::make_shared<ResourceLoader>();
    5,573 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceLoader> std::make_shared<Ship::ResourceLoader>() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceLoader>::operator=(std::shared_ptr<Ship::ResourceLoader>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceLoader>::~shared_ptr() (1x)
       12 ( 0.00%)      mArchiveManager = std::make_shared<ArchiveManager>();
      921 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager> std::make_shared<Ship::ArchiveManager>() (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager>::operator=(std::shared_ptr<Ship::ArchiveManager>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager>::~shared_ptr() (1x)
       17 ( 0.00%)      GetArchiveManager()->Init(otrFiles, validHashes);
326,447,102 ( 0.27%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::Init(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> > const&) (1x)
       82 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager>::~shared_ptr() (1x)
       91 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetArchiveManager() (1x)
       25 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (1x)
        .           
        .               // the extra `- 1` is because we reserve an extra thread for spdlog
       20 ( 0.00%)      size_t threadCount = std::max(1, (int32_t)(std::thread::hardware_concurrency() - reservedThreadCount - 1));
    1,302 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      520 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/thread.cc:std::thread::hardware_concurrency() (1x)
       14 ( 0.00%)  => /usr/include/c++/14/bits/stl_algobase.h:int const& std::max<int>(int const&, int const&) (1x)
       14 ( 0.00%)      mThreadPool = std::make_shared<BS::thread_pool>(threadCount);
   64,406 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<BS::thread_pool> std::make_shared<BS::thread_pool, unsigned long&>(unsigned long&) (1x)
      205 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<BS::thread_pool>::operator=(std::shared_ptr<BS::thread_pool>&&) (1x)
       32 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<BS::thread_pool>::~shared_ptr() (1x)
        .           
        6 ( 0.00%)      if (!DidLoadSuccessfully()) {
      176 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::DidLoadSuccessfully() (1x)
        .                   // Nothing ever unpauses the thread pool since nothing will ever try to load the archive again.
        .                   mThreadPool->pause();
        .               }
        4 ( 0.00%)  }
        .           
        .           ResourceManager::~ResourceManager() {
        .               SPDLOG_INFO("destruct ResourceManager");
        .           }
        .           
        8 ( 0.00%)  bool ResourceManager::DidLoadSuccessfully() {
       36 ( 0.00%)      return mArchiveManager != nullptr && mArchiveManager->IsArchiveLoaded();
      214 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::IsArchiveLoaded() (2x)
       50 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (2x)
       40 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::ArchiveManager>(std::shared_ptr<Ship::ArchiveManager> const&, decltype(nullptr)) (2x)
        4 ( 0.00%)  }
        .           
        .           std::shared_ptr<File> ResourceManager::LoadFileProcess(const std::string& filePath,
    7,824 ( 0.00%)                                                         std::shared_ptr<ResourceInitData> initData) {
   12,388 ( 0.00%)      auto file = mArchiveManager->LoadFile(filePath, initData);
59,663,842 ( 0.05%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::LoadFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::shared_ptr<Ship::ResourceInitData>) (652x)
   31,296 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) (652x)
   20,864 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (652x)
   16,300 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ArchiveManager, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (652x)
    4,564 ( 0.00%)      if (file != nullptr) {
   13,040 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::File>(std::shared_ptr<Ship::File> const&, decltype(nullptr)) (652x)
   22,168 ( 0.00%)          SPDLOG_TRACE("Loaded File {} on ResourceManager", file->InitData->Path);
4,455,722 ( 0.00%)  => /usr/include/spdlog/logger.h:void spdlog::logger::log<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>(spdlog::source_loc, spdlog::level::level_enum, fmt::v10::basic_format_string<char, fmt::v10::type_identity<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&>::type>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) (652x)
   18,256 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::default_logger_raw() (652x)
   16,300 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::File, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (652x)
   16,300 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceInitData, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (652x)
   11,736 ( 0.00%)  => /usr/include/spdlog/common.h:spdlog::source_loc::source_loc(char const*, int, char const*) (652x)
        .               } else {
        .                   SPDLOG_TRACE("Could not load File {} in ResourceManager", filePath);
        .               }
      652 ( 0.00%)      return file;
    5,868 ( 0.00%)  }
        .           
        .           std::shared_ptr<IResource> ResourceManager::LoadResourceProcess(const std::string& filePath, bool loadExact,
1,225,014 ( 0.00%)                                                                  std::shared_ptr<ResourceInitData> initData) {
        .               // Check for and remove the OTR signature
  875,010 ( 0.00%)      if (OtrSignatureCheck(filePath.c_str())) {
2,925,135 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::OtrSignatureCheck(char const*) (47,964x)
  767,424 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (47,964x)
  237,222 ( 0.00%)          const auto newFilePath = filePath.substr(7);
25,285,327 ( 0.02%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::substr(unsigned long, unsigned long) const (39,537x)
  672,129 ( 0.00%)          return LoadResourceProcess(newFilePath, false, initData);
163,318,886 ( 0.14%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)'2 (39,537x)
1,897,776 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) (39,537x)
1,265,184 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (39,537x)
  118,611 ( 0.00%)      }
10,398,231 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (39,537x)
        .           
        .               // Attempt to load the alternate version of the asset, if we fail then we continue trying to load the standard
        .               // asset.
  527,604 ( 0.00%)      if (!loadExact && mAltAssetsEnabled && !filePath.starts_with(IResource::gAltAssetPrefix)) {
        .                   const auto altPath = IResource::gAltAssetPrefix + filePath;
        .                   auto altResource = LoadResourceProcess(altPath, loadExact, initData);
        .           
        .                   if (altResource != nullptr) {
        .                       return altResource;
        .                   }
        .               }
        .           
        .               // While waiting in the queue, another thread could have loaded the resource.
        .               // In a last attempt to avoid doing work that will be discarded, let's check if the cached version exists.
  287,784 ( 0.00%)      auto cacheLine = CheckCache(filePath, loadExact);
13,848,007 ( 0.01%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (8,427x)
  671,496 ( 0.00%)      auto cachedResource = GetCachedResource(cacheLine);
3,675,542 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~variant() (8,427x)
5,326,717 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::variant(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (8,427x)
3,452,556 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >) (8,427x)
  335,748 ( 0.00%)      if (cachedResource != nullptr) {
  168,540 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, decltype(nullptr)) (8,427x)
  283,872 ( 0.00%)          return cachedResource;
  574,364 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource>&&) (7,868x)
        .               }
        .           
        .               // Check for resource load errors which can indicate an alternate asset.
        .               // If we are attempting to load an alternate asset, we can return null
    7,172 ( 0.00%)      if (!loadExact && mAltAssetsEnabled && filePath.starts_with(IResource::gAltAssetPrefix)) {
        .                   if (std::holds_alternative<ResourceLoadError>(cacheLine)) {
        .                       try {
        .                           // If we have attempted to cache an alternate asset, but failed, we return nullptr and rely on the
        .                           // calling function to return a regular asset. If we have NOT attempted load already, attempt the load.
        .                           auto loadError = std::get<ResourceLoadError>(cacheLine);
        .                           if (loadError != ResourceLoadError::NotCached) {
        .                               return nullptr;
        .                           }
        .                       } catch (std::bad_variant_access const& e) {
        .                           // Ignore the exception. This should never happen. The last check should've returned the resource.
        .                       }
        .                   }
        .               }
        .           
        .               // Get the file from the OTR
    9,128 ( 0.00%)      auto file = LoadFileProcess(filePath, initData);
54,381,222 ( 0.05%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadFileProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::shared_ptr<Ship::ResourceInitData>) (559x)
   26,832 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) (559x)
   17,888 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (559x)
    3,912 ( 0.00%)      if (file == nullptr) {
   11,180 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::File>(std::shared_ptr<Ship::File> const&, decltype(nullptr)) (559x)
        .                   SPDLOG_TRACE("Failed to load resource file at path {}", filePath);
        .               }
        .           
        .               // Transform the raw data into a resource
   16,300 ( 0.00%)      auto resource = GetResourceLoader()->LoadResource(file);
23,241,277 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceLoader.cpp:Ship::ResourceLoader::LoadResource(std::shared_ptr<Ship::File>) (559x)
   45,838 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::File>::~shared_ptr() (559x)
   50,869 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetResourceLoader() (559x)
   45,838 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceLoader>::~shared_ptr() (559x)
   43,043 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::File>::shared_ptr(std::shared_ptr<Ship::File> const&) (559x)
   13,975 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::ResourceLoader, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (559x)
        .           
        .               // Another thread could have loaded the resource while we were processing, so we want to check before setting to
        .               // the cache.
    9,128 ( 0.00%)      cachedResource = GetCachedResource(filePath, true);
  818,251 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (559x)
   17,888 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (559x)
  114,595 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::operator=(std::shared_ptr<Ship::IResource>&&) (559x)
        .               {
    3,912 ( 0.00%)          const std::lock_guard<std::mutex> lock(mMutex);
   47,515 ( 0.00%)  => /usr/include/c++/14/bits/std_mutex.h:std::lock_guard<std::mutex>::lock_guard(std::mutex&) (559x)
        .           
    4,564 ( 0.00%)          if (cachedResource != nullptr) {
   11,180 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, decltype(nullptr)) (559x)
        .                       // If another thread has already loaded this resource, discard the work we already did and return from
        .                       // cache.
        .                       resource = cachedResource;
        .                   }
        .           
        .                   // Set the cache to the loaded resource
    4,564 ( 0.00%)          if (resource != nullptr) {
   11,180 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, decltype(nullptr)) (559x)
    7,172 ( 0.00%)              mResourceCache[filePath] = resource;
1,152,434 ( 0.00%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > > >::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (559x)
  347,698 ( 0.00%)  => /usr/include/c++/14/variant:std::enable_if<((__exactly_once<std::_Nth_type<__accepted_index<std::shared_ptr<Ship::IResource>&>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::type>)&&(is_constructible_v<std::_Nth_type<__accepted_index<std::shared_ptr<Ship::IResource>&>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::type, std::shared_ptr<Ship::IResource>&>))&&(is_assignable_v<std::_Nth_type<__accepted_index<std::shared_ptr<Ship::IResource>&>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::type&, std::shared_ptr<Ship::IResource>&>), std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&>::type std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::operator=<std::shared_ptr<Ship::IResource>&>(std::shared_ptr<Ship::IResource>&) (559x)
        .                   } else {
        .                       mResourceCache[filePath] = ResourceLoadError::NotFound;
        .                   }
    1,956 ( 0.00%)      }
   41,366 ( 0.00%)  => /usr/include/c++/14/bits/std_mutex.h:std::lock_guard<std::mutex>::~lock_guard() (559x)
        .           
    4,564 ( 0.00%)      if (resource != nullptr) {
   11,180 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, decltype(nullptr)) (559x)
   18,908 ( 0.00%)          SPDLOG_TRACE("Loaded Resource {} on ResourceManager", filePath);
4,030,877 ( 0.00%)  => /usr/include/spdlog/logger.h:void spdlog::logger::log<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(spdlog::source_loc, spdlog::level::level_enum, fmt::v10::basic_format_string<char, fmt::v10::type_identity<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>::type>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (559x)
   15,652 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::default_logger_raw() (559x)
   10,062 ( 0.00%)  => /usr/include/spdlog/common.h:spdlog::source_loc::source_loc(char const*, int, char const*) (559x)
        .               } else {
        .                   SPDLOG_TRACE("Resource load FAILED {} on ResourceManager", filePath);
        .               }
        .           
    3,260 ( 0.00%)      return resource;
   40,807 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource>&&) (559x)
1,166,706 ( 0.00%)  }
3,675,542 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~variant() (8,427x)
1,414,309 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::File>::~shared_ptr() (559x)
  287,552 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (8,986x)
        .           
        .           std::shared_future<std::shared_ptr<IResource>>
        .           ResourceManager::LoadResourceAsync(const std::string& filePath, bool loadExact, BS::priority_t priority,
2,617,072 ( 0.00%)                                     std::shared_ptr<ResourceInitData> initData) {
        .               // Check for and remove the OTR signature
1,635,670 ( 0.00%)      if (OtrSignatureCheck(filePath.c_str())) {
5,985,188 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::OtrSignatureCheck(char const*) (98,164x)
1,570,624 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::c_str() const (98,164x)
  392,418 ( 0.00%)          auto newFilePath = filePath.substr(7);
41,820,303 ( 0.03%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::substr(unsigned long, unsigned long) const (65,403x)
1,242,657 ( 0.00%)          return LoadResourceAsync(newFilePath, loadExact, priority);
506,983,909 ( 0.42%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>)'2 (65,403x)
2,746,926 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(decltype(nullptr)) (65,403x)
2,092,896 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (65,403x)
  196,209 ( 0.00%)      }
17,201,197 ( 0.01%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (65,403x)
        .           
        .               // Check the cache before queueing the job.
  687,148 ( 0.00%)      auto cacheCheck = GetCachedResource(filePath, loadExact);
82,738,213 ( 0.07%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (32,761x)
  490,820 ( 0.00%)      if (cacheCheck) {
  294,849 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::operator bool() const (32,761x)
  292,893 ( 0.00%)          auto promise = std::make_shared<std::promise<std::shared_ptr<IResource>>>();
41,673,830 ( 0.03%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::promise<std::shared_ptr<Ship::IResource> > > std::make_shared<std::promise<std::shared_ptr<Ship::IResource> >>() (32,595x)
  781,048 ( 0.00%)          promise->set_value(cacheCheck);
67,862,790 ( 0.06%)  => /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::set_value(std::shared_ptr<Ship::IResource> const&) (32,595x)
  814,875 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::promise<std::shared_ptr<Ship::IResource> >, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (32,595x)
1,562,096 ( 0.00%)          return promise->get_future().share();
6,193,050 ( 0.01%)  => /usr/include/c++/14/future:std::promise<std::shared_ptr<Ship::IResource> >::get_future() (32,595x)
4,595,895 ( 0.00%)  => /usr/include/c++/14/future:std::future<std::shared_ptr<Ship::IResource> >::share() (32,595x)
1,694,940 ( 0.00%)  => /usr/include/c++/14/future:std::future<std::shared_ptr<Ship::IResource> >::~future() (32,595x)
  814,875 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<std::promise<std::shared_ptr<Ship::IResource> >, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (32,595x)
  390,524 ( 0.00%)      }
38,592,480 ( 0.03%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<std::promise<std::shared_ptr<Ship::IResource> > >::~shared_ptr() (32,595x)
        .           
    2,665 ( 0.00%)      const auto newFilePath = std::string(filePath);
  101,888 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (166x)
        .           
    7,995 ( 0.00%)      return mThreadPool->submit_task(
    8,632 ( 0.00%)  => /usr/include/c++/14/future:std::future<std::shared_ptr<Ship::IResource> >::~future() (166x)
  864,970 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/threadpool-src/include/BS_thread_pool.hpp:std::future<std::shared_ptr<Ship::IResource> > BS::thread_pool::submit_task<std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>, std::shared_ptr<Ship::IResource> >(std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>&&, short) (166x)
    4,150 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<BS::thread_pool, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (166x)
   12,792 ( 0.00%)          std::bind(&ResourceManager::LoadResourceProcess, this, newFilePath, loadExact, initData), priority);
  202,887 ( 0.00%)  => /usr/include/c++/14/functional:std::_Bind_helper<std::__or_<std::is_integral<std::decay<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>::type>, std::is_enum<std::decay<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>::type> >::value, std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>), Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool&, std::shared_ptr<Ship::ResourceInitData>&>::type std::bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>), Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool&, std::shared_ptr<Ship::ResourceInitData>&>(std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*&&)(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>), Ship::ResourceManager*&&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool&, std::shared_ptr<Ship::ResourceInitData>&) (166x)
   36,022 ( 0.00%)  => /usr/include/c++/14/functional:std::_Bind<std::shared_ptr<Ship::IResource> (Ship::ResourceManager::*(Ship::ResourceManager*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, std::shared_ptr<Ship::ResourceInitData>))(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)>::~_Bind() (166x)
   19,754 ( 0.00%)  => /usr/include/c++/14/future:std::shared_future<std::shared_ptr<Ship::IResource> >::shared_future(std::future<std::shared_ptr<Ship::IResource> >&&) (166x)
1,768,194 ( 0.00%)  }
   43,658 ( 0.00%)  => /usr/include/c++/14/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (166x)
2,678,102 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (32,761x)
        .           
        .           std::shared_ptr<IResource> ResourceManager::LoadResource(const std::string& filePath, bool loadExact,
1,177,968 ( 0.00%)                                                           std::shared_ptr<ResourceInitData> initData) {
2,748,592 ( 0.00%)      auto resource = LoadResourceAsync(filePath, loadExact, BS::pr::highest, initData).get();
834,413,589 ( 0.69%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>) (98,164x)
82,201,728 ( 0.07%)  => /usr/include/c++/14/future:std::shared_future<std::shared_ptr<Ship::IResource> >::~shared_future() (98,164x)
27,665,821 ( 0.02%)  => /usr/include/c++/14/future:std::shared_future<std::shared_ptr<Ship::IResource> >::get() const (98,164x)
7,558,628 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource> const&) (98,164x)
4,711,872 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::shared_ptr(std::shared_ptr<Ship::ResourceInitData> const&) (98,164x)
3,141,248 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceInitData>::~shared_ptr() (98,164x)
  588,984 ( 0.00%)      if (resource == nullptr) {
1,963,280 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:bool std::operator==<Ship::IResource>(std::shared_ptr<Ship::IResource> const&, decltype(nullptr)) (98,164x)
        .                   SPDLOG_ERROR("Failed to load resource file at path {}", filePath);
        .               }
   98,164 ( 0.00%)      return resource;
  687,148 ( 0.00%)  }
        .           
        .           std::variant<ResourceManager::ResourceLoadError, std::shared_ptr<IResource>>
1,614,580 ( 0.00%)  ResourceManager::CheckCache(const std::string& filePath, bool loadExact) {
1,611,972 ( 0.00%)      if (!loadExact && mAltAssetsEnabled && !filePath.starts_with(IResource::gAltAssetPrefix)) {
        .                   const auto altPath = IResource::gAltAssetPrefix + filePath;
        .                   auto altCacheResult = CheckCache(altPath, loadExact);
        .           
        .                   // If the type held at this cache index is a resource, then we return it.
        .                   // Else we attempt to load standard definition assets.
        .                   if (std::holds_alternative<std::shared_ptr<IResource>>(altCacheResult)) {
        .                       return altCacheResult;
        .                   }
        .               }
        .           
  880,680 ( 0.00%)      const std::lock_guard<std::mutex> lock(mMutex);
12,476,300 ( 0.01%)  => /usr/include/c++/14/bits/std_mutex.h:std::lock_guard<std::mutex>::lock_guard(std::mutex&) (146,780x)
        .           
  880,680 ( 0.00%)      auto resourceCacheFind = mResourceCache.find(filePath);
98,066,900 ( 0.08%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > > >::find(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (146,780x)
1,614,580 ( 0.00%)      if (resourceCacheFind == mResourceCache.end()) {
6,311,540 ( 0.01%)  => /usr/include/c++/14/bits/unordered_map.h:std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > > > >::end() (146,780x)
1,761,360 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::operator==(std::__detail::_Node_iterator_base<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true> const&, std::__detail::_Node_iterator_base<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, true> const&) (146,780x)
   12,859 ( 0.00%)          return ResourceLoadError::NotCached;
  345,356 ( 0.00%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::variant<Ship::ResourceManager::ResourceLoadError, void, void, Ship::ResourceManager::ResourceLoadError, void>(Ship::ResourceManager::ResourceLoadError&&) (1,837x)
        .               }
        .           
1,159,544 ( 0.00%)      return resourceCacheFind->second;
92,618,577 ( 0.08%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::variant(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (144,943x)
4,203,347 ( 0.00%)  => /usr/include/c++/14/bits/hashtable_policy.h:std::__detail::_Node_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > >, false, true>::operator->() const (144,943x)
1,467,800 ( 0.00%)  }
10,861,720 ( 0.01%)  => /usr/include/c++/14/bits/std_mutex.h:std::lock_guard<std::mutex>::~lock_guard() (146,780x)
        .           
  889,344 ( 0.00%)  std::shared_ptr<IResource> ResourceManager::GetCachedResource(const std::string& filePath, bool loadExact) {
        .               // Gets the cached resource based on filePath.
1,679,872 ( 0.00%)      return GetCachedResource(CheckCache(filePath, loadExact));
159,064,873 ( 0.13%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (98,816x)
43,572,392 ( 0.04%)  => /usr/include/c++/14/variant:std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >::~variant() (98,816x)
42,128,270 ( 0.03%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >) (98,816x)
  395,264 ( 0.00%)  }
        .           
        .           std::shared_ptr<IResource>
1,174,240 ( 0.00%)  ResourceManager::GetCachedResource(std::variant<ResourceLoadError, std::shared_ptr<IResource>> cacheLine) {
        .               // Gets the cached resource based on a cache line std::variant from the cache map.
  733,900 ( 0.00%)      if (std::holds_alternative<std::shared_ptr<IResource>>(cacheLine)) {
8,513,240 ( 0.01%)  => /usr/include/c++/14/variant:bool std::holds_alternative<std::shared_ptr<Ship::IResource>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> > const&) (146,780x)
        .                   try {
1,159,544 ( 0.00%)              auto resource = std::get<std::shared_ptr<IResource>>(cacheLine);
11,160,611 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource> const&) (144,943x)
10,725,782 ( 0.01%)  => /usr/include/c++/14/variant:std::shared_ptr<Ship::IResource>& std::get<std::shared_ptr<Ship::IResource>, Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >&) (144,943x)
        .           
1,014,601 ( 0.00%)              if (resource.use_count() <= 0) {
4,928,062 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr<Ship::IResource, (__gnu_cxx::_Lock_policy)2>::use_count() const (144,943x)
        .                           return nullptr;
        .                       }
        .           
1,014,601 ( 0.00%)              if (resource->IsDirty()) {
3,623,575 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::__shared_ptr_access<Ship::IResource, (__gnu_cxx::_Lock_policy)2, false, false>::operator->() const (144,943x)
1,014,601 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.cpp:Ship::IResource::IsDirty() (144,943x)
        .                           return nullptr;
        .                       }
        .           
  724,715 ( 0.00%)              return resource;
10,580,839 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(std::shared_ptr<Ship::IResource>&&) (144,943x)
  434,829 ( 0.00%)          } catch (std::bad_variant_access const& e) {
4,638,176 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::~shared_ptr() (144,943x)
        .                       // Ignore the exception
        .                   }
        .               }
        .           
    9,185 ( 0.00%)      return nullptr;
   77,154 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::IResource>::shared_ptr(decltype(nullptr)) (1,837x)
1,025,623 ( 0.00%)  }
        .           
        .           std::shared_ptr<std::vector<std::shared_future<std::shared_ptr<IResource>>>>
        .           ResourceManager::LoadDirectoryAsync(const std::string& searchMask, BS::priority_t priority) {
        .               auto loadedList = std::make_shared<std::vector<std::shared_future<std::shared_ptr<IResource>>>>();
        .               auto fileList = GetArchiveManager()->ListFiles(searchMask);
        .               loadedList->reserve(fileList->size());
        .           
        .               for (size_t i = 0; i < fileList->size(); i++) {
-- line 224 ----------------------------------------
-- line 260 ----------------------------------------
        .           void ResourceManager::UnloadDirectory(const std::string& searchMask) {
        .               auto list = GetArchiveManager()->ListFiles(searchMask);
        .           
        .               for (const auto& key : *list.get()) {
        .                   UnloadResource(key);
        .               }
        .           }
        .           
  669,720 ( 0.00%)  std::shared_ptr<ArchiveManager> ResourceManager::GetArchiveManager() {
  803,664 ( 0.00%)      return mArchiveManager;
10,313,688 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ArchiveManager>::shared_ptr(std::shared_ptr<Ship::ArchiveManager> const&) (133,944x)
  401,832 ( 0.00%)  }
        .           
    3,275 ( 0.00%)  std::shared_ptr<ResourceLoader> ResourceManager::GetResourceLoader() {
    3,930 ( 0.00%)      return mResourceLoader;
   50,435 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr.h:std::shared_ptr<Ship::ResourceLoader>::shared_ptr(std::shared_ptr<Ship::ResourceLoader> const&) (655x)
    1,965 ( 0.00%)  }
        .           
        .           size_t ResourceManager::UnloadResource(const std::string& filePath) {
        .               // Store a shared pointer here so that erase doesn't destruct the resource.
        .               // The resource will attempt to load other resources on the destructor, and this will fail because we already hold
        .               // the mutex.
        .               std::variant<ResourceLoadError, std::shared_ptr<IResource>> value = nullptr;
        .               size_t ret = 0;
        .               {
-- line 282 ----------------------------------------
-- line 283 ----------------------------------------
        .                   const std::lock_guard<std::mutex> lock(mMutex);
        .                   value = mResourceCache[filePath];
        .                   ret = mResourceCache.erase(filePath);
        .               }
        .           
        .               return ret;
        .           }
        .           
1,574,730 ( 0.00%)  bool ResourceManager::OtrSignatureCheck(const char* fileName) {
        .               static const char* sOtrSignature = "__OTR__";
4,094,298 ( 0.00%)      return strncmp(fileName, sOtrSignature, strlen(sOtrSignature)) == 0;
8,644,098 ( 0.01%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (314,946x)
4,409,244 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (314,946x)
  629,892 ( 0.00%)  }
        .           
        .           bool ResourceManager::IsAltAssetsEnabled() {
        .               return mAltAssetsEnabled;
        .           }
        .           
        .           void ResourceManager::SetAltAssetsEnabled(bool isEnabled) {
        .               mAltAssetsEnabled = isEnabled;
        .           }
        .           
       10 ( 0.00%)  } // namespace Ship
        9 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/any
--------------------------------------------------------------------------------
Ir                  

-- line 78 ----------------------------------------
         .              *
         .              *  @since C++17
         .              */
         .             class any
         .             {
         .               // Holds either pointer to a heap object or the contained object itself.
         .               union _Storage
         .               {
       224 ( 0.00%)        constexpr _Storage() : _M_ptr{nullptr} {}
         .           
         .                 // Prevent trivial copies of this type, buffer might hold a non-POD.
         .                 _Storage(const _Storage&) = delete;
         .                 _Storage& operator=(const _Storage&) = delete;
         .           
         .                 void* _M_ptr;
         .                 aligned_storage<sizeof(_M_ptr), alignof(void*)>::type _M_buffer;
         .               };
-- line 94 ----------------------------------------
-- line 149 ----------------------------------------
         .           
         .             public:
         .               // construct/destruct
         .           
         .               /// Default constructor, creates an empty object.
         .               constexpr any() noexcept : _M_manager(nullptr) { }
         .           
         .               /// Copy constructor, copies the state of @p __other
        70 ( 0.00%)      any(const any& __other)
        56 ( 0.00%)      {
       112 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Storage::_Storage() (14x)
        84 ( 0.00%)        if (!__other.has_value())
       126 ( 0.00%)  => /usr/include/c++/14/any:std::any::has_value() const (14x)
         .           	_M_manager = nullptr;
         .                 else
         .           	{
         .           	  _Arg __arg;
        28 ( 0.00%)  	  __arg._M_any = this;
        98 ( 0.00%)  	  __other._M_manager(_Op_clone, &__other, &__arg);
       336 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<signed char>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (8x)
       252 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<unsigned int>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (6x)
         .           	}
        42 ( 0.00%)      }
         .           
         .               /**
         .                * @brief Move constructor, transfer the state from @p __other
         .                *
         .                * @post @c !__other.has_value() (this postcondition is a GNU extension)
         .                */
         .               any(any&& __other) noexcept
         .               {
-- line 175 ----------------------------------------
-- line 183 ----------------------------------------
         .           	}
         .               }
         .           
         .               /// Construct with a copy of @p __value as the contained object.
         .               template <typename _Tp, typename _VTp = _Decay_if_not_any<_Tp>,
         .           	      typename _Mgr = _Manager<_VTp>,
         .           	      enable_if_t<is_copy_constructible_v<_VTp>
         .           			  && !__is_in_place_type_v<_VTp>, bool> = true>
        70 ( 0.00%)        any(_Tp&& __value)
        84 ( 0.00%)        : _M_manager(&_Mgr::_S_manage)
        64 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Storage::_Storage() (8x)
         .                 {
       126 ( 0.00%)  	_Mgr::_S_create(_M_storage, std::forward<_Tp>(__value));
       280 ( 0.00%)  => /usr/include/c++/14/any:void std::any::_Manager_internal<signed char>::_S_create<signed char const&>(std::any::_Storage&, signed char const&) (8x)
        48 ( 0.00%)  => /usr/include/c++/14/bits/move.h:signed char const& std::forward<signed char const&>(std::remove_reference<signed char const&>::type&) (8x)
        42 ( 0.00%)        }
         .           
         .               /// Construct with an object created from @p __args as the contained object.
         .               template <typename _Tp, typename... _Args, typename _VTp = decay_t<_Tp>,
         .           	      typename _Mgr = _Manager<_VTp>,
         .           	      __any_constructible_t<_VTp, _Args&&...> = false>
         .                 explicit
         .                 any(in_place_type_t<_Tp>, _Args&&... __args)
         .                 : _M_manager(&_Mgr::_S_manage)
-- line 203 ----------------------------------------
-- line 214 ----------------------------------------
         .                 explicit
         .                 any(in_place_type_t<_Tp>, initializer_list<_Up> __il, _Args&&... __args)
         .                 : _M_manager(&_Mgr::_S_manage)
         .                 {
         .           	_Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
         .                 }
         .           
         .               /// Destructor, calls @c reset()
       280 ( 0.00%)      ~any() { reset(); }
     1,428 ( 0.00%)  => /usr/include/c++/14/any:std::any::reset() (28x)
         .           
         .               // assignments
         .           
         .               /// Copy the state of another object.
         .               any&
         .               operator=(const any& __rhs)
         .               {
         .                 *this = any(__rhs);
-- line 230 ----------------------------------------
-- line 279 ----------------------------------------
         .           	using _VTp = decay_t<_Tp>;
         .           	__do_emplace<_VTp, _Up>(__il, std::forward<_Args>(__args)...);
         .           	return *any::_Manager<_VTp>::_S_access(_M_storage);
         .                 }
         .           
         .               // modifiers
         .           
         .               /// If not empty, destroy the contained object.
       112 ( 0.00%)      void reset() noexcept
         .               {
       140 ( 0.00%)        if (has_value())
       252 ( 0.00%)  => /usr/include/c++/14/any:std::any::has_value() const (28x)
         .                 {
       196 ( 0.00%)  	_M_manager(_Op_destroy, this, nullptr);
       336 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<signed char>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (16x)
       252 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<unsigned int>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (12x)
        56 ( 0.00%)  	_M_manager = nullptr;
         .                 }
        84 ( 0.00%)      }
         .           
         .               /// Exchange state with another object.
         .               void swap(any& __rhs) noexcept
         .               {
         .                 if (!has_value() && !__rhs.has_value())
         .           	return;
         .           
         .                 if (has_value() && __rhs.has_value())
-- line 302 ----------------------------------------
-- line 321 ----------------------------------------
         .           	  __arg._M_any = __empty;
         .           	  __full->_M_manager(_Op_xfer, __full, &__arg);
         .           	}
         .               }
         .           
         .               // observers
         .           
         .               /// Reports whether there is a contained object or not.
       378 ( 0.00%)      bool has_value() const noexcept { return _M_manager != nullptr; }
         .           
         .           #if __cpp_rtti
         .               /// The @c typeid of the contained object, or @c typeid(void) if empty.
         .               const type_info& type() const noexcept
         .               {
         .                 if (!has_value())
         .           	return typeid(void);
         .                 _Arg __arg;
-- line 337 ----------------------------------------
-- line 370 ----------------------------------------
         .               template<typename _Tp>
         .                 struct _Manager_internal
         .                 {
         .           	static void
         .           	_S_manage(_Op __which, const any* __anyp, _Arg* __arg);
         .           
         .           	template<typename _Up>
         .           	  static void
        84 ( 0.00%)  	  _S_create(_Storage& __storage, _Up&& __value)
         .           	  {
        28 ( 0.00%)  	    void* __addr = &__storage._M_buffer;
       140 ( 0.00%)  	    ::new (__addr) _Tp(std::forward<_Up>(__value));
        56 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (8x)
        48 ( 0.00%)  => /usr/include/c++/14/bits/move.h:signed char const& std::forward<signed char const&>(std::remove_reference<signed char const&>::type&) (8x)
        56 ( 0.00%)  	  }
         .           
         .           	template<typename... _Args>
         .           	  static void
         .           	  _S_create(_Storage& __storage, _Args&&... __args)
         .           	  {
         .           	    void* __addr = &__storage._M_buffer;
         .           	    ::new (__addr) _Tp(std::forward<_Args>(__args)...);
         .           	  }
         .           
         .           	static _Tp*
17,215,218 ( 0.01%)  	_S_access(const _Storage& __storage)
         .           	{
         .           	  // The contained object is in __storage._M_buffer
11,476,812 ( 0.01%)  	  const void* __addr = &__storage._M_buffer;
 5,738,406 ( 0.00%)  	  return static_cast<_Tp*>(const_cast<void*>(__addr));
11,476,812 ( 0.01%)  	}
         .                 };
         .           
         .               // Manage external contained object.
         .               template<typename _Tp>
         .                 struct _Manager_external
         .                 {
         .           	static void
         .           	_S_manage(_Op __which, const any* __anyp, _Arg* __arg);
-- line 406 ----------------------------------------
-- line 454 ----------------------------------------
         .              * @tparam  _ValueType  A const-reference or CopyConstructible type.
         .              * @param   __any       The object to access.
         .              * @return  The contained object.
         .              * @throw   bad_any_cast If <code>
         .              *          __any.type() != typeid(remove_reference_t<_ValueType>)
         .              *          </code>
         .              */
         .             template<typename _ValueType>
22,953,624 ( 0.02%)      inline _ValueType any_cast(const any& __any)
         .               {
         .                 using _Up = __remove_cvref_t<_ValueType>;
         .                 static_assert(any::__is_valid_cast<_ValueType>(),
         .           	  "Template argument must be a reference or CopyConstructible type");
         .                 static_assert(is_constructible_v<_ValueType, const _Up&>,
         .           	  "Template argument must be constructible from a const value.");
22,953,624 ( 0.02%)        auto __p = any_cast<_Up>(&__any);
217,594,026 ( 0.18%)  => /usr/include/c++/14/any:unsigned int const* std::any_cast<unsigned int>(std::any const*) (5,579,334x)
11,476,812 ( 0.01%)        if (__p)
17,215,218 ( 0.01%)  	return static_cast<_ValueType>(*__p);
         .                 __throw_bad_any_cast();
11,476,812 ( 0.01%)      }
         .           
         .             /**
         .              * @brief Access the contained object.
         .              *
         .              * @tparam  _ValueType  A reference or CopyConstructible type.
         .              * @param   __any       The object to access.
         .              * @return  The contained object.
         .              * @throw   bad_any_cast If <code>
-- line 481 ----------------------------------------
-- line 510 ----------------------------------------
         .                 if (__p)
         .           	return static_cast<_ValueType>(std::move(*__p));
         .                 __throw_bad_any_cast();
         .               }
         .             /// @}
         .           
         .             /// @cond undocumented
         .             template<typename _Tp>
22,953,624 ( 0.02%)      void* __any_caster(const any* __any)
         .               {
         .                 // any_cast<T> returns non-null if __any->type() == typeid(T) and
         .                 // typeid(T) ignores cv-qualifiers so remove them:
         .                 using _Up = remove_cv_t<_Tp>;
         .                 // The contained value has a decayed type, so if decay_t<U> is not U,
         .                 // then it's not possible to have a contained value of type U:
         .                 if constexpr (!is_same_v<decay_t<_Up>, _Up>)
         .           	return nullptr;
         .                 // Only copy constructible types can be used for contained values:
         .                 else if constexpr (!is_copy_constructible_v<_Up>)
         .           	return nullptr;
         .                 // First try comparing function addresses, which works without RTTI
22,953,624 ( 0.02%)        else if (__any->_M_manager == &any::_Manager<_Up>::_S_manage
         .           #if __cpp_rtti
22,953,624 ( 0.02%)  	  || __any->type() == typeid(_Tp)
         .           #endif
         .           	  )
         .           	{
28,692,030 ( 0.02%)  	  return any::_Manager<_Up>::_S_access(__any->_M_storage);
44,634,672 ( 0.04%)  => /usr/include/c++/14/any:std::any::_Manager_internal<unsigned int>::_S_access(std::any::_Storage const&) (5,579,334x)
         .           	}
         .                 return nullptr;
11,476,812 ( 0.01%)      }
         .             /// @endcond
         .           
         .             /**
         .              * @brief Access the contained object.
         .              *
         .              * @tparam  _ValueType  The type of the contained object.
         .              * @param   __any       A pointer to the object to access.
         .              * @return  The address of the contained object if <code>
         .              *          __any != nullptr && __any.type() == typeid(_ValueType)
         .              *          </code>, otherwise a null pointer.
         .              *
         .              * @{
         .              */
         .             template<typename _ValueType>
22,953,624 ( 0.02%)      inline const _ValueType* any_cast(const any* __any) noexcept
         .               {
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 3305. any_cast<void>
         .                 static_assert(!is_void_v<_ValueType>);
         .           
         .                 // As an optimization, don't bother instantiating __any_caster for
         .                 // function types, since std::any can only hold objects.
         .                 if constexpr (is_object_v<_ValueType>)
11,476,812 ( 0.01%)  	if (__any)
22,953,624 ( 0.02%)  	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
150,642,018 ( 0.12%)  => /usr/include/c++/14/any:void* std::__any_caster<unsigned int>(std::any const*) (5,579,334x)
         .                 return nullptr;
11,476,812 ( 0.01%)      }
         .           
         .             template<typename _ValueType>
         .               inline _ValueType* any_cast(any* __any) noexcept
         .               {
         .                 static_assert(!is_void_v<_ValueType>);
         .           
         .                 if constexpr (is_object_v<_ValueType>)
         .           	if (__any)
         .           	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
         .                 return nullptr;
         .               }
         .             /// @}
         .           
         .             template<typename _Tp>
         .               void
       294 ( 0.00%)      any::_Manager_internal<_Tp>::
         .               _S_manage(_Op __which, const any* __any, _Arg* __arg)
         .               {
         .                 // The contained object is in _M_storage._M_buffer
       126 ( 0.00%)        auto __ptr = reinterpret_cast<const _Tp*>(&__any->_M_storage._M_buffer);
       252 ( 0.00%)        switch (__which)
         .                 {
         .                 case _Op_access:
         .           	__arg->_M_obj = const_cast<_Tp*>(__ptr);
         .           	break;
         .                 case _Op_get_type_info:
         .           #if __cpp_rtti
         .           	__arg->_M_typeinfo = &typeid(_Tp);
         .           #endif
         .           	break;
         .                 case _Op_clone:
       126 ( 0.00%)  	::new(&__arg->_M_any->_M_storage._M_buffer) _Tp(*__ptr);
        42 ( 0.00%)  => /usr/include/c++/14/new:operator new(unsigned long, void*) (6x)
        70 ( 0.00%)  	__arg->_M_any->_M_manager = __any->_M_manager;
        14 ( 0.00%)  	break;
         .                 case _Op_destroy:
         .           	__ptr->~_Tp();
        28 ( 0.00%)  	break;
         .                 case _Op_xfer:
         .           	::new(&__arg->_M_any->_M_storage._M_buffer) _Tp
         .           	  (std::move(*const_cast<_Tp*>(__ptr)));
         .           	__ptr->~_Tp();
         .           	__arg->_M_any->_M_manager = __any->_M_manager;
         .           	const_cast<any*>(__any)->_M_manager = nullptr;
         .           	break;
         .                 }
       168 ( 0.00%)      }
         .           
         .             template<typename _Tp>
         .               void
         .               any::_Manager_external<_Tp>::
         .               _S_manage(_Op __which, const any* __any, _Arg* __arg)
         .               {
         .                 // The contained object is *_M_storage._M_ptr
         .                 auto __ptr = static_cast<const _Tp*>(__any->_M_storage._M_ptr);
-- line 621 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imgui.h
--------------------------------------------------------------------------------
Ir                  

-- line 271 ----------------------------------------
         .           
         .           // ImVec2: 2D vector used to store positions, sizes etc. [Compile-time configurable type]
         .           // This is a frequently used type in the API. Consider using IM_VEC2_CLASS_EXTRA to create implicit cast from/to our preferred type.
         .           // Add '#define IMGUI_DEFINE_MATH_OPERATORS' in your imconfig.h file to benefit from courtesy maths operators for those types.
         .           IM_MSVC_RUNTIME_CHECKS_OFF
         .           struct ImVec2
         .           {
         .               float                                   x, y;
     2,952 ( 0.00%)      constexpr ImVec2()                      : x(0.0f), y(0.0f) { }
 2,792,958 ( 0.00%)      constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }
   338,800 ( 0.00%)      float& operator[] (size_t idx)          { IM_ASSERT(idx == 0 || idx == 1); return ((float*)(void*)(char*)this)[idx]; } // We very rarely use this [] operator, so the assert overhead is fine.
         .               float  operator[] (size_t idx) const    { IM_ASSERT(idx == 0 || idx == 1); return ((const float*)(const void*)(const char*)this)[idx]; }
         .           #ifdef IM_VEC2_CLASS_EXTRA
         .               IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.
         .           #endif
         .           };
         .           
         .           // ImVec4: 4D vector used to store clipping rectangles, colors etc. [Compile-time configurable type]
         .           struct ImVec4
         .           {
         .               float                                                     x, y, z, w;
   275,832 ( 0.00%)      constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
   259,798 ( 0.00%)      constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }
         .           #ifdef IM_VEC4_CLASS_EXTRA
         .               IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.
         .           #endif
         .           };
         .           IM_MSVC_RUNTIME_CHECKS_RESTORE
         .           
         .           //-----------------------------------------------------------------------------
         .           // [SECTION] Dear ImGui end-user API functions
-- line 301 ----------------------------------------
-- line 1968 ----------------------------------------
         .           
         .           //-----------------------------------------------------------------------------
         .           // IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()
         .           // We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
         .           // Defining a custom placement new() with a custom parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
         .           //-----------------------------------------------------------------------------
         .           
         .           struct ImNewWrapper {};
       196 ( 0.00%)  inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
         .           inline void  operator delete(void*, ImNewWrapper, void*)   {} // This is only required so we can use the symmetrical new()
         .           #define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
         .           #define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
         .           #define IM_PLACEMENT_NEW(_PTR)              new(ImNewWrapper(), _PTR)
         .           #define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
        30 ( 0.00%)  template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }
       290 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
        85 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGuiViewportP::~ImGuiViewportP() (1x)
         .           
         .           //-----------------------------------------------------------------------------
         .           // ImVector<>
         .           // Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
         .           //-----------------------------------------------------------------------------
         .           // - You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our public structures are relying on it.
         .           // - We use std-like naming convention here, which is a little unusual for this codebase.
         .           // - Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
-- line 1990 ----------------------------------------
-- line 2001 ----------------------------------------
         .               T*                  Data;
         .           
         .               // Provide standard typedefs but we don't use them ourselves.
         .               typedef T                   value_type;
         .               typedef value_type*         iterator;
         .               typedef const value_type*   const_iterator;
         .           
         .               // Constructors, destructor
     2,366 ( 0.00%)      inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
         .               inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }
         .               inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); if (src.Data) memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
       196 ( 0.00%)      inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
       159 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
         .           
       499 ( 0.00%)      inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
       159 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
         .               inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.
        48 ( 0.00%)      inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.
       532 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImFontBuildSrcData::~ImFontBuildSrcData() (2x)
       294 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImFontBuildSrcData>::clear() (1x)
         .           
    18,198 ( 0.00%)      inline bool         empty() const                       { return Size == 0; }
         .               inline int          size() const                        { return Size; }
        46 ( 0.00%)      inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
         .               inline int          max_size() const                    { return 0x7FFFFFFF / (int)sizeof(T); }
         .               inline int          capacity() const                    { return Capacity; }
16,242,675 ( 0.01%)      inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
    17,754 ( 0.00%)      inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
         .           
    78,673 ( 0.00%)      inline T*           begin()                             { return Data; }
        14 ( 0.00%)      inline const T*     begin() const                       { return Data; }
   138,627 ( 0.00%)      inline T*           end()                               { return Data + Size; }
    33,996 ( 0.00%)      inline const T*     end() const                         { return Data + Size; }
         .               inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }
         .               inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }
   989,736 ( 0.00%)      inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
         .               inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    29,822 ( 0.00%)      inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
         .           
     2,997 ( 0.00%)      inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
   389,310 ( 0.00%)      inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
       746 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::reserve(int) (2x)
        33 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<stbrp_rect>::_grow_capacity(int) const (2x)
 1,653,589 ( 0.00%)      inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
       471 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::reserve(int) (1x)
        16 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::_grow_capacity(int) const (1x)
         .               inline void         shrink(int new_size)                { IM_ASSERT(new_size <= Size); Size = new_size; } // Resize a vector to a smaller size, guaranteed not to cause a reallocation
    10,361 ( 0.00%)      inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
       118 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
     9,734 ( 0.00%)      inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
       118 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
         .           
         .               // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
 1,677,902 ( 0.00%)      inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
       149 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::reserve(int) (1x)
        66 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (3x)
        17 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiSettingsHandler>::_grow_capacity(int) const (1x)
   515,888 ( 0.00%)      inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
        19 ( 0.00%)      inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }
        91 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiWindow*>::insert(ImGuiWindow* const*, ImGuiWindow* const&) (1x)
        59 ( 0.00%)      inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
        13 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
     1,890 ( 0.00%)      inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
   225,657 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (18x)
         .               inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data + Size);  const ptrdiff_t off = it - Data; if (it < Data + Size - 1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
       658 ( 0.00%)      inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
        13 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
   132,056 ( 0.00%)      inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
         .               inline T*           find(const T& v)                    { T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
         .               inline const T*     find(const T& v) const              { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
         .               inline int          find_index(const T& v) const        { const T* data_end = Data + Size; const T* it = find(v); if (it == data_end) return -1; const ptrdiff_t off = it - Data; return (int)off; }
         .               inline bool         find_erase(const T& v)              { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }
         .               inline bool         find_erase_unsorted(const T& v)     { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }
         .               inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }
         .           };
         .           IM_MSVC_RUNTIME_CHECKS_RESTORE
-- line 2059 ----------------------------------------
-- line 2425 ----------------------------------------
         .               ImGuiID             FocusRouteParentWindowId;   // ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.
         .               ImGuiViewportFlags  ViewportFlagsOverrideSet;   // Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
         .               ImGuiViewportFlags  ViewportFlagsOverrideClear; // Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
         .               ImGuiTabItemFlags   TabItemFlagsOverrideSet;    // [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.
         .               ImGuiDockNodeFlags  DockNodeFlagsOverrideSet;   // [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)
         .               bool                DockingAlwaysTabBar;        // Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)
         .               bool                DockingAllowUnclassed;      // Set to true to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?
         .           
     7,089 ( 0.00%)      ImGuiWindowClass() { memset(this, 0, sizeof(*this)); ParentViewportId = (ImGuiID)-1; DockingAllowUnclassed = true; }
     5,004 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (417x)
         .           };
         .           
         .           // Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
         .           struct ImGuiPayload
         .           {
         .               // Members
         .               void*           Data;               // Data (copied and owned by dear imgui)
         .               int             DataSize;           // Data size
-- line 2441 ----------------------------------------
-- line 2443 ----------------------------------------
         .               // [Internal]
         .               ImGuiID         SourceId;           // Source item id
         .               ImGuiID         SourceParentId;     // Source parent id (if available)
         .               int             DataFrameCount;     // Data timestamp
         .               char            DataType[32 + 1];   // Data type tag (short user-supplied string, 32 characters max)
         .               bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
         .               bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
         .           
        10 ( 0.00%)      ImGuiPayload()  { Clear(); }
        44 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImGuiPayload::Clear() (1x)
        32 ( 0.00%)      void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
        12 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
         .               bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
         .               bool IsPreview() const                  { return Preview; }
         .               bool IsDelivery() const                 { return Delivery; }
         .           };
         .           
         .           //-----------------------------------------------------------------------------
         .           // [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)
         .           //-----------------------------------------------------------------------------
-- line 2460 ----------------------------------------
-- line 2499 ----------------------------------------
         .               };
         .               char                    InputBuf[256];
         .               ImVector<ImGuiTextRange>Filters;
         .               int                     CountGrep;
         .           };
         .           
         .           // Helper: Growable text buffer for logging/accumulating text
         .           // (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
        10 ( 0.00%)  struct ImGuiTextBuffer
        11 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<char>::~ImVector() (1x)
         .           {
         .               ImVector<char>      Buf;
         .               IMGUI_API static char EmptyString[1];
         .           
        40 ( 0.00%)      ImGuiTextBuffer()   { }
        56 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<char>::ImVector() (4x)
         .               inline char         operator[](int i) const { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }
         .               const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }
         .               const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator
         .               int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }
         .               bool                empty() const           { return Buf.Size <= 1; }
         .               void                clear()                 { Buf.clear(); }
         .               void                reserve(int capacity)   { Buf.reserve(capacity); }
         .               const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }
-- line 2520 ----------------------------------------
-- line 2526 ----------------------------------------
         .           // Helper: Key->Value storage
         .           // Typically you don't have to worry about this since a storage is held within each Window.
         .           // We use it to e.g. store collapse state for a tree (Int 0/1)
         .           // This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
         .           // You can use it as custom user storage for temporary values. Declare your own storage if, for example:
         .           // - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
         .           // - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
         .           // Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
       120 ( 0.00%)  struct ImGuiStorage
        11 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::~ImVector() (1x)
         .           {
         .               // [Internal]
         .               struct ImGuiStoragePair
         .               {
         .                   ImGuiID key;
         .                   union { int val_i; float val_f; void* val_p; };
        14 ( 0.00%)          ImGuiStoragePair(ImGuiID _key, int _val)    { key = _key; val_i = _val; }
         .                   ImGuiStoragePair(ImGuiID _key, float _val)  { key = _key; val_f = _val; }
        98 ( 0.00%)          ImGuiStoragePair(ImGuiID _key, void* _val)  { key = _key; val_p = _val; }
         .               };
         .           
         .               ImVector<ImGuiStoragePair>      Data;
         .           
         .               // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
         .               // - Set***() functions find pair, insertion on demand if missing.
         .               // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
        20 ( 0.00%)      void                Clear() { Data.clear(); }
       193 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiStorage::ImGuiStoragePair>::clear() (2x)
         .               IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
         .               IMGUI_API void      SetInt(ImGuiID key, int val);
         .               IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
         .               IMGUI_API void      SetBool(ImGuiID key, bool val);
         .               IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
         .               IMGUI_API void      SetFloat(ImGuiID key, float val);
         .               IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
         .               IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);
-- line 2559 ----------------------------------------
-- line 2625 ----------------------------------------
         .           
         .           // Helpers: ImVec2/ImVec4 operators
         .           // - It is important that we are keeping those disabled by default so they don't leak in user space.
         .           // - This is in order to allow user enabling implicit cast operators between ImVec2/ImVec4 and their own types (using IM_VEC2_CLASS_EXTRA in imconfig.h)
         .           // - You can use '#define IMGUI_DEFINE_MATH_OPERATORS' to import our operators, provided as a courtesy.
         .           #ifdef IMGUI_DEFINE_MATH_OPERATORS
         .           #define IMGUI_DEFINE_MATH_OPERATORS_IMPLEMENTED
         .           IM_MSVC_RUNTIME_CHECKS_OFF
   145,240 ( 0.00%)  static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
   101,668 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (7,262x)
         .           static inline ImVec2  operator/(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x / rhs, lhs.y / rhs); }
   454,250 ( 0.00%)  static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
   254,380 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (18,170x)
   226,950 ( 0.00%)  static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
   127,092 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (9,078x)
     3,200 ( 0.00%)  static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
     1,792 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (128x)
         .           static inline ImVec2  operator/(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x / rhs.x, lhs.y / rhs.y); }
        22 ( 0.00%)  static inline ImVec2  operator-(const ImVec2& lhs)                      { return ImVec2(-lhs.x, -lhs.y); }
        14 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (1x)
         .           static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)          { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
         .           static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)          { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
     4,221 ( 0.00%)  static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
        21 ( 0.00%)  static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
         .           static inline ImVec2& operator*=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x *= rhs.x; lhs.y *= rhs.y; return lhs; }
         .           static inline ImVec2& operator/=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x /= rhs.x; lhs.y /= rhs.y; return lhs; }
         .           static inline bool    operator==(const ImVec2& lhs, const ImVec2& rhs)  { return lhs.x == rhs.x && lhs.y == rhs.y; }
        23 ( 0.00%)  static inline bool    operator!=(const ImVec2& lhs, const ImVec2& rhs)  { return lhs.x != rhs.x || lhs.y != rhs.y; }
         .           static inline ImVec4  operator+(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w); }
         .           static inline ImVec4  operator-(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w); }
        38 ( 0.00%)  static inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }
        22 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec4::ImVec4(float, float, float, float) (1x)
         .           static inline bool    operator==(const ImVec4& lhs, const ImVec4& rhs)  { return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z && lhs.w == rhs.w; }
         .           static inline bool    operator!=(const ImVec4& lhs, const ImVec4& rhs)  { return lhs.x != rhs.x || lhs.y != rhs.y || lhs.z != rhs.z || lhs.w != rhs.w; }
         .           IM_MSVC_RUNTIME_CHECKS_RESTORE
         .           #endif
         .           
         .           // Helpers macros to generate 32-bit encoded colors
         .           // User can declare their own format by #defining the 5 _SHIFT/_MASK macros in their imconfig file.
         .           #ifndef IM_COL32_R_SHIFT
-- line 2658 ----------------------------------------
-- line 2733 ----------------------------------------
         .               ImVec4          ClipRect;           // 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
         .               ImTextureID     TextureId;          // 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
         .               unsigned int    VtxOffset;          // 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.
         .               unsigned int    IdxOffset;          // 4    // Start offset in index buffer.
         .               unsigned int    ElemCount;          // 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
         .               ImDrawCallback  UserCallback;       // 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
         .               void*           UserCallbackData;   // 4-8  // The draw callback code can access this.
         .           
    64,496 ( 0.00%)      ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed
    72,558 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec4::ImVec4() (4,031x)
    48,372 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (4,031x)
         .           
         .               // Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)
     5,649 ( 0.00%)      inline ImTextureID GetTexID() const { return TextureId; }
         .           };
         .           
         .           // Vertex layout
         .           #ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
         .           struct ImDrawVert
         .           {
         .               ImVec2  pos;
         .               ImVec2  uv;
-- line 2752 ----------------------------------------
-- line 2756 ----------------------------------------
         .           // You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
         .           // The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
         .           // The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared at the time you'd want to set your type up.
         .           // NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
         .           IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
         .           #endif
         .           
         .           // [Internal] For use by ImDrawList
        60 ( 0.00%)  struct ImDrawCmdHeader
       108 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec4::ImVec4() (6x)
         .           {
         .               ImVec4          ClipRect;
         .               ImTextureID     TextureId;
         .               unsigned int    VtxOffset;
         .           };
         .           
         .           // [Internal] For use by ImDrawListSplitter
        14 ( 0.00%)  struct ImDrawChannel
        14 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::ImVector() (1x)
        14 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::ImVector() (1x)
         .           {
         .               ImVector<ImDrawCmd>         _CmdBuffer;
         .               ImVector<ImDrawIdx>         _IdxBuffer;
         .           };
         .           
         .           
         .           // Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
         .           // This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.
         .           struct ImDrawListSplitter
         .           {
         .               int                         _Current;    // Current channel number (0)
         .               int                         _Count;      // Number of active channels (1+)
         .               ImVector<ImDrawChannel>     _Channels;   // Draw channels (not resized down so _Count might be < Channels.Size)
         .           
       102 ( 0.00%)      inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImDrawChannel>::ImVector() (6x)
        66 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6x)
         .               inline ~ImDrawListSplitter() { ClearFreeMemory(); }
    20,160 ( 0.00%)      inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame
         .               IMGUI_API void              ClearFreeMemory();
         .               IMGUI_API void              Split(ImDrawList* draw_list, int count);
         .               IMGUI_API void              Merge(ImDrawList* draw_list);
         .               IMGUI_API void              SetCurrentChannel(ImDrawList* draw_list, int channel_idx);
         .           };
         .           
         .           // Flags for ImDrawList functions
         .           // (Legacy: bit 0 must always correspond to ImDrawFlags_Closed to be backward compatible with old API using a bool. Bits 1..3 must be unused)
-- line 2797 ----------------------------------------
-- line 2850 ----------------------------------------
         .               ImDrawCmdHeader         _CmdHeader;         // [Internal] template of active commands. Fields should match those of CmdBuffer.back().
         .               ImDrawListSplitter      _Splitter;          // [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
         .               ImVector<ImVec4>        _ClipRectStack;     // [Internal]
         .               ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
         .               float                   _FringeScale;       // [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
         .               const char*             _OwnerName;         // Pointer to owner window's name for debugging
         .           
         .               // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
       288 ( 0.00%)      ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }
       252 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImDrawListSplitter::ImDrawListSplitter() (6x)
       168 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImDrawCmdHeader::ImDrawCmdHeader() (6x)
       156 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6x)
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImDrawCmd>::ImVector() (6x)
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<void*>::ImVector() (6x)
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImVec2>::ImVector() (6x)
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<unsigned short>::ImVector() (6x)
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImDrawVert>::ImVector() (6x)
        84 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImVec4>::ImVector() (6x)
         .           
         .               ~ImDrawList() { _ClearFreeMemory(); }
         .               IMGUI_API void  PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
         .               IMGUI_API void  PushClipRectFullScreen();
         .               IMGUI_API void  PopClipRect();
         .               IMGUI_API void  PushTextureID(ImTextureID texture_id);
         .               IMGUI_API void  PopTextureID();
         .               inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
-- line 2866 ----------------------------------------
-- line 2906 ----------------------------------------
         .               IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2(0, 0), const ImVec2& uv_max = ImVec2(1, 1), ImU32 col = IM_COL32_WHITE);
         .               IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2(0, 0), const ImVec2& uv2 = ImVec2(1, 0), const ImVec2& uv3 = ImVec2(1, 1), const ImVec2& uv4 = ImVec2(0, 1), ImU32 col = IM_COL32_WHITE);
         .               IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags = 0);
         .           
         .               // Stateful path API, add points then finish with PathFillConvex() or PathStroke()
         .               // - Important: filled shapes must always use clockwise winding order! The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
         .               //   so e.g. 'PathArcTo(center, radius, PI * -0.5f, PI)' is ok, whereas 'PathArcTo(center, radius, PI, PI * -0.5f)' won't have correct anti-aliasing when followed by PathFillConvex().
         .               inline    void  PathClear()                                                 { _Path.Size = 0; }
    39,648 ( 0.00%)      inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    82,597 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImVec2>::push_back(ImVec2 const&) (2,832x)
         .               inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }
     7,272 ( 0.00%)      inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
   433,486 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddConvexPolyFilled(ImVec2 const*, int, unsigned int) (404x)
         .               inline    void  PathFillConcave(ImU32 col)                                  { AddConcavePolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
     9,338 ( 0.00%)      inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
   651,057 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddPolyline(ImVec2 const*, int, unsigned int, int, float) (406x)
         .               IMGUI_API void  PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 0);
         .               IMGUI_API void  PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12);                // Use precomputed angles for a 12 steps circle
         .               IMGUI_API void  PathEllipticalArcTo(const ImVec2& center, const ImVec2& radius, float rot, float a_min, float a_max, int num_segments = 0); // Ellipse
         .               IMGUI_API void  PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0); // Cubic Bezier (4 control points)
         .               IMGUI_API void  PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);               // Quadratic Bezier (3 control points)
         .               IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawFlags flags = 0);
         .           
         .               // Advanced
-- line 2926 ----------------------------------------
-- line 2929 ----------------------------------------
         .               IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.
         .           
         .               // Advanced: Channels
         .               // - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)
         .               // - Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)
         .               // - This API shouldn't have been in ImDrawList in the first place!
         .               //   Prefer using your own persistent instance of ImDrawListSplitter as you can stack them.
         .               //   Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.
     6,045 ( 0.00%)      inline void     ChannelsSplit(int count)    { _Splitter.Split(this, count); }
    67,620 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::Split(ImDrawList*, int) (403x)
     5,239 ( 0.00%)      inline void     ChannelsMerge()             { _Splitter.Merge(this); }
   263,878 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::Merge(ImDrawList*) (403x)
    12,105 ( 0.00%)      inline void     ChannelsSetCurrent(int n)   { _Splitter.SetCurrentChannel(this, n); }
    98,091 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::SetCurrentChannel(ImDrawList*, int) (807x)
         .           
         .               // Advanced: Primitives allocations
         .               // - We render triangles (three vertices)
         .               // - All primitives needs to be reserved via PrimReserve() beforehand.
         .               IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
         .               IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);
         .               IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
         .               IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
-- line 2947 ----------------------------------------
-- line 2968 ----------------------------------------
         .               IMGUI_API int   _CalcCircleAutoSegmentCount(float radius) const;
         .               IMGUI_API void  _PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step);
         .               IMGUI_API void  _PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments);
         .           };
         .           
         .           // All draw data to render a Dear ImGui frame
         .           // (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
         .           // as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
        11 ( 0.00%)  struct ImDrawData
        11 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::~ImVector() (1x)
         .           {
         .               bool                Valid;              // Only valid after Render() is called and before the next NewFrame() is called.
         .               int                 CmdListsCount;      // Number of ImDrawList* to render
         .               int                 TotalIdxCount;      // For convenience, sum of all ImDrawList's IdxBuffer.Size
         .               int                 TotalVtxCount;      // For convenience, sum of all ImDrawList's VtxBuffer.Size
         .               ImVector<ImDrawList*> CmdLists;         // Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.
         .               ImVec2              DisplayPos;         // Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)
         .               ImVec2              DisplaySize;        // Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)
         .               ImVec2              FramebufferScale;   // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
         .               ImGuiViewport*      OwnerViewport;      // Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).
         .           
         .               // Functions
        56 ( 0.00%)      ImDrawData()    { Clear(); }
       148 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawData::Clear() (2x)
        72 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (6x)
        28 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImDrawList*>::ImVector() (2x)
         .               IMGUI_API void  Clear();
         .               IMGUI_API void  AddDrawList(ImDrawList* draw_list);     // Helper to add an external draw list into an existing ImDrawData.
         .               IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
         .               IMGUI_API void  ScaleClipRects(const ImVec2& fb_scale); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
         .           };
         .           
         .           //-----------------------------------------------------------------------------
         .           // [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
-- line 2997 ----------------------------------------
-- line 3057 ----------------------------------------
         .           struct ImFontAtlasCustomRect
         .           {
         .               unsigned short  Width, Height;  // Input    // Desired rectangle dimension
         .               unsigned short  X, Y;           // Output   // Packed position in Atlas
         .               unsigned int    GlyphID;        // Input    // For custom font glyphs only (ID < 0x110000)
         .               float           GlyphAdvanceX;  // Input    // For custom font glyphs only: glyph xadvance
         .               ImVec2          GlyphOffset;    // Input    // For custom font glyphs only: glyph display offset
         .               ImFont*         Font;           // Input    // For custom font glyphs only: target font
        78 ( 0.00%)      ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
        28 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (2x)
        24 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (2x)
        18 ( 0.00%)      bool IsPacked() const           { return X != 0xFFFF; }
         .           };
         .           
         .           // Flags for ImFontAtlas build
         .           enum ImFontAtlasFlags_
         .           {
         .               ImFontAtlasFlags_None               = 0,
         .               ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
         .               ImFontAtlasFlags_NoMouseCursors     = 1 << 1,   // Don't build software mouse cursors into the atlas (save a little texture memory)
-- line 3074 ----------------------------------------
-- line 3110 ----------------------------------------
         .               // Build atlas, retrieve pixel data.
         .               // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
         .               // The pitch is always = Width * BytesPerPixels (1 or 4)
         .               // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
         .               // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
         .               IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
         .               IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
         .               IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
     6,045 ( 0.00%)      bool                        IsBuilt() const             { return Fonts.Size > 0 && TexReady; } // Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
        10 ( 0.00%)      void                        SetTexID(ImTextureID id)    { TexID = id; }
         .           
         .               //-------------------------------------------
         .               // Glyph Ranges
         .               //-------------------------------------------
         .           
         .               // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
         .               // NB: Make sure that your string are UTF-8 and NOT in your local code page.
         .               // Read https://github.com/ocornut/imgui/blob/master/docs/FONTS.md/#about-utf-8-encoding for details.
-- line 3127 ----------------------------------------
-- line 3144 ----------------------------------------
         .               // - After calling Build(), you can query the rectangle position and render your pixels.
         .               // - If you render colored output, set 'atlas->TexPixelsUseColors = true' as this may help some backends decide of prefered texture format.
         .               // - You can also request your rectangles to be mapped as font glyph (given a font + Unicode point),
         .               //   so you can render e.g. custom colorful icons and use them as regular glyphs.
         .               // - Read docs/FONTS.md for more details about using colorful icons.
         .               // - Note: this API may be redesigned later in order to support multi-monitor varying DPI settings.
         .               IMGUI_API int               AddCustomRectRegular(int width, int height);
         .               IMGUI_API int               AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0, 0));
        30 ( 0.00%)      ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }
        38 ( 0.00%)  => ???:ImVector<ImFontAtlasCustomRect>::operator[](int) (2x)
         .           
         .               // [Internal]
         .               IMGUI_API void              CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const;
         .               IMGUI_API bool              GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);
         .           
         .               //-------------------------------------------
         .               // Members
         .               //-------------------------------------------
-- line 3160 ----------------------------------------
-- line 3224 ----------------------------------------
         .               ImU8                        Used4kPagesMap[(IM_UNICODE_CODEPOINT_MAX+1)/4096/8]; // 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
         .           
         .               // Methods
         .               IMGUI_API ImFont();
         .               IMGUI_API ~ImFont();
         .               IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
         .               IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
         .               float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
     7,272 ( 0.00%)      bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
         .               const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }
         .           
         .               // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
         .               // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
         .               IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
         .               IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
         .               IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const;
         .               IMGUI_API void              RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;
-- line 3240 ----------------------------------------
-- line 3303 ----------------------------------------
         .               void*               PlatformUserData;       // void* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.
         .               void*               PlatformHandle;         // void* for FindViewportByPlatformHandle(). (e.g. suggested to use natural platform handle such as HWND, GLFWWindow*, SDL_Window*)
         .               void*               PlatformHandleRaw;      // void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)
         .               bool                PlatformWindowCreated;  // Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.
         .               bool                PlatformRequestMove;    // Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)
         .               bool                PlatformRequestResize;  // Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)
         .               bool                PlatformRequestClose;   // Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)
         .           
        58 ( 0.00%)      ImGuiViewport()     { memset(this, 0, sizeof(*this)); }
        96 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (8x)
        38 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2x)
        15 ( 0.00%)      ~ImGuiViewport()    { IM_ASSERT(PlatformUserData == NULL && RendererUserData == NULL); }
         .           
         .               // Helpers
         .               ImVec2              GetCenter() const       { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }
         .               ImVec2              GetWorkCenter() const   { return ImVec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f); }
         .           };
         .           
         .           //-----------------------------------------------------------------------------
         .           // [SECTION] Platform Dependent Interfaces (for e.g. multi-viewport support)
-- line 3320 ----------------------------------------
-- line 3419 ----------------------------------------
         .           
         .               //------------------------------------------------------------------
         .               // Output - List of viewports to render into platform windows
         .               //------------------------------------------------------------------
         .           
         .               // Viewports list (the list is updated by calling ImGui::EndFrame or ImGui::Render)
         .               // (in the future we will attempt to organize this feature to remove the need for a "main viewport")
         .               ImVector<ImGuiViewport*>        Viewports;                              // Main viewports, followed by all secondary viewports.
        21 ( 0.00%)      ImGuiPlatformIO()               { memset(this, 0, sizeof(*this)); }     // Zero clear
        26 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        14 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiPlatformMonitor>::ImVector() (1x)
        14 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVector<ImGuiViewport*>::ImVector() (1x)
         .           };
         .           
         .           // (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.
         .           // We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.
         .           struct ImGuiPlatformMonitor
         .           {
         .               ImVec2  MainPos, MainSize;      // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
         .               ImVec2  WorkPos, WorkSize;      // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
         .               float   DpiScale;               // 1.0f = 96 DPI
         .               void*   PlatformHandle;         // Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
       153 ( 0.00%)      ImGuiPlatformMonitor()          { MainPos = MainSize = WorkPos = WorkSize = ImVec2(0, 0); DpiScale = 1.0f; PlatformHandle = NULL; }
       144 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (12x)
        42 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2(float, float) (3x)
         .           };
         .           
         .           // (Optional) Support for IME (Input Method Editor) via the io.SetPlatformImeDataFn() function.
         .           struct ImGuiPlatformImeData
         .           {
         .               bool    WantVisible;        // A widget wants the IME to be visible
         .               ImVec2  InputPos;           // Position of the input cursor
         .               float   InputLineHeight;    // Line height
         .           
        34 ( 0.00%)      ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
        24 ( 0.00%)  => build/_deps/imgui-src/imgui.h:ImVec2::ImVec2() (2x)
        22 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (2x)
         .           };
         .           
         .           //-----------------------------------------------------------------------------
         .           // [SECTION] Obsolete functions and types
         .           // (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
         .           // Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.
         .           //-----------------------------------------------------------------------------
         .           
-- line 3456 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/char_traits.h
--------------------------------------------------------------------------------
Ir                 

-- line 335 ----------------------------------------
        .                 typedef streamoff         off_type;
        .                 typedef mbstate_t         state_type;
        .           #endif // HOSTED
        .           #if __cpp_lib_three_way_comparison
        .                 using comparison_category = strong_ordering;
        .           #endif
        .           
        .                 static _GLIBCXX17_CONSTEXPR void
3,656,055 ( 0.00%)        assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
        .                 {
        .           #if __cpp_constexpr_dynamic_alloc
1,462,422 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  std::construct_at(__builtin_addressof(__c1), __c2);
        .           	else
        .           #endif
2,925,071 ( 0.00%)  	__c1 = __c2;
2,193,639 ( 0.00%)        }
        .           
        .                 static _GLIBCXX_CONSTEXPR bool
        .                 eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
        .                 { return __c1 == __c2; }
        .           
        .                 static _GLIBCXX_CONSTEXPR bool
        .                 lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
        .                 {
        .           	// LWG 467.
        .           	return (static_cast<unsigned char>(__c1)
        .           		< static_cast<unsigned char>(__c2));
        .                 }
        .           
        .                 static _GLIBCXX17_CONSTEXPR int
1,604,172 ( 0.00%)        compare(const char_type* __s1, const char_type* __s2, size_t __n)
        .                 {
  534,728 ( 0.00%)  	if (__n == 0)
        2 ( 0.00%)  	  return 0;
        .           #if __cplusplus >= 201703L
  534,722 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  {
        .           	    for (size_t __i = 0; __i < __n; ++__i)
        .           	      if (lt(__s1[__i], __s2[__i]))
        .           		return -1;
        .           	      else if (lt(__s2[__i], __s1[__i]))
        .           		return 1;
        .           	    return 0;
        .           	  }
        .           #endif
2,138,896 ( 0.00%)  	return __builtin_memcmp(__s1, __s2, __n);
5,168,305 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (267,361x)
    1,201 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  534,724 ( 0.00%)        }
        .           
        .                 static _GLIBCXX17_CONSTEXPR size_t
1,407,364 ( 0.00%)        length(const char_type* __s)
        .                 {
        .           #if __cplusplus >= 201703L
  703,682 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  return __gnu_cxx::char_traits<char_type>::length(__s);
        .           #endif
1,771,031 ( 0.00%)  	return __builtin_strlen(__s);
6,228,512 ( 0.01%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (351,841x)
    1,292 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  703,682 ( 0.00%)        }
        .           
        .                 static _GLIBCXX17_CONSTEXPR const char_type*
  371,502 ( 0.00%)        find(const char_type* __s, size_t __n, const char_type& __a)
        .                 {
  123,834 ( 0.00%)  	if (__n == 0)
        .           	  return 0;
        .           #if __cplusplus >= 201703L
  123,834 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
        .           #endif
  619,238 ( 0.00%)  	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
1,247,646 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2 (61,917x)
    1,224 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  123,834 ( 0.00%)        }
        .           
        .                 static _GLIBCXX20_CONSTEXPR char_type*
    1,254 ( 0.00%)        move(char_type* __s1, const char_type* __s2, size_t __n)
        .                 {
      418 ( 0.00%)  	if (__n == 0)
        .           	  return __s1;
        .           #if __cplusplus >= 202002L
      418 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
        .           #endif
    1,676 ( 0.00%)  	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
    2,709 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (209x)
    1,199 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      418 ( 0.00%)        }
        .           
        .                 static _GLIBCXX20_CONSTEXPR char_type*
3,713,754 ( 0.00%)        copy(char_type* __s1, const char_type* __s2, size_t __n)
        .                 {
1,237,966 ( 0.00%)  	if (__n == 0)
   38,296 ( 0.00%)  	  return __s1;
        .           #if __cplusplus >= 202002L
1,199,622 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
        .           #endif
5,998,370 ( 0.00%)  	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
7,373,234 ( 0.01%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (599,811x)
    1,400 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
1,237,918 ( 0.00%)        }
        .           
        .                 static _GLIBCXX20_CONSTEXPR char_type*
       84 ( 0.00%)        assign(char_type* __s, size_t __n, char_type __a)
        .                 {
       24 ( 0.00%)  	if (__n == 0)
        .           	  return __s;
        .           #if __cplusplus >= 202002L
       24 ( 0.00%)  	if (std::__is_constant_evaluated())
        .           	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
        .           #endif
       96 ( 0.00%)  	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
    8,670 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (12x)
       24 ( 0.00%)        }
        .           
        .                 static _GLIBCXX_CONSTEXPR char_type
   36,792 ( 0.00%)        to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
   49,056 ( 0.00%)        { return static_cast<char_type>(__c); }
        .           
        .                 // To keep both the byte 0xff and the eof symbol 0xffffffff
        .                 // from ending up as 0xffffffff.
        .                 static _GLIBCXX_CONSTEXPR int_type
        .                 to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
        .                 { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
        .           
        .                 static _GLIBCXX_CONSTEXPR bool
        .                 eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
        .                 { return __c1 == __c2; }
        .           
        .           #ifdef _GLIBCXX_STDIO_EOF
        .                 static _GLIBCXX_CONSTEXPR int_type
   47,340 ( 0.00%)        eof() _GLIBCXX_NOEXCEPT
   71,010 ( 0.00%)        { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }
        .           
        .                 static _GLIBCXX_CONSTEXPR int_type
        .                 not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
        .                 { return (__c == eof()) ? 0 : __c; }
        .           #endif // defined(_GLIBCXX_STDIO_EOF)
        .             };
        .           
        .           
-- line 467 ----------------------------------------
-- line 988 ----------------------------------------
        .           #endif // HOSTED
        .               };
        .           
        .           #if __cpp_lib_three_way_comparison
        .             namespace __detail
        .             {
        .               template<typename _ChTraits>
        .                 constexpr auto
  117,303 ( 0.00%)        __char_traits_cmp_cat(int __cmp) noexcept
        .                 {
        .           	if constexpr (requires { typename _ChTraits::comparison_category; })
        .           	  {
        .           	    using _Cat = typename _ChTraits::comparison_category;
        .           	    static_assert( !is_void_v<common_comparison_category_t<_Cat>> );
  221,573 ( 0.00%)  	    return static_cast<_Cat>(__cmp <=> 0);
        .           	  }
        .           	else
        .           	  return static_cast<weak_ordering>(__cmp <=> 0);
   78,202 ( 0.00%)        }
        .             } // namespace __detail
        .           #endif // C++20
        .           
        .           #pragma GCC diagnostic pop
        .           
        .           _GLIBCXX_END_NAMESPACE_VERSION
        .           } // namespace
        .           
-- line 1014 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/unique_ptr.h
--------------------------------------------------------------------------------
Ir                  

-- line 74 ----------------------------------------
         .                 /** @brief Converting constructor.
         .                  *
         .                  * Allows conversion from a deleter for objects of another type, `_Up`,
         .                  * only if `_Up*` is convertible to `_Tp*`.
         .                  */
         .                 template<typename _Up,
         .           	       typename = _Require<is_convertible<_Up*, _Tp*>>>
         .           	_GLIBCXX23_CONSTEXPR
       588 ( 0.00%)          default_delete(const default_delete<_Up>&) noexcept { }
         .           
         .                 /// Calls `delete __ptr`
         .                 _GLIBCXX23_CONSTEXPR
         .                 void
       420 ( 0.00%)        operator()(_Tp* __ptr) const
         .                 {
         .           	static_assert(!is_void<_Tp>::value,
         .           		      "can't delete pointer to incomplete type");
         .           	static_assert(sizeof(_Tp)>0,
         .           		      "can't delete pointer to incomplete type");
       691 ( 0.00%)  	delete __ptr;
       736 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/engine/vehicles/Train.h:ATrain::~ATrain() (2x)
       252 ( 0.00%)        }
         .               };
         .           
         .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .             // DR 740 - omit specialization for array objects with a compile time length
         .           
         .             /** Specialization of default_delete for arrays, used by `unique_ptr<T[]>`
         .              *
         .              * @headerfile memory
-- line 102 ----------------------------------------
-- line 160 ----------------------------------------
         .           	       is_default_constructible<_Dp>>::value>;
         .           
         .                 using pointer = typename _Ptr<_Tp, _Dp>::type;
         .           
         .                 static_assert( !is_rvalue_reference<_Dp>::value,
         .           		     "unique_ptr's deleter type must be a function object type"
         .           		     " or an lvalue reference type" );
         .           
   981,640 ( 0.00%)        __uniq_ptr_impl() = default;
 4,613,708 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::tuple() (98,164x)
         .                 _GLIBCXX23_CONSTEXPR
 1,768,847 ( 0.00%)        __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }
     3,525 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<ABall*, std::default_delete<ABall> >::tuple() (75x)
     3,150 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<ABall, std::default_delete<ABall> >::_M_ptr() (75x)
         .           
         .                 template<typename _Del>
         .           	_GLIBCXX23_CONSTEXPR
 1,390,795 ( 0.00%)  	__uniq_ptr_impl(pointer __p, _Del&& __d)
 2,582,905 ( 0.00%)  	: _M_t(__p, std::forward<_Del>(__d)) { }
   181,680 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}>::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*&, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&) (1,514x)
     9,084 ( 0.00%)  => /usr/include/c++/14/bits/move.h:nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const& std::forward<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&>(std::remove_reference<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&>::type&) (1,514x)
         .           
         .                 _GLIBCXX23_CONSTEXPR
   590,298 ( 0.00%)        __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
   688,681 ( 0.00%)        : _M_t(std::move(__u._M_t))
     7,474 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple<AActor*, std::default_delete<AActor> >::tuple(std::tuple<AActor*, std::default_delete<AActor> >&&) (202x)
     1,212 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<std::tuple<AActor*, std::default_delete<AActor> >&>::type&& std::move<std::tuple<AActor*, std::default_delete<AActor> >&>(std::tuple<AActor*, std::default_delete<AActor> >&) (202x)
   787,110 ( 0.00%)        { __u._M_ptr() = nullptr; }
     8,484 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<AActor, std::default_delete<AActor> >::_M_ptr() (202x)
         .           
         .                 _GLIBCXX23_CONSTEXPR
         .                 __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
         .                 {
         .           	reset(__u.release());
         .           	_M_deleter() = std::forward<_Dp>(__u._M_deleter());
         .           	return *this;
         .                 }
         .           
         .                 _GLIBCXX23_CONSTEXPR
11,556,812 ( 0.01%)        pointer&   _M_ptr() noexcept { return std::get<0>(_M_t); }
   154,428 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple_element<0ul, std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}> >::type& std::get<0ul, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}>(std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}>&) (4,542x)
         .                 _GLIBCXX23_CONSTEXPR
 3,938,040 ( 0.00%)        pointer    _M_ptr() const noexcept { return std::get<0>(_M_t); }
    49,436 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple_element<0ul, std::tuple<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >>()::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1}> >::type const& std::get<0ul, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >>()::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1}>(std::tuple<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >>()::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1}> const&) (1,454x)
         .                 _GLIBCXX23_CONSTEXPR
 4,420,314 ( 0.00%)        _Dp&       _M_deleter() noexcept { return std::get<1>(_M_t); }
       231 ( 0.00%)  => /usr/include/c++/14/tuple:std::tuple_element<1ul, std::tuple<OBombKart*, std::default_delete<OBombKart> > >::type& std::get<1ul, OBombKart*, std::default_delete<OBombKart> >(std::tuple<OBombKart*, std::default_delete<OBombKart> >&) (7x)
         .                 _GLIBCXX23_CONSTEXPR
         .                 const _Dp& _M_deleter() const noexcept { return std::get<1>(_M_t); }
         .           
         .                 _GLIBCXX23_CONSTEXPR
         .                 void reset(pointer __p) noexcept
         .                 {
         2 ( 0.00%)  	const pointer __old_p = _M_ptr();
         2 ( 0.00%)  	_M_ptr() = __p;
         4 ( 0.00%)  	if (__old_p)
         .           	  _M_deleter()(__old_p);
         .                 }
         .           
         .                 _GLIBCXX23_CONSTEXPR
   794,740 ( 0.00%)        pointer release() noexcept
         .                 {
   993,427 ( 0.00%)  	pointer __p = _M_ptr();
 8,242,332 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::_M_ptr() (196,246x)
   794,742 ( 0.00%)  	_M_ptr() = nullptr;
 8,242,332 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result<std::shared_ptr<Ship::IResource> >, std::__future_base::_Result_base::_Deleter>::_M_ptr() (196,246x)
   198,685 ( 0.00%)  	return __p;
   397,370 ( 0.00%)        }
         .           
         .                 _GLIBCXX23_CONSTEXPR
         .                 void
   588,984 ( 0.00%)        swap(__uniq_ptr_impl& __rhs) noexcept
         .                 {
         .           	using std::swap;
   981,640 ( 0.00%)  	swap(this->_M_ptr(), __rhs._M_ptr());
 8,245,776 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::_M_ptr() (196,328x)
 4,221,052 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<std::__future_base::_Result_base*> >, std::is_move_constructible<std::__future_base::_Result_base*>, std::is_move_assignable<std::__future_base::_Result_base*> >::value, void>::type std::swap<std::__future_base::_Result_base*>(std::__future_base::_Result_base*&, std::__future_base::_Result_base*&) (98,164x)
   981,640 ( 0.00%)  	swap(this->_M_deleter(), __rhs._M_deleter());
 8,245,776 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::_M_deleter() (196,328x)
 3,435,740 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<std::__future_base::_Result_base::_Deleter> >, std::is_move_constructible<std::__future_base::_Result_base::_Deleter>, std::is_move_assignable<std::__future_base::_Result_base::_Deleter> >::value, void>::type std::swap<std::__future_base::_Result_base::_Deleter>(std::__future_base::_Result_base::_Deleter&, std::__future_base::_Result_base::_Deleter&) (98,164x)
   392,656 ( 0.00%)        }
         .           
         .               private:
         .                 tuple<pointer, _Dp> _M_t;
         .               };
         .           
         .             // Defines move construction + assignment as either defaulted or deleted.
         .             template <typename _Tp, typename _Dp,
         .           	    bool = is_move_constructible<_Dp>::value,
         .           	    bool = is_move_assignable<_Dp>::value>
   981,640 ( 0.00%)      struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
 5,595,348 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::__uniq_ptr_impl() (98,164x)
         .               {
 4,222,447 ( 0.00%)        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
       214 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<ATrain, std::default_delete<ATrain> >::__uniq_ptr_impl(ATrain*) (2x)
 1,278,979 ( 0.00%)        __uniq_ptr_data(__uniq_ptr_data&&) = default;
       318 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<AVehicle, std::default_delete<AVehicle> >::__uniq_ptr_impl(std::__uniq_ptr_impl<AVehicle, std::default_delete<AVehicle> >&&) (3x)
         .                 __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
         .               };
         .           
         .             template <typename _Tp, typename _Dp>
         .               struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
         .               {
    35,325 ( 0.00%)        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
    16,644 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&>(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&)::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1}>::__uniq_ptr_impl<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&>(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&)::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1} const&>(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&>(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&)::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1} const&) (114x)
         .                 __uniq_ptr_data(__uniq_ptr_data&&) = default;
         .                 __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
         .               };
         .           
         .             template <typename _Tp, typename _Dp>
         .               struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
         .               {
         .                 using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
-- line 251 ----------------------------------------
-- line 290 ----------------------------------------
         .           	  __not_<is_array<_Up>>
         .                   >;
         .           
         .               public:
         .                 // Constructors.
         .           
         .                 /// Default constructor, creates a unique_ptr that owns nothing.
         .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
   392,656 ( 0.00%)  	constexpr unique_ptr() noexcept
   490,820 ( 0.00%)  	: _M_t()
 6,576,988 ( 0.01%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter, true, true>::__uniq_ptr_data() (98,164x)
   294,492 ( 0.00%)  	{ }
         .           
         .                 /** Takes ownership of a pointer.
         .                  *
         .                  * @param __p  A pointer to an object of @c element_type
         .                  *
         .                  * The deleter will be value-initialized.
         .                  */
         .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
         .           	_GLIBCXX23_CONSTEXPR
         .           	explicit
   491,340 ( 0.00%)  	unique_ptr(pointer __p) noexcept
   491,340 ( 0.00%)  	: _M_t(__p)
       240 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<ATrain, std::default_delete<ATrain>, true, true>::__uniq_ptr_impl(ATrain*) (2x)
   294,804 ( 0.00%)          { }
         .           
         .                 /** Takes ownership of a pointer.
         .                  *
         .                  * @param __p  A pointer to an object of @c element_type
         .                  * @param __d  A reference to a deleter.
         .                  *
         .                  * The deleter will be initialized with @p __d
         .                  */
         .                 template<typename _Del = deleter_type,
         .           	       typename = _Require<is_copy_constructible<_Del>>>
         .           	_GLIBCXX23_CONSTEXPR
    14,130 ( 0.00%)  	unique_ptr(pointer __p, const deleter_type& __d) noexcept
    21,195 ( 0.00%)  	: _M_t(__p, __d) { }
   243,754 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}, true, false>::__uniq_ptr_impl<nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1} const&) (1,514x)
         .           
         .                 /** Takes ownership of a pointer.
         .                  *
         .                  * @param __p  A pointer to an object of @c element_type
         .                  * @param __d  An rvalue reference to a (non-reference) deleter.
         .                  *
         .                  * The deleter will be initialized with @p std::move(__d)
         .                  */
-- line 334 ----------------------------------------
-- line 352 ----------------------------------------
         .                 template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
         .           	constexpr unique_ptr(nullptr_t) noexcept
         .           	: _M_t()
         .           	{ }
         .           
         .                 // Move constructors.
         .           
         .                 /// Move constructor.
 1,278,979 ( 0.00%)        unique_ptr(unique_ptr&&) = default;
     1,666 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<GameObject, std::default_delete<GameObject>, true, true>::__uniq_ptr_data(std::__uniq_ptr_data<GameObject, std::default_delete<GameObject>, true, true>&&) (14x)
         .           
         .                 /** @brief Converting constructor from another type
         .                  *
         .                  * Requires that the pointer owned by @p __u is convertible to the
         .                  * type of pointer owned by this object, @p __u does not own an array,
         .                  * and @p __u has a compatible deleter type.
         .                  */
         .                 template<typename _Up, typename _Ep, typename = _Require<
         .                          __safe_conversion_up<_Up, _Ep>,
         .           	       __conditional_t<is_reference<_Dp>::value,
         .           			       is_same<_Ep, _Dp>,
         .           			       is_convertible<_Ep, _Dp>>>>
         .           	_GLIBCXX23_CONSTEXPR
 1,374,310 ( 0.00%)  	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 2,748,620 ( 0.00%)  	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
       378 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<AVehicle, std::default_delete<AVehicle>, true, true>::__uniq_ptr_impl<std::default_delete<ATrain> >(AVehicle*, std::default_delete<ATrain>&&) (2x)
       218 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<ATrain, std::default_delete<ATrain> >::release() (2x)
       102 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<ATrain, std::default_delete<ATrain> >::get_deleter() (2x)
        12 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::default_delete<ATrain>&& std::forward<std::default_delete<ATrain> >(std::remove_reference<std::default_delete<ATrain> >::type&) (2x)
 1,177,980 ( 0.00%)  	{ }
         .           
         .           #if _GLIBCXX_USE_DEPRECATED
         .           #pragma GCC diagnostic push
         .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .                 /// Converting constructor from @c auto_ptr
         .                 template<typename _Up, typename = _Require<
         .           	       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
         .           	unique_ptr(auto_ptr<_Up>&& __u) noexcept;
         .           #pragma GCC diagnostic pop
         .           #endif
         .           
         .                 /// Destructor, invokes the deleter if the stored pointer is not null.
         .           #if __cplusplus > 202002L && __cpp_constexpr_dynamic_alloc
         .                 constexpr
         .           #endif
 2,468,700 ( 0.00%)        ~unique_ptr() noexcept
         .                 {
         .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
         .           		      "unique_ptr's deleter must be invocable with a pointer");
 1,974,960 ( 0.00%)  	auto& __ptr = _M_t._M_ptr();
       840 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::thread::_State, std::default_delete<std::thread::_State> >::_M_ptr() (20x)
 1,975,104 ( 0.00%)  	if (__ptr != nullptr)
 1,083,612 ( 0.00%)  	  get_deleter()(std::move(__ptr));
    20,230 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::default_delete<AActor>::operator()(AActor*) const (75x)
     3,825 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<AActor, std::default_delete<AActor> >::get_deleter() (75x)
       450 ( 0.00%)  => /usr/include/c++/14/bits/move.h:std::remove_reference<AActor*&>::type&& std::move<AActor*&>(AActor*&) (75x)
   987,480 ( 0.00%)  	__ptr = pointer();
 1,974,988 ( 0.00%)        }
         .           
         .                 // Assignment.
         .           
         .                 /** @brief Move assignment operator.
         .                  *
         .                  * Invokes the deleter if this object owns a pointer.
         .                  */
         .                 unique_ptr& operator=(unique_ptr&&) = default;
-- line 408 ----------------------------------------
-- line 437 ----------------------------------------
         .           	return *this;
         .                 }
         .           
         .                 // Observers.
         .           
         .                 /// Dereference the stored pointer.
         .                 _GLIBCXX23_CONSTEXPR
         .                 typename add_lvalue_reference<element_type>::type
   392,656 ( 0.00%)        operator*() const noexcept(noexcept(*std::declval<pointer>()))
         .                 {
   196,328 ( 0.00%)  	__glibcxx_assert(get() != pointer());
   294,492 ( 0.00%)  	return *get();
 5,104,528 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get() const (98,164x)
   196,328 ( 0.00%)        }
         .           
         .                 /// Return the stored pointer.
         .                 _GLIBCXX23_CONSTEXPR
         .                 pointer
   711,400 ( 0.00%)        operator->() const noexcept
         .                 {
         .           	_GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
   533,550 ( 0.00%)  	return get();
 3,884,400 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<AActor, std::default_delete<AActor> >::get() const (74,700x)
   355,700 ( 0.00%)        }
         .           
         .                 /// Return the stored pointer.
         .                 _GLIBCXX23_CONSTEXPR
         .                 pointer
 1,542,040 ( 0.00%)        get() const noexcept
 1,927,550 ( 0.00%)        { return _M_t._M_ptr(); }
       301 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<GameObject, std::default_delete<GameObject> >::_M_ptr() const (7x)
         .           
         .                 /// Return a reference to the stored deleter.
         .                 _GLIBCXX23_CONSTEXPR
         .                 deleter_type&
 1,179,272 ( 0.00%)        get_deleter() noexcept
 1,474,090 ( 0.00%)        { return _M_t._M_deleter(); }
    10,080 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::filesystem::__cxx11::path::_List::_Impl, std::filesystem::__cxx11::path::_List::_Impl_deleter>::_M_deleter() (240x)
         .           
         .                 /// Return a reference to the stored deleter.
         .                 _GLIBCXX23_CONSTEXPR
         .                 const deleter_type&
         .                 get_deleter() const noexcept
         .                 { return _M_t._M_deleter(); }
         .           
         .                 /// Return @c true if the stored pointer is not null.
         .                 _GLIBCXX23_CONSTEXPR
   421,692 ( 0.00%)        explicit operator bool() const noexcept
   737,961 ( 0.00%)        { return get() == pointer() ? false : true; }
    80,242 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}>::get() const (1,514x)
         .           
         .                 // Modifiers.
         .           
         .                 /// Release ownership of any stored pointer.
         .                 _GLIBCXX23_CONSTEXPR
         .                 pointer
   794,740 ( 0.00%)        release() noexcept
   993,425 ( 0.00%)        { return _M_t.release(); }
   154,428 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)#1}>::release() (1,514x)
         .           
         .                 /** @brief Replace the stored pointer.
         .                  *
         .                  * @param __p  The new pointer to store.
         .                  *
         .                  * The deleter will be invoked if a pointer is already owned.
         .                  */
         .                 _GLIBCXX23_CONSTEXPR
-- line 497 ----------------------------------------
-- line 501 ----------------------------------------
         .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
         .           		      "unique_ptr's deleter must be invocable with a pointer");
         .           	_M_t.reset(std::move(__p));
         .                 }
         .           
         .                 /// Exchange the pointer and deleter with another object.
         .                 _GLIBCXX23_CONSTEXPR
         .                 void
   490,820 ( 0.00%)        swap(unique_ptr& __u) noexcept
         .                 {
         .           	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
   490,820 ( 0.00%)  	_M_t.swap(__u._M_t);
27,093,264 ( 0.02%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::swap(std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>&) (98,164x)
   294,492 ( 0.00%)        }
         .           
         .                 // Disable copy from lvalue.
         .                 unique_ptr(const unique_ptr&) = delete;
         .                 unique_ptr& operator=(const unique_ptr&) = delete;
         .           
         .               private:
         .           #ifdef __glibcxx_out_ptr
         .                 template<typename, typename, typename...>
-- line 521 ----------------------------------------
-- line 597 ----------------------------------------
         .                  */
         .                 template<typename _Up,
         .           	       typename _Vp = _Dp,
         .           	       typename = _DeleterConstraint<_Vp>,
         .           	       typename = typename enable_if<
         .                            __safe_conversion_raw<_Up>::value, bool>::type>
         .           	_GLIBCXX23_CONSTEXPR
         .           	explicit
         5 ( 0.00%)  	unique_ptr(_Up __p) noexcept
         5 ( 0.00%)  	: _M_t(__p)
       120 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_data<std::thread, std::default_delete<std::thread []>, true, true>::__uniq_ptr_impl(std::thread*) (1x)
         3 ( 0.00%)          { }
         .           
         .                 /** Takes ownership of a pointer.
         .                  *
         .                  * @param __p  A pointer to an array of a type safely convertible
         .                  * to an array of @c element_type
         .                  * @param __d  A reference to a deleter.
         .                  *
         .                  * The deleter will be initialized with @p __d
-- line 615 ----------------------------------------
-- line 716 ----------------------------------------
         .           	return *this;
         .                 }
         .           
         .                 // Observers.
         .           
         .                 /// Access an element of owned array.
         .                 _GLIBCXX23_CONSTEXPR
         .                 typename std::add_lvalue_reference<element_type>::type
       100 ( 0.00%)        operator[](size_t __i) const
         .                 {
        40 ( 0.00%)  	__glibcxx_assert(get() != pointer());
       120 ( 0.00%)  	return get()[__i];
     1,040 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::thread [], std::default_delete<std::thread []> >::get() const (20x)
        40 ( 0.00%)        }
         .           
         .                 /// Return the stored pointer.
         .                 _GLIBCXX23_CONSTEXPR
         .                 pointer
        80 ( 0.00%)        get() const noexcept
       100 ( 0.00%)        { return _M_t._M_ptr(); }
       860 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::__uniq_ptr_impl<std::thread, std::default_delete<std::thread []> >::_M_ptr() const (20x)
         .           
         .                 /// Return a reference to the stored deleter.
         .                 _GLIBCXX23_CONSTEXPR
         .                 deleter_type&
         .                 get_deleter() noexcept
         .                 { return _M_t._M_deleter(); }
         .           
         .                 /// Return a reference to the stored deleter.
-- line 742 ----------------------------------------
-- line 837 ----------------------------------------
         .               operator==(const unique_ptr<_Tp, _Dp>& __x,
         .           	       const unique_ptr<_Up, _Ep>& __y)
         .               { return __x.get() == __y.get(); }
         .           
         .             /// unique_ptr comparison with nullptr
         .             template<typename _Tp, typename _Dp>
         .               _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
         .               inline bool
    11,775 ( 0.00%)      operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    14,130 ( 0.00%)      { return !__x; }
     7,296 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>::create<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >, std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&>(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > > const&)::{lambda(std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void>, std::less<void>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, nlohmann::json_abi_v3_11_3::basic_json<std::map, std::vector, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool, long, unsigned long, double, std::allocator, nlohmann::json_abi_v3_11_3::adl_serializer, std::vector<unsigned char, std::allocator<unsigned char> >, void> > > >*)#1}>::operator bool() const (114x)
         .           
         .           #ifndef __cpp_lib_three_way_comparison
         .             /// unique_ptr comparison with nullptr
         .             template<typename _Tp, typename _Dp>
         .               _GLIBCXX_NODISCARD
         .               inline bool
         .               operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
         .               { return !__x; }
-- line 854 ----------------------------------------
-- line 1067 ----------------------------------------
         .              *  @param __args Constructor arguments for the new object.
         .              *  @returns A `unique_ptr<_Tp>` that owns the new object.
         .              *  @since C++14
         .              *  @relates unique_ptr
         .              */
         .             template<typename _Tp, typename... _Args>
         .               _GLIBCXX23_CONSTEXPR
         .               inline __detail::__unique_ptr_t<_Tp>
       633 ( 0.00%)      make_unique(_Args&&... __args)
     2,192 ( 0.00%)      { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
       931 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<OBombKart, std::default_delete<OBombKart> >::unique_ptr<std::default_delete<OBombKart>, void>(OBombKart*) (7x)
       413 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (7x)
       252 ( 0.00%)  => /usr/include/c++/14/bits/move.h:int&& std::forward<int>(std::remove_reference<int>::type&) (42x)
       238 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/engine/courses/BombKart.cpp:OBombKart::OBombKart(unsigned short, unsigned short, float, float, float, float, float) (7x)
        42 ( 0.00%)  => /usr/include/c++/14/bits/move.h:double&& std::forward<double>(std::remove_reference<double>::type&) (7x)
         .           
         .             /** Create an array owned by a `unique_ptr`.
         .              *  @tparam _Tp An array type of unknown bound, such as `U[]`.
         .              *  @param __num The number of elements of type `U` in the new array.
         .              *  @returns A `unique_ptr<U[]>` that owns the new array.
         .              *  @since C++14
         .              *  @relates unique_ptr
         .              *
         .              *  The array elements are value-initialized.
         .              */
         .             template<typename _Tp>
         .               _GLIBCXX23_CONSTEXPR
         .               inline __detail::__unique_ptr_array_t<_Tp>
         8 ( 0.00%)      make_unique(size_t __num)
       175 ( 0.00%)      { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
     1,080 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       360 ( 0.00%)  => /usr/include/c++/14/bits/std_thread.h:std::thread::thread() (20x)
       133 ( 0.00%)  => /usr/include/c++/14/bits/unique_ptr.h:std::unique_ptr<std::thread [], std::default_delete<std::thread []> >::unique_ptr<std::thread*, std::default_delete<std::thread []>, void, bool>(std::thread*) (1x)
        63 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_opv.cc:operator new[](unsigned long) (1x)
         .           
         .             /** Disable std::make_unique for arrays of known bound.
         .              *  @tparam _Tp An array type of known bound, such as `U[N]`.
         .              *  @since C++14
         .              *  @relates unique_ptr
         .              */
         .             template<typename _Tp, typename... _Args>
         .               __detail::__invalid_make_unique_t<_Tp>
-- line 1099 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h
--------------------------------------------------------------------------------
Ir               

-- line 306 ----------------------------------------
      .           
      .             return __gthread_active_latest_value != 0;
      .           }
      .           
      .           #else /* not hppa-hpux */
      .           
      .           static inline int
      .           __gthread_active_p (void)
792,576 ( 0.00%)  {
396,288 ( 0.00%)    return 1;
792,576 ( 0.00%)  }
      .           
      .           #endif /* hppa-hpux */
      .           
      .           #endif /* __GXX_WEAK__ */
      .           
      .           #ifdef _LIBOBJC
      .           
      .           /* This is the config.h file in libobjc/ */
-- line 324 ----------------------------------------
-- line 703 ----------------------------------------
      .           static inline int
      .           __gthread_yield (void)
      .           {
      .             return __gthrw_(sched_yield) ();
      .           }
      .           
      .           static inline int
      .           __gthread_once (__gthread_once_t *__once, void (*__func) (void))
490,820 ( 0.00%)  {
490,820 ( 0.00%)    if (__gthread_active_p ())
490,820 ( 0.00%)  => /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_active_p() (98,164x)
687,152 ( 0.00%)      return __gthrw_(pthread_once) (__once, __func);
154,716,202 ( 0.13%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_once.c:pthread_once@@GLIBC_2.34 (98,164x)
  1,410 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      .             else
      .               return -1;
196,328 ( 0.00%)  }
      .           
      .           static inline int
      .           __gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
      .           {
      .             return __gthrw_(pthread_key_create) (__key, __dtor);
      .           }
      .           
      .           static inline int
-- line 724 ----------------------------------------
-- line 752 ----------------------------------------
      .             if (__gthread_active_p ())
      .               return __gthrw_(pthread_mutex_destroy) (__mutex);
      .             else
      .               return 0;
      .           }
      .           
      .           static inline int
      .           __gthread_mutex_lock (__gthread_mutex_t *__mutex)
596,288 ( 0.00%)  {
745,360 ( 0.00%)    if (__gthread_active_p ())
745,360 ( 0.00%)  => /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_active_p() (149,072x)
769,012 ( 0.00%)      return __gthrw_(pthread_mutex_lock) (__mutex);
5,366,592 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_lock.c:pthread_mutex_lock@@GLIBC_2.2.5 (149,072x)
      .             else
      .               return 0;
298,144 ( 0.00%)  }
      .           
      .           static inline int
      .           __gthread_mutex_trylock (__gthread_mutex_t *__mutex)
      .           {
      .             if (__gthread_active_p ())
      .               return __gthrw_(pthread_mutex_trylock) (__mutex);
      .             else
      .               return 0;
-- line 773 ----------------------------------------
-- line 782 ----------------------------------------
      .               return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);
      .             else
      .               return 0;
      .           }
      .           #endif
      .           
      .           static inline int
      .           __gthread_mutex_unlock (__gthread_mutex_t *__mutex)
596,208 ( 0.00%)  {
745,260 ( 0.00%)    if (__gthread_active_p ())
745,260 ( 0.00%)  => /usr/include/c++/14/x86_64-redhat-linux/bits/gthr-default.h:__gthread_active_p() (149,052x)
768,922 ( 0.00%)      return __gthrw_(pthread_mutex_unlock) (__mutex);
4,774,944 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_unlock.c:pthread_mutex_unlock@@GLIBC_2.2.5 (149,052x)
      .             else
      .               return 0;
298,104 ( 0.00%)  }
      .           
      .           #if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \
      .             || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)
      .           static inline int
      .           __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
      .           {
      .             if (__gthread_active_p ())
      .               {
-- line 803 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/hash_bytes.cc
  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/dl-lookup.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/getc.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/libioP.h
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/arena.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_lock.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_unlock.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_once.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_self.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/../stdlib/strtol_l.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/getenv.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcspn-sse4.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/StrKeysym.c
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/VisUtil.c
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/xlibi18n/lcFile.c
  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/hashmap.c
  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/path-util.c
  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/siphash24.c
  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inffast_tpl.h
  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inflate.c
  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inftrees.c

--------------------------------------------------------------------------------
Ir                       
--------------------------------------------------------------------------------
119,348,661,902 (98.88%)  events annotated

