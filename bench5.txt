--------------------------------------------------------------------------------
Profile data file 'callgrind.out.86022' (creator: callgrind-3.23.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 7906996949
Trigger: Program termination
Profiled target:  ./build/Spaghettify (PID 86022, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
58,941,547,270 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                       file:function
--------------------------------------------------------------------------------
43,760,414,797 (74.24%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 6,873,578,588 (11.66%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 2,718,601,667 ( 4.61%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_run(Gfx*, std::unordered_map<MtxS*, MtxF, std::hash<MtxS*>, std::equal_to<MtxS*>, std::allocator<std::pair<MtxS* const, MtxF> > > const&) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
 1,915,775,793 ( 3.25%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tri2_handler_f3dex(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   661,321,908 ( 1.12%)  /usr/include/c++/14/bits/stl_deque.h:gfx_run(Gfx*, std::unordered_map<MtxS*, MtxF, std::hash<MtxS*>, std::equal_to<MtxS*>, std::allocator<std::pair<MtxS* const, MtxF> > > const&)
   165,327,620 ( 0.28%)  libultraship/src/graphic/Fast3D/debug/GfxDebugger.cpp:Fast::GfxDebugger::IsDebugging() const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   147,248,280 ( 0.25%)  /usr/include/c++/14/bits/hashtable_policy.h:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool)
   145,589,776 ( 0.25%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_vtx_handler_f3dex(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   137,353,689 ( 0.23%)  /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const [clone .isra.0] [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
   102,255,750 ( 0.17%)  /usr/include/c++/14/bits/hashtable.h:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool)
    98,662,200 ( 0.17%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib64/libc.so.6]
    81,972,190 ( 0.14%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_free [/usr/lib64/libc.so.6]
    68,197,693 ( 0.12%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc [/usr/lib64/libc.so.6]
    62,433,495 ( 0.11%)  /usr/include/c++/14/bits/hashtable_policy.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const [clone .isra.0]
    44,992,530 ( 0.08%)  /usr/include/c++/14/any:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool)
    43,559,919 ( 0.07%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_malloc [/usr/lib64/libc.so.6]
    41,085,316 ( 0.07%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free [/usr/lib64/libc.so.6]
    36,020,064 ( 0.06%)  build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    34,753,282 ( 0.06%)  ???:0x0000000000847890 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    27,597,469 ( 0.05%)  ???:0x0000000000a7c320 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    26,104,513 ( 0.04%)  ???:0x0000000000ad9080 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    25,387,802 ( 0.04%)  ???:0x0000000000b29bc0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    24,680,016 ( 0.04%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_ci8(int, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    24,628,767 ( 0.04%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms [/usr/lib64/libc.so.6]
    23,781,424 ( 0.04%)  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/hash_bytes.cc:std::_Hash_bytes(void const*, unsigned long, unsigned long) [/usr/lib64/libstdc++.so.6.0.33]
    23,738,316 ( 0.04%)  ???:0x0000000000f7a470 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    21,927,101 ( 0.04%)  ???:0x0000000000b2c2d0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    18,339,257 ( 0.03%)  ???:0x0000000000816080 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    17,831,665 ( 0.03%)  ???:0x0000000000b61150 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    16,418,628 ( 0.03%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/getc.c:getc [/usr/lib64/libc.so.6]
    15,158,625 ( 0.03%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 [/usr/lib64/libc.so.6]
    14,846,028 ( 0.03%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_lock.c:pthread_mutex_lock@@GLIBC_2.2.5 [/usr/lib64/libc.so.6]
    14,047,085 ( 0.02%)  ???:0x00000000006fd110 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    13,746,611 ( 0.02%)  build/_deps/imgui-src/imstb_truetype.h:ImFontAtlasBuildWithStbTruetype(ImFontAtlas*)
    13,187,808 ( 0.02%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    12,925,716 ( 0.02%)  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) [/usr/lib64/libstdc++.so.6.0.33]
    12,785,013 ( 0.02%)  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inffast_tpl.h:inflate_fast_avx2 [/usr/lib64/libz.so.1.3.1.zlib-ng]
    12,486,699 ( 0.02%)  /usr/include/c++/14/bits/functional_hash.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const [clone .isra.0]
    12,486,699 ( 0.02%)  /usr/include/c++/14/bits/stl_function.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const [clone .isra.0]
    12,417,632 ( 0.02%)  /usr/include/c++/14/bits/stl_function.h:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool)
    12,341,508 ( 0.02%)  ???:0x0000000000a25d20 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    12,307,942 ( 0.02%)  ???:0x0000000000069100 [/usr/lib64/libnvidia-glsi.so.560.35.03]
    12,252,451 ( 0.02%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_unlock.c:__pthread_mutex_unlock_usercnt [/usr/lib64/libc.so.6]
    11,821,465 ( 0.02%)  ???:0x0000000000a1b880 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    11,796,280 ( 0.02%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture(int, int, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    11,414,402 ( 0.02%)  ???:0x000000000087e2a0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    11,155,740 ( 0.02%)  ???:0x00000000007aa5e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    10,971,937 ( 0.02%)  ???:0x00000000007a2bb0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    10,520,523 ( 0.02%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_combine_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,417,621 ( 0.02%)  ???:0x0000000000fc60e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    10,399,823 ( 0.02%)  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inftrees.c:zng_inflate_table [/usr/lib64/libz.so.1.3.1.zlib-ng]
    10,337,064 ( 0.02%)  /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
    10,106,837 ( 0.02%)  ???:0x0000000000a70090 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    10,106,718 ( 0.02%)  ???:0x00000000009f1040 [/usr/lib64/libnvidia-glcore.so.560.35.03]
    10,012,782 ( 0.02%)  ???:0x0000000000a22680 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     9,822,389 ( 0.02%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/dl-lookup.c:do_lookup_x [/usr/lib64/ld-linux-x86-64.so.2]
     9,655,773 ( 0.02%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 [/usr/lib64/libc.so.6]
     9,466,157 ( 0.02%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_matrix(unsigned char, int const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     9,189,529 ( 0.02%)  build/_deps/stormlib-src/src/SBaseCommon.cpp:LoadMpqTable(_TMPQArchive*, unsigned long long, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     8,972,146 ( 0.02%)  ???:0x000000000093eb10 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,830,366 ( 0.01%)  ???:0x0000000000b4e1a0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     8,634,846 ( 0.01%)  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inflate.c:inflate [/usr/lib64/libz.so.1.3.1.zlib-ng]
     8,316,931 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_clip_parameters()
     8,053,500 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_shader_get_info(ShaderProgram*, unsigned char*, bool*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,681,704 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:calloc [/usr/lib64/libc.so.6]
     7,507,488 ( 0.01%)  ???:0x0000000000a241b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,489,852 ( 0.01%)  src/racing/actors.c:evaluate_collision_for_players_and_actors [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,463,599 ( 0.01%)  ???:0x0000000000847970 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,456,117 ( 0.01%)  ???:0x0000000000b5e190 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,451,743 ( 0.01%)  ???:0x0000000000b5fd40 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,207,309 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe [/usr/lib64/libc.so.6]
     7,201,657 ( 0.01%)  ???:0x0000000000b5a2b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     7,117,535 ( 0.01%)  build/_deps/imgui-src/imgui.cpp:ImGui::UpdateKeyboardInputs() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     7,065,183 ( 0.01%)  ???:0x0000000000815e50 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,989,806 ( 0.01%)  ???:0x0000000000a70ff0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,989,224 ( 0.01%)  ???:0x0000000000fc04d0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,983,668 ( 0.01%)  ???:0x0000000001006030 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,903,423 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c:nexttoken [/usr/lib64/libX11.so.6.4.0]
     6,849,402 ( 0.01%)  ???:0x0000000000b6f140 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,697,602 ( 0.01%)  /usr/include/c++/14/bits/stl_deque.h:GfxExecStack::ret()
     6,651,833 ( 0.01%)  src/code_80091750.c:func_800A7A4C [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,615,607 ( 0.01%)  ???:0x00000000006eb0a0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,570,013 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c:parsestringfile [/usr/lib64/libX11.so.6.4.0]
     6,374,430 ( 0.01%)  ???:0x0000000000819120 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,315,384 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c:nextch [/usr/lib64/libX11.so.6.4.0]
     6,260,868 ( 0.01%)  ???:0x0000000000fbafd0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,081,542 ( 0.01%)  build/_deps/stormlib-src/src/SFileListFile.cpp:SFileAddArbitraryListFile(_TMPQArchive*, void*, char const*, unsigned int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     6,077,984 ( 0.01%)  ???:0x0000000000a21360 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     6,067,649 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_once.c:__pthread_once_slow.isra.0 [/usr/lib64/libc.so.6]
     6,059,356 ( 0.01%)  ???:0x0000000000b21b20 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,938,085 ( 0.01%)  libultraship/src/utils/StrHash64.cpp:CRC64(char const*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,910,038 ( 0.01%)  ???:0x0000000000a6fc20 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,891,158 ( 0.01%)  ???:0x0000000000a750c0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,874,934 ( 0.01%)  ???:0x0000000000a70fb0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,853,219 ( 0.01%)  ???:0x0000000000a25600 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,839,612 ( 0.01%)  ???:0x0000000000b839e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,833,634 ( 0.01%)  ???:0x00000000009f1060 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,714,130 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_block(unsigned char, unsigned int, unsigned int, unsigned int, unsigned int) [clone .isra.0] [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,712,880 ( 0.01%)  ???:0x0000000000abe6d0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,575,339 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_free_merge_chunk [/usr/lib64/libc.so.6]
     5,553,305 ( 0.01%)  ???:0x0000000000a6d610 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,472,876 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/libioP.h:getc
     5,413,068 ( 0.01%)  ???:0x0000000000ac1cf0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,396,025 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dl_handler_common(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,391,105 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__fill_active_edges_new(float*, float*, int, stbtt__active_edge*, float) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,362,695 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 [/usr/lib64/libc.so.6]
     5,358,763 ( 0.01%)  ???:0x00000000006ebb10 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,306,243 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,287,379 ( 0.01%)  ???:0x0000000000cdbab0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,230,214 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_cc.h:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool)
     5,199,869 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     5,197,821 ( 0.01%)  ???:0x000000000070dc80 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     5,142,210 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:ResourceGetNameByCrc
     5,103,048 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_self.c:pthread_self [/usr/lib64/libc.so.6]
     4,978,248 ( 0.01%)  ???:0x00000000009f1220 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,894,094 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::ret() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,825,614 ( 0.01%)  build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyphShapeTT(stbtt_fontinfo const*, int, stbtt_vertex**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,677,611 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_timg_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,658,892 ( 0.01%)  ???:0x0000000000abcfe0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,537,509 ( 0.01%)  ???:0x00000000006fd4e0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,507,391 ( 0.01%)  ???:0x00000000009f1720 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,483,813 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/arena.c:free
     4,391,890 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>)'2
     4,329,760 ( 0.01%)  ???:0x0000000000b242f0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     4,211,499 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:_int_free_create_chunk [/usr/lib64/libc.so.6]
     4,145,652 ( 0.01%)  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/path-util.c:path_find_first_component [/usr/lib64/libudev.so.1.7.8]
     4,137,858 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) [clone .isra.0] [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,119,172 ( 0.01%)  /usr/src/debug/libXi-1.8.2-1.fc40.x86_64/src/XExtInt.c:XInputWireToCookie [/usr/lib64/libXi.so.6.1.0]
     4,112,961 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     4,001,497 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)
     3,962,157 ( 0.01%)  ???:0x0000000000b27090 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,942,361 ( 0.01%)  libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,873,000 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<std::promise<std::shared_ptr<Ship::IResource> >, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,811,282 ( 0.01%)  ???:0x0000000000fb6ed0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,776,728 ( 0.01%)  ???:0x0000000000a6d7c0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,773,723 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>)'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,743,639 ( 0.01%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,702,679 ( 0.01%)  ???:glXGetConfig [/usr/lib64/libGLX_nvidia.so.560.35.03]
     3,687,187 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:unlink_chunk.isra.0 [/usr/lib64/libc.so.6]
     3,682,616 ( 0.01%)  ???:0x0000000000a25c50 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,587,672 ( 0.01%)  ???:0x00000000005705b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,559,235 ( 0.01%)  ???:0x00000000007cf230 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,557,886 ( 0.01%)  ???:0x0000000000a74ac0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,501,427 ( 0.01%)  ???:0x0000000000b5b1f0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,433,252 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:gfx_set_timg_handler_rdp(F3DGfx**)
     3,390,272 ( 0.01%)  build/_deps/imgui-src/imgui_draw.cpp:ImFont::RenderText(ImDrawList*, float, ImVec2 const&, unsigned int, ImVec4 const&, char const*, char const*, float, bool) const [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,347,184 ( 0.01%)  /usr/include/c++/14/bits/shared_ptr_base.h:gSPDisplayList
     3,342,574 ( 0.01%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcspn-sse4.c:__strcspn_sse42 [/usr/lib64/libc.so.6]
     3,339,585 ( 0.01%)  src/racing/actors.c:evaluate_collision_between_player_actor [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,303,870 ( 0.01%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_othermode_h_handler_f3d(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,239,433 ( 0.01%)  /usr/include/c++/14/future:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>)'2
     3,203,890 ( 0.01%)  ???:0x0000000000fc2730 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,178,384 ( 0.01%)  ???:0x0000000000b1fe30 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,165,400 ( 0.01%)  ???:0x0000000000a29660 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,107,027 ( 0.01%)  src/code_80057C60.c:func_80062B18 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,093,516 ( 0.01%)  ???:0x0000000000fc95c0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     3,060,885 ( 0.01%)  src/port/GBIMiddleware.cpp:gSPDisplayList [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,057,557 ( 0.01%)  /usr/src/debug/libxcb-1.17.0-2.fc40.x86_64/src/xcb_in.c:_xcb_in_read [/usr/lib64/libxcb.so.1.1.0]
     3,055,274 ( 0.01%)  build/_deps/imgui-src/imgui.cpp:ImGui::Begin(char const*, bool*, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,040,116 ( 0.01%)  src/racing/collision.c:generate_collision_grid [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     3,008,129 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/StrKeysym.c:XStringToKeysym [/usr/lib64/libX11.so.6.4.0]
     2,976,328 ( 0.01%)  ???:0x000000000076ef90 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,970,808 ( 0.01%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/xlibi18n/lcFile.c:resolve_name [/usr/lib64/libX11.so.6.4.0]
     2,954,169 ( 0.01%)  ???:0x00000000007bbb50 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,895,982 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc_consolidate [/usr/lib64/libc.so.6]
     2,795,839 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)'2 [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,778,616 ( 0.00%)  ???:0x0000000000b2bdd0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,773,614 ( 0.00%)  src/racing/math_util.c:coss [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,766,524 ( 0.00%)  ???:0x00000000007ace90 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,731,160 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_draw_rectangle(int, int, int, int) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,710,915 ( 0.00%)  /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_destroy() [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,705,963 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/getenv.c:getenv [/usr/lib64/libc.so.6]
     2,678,936 ( 0.00%)  ???:0x0000000000a5de00 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,677,915 ( 0.00%)  libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,671,943 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,623,508 ( 0.00%)  src/racing/math_util.c:mtxf_pos_rotation_xyz [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,593,440 ( 0.00%)  ???:0x0000000000b28ca0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,571,105 ( 0.00%)  /usr/include/c++/14/ext/atomicity.h:ResourceGetNameByCrc
     2,555,399 ( 0.00%)  ???:0x0000000000b1d430 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,527,531 ( 0.00%)  /usr/include/c++/14/bits/hashtable.h:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool)
     2,520,570 ( 0.00%)  ???:0x00000000007891f0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,507,079 ( 0.00%)  ???:0x0000000000847d70 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,489,080 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tex_rect_and_flip_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,471,129 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool)
     2,462,938 ( 0.00%)  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/VisUtil.c:XGetVisualInfo [/usr/lib64/libX11.so.6.4.0]
     2,441,938 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_draw_triangles(float*, unsigned long, unsigned long) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,434,320 ( 0.00%)  /usr/include/fmt/format.h:void fmt::v10::detail::buffer<char>::append<char>(char const*, char const*) [/usr/lib64/libspdlog.so.1.12.0]
     2,434,300 ( 0.00%)  src/racing/math_util.c:sins [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,414,809 ( 0.00%)  ???:0x0000000000b5bd50 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,411,183 ( 0.00%)  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/hashmap.c:bucket_move_entry.lto_priv.0 [/usr/lib64/libudev.so.1.7.8]
     2,392,956 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_size_handler_rdp(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,364,308 ( 0.00%)  ???:0x0000000000b83200 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,324,628 ( 0.00%)  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/../stdlib/strtol_l.c:____strtoul_l_internal [/usr/lib64/libc.so.6]
     2,318,796 ( 0.00%)  libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_end_dl_handler_common(F3DGfx**) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]
     2,304,096 ( 0.00%)  /usr/include/c++/14/bits/hashtable_policy.h:gfx_sp_matrix(unsigned char, int const*)
     2,276,804 ( 0.00%)  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/siphash24.c:siphash24_compress [/usr/lib64/libudev.so.1.7.8]
     2,275,210 ( 0.00%)  ???:0x00000000007199b0 [/usr/lib64/libnvidia-glcore.so.560.35.03]
     2,264,043 ( 0.00%)  /usr/include/fmt/core.h:fmt::v10::appender fmt::v10::vformat_to<fmt::v10::appender, 0>(fmt::v10::appender, fmt::v10::basic_string_view<char>, fmt::v10::basic_format_args<fmt::v10::basic_format_context<fmt::v10::appender, char> >) [/home/coco/Documents/GitHub/SpaghettiKart/build/Spaghettify]

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_pc.cpp
--------------------------------------------------------------------------------
Ir                     

-- line 64 ----------------------------------------
            .           // Ratios for current window dimensions or active framebuffer scaled size
            .           #define RATIO_X \
            .               ((fbActive ? active_fb->second.applied_width : gfx_current_dimensions.width) / (2.0f * HALF_SCREEN_WIDTH))
            .           #define RATIO_Y \
            .               ((fbActive ? active_fb->second.applied_height : gfx_current_dimensions.height) / (2.0f * HALF_SCREEN_HEIGHT))
            .           
            .           #define TEXTURE_CACHE_MAX_SIZE 500
            .           
            7 ( 0.00%)  static struct {
            .               TextureCacheMap map;
            .               list<TextureCacheMapIter> lru;
            .               vector<uint32_t> free_texture_ids;
            .           } gfx_texture_cache;
            .           
            .           struct ColorCombiner {
            .               uint64_t shader_id0;
            .               uint32_t shader_id1;
            .               bool used_textures[2];
            .               struct ShaderProgram* prg[16];
            .               uint8_t shader_input_mapping[2][7];
            .           };
            .           
            .           static map<ColorCombinerKey, struct ColorCombiner> color_combiner_pool;
            1 ( 0.00%)  static map<ColorCombinerKey, struct ColorCombiner>::iterator prev_combiner = color_combiner_pool.end();
            .           
            .           static uint8_t* tex_upload_buffer = nullptr;
            .           
            .           RSP g_rsp;
            .           RDP g_rdp;
            .           static struct RenderingState {
            .               uint8_t depth_test_and_mask; // 1: depth test, 2: depth mask
            .               bool decal_mode;
-- line 95 ----------------------------------------
-- line 150 ----------------------------------------
            .           static map<string, MaskedTextureEntry> masked_textures;
            .           
            .           static UcodeHandlers ucode_handler_index = ucode_f3dex2;
            .           
            .           const static std::unordered_map<Attribute, std::any> f3dex2AttrHandler = {
            .               { MTX_PROJECTION, F3DEX2_G_MTX_PROJECTION }, { MTX_LOAD, F3DEX2_G_MTX_LOAD },     { MTX_PUSH, F3DEX2_G_MTX_PUSH },
            .               { MTX_NOPUSH, F3DEX_G_MTX_NOPUSH },          { CULL_FRONT, F3DEX2_G_CULL_FRONT }, { CULL_BACK, F3DEX2_G_CULL_BACK },
            .               { CULL_BOTH, F3DEX2_G_CULL_BOTH },
           21 ( 0.00%)  };
            .           
            .           const static std::unordered_map<Attribute, std::any> f3dexAttrHandler = { { MTX_PROJECTION, F3DEX_G_MTX_PROJECTION },
            .                                                                                     { MTX_LOAD, F3DEX_G_MTX_LOAD },
            .                                                                                     { MTX_PUSH, F3DEX_G_MTX_PUSH },
            .                                                                                     { MTX_NOPUSH, F3DEX_G_MTX_NOPUSH },
            .                                                                                     { CULL_FRONT, F3DEX_G_CULL_FRONT },
            .                                                                                     { CULL_BACK, F3DEX_G_CULL_BACK },
           21 ( 0.00%)                                                                            { CULL_BOTH, F3DEX_G_CULL_BOTH } };
            .           
            .           static constexpr std::array ucode_attr_handlers = {
            .               &f3dexAttrHandler,
            .               &f3dexAttrHandler,
            .               &f3dex2AttrHandler,
            .               &f3dex2AttrHandler,
            .           };
            .           
            .           template <typename T> static constexpr T get_attr(Attribute attr) {
    8,324,466 ( 0.01%)      const auto ucode_map = ucode_attr_handlers[ucode_handler_index];
   24,973,398 ( 0.04%)      assert(ucode_map->contains(attr) && "Attribute not found in the current ucode handler");
            .               return std::any_cast<T>(ucode_map->at(attr));
            .           }
            .           
            .           static std::string GetPathWithoutFileName(char* filePath) {
            .               size_t len = strlen(filePath);
            .           
            .               for (size_t i = len - 1; i >= 0; i--) {
            .                   if (filePath[i] == '/' || filePath[i] == '\\') {
-- line 185 ----------------------------------------
-- line 186 ----------------------------------------
            .                       return std::string(filePath).substr(0, i);
            .                   }
            .               }
            .           
            .               return filePath;
            .           }
            .           
            .           static void gfx_flush(void) {
      337,281 ( 0.00%)      if (buf_vbo_len > 0) {
      349,378 ( 0.00%)          gfx_rapi->draw_triangles(buf_vbo, buf_vbo_len, buf_vbo_num_tris);
  609,634,675 ( 1.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_draw_triangles(float*, unsigned long, unsigned long) (64,046x)
       64,617 ( 0.00%)          buf_vbo_len = 0;
      902,593 ( 0.00%)          buf_vbo_num_tris = 0;
            .               }
            .           }
            .           
            .           static struct ShaderProgram* gfx_lookup_or_create_shader_program(uint64_t shader_id0, uint32_t shader_id1) {
          115 ( 0.00%)      struct ShaderProgram* prg = gfx_rapi->lookup_shader(shader_id0, shader_id1);
          918 ( 0.00%)  => /usr/include/c++/14/bits/stl_tree.h:gfx_opengl_lookup_shader(unsigned long, unsigned int) (23x)
           92 ( 0.00%)      if (prg == NULL) {
           57 ( 0.00%)          gfx_rapi->unload_shader(rendering_state.shader_program);
        5,197 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_unload_shader(ShaderProgram*) (19x)
           95 ( 0.00%)          prg = gfx_rapi->create_and_load_new_shader(shader_id0, shader_id1);
   18,273,547 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_create_and_load_new_shader(unsigned long, unsigned int) (19x)
           76 ( 0.00%)          rendering_state.shader_program = prg;
            .               }
            .               return prg;
            .           }
            .           
            .           static const char* ccmux_to_string(uint32_t ccmux) {
            .               static const char* const tbl[] = {
            .                   "G_CCMUX_COMBINED",
            .                   "G_CCMUX_TEXEL0",
-- line 214 ----------------------------------------
-- line 245 ----------------------------------------
            .                   "G_ACMUX_ENVIRONMENT",
            .                   "G_ACMUX_1 or G_ACMUX_PRIM_LOD_FRAC",
            .                   "G_ACMUX_0",
            .               };
            .               return tbl[acmux];
            .           }
            .           
            .           static void gfx_generate_cc(struct ColorCombiner* comb, const ColorCombinerKey& key) {
           63 ( 0.00%)      bool is_2cyc = (key.options & SHADER_OPT(_2CYC)) != 0;
            .           
            .               uint8_t c[2][2][4];
            .               uint64_t shader_id0 = 0;
            .               uint32_t shader_id1 = key.options;
           42 ( 0.00%)      uint8_t shader_input_mapping[2][7] = { { 0 } };
            .               bool used_textures[2] = { false, false };
           82 ( 0.00%)      for (uint32_t i = 0; i < 2 && (i == 0 || is_2cyc); i++) {
          111 ( 0.00%)          uint32_t rgb_a = (key.combine_mode >> (i * 28)) & 0xf;
          133 ( 0.00%)          uint32_t rgb_b = (key.combine_mode >> (i * 28 + 4)) & 0xf;
           44 ( 0.00%)          uint32_t rgb_c = (key.combine_mode >> (i * 28 + 8)) & 0x1f;
           66 ( 0.00%)          uint32_t rgb_d = (key.combine_mode >> (i * 28 + 13)) & 7;
          108 ( 0.00%)          uint32_t alpha_a = (key.combine_mode >> (i * 28 + 16)) & 7;
           87 ( 0.00%)          uint32_t alpha_b = (key.combine_mode >> (i * 28 + 16 + 3)) & 7;
           88 ( 0.00%)          uint32_t alpha_c = (key.combine_mode >> (i * 28 + 16 + 6)) & 7;
          108 ( 0.00%)          uint32_t alpha_d = (key.combine_mode >> (i * 28 + 16 + 9)) & 7;
            .           
            .                   if (rgb_a >= 8) {
            .                       rgb_a = G_CCMUX_0;
            .                   }
            .                   if (rgb_b >= 8) {
            .                       rgb_b = G_CCMUX_0;
            .                   }
           44 ( 0.00%)          if (rgb_c >= 16) {
            .                       rgb_c = G_CCMUX_0;
            .                   }
           56 ( 0.00%)          if (rgb_d == 7) {
            .                       rgb_d = G_CCMUX_0;
            .                   }
            .           
           36 ( 0.00%)          if (rgb_a == rgb_b || rgb_c == G_CCMUX_0) {
            .                       // Normalize
            .                       rgb_a = G_CCMUX_0;
            .                       rgb_b = G_CCMUX_0;
            .                       rgb_c = G_CCMUX_0;
            .                   }
          160 ( 0.00%)          if (alpha_a == alpha_b || alpha_c == G_ACMUX_0) {
            .                       // Normalize
            1 ( 0.00%)              alpha_a = G_ACMUX_0;
            1 ( 0.00%)              alpha_b = G_ACMUX_0;
            .                       alpha_c = G_ACMUX_0;
            .                   }
            .                   if (i == 1) {
            4 ( 0.00%)              if (rgb_a != G_CCMUX_COMBINED && rgb_b != G_CCMUX_COMBINED && rgb_c != G_CCMUX_COMBINED &&
            .                           rgb_d != G_CCMUX_COMBINED) {
            .                           // First cycle RGB not used, so clear it away
            .                           c[0][0][0] = c[0][0][1] = c[0][0][2] = c[0][0][3] = G_CCMUX_0;
            .                       }
            8 ( 0.00%)              if (rgb_c != G_CCMUX_COMBINED_ALPHA && alpha_a != G_ACMUX_COMBINED && alpha_b != G_ACMUX_COMBINED &&
            .                           alpha_d != G_ACMUX_COMBINED) {
            .                           // First cycle ALPHA not used, so clear it away
            .                           c[0][1][0] = c[0][1][1] = c[0][1][2] = c[0][1][3] = G_ACMUX_0;
            .                       }
            .                   }
            .           
          462 ( 0.00%)          c[i][0][0] = rgb_a;
            .                   c[i][0][1] = rgb_b;
            9 ( 0.00%)          c[i][0][2] = rgb_c;
           46 ( 0.00%)          c[i][0][3] = rgb_d;
            5 ( 0.00%)          c[i][1][0] = alpha_a;
            .                   c[i][1][1] = alpha_b;
            5 ( 0.00%)          c[i][1][2] = alpha_c;
           21 ( 0.00%)          c[i][1][3] = alpha_d;
            .               }
            .               if (!is_2cyc) {
            .                   for (uint32_t i = 0; i < 2; i++) {
            .                       for (uint32_t k = 0; k < 4; k++) {
            .                           c[1][i][k] = i == 0 ? G_CCMUX_0 : G_ACMUX_0;
            .                       }
            .                   }
            .               }
            .               {
          210 ( 0.00%)          uint8_t input_number[32] = { 0 };
            .                   uint32_t next_input_number = SHADER_INPUT_1;
           86 ( 0.00%)          for (uint32_t i = 0; i < 2 && (i == 0 || is_2cyc); i++) {
          373 ( 0.00%)              for (uint32_t j = 0; j < 4; j++) {
            .                           uint32_t val = 0;
          440 ( 0.00%)                  switch (c[i][0][j]) {
            .                               case G_CCMUX_0:
            .                                   val = SHADER_0;
            .                                   break;
            .                               case G_CCMUX_1:
            .                                   val = SHADER_1;
            1 ( 0.00%)                          break;
            .                               case G_CCMUX_TEXEL0:
            .                                   val = SHADER_TEXEL0;
            .                                   // Set the opposite texture when reading from the second cycle color options
            .                                   if (i == 0) {
           13 ( 0.00%)                              used_textures[0] = true;
            .                                   } else {
            .                                       used_textures[1] = true;
            .                                   }
            .                                   break;
            .                               case G_CCMUX_TEXEL1:
            .                                   val = SHADER_TEXEL1;
            .                                   if (i == 0) {
            .                                       used_textures[1] = true;
            .                                   } else {
            .                                       used_textures[0] = true;
            .                                   }
            .                                   break;
            .                               case G_CCMUX_TEXEL0_ALPHA:
            .                                   val = SHADER_TEXEL0A;
            .                                   if (i == 0) {
            1 ( 0.00%)                              used_textures[0] = true;
            .                                   } else {
            .                                       used_textures[1] = true;
            .                                   }
            .                                   break;
            .                               case G_CCMUX_TEXEL1_ALPHA:
            .                                   val = SHADER_TEXEL1A;
            .                                   if (i == 0) {
            .                                       used_textures[1] = true;
-- line 365 ----------------------------------------
-- line 372 ----------------------------------------
            .                                   break;
            .                               case G_CCMUX_PRIMITIVE:
            .                               case G_CCMUX_PRIMITIVE_ALPHA:
            .                               case G_CCMUX_PRIM_LOD_FRAC:
            .                               case G_CCMUX_SHADE:
            .                               case G_CCMUX_ENVIRONMENT:
            .                               case G_CCMUX_ENV_ALPHA:
            .                               case G_CCMUX_LOD_FRACTION:
           84 ( 0.00%)                          if (input_number[c[i][0][j]] == 0) {
           38 ( 0.00%)                              shader_input_mapping[0][next_input_number - 1] = c[i][0][j];
           57 ( 0.00%)                              input_number[c[i][0][j]] = next_input_number++;
            .                                   }
            .                                   val = input_number[c[i][0][j]];
           21 ( 0.00%)                          break;
            .                               case G_CCMUX_COMBINED:
            .                                   val = SHADER_COMBINED;
            .                                   break;
            .                               default:
            .                                   fprintf(stderr, "Unsupported ccmux: %d\n", c[i][0][j]);
            .                                   break;
            .                           }
          126 ( 0.00%)                  shader_id0 |= (uint64_t)val << (i * 32 + j * 4);
            .                       }
            .                   }
            .               }
            .               {
           42 ( 0.00%)          uint8_t input_number[16] = { 0 };
            9 ( 0.00%)          uint32_t next_input_number = SHADER_INPUT_1;
            .                   for (uint32_t i = 0; i < 2; i++) {
            .                       for (uint32_t j = 0; j < 4; j++) {
            .                           uint32_t val = 0;
          747 ( 0.00%)                  switch (c[i][1][j]) {
            .                               case G_ACMUX_0:
            .                                   val = SHADER_0;
            .                                   break;
            .                               case G_ACMUX_TEXEL0:
            .                                   val = SHADER_TEXEL0;
            .                                   // Set the opposite texture when reading from the second cycle color options
            .                                   if (i == 0) {
           19 ( 0.00%)                              used_textures[0] = true;
            .                                   } else {
    1,150,500 ( 0.00%)                              used_textures[1] = true;
            .                                   }
            .                                   break;
            .                               case G_ACMUX_TEXEL1:
            .                                   val = SHADER_TEXEL1;
            .                                   if (i == 0) {
            .                                       used_textures[1] = true;
            .                                   } else {
            .                                       used_textures[0] = true;
-- line 421 ----------------------------------------
-- line 434 ----------------------------------------
            .                                   if (j != 2) {
            .                                       val = SHADER_1;
            .                                       break;
            .                                   }
            .                                   [[fallthrough]]; // for G_ACMUX_PRIM_LOD_FRAC
            .                               case G_ACMUX_PRIMITIVE:
            .                               case G_ACMUX_SHADE:
            .                               case G_ACMUX_ENVIRONMENT:
           44 ( 0.00%)                          if (input_number[c[i][1][j]] == 0) {
           13 ( 0.00%)                              shader_input_mapping[1][next_input_number - 1] = c[i][1][j];
           21 ( 0.00%)                              input_number[c[i][1][j]] = next_input_number++;
            .                                   }
            .                                   val = input_number[c[i][1][j]];
            .                                   break;
            .                           }
           61 ( 0.00%)                  shader_id0 |= (uint64_t)val << (i * 32 + 16 + j * 4);
            .                       }
            .                   }
            .               }
           21 ( 0.00%)      comb->shader_id0 = shader_id0;
           21 ( 0.00%)      comb->shader_id1 = shader_id1;
           21 ( 0.00%)      comb->used_textures[0] = used_textures[0];
           21 ( 0.00%)      comb->used_textures[1] = used_textures[1];
            .               // comb->prg = gfx_lookup_or_create_shader_program(shader_id0, shader_id1);
           84 ( 0.00%)      memcpy(comb->shader_input_mapping, shader_input_mapping, sizeof(shader_input_mapping));
            .           }
            .           
            .           static struct ColorCombiner* gfx_lookup_or_create_color_combiner(const ColorCombinerKey& key) {
    2,301,000 ( 0.00%)      if (prev_combiner != color_combiner_pool.end() && prev_combiner->first == key) {
            .                   return &prev_combiner->second;
            .               }
            .           
       55,421 ( 0.00%)      prev_combiner = color_combiner_pool.find(key);
            .               if (prev_combiner != color_combiner_pool.end()) {
    3,451,437 ( 0.01%)          return &prev_combiner->second;
            .               }
            .               gfx_flush();
          147 ( 0.00%)      prev_combiner = color_combiner_pool.insert(make_pair(key, ColorCombiner())).first;
            .               gfx_generate_cc(&prev_combiner->second, key);
           63 ( 0.00%)      return &prev_combiner->second;
            .           }
            .           
            7 ( 0.00%)  void gfx_texture_cache_clear() {
            3 ( 0.00%)      for (const auto& entry : gfx_texture_cache.map) {
            .                   gfx_texture_cache.free_texture_ids.push_back(entry.second.texture_id);
            .               }
            .               gfx_texture_cache.map.clear();
            .               gfx_texture_cache.lru.clear();
            8 ( 0.00%)  }
            .           
      420,372 ( 0.00%)  static bool gfx_texture_cache_lookup(int i, const TextureCacheKey& key) {
            .               TextureCacheMap::iterator it = gfx_texture_cache.map.find(key);
            .               TextureCacheNode** n = &rendering_state.textures[i];
            .           
       92,612 ( 0.00%)      if (it != gfx_texture_cache.map.end()) {
      185,224 ( 0.00%)          gfx_rapi->select_texture(i, it->second.texture_id);
    9,643,475 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_select_texture(int, unsigned int) (46,306x)
            .                   *n = &*it;
            .                   gfx_texture_cache.lru.splice(gfx_texture_cache.lru.end(), gfx_texture_cache.lru,
            .                                                it->second.lru_location); // move to back
       46,306 ( 0.00%)          return true;
            .               }
            .           
          802 ( 0.00%)      if (gfx_texture_cache.map.size() >= TEXTURE_CACHE_MAX_SIZE) {
            .                   // Remove the texture that was least recently used
            .                   it = gfx_texture_cache.lru.front().it;
            .                   gfx_texture_cache.free_texture_ids.push_back(it->second.texture_id);
            .                   gfx_texture_cache.map.erase(it);
            .                   gfx_texture_cache.lru.pop_front();
            .               }
            .           
            .               uint32_t texture_id;
          804 ( 0.00%)      if (!gfx_texture_cache.free_texture_ids.empty()) {
            .                   texture_id = gfx_texture_cache.free_texture_ids.back();
            .                   gfx_texture_cache.free_texture_ids.pop_back();
            .               } else {
        1,608 ( 0.00%)          texture_id = gfx_rapi->new_texture();
      137,178 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_new_texture() (402x)
            .               }
            .           
            .               it = gfx_texture_cache.map.insert(make_pair(key, TextureCacheValue())).first;
            .               TextureCacheNode* node = &*it;
          402 ( 0.00%)      node->second.texture_id = texture_id;
          402 ( 0.00%)      node->second.lru_location = gfx_texture_cache.lru.insert(gfx_texture_cache.lru.end(), { it });
            .           
        1,608 ( 0.00%)      gfx_rapi->select_texture(i, texture_id);
    1,488,585 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_select_texture(int, unsigned int) (402x)
        2,412 ( 0.00%)      gfx_rapi->set_sampler_parameters(i, false, 0, 0);
    1,015,452 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_sampler_parameters(int, bool, unsigned int, unsigned int) (402x)
          402 ( 0.00%)      *n = node;
            .               return false;
      373,664 ( 0.00%)  }
            .           
      449,848 ( 0.00%)  static std::string gfx_get_base_texture_path(const std::string& path) {
            .               if (path.starts_with(Ship::IResource::gAltAssetPrefix)) {
            .                   return path.substr(Ship::IResource::gAltAssetPrefix.length());
            .               }
            .           
            .               return path;
      449,848 ( 0.00%)  }
            .           
            .           void gfx_texture_cache_delete(const uint8_t* orig_addr) {
            .               while (gfx_texture_cache.map.bucket_count() > 0) {
            .                   TextureCacheKey key = { orig_addr, { 0 }, 0, 0, 0 }; // bucket index only depends on the address
            .                   size_t bucket = gfx_texture_cache.map.bucket(key);
            .                   bool again = false;
            .                   for (auto it = gfx_texture_cache.map.begin(bucket); it != gfx_texture_cache.map.end(bucket); ++it) {
            .                       if (it->first.texture_addr == orig_addr) {
-- line 537 ----------------------------------------
-- line 544 ----------------------------------------
            .                   }
            .                   if (!again) {
            .                       break;
            .                   }
            .               }
            .           }
            .           
            .           static void import_texture_rgba16(int tile, bool importReplacement) {
          320 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
          800 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
          480 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
          160 ( 0.00%)      uint32_t full_image_line_size_bytes =
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
            .               uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .               // SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
          640 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes / 2;
          480 ( 0.00%)      uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
            .               // A single line of pixels should not equal the entire image (height == 1 non-withstanding)
            .               if (full_image_line_size_bytes == size_bytes)
          640 ( 0.00%)          full_image_line_size_bytes = width * 2;
            .           
            .               uint32_t i = 0;
            .           
        7,700 ( 0.00%)      for (uint32_t y = 0; y < height; y++) {
      528,896 ( 0.00%)          for (uint32_t x = 0; x < width; x++) {
       11,955 ( 0.00%)              uint32_t clrIdx = (y * (full_image_line_size_bytes / 2)) + (x);
            .           
      793,344 ( 0.00%)              uint16_t col16 = (addr[2 * clrIdx] << 8) | addr[2 * clrIdx + 1];
      132,224 ( 0.00%)              uint8_t a = col16 & 1;
      132,224 ( 0.00%)              uint8_t r = col16 >> 11;
      264,448 ( 0.00%)              uint8_t g = (col16 >> 6) & 0x1f;
      264,448 ( 0.00%)              uint8_t b = (col16 >> 1) & 0x1f;
    3,041,152 ( 0.01%)              tex_upload_buffer[4 * i + 0] = SCALE_5_8(r);
    1,454,464 ( 0.00%)              tex_upload_buffer[4 * i + 1] = SCALE_5_8(g);
    1,454,464 ( 0.00%)              tex_upload_buffer[4 * i + 2] = SCALE_5_8(b);
      132,224 ( 0.00%)              tex_upload_buffer[4 * i + 3] = a ? 255 : 0;
            .           
            .                       i++;
            .                   }
            .               }
            .           
          960 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
            .           }
            .           
            .           static void import_texture_rgba32(int tile, bool importReplacement) {
           64 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
          192 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
          128 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
            .               uint32_t full_image_line_size_bytes =
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
            .               uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
           96 ( 0.00%)      SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
           96 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes / 2;
           96 ( 0.00%)      uint32_t height = (size_bytes / 2) / g_rdp.texture_tile[tile].line_size_bytes;
          160 ( 0.00%)      gfx_rapi->upload_texture(addr, width, height);
            .           }
            .           
            .           static void import_texture_ia4(int tile, bool importReplacement) {
            .               const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
            .                       ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
-- line 617 ----------------------------------------
-- line 700 ----------------------------------------
            .           
            .               uint32_t width = g_rdp.texture_tile[tile].line_size_bytes / 2;
            .               uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
            .               gfx_rapi->upload_texture(tex_upload_buffer, width, height);
            .           }
            .           
            .           static void import_texture_i4(int tile, bool importReplacement) {
           36 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
          108 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
           54 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
            .               uint32_t full_image_line_size_bytes =
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
            .               uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .               // SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
      153,130 ( 0.00%)      for (uint32_t i = 0; i < size_bytes * 2; i++) {
       76,520 ( 0.00%)          uint8_t byte = addr[i / 2];
      306,080 ( 0.00%)          uint8_t part = (byte >> (4 - (i % 2) * 4)) & 0xf;
            .                   uint8_t intensity = part;
            .                   uint8_t r = intensity;
            .                   uint8_t g = intensity;
            .                   uint8_t b = intensity;
            .                   uint8_t a = intensity;
      306,080 ( 0.00%)          tex_upload_buffer[4 * i + 0] = SCALE_4_8(r);
            .                   tex_upload_buffer[4 * i + 1] = SCALE_4_8(g);
            .                   tex_upload_buffer[4 * i + 2] = SCALE_4_8(b);
            .                   tex_upload_buffer[4 * i + 3] = SCALE_4_8(a);
            .               }
            .           
           72 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes * 2;
           36 ( 0.00%)      uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
           18 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
            .           }
            .           
            .           static void import_texture_i8(int tile, bool importReplacement) {
           14 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
           35 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
           28 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
            .               uint32_t full_image_line_size_bytes =
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
            .               uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .               // SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
       41,016 ( 0.00%)      for (uint32_t i = 0; i < size_bytes; i++) {
            .                   uint8_t intensity = addr[i];
            .                   uint8_t r = intensity;
            .                   uint8_t g = intensity;
            .                   uint8_t b = intensity;
            .                   uint8_t a = intensity;
       61,440 ( 0.00%)          tex_upload_buffer[4 * i + 0] = r;
            .                   tex_upload_buffer[4 * i + 1] = g;
            .                   tex_upload_buffer[4 * i + 2] = b;
            .                   tex_upload_buffer[4 * i + 3] = a;
            .               }
            .           
           14 ( 0.00%)      uint32_t width = g_rdp.texture_tile[tile].line_size_bytes;
           14 ( 0.00%)      uint32_t height = size_bytes / g_rdp.texture_tile[tile].line_size_bytes;
            .           
          491 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
    3,165,348 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (217x)
            .           }
            .           
            6 ( 0.00%)  static void import_texture_ci4(int tile, bool importReplacement) {
            3 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
            7 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
            4 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
            1 ( 0.00%)      uint32_t full_image_line_size_bytes =
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
            1 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            2 ( 0.00%)      uint32_t pal_idx = g_rdp.texture_tile[tile].palette; // 0-15
            .           
            .               uint8_t* palette = nullptr;
            .               // const uint8_t* palette = g_rdp.palettes[pal_idx / 8] + (pal_idx % 8) * 16 * 2; // 16 pixel entries, 16 bits each
            .           
            2 ( 0.00%)      if (pal_idx > 7)
            .                   palette = (uint8_t*)g_rdp.palettes[pal_idx / 8]; // 16 pixel entries, 16 bits each
            .               else
            3 ( 0.00%)          palette = (uint8_t*)(g_rdp.palettes[pal_idx / 8] + (pal_idx % 8) * 16 * 2);
            .           
            2 ( 0.00%)      SUPPORT_CHECK(full_image_line_size_bytes == line_size_bytes);
            .           
       16,390 ( 0.00%)      for (uint32_t i = 0; i < size_bytes * 2; i++) {
        8,192 ( 0.00%)          uint8_t byte = addr[i / 2];
       24,576 ( 0.00%)          uint8_t idx = (byte >> (4 - (i % 2) * 4)) & 0xf;
       24,576 ( 0.00%)          uint16_t col16 = (palette[idx * 2] << 8) | palette[idx * 2 + 1]; // Big endian load
        4,096 ( 0.00%)          uint8_t a = col16 & 1;
        4,096 ( 0.00%)          uint8_t r = col16 >> 11;
        8,192 ( 0.00%)          uint8_t g = (col16 >> 6) & 0x1f;
        8,192 ( 0.00%)          uint8_t b = (col16 >> 1) & 0x1f;
       94,208 ( 0.00%)          tex_upload_buffer[4 * i + 0] = SCALE_5_8(r);
       45,056 ( 0.00%)          tex_upload_buffer[4 * i + 1] = SCALE_5_8(g);
       45,056 ( 0.00%)          tex_upload_buffer[4 * i + 2] = SCALE_5_8(b);
        4,096 ( 0.00%)          tex_upload_buffer[4 * i + 3] = a ? 255 : 0;
            .               }
            .           
            2 ( 0.00%)      uint32_t result_line_size = g_rdp.texture_tile[tile].line_size_bytes;
            7 ( 0.00%)      if (metadata->h_byte_scale != 1) {
            .                   result_line_size *= metadata->h_byte_scale;
            .               }
            .           
            1 ( 0.00%)      uint32_t width = result_line_size * 2;
            2 ( 0.00%)      uint32_t height = size_bytes / result_line_size;
            .           
            6 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
       17,315 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (1x)
            6 ( 0.00%)  }
            .           
        1,288 ( 0.00%)  static void import_texture_ci8(int tile, bool importReplacement) {
          552 ( 0.00%)      const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
        1,656 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
          736 ( 0.00%)      uint32_t size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes;
          368 ( 0.00%)      uint32_t full_image_line_size_bytes =
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes;
          184 ( 0.00%)      uint32_t line_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes;
            .           
        3,312 ( 0.00%)      for (uint32_t i = 0, j = 0; i < size_bytes; j += full_image_line_size_bytes - line_size_bytes) {
    1,451,560 ( 0.00%)          for (uint32_t k = 0; k < line_size_bytes; i++, k++, j++) {
      725,504 ( 0.00%)              uint8_t idx = addr[j];
    3,264,768 ( 0.01%)              uint16_t col16 = (g_rdp.palettes[idx / 128][(idx % 128) * 2] << 8) |
      362,752 ( 0.00%)                               g_rdp.palettes[idx / 128][(idx % 128) * 2 + 1]; // Big endian load
      362,752 ( 0.00%)              uint8_t a = col16 & 1;
      362,752 ( 0.00%)              uint8_t r = col16 >> 11;
      725,504 ( 0.00%)              uint8_t g = (col16 >> 6) & 0x1f;
      725,504 ( 0.00%)              uint8_t b = (col16 >> 1) & 0x1f;
    8,343,296 ( 0.01%)              tex_upload_buffer[4 * i + 0] = SCALE_5_8(r);
    3,990,272 ( 0.01%)              tex_upload_buffer[4 * i + 1] = SCALE_5_8(g);
    3,990,272 ( 0.01%)              tex_upload_buffer[4 * i + 2] = SCALE_5_8(b);
      362,752 ( 0.00%)              tex_upload_buffer[4 * i + 3] = a ? 255 : 0;
            .                   }
            .               }
            .           
          368 ( 0.00%)      uint32_t result_line_size = g_rdp.texture_tile[tile].line_size_bytes;
        1,104 ( 0.00%)      if (metadata->h_byte_scale != 1) {
            .                   result_line_size *= metadata->h_byte_scale;
            .               }
            .           
            .               uint32_t width = result_line_size;
          368 ( 0.00%)      uint32_t height = size_bytes / result_line_size;
            .           
        1,104 ( 0.00%)      gfx_rapi->upload_texture(tex_upload_buffer, width, height);
    2,833,626 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_upload_texture(unsigned char const*, unsigned int, unsigned int) (184x)
        1,288 ( 0.00%)  }
            .           
            .           static void import_texture_raw(int tile, bool importReplacement) {
            .               const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* addr =
            .                   importReplacement && (metadata->resource != nullptr)
            .                       ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr;
-- line 864 ----------------------------------------
-- line 927 ----------------------------------------
            .               // Set the remaining bytes to load as 0
            .               if (num_loaded_bytes > resource_image_size_bytes) {
            .                   memset(tex_upload_buffer + resource_image_size_bytes, 0, num_loaded_bytes - resource_image_size_bytes);
            .               }
            .           
            .               gfx_rapi->upload_texture(tex_upload_buffer, result_new_line_size / 4, result_new_height);
            .           }
            .           
      653,912 ( 0.00%)  static void import_texture(int i, int tile, bool importReplacement) {
       46,708 ( 0.00%)      uint8_t fmt = g_rdp.texture_tile[tile].fmt;
       93,416 ( 0.00%)      uint8_t siz = g_rdp.texture_tile[tile].siz;
      326,956 ( 0.00%)      uint32_t texFlags = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].tex_flags;
            .               uint32_t tmem_index = g_rdp.texture_tile[tile].tmem_index;
       46,708 ( 0.00%)      uint8_t palette_index = g_rdp.texture_tile[tile].palette;
       46,708 ( 0.00%)      uint32_t orig_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes;
            .           
            .               const RawTexMetadata* metadata = &g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata;
            .               const uint8_t* orig_addr =
            .                   importReplacement && (metadata->resource != nullptr)
      373,664 ( 0.00%)              ? masked_textures.find(gfx_get_base_texture_path(metadata->resource->GetInitData()->Path))
            .                             ->second.replacementData
            .                       : g_rdp.loaded_texture[tmem_index].addr;
            .           
            .               TextureCacheKey key;
       93,416 ( 0.00%)      if (fmt == G_IM_FMT_CI) {
      181,564 ( 0.00%)          key = { orig_addr, { g_rdp.palettes[0], g_rdp.palettes[1] }, fmt, siz, palette_index, orig_size_bytes };
            .               } else {
      153,680 ( 0.00%)          key = { orig_addr, {}, fmt, siz, palette_index, orig_size_bytes };
            .               }
            .           
      233,540 ( 0.00%)      if (gfx_texture_cache_lookup(i, key)) {
   17,203,772 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_cache_lookup(int, TextureCacheKey const&) (46,708x)
            .                   return;
            .               }
            .           
            .               // if load as raw is set then we load_raw();
        1,206 ( 0.00%)      if ((texFlags & TEX_FLAG_LOAD_AS_RAW) != 0) {
            .                   import_texture_raw(tile, importReplacement);
            .                   return;
            .               }
            .           
          804 ( 0.00%)      if (fmt == G_IM_FMT_RGBA) {
          384 ( 0.00%)          if (siz == G_IM_SIZ_16b) {
            .                       import_texture_rgba16(tile, importReplacement);
           64 ( 0.00%)          } else if (siz == G_IM_SIZ_32b) {
            .                       import_texture_rgba32(tile, importReplacement);
            .                   } else {
            .                       // abort(); // OTRTODO: Sometimes, seemingly randomly, we end up here. Could be a bad dlist, could be
            .                       // something F3D does not have supported. Further investigation is needed.
            .                   }
          420 ( 0.00%)      } else if (fmt == G_IM_FMT_IA) {
            .                   if (siz == G_IM_SIZ_4b) {
            .                       import_texture_ia4(tile, importReplacement);
            .                   } else if (siz == G_IM_SIZ_8b) {
            .                       import_texture_ia8(tile, importReplacement);
            .                   } else if (siz == G_IM_SIZ_16b) {
            .                       import_texture_ia16(tile, importReplacement);
            .                   } else {
            .                       abort();
            .                   }
          420 ( 0.00%)      } else if (fmt == G_IM_FMT_CI) {
          370 ( 0.00%)          if (siz == G_IM_SIZ_4b) {
            3 ( 0.00%)              import_texture_ci4(tile, importReplacement);
      304,096 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_ci4(int, bool) (1x)
          368 ( 0.00%)          } else if (siz == G_IM_SIZ_8b) {
          552 ( 0.00%)              import_texture_ci8(tile, importReplacement);
   27,513,642 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture_ci8(int, bool) (184x)
            .                   } else {
            .                       abort();
            .                   }
           50 ( 0.00%)      } else if (fmt == G_IM_FMT_I) {
           50 ( 0.00%)          if (siz == G_IM_SIZ_4b) {
            .                       import_texture_i4(tile, importReplacement);
           14 ( 0.00%)          } else if (siz == G_IM_SIZ_8b) {
            .                       import_texture_i8(tile, importReplacement);
            .                   } else {
            .                       abort();
            .                   }
            .               } else {
            .                   abort();
            .               }
      373,262 ( 0.00%)  }
            .           
            .           static void import_texture_mask(int i, int tile) {
            .               uint32_t tmem_index = g_rdp.texture_tile[tile].tmem_index;
            .               RawTexMetadata metadata = g_rdp.loaded_texture[tmem_index].raw_tex_metadata;
            .           
            .               if (metadata.resource == nullptr) {
            .                   return;
            .               }
-- line 1013 ----------------------------------------
-- line 1061 ----------------------------------------
            .                       tex_upload_buffer[4 * texIndex + 3] = 0;
            .                   }
            .               }
            .           
            .               gfx_rapi->upload_texture(tex_upload_buffer, width, height);
            .           }
            .           
            .           static void gfx_normalize_vector(float v[3]) {
      447,336 ( 0.00%)      float s = sqrtf(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      223,668 ( 0.00%)      v[0] /= s;
      223,668 ( 0.00%)      v[1] /= s;
      223,668 ( 0.00%)      v[2] /= s;
            .           }
            .           
            .           static void gfx_transposed_matrix_mul(float res[3], const float a[3], const float b[4][4]) {
      447,336 ( 0.00%)      res[0] = a[0] * b[0][0] + a[1] * b[0][1] + a[2] * b[0][2];
      447,336 ( 0.00%)      res[1] = a[0] * b[1][0] + a[1] * b[1][1] + a[2] * b[1][2];
      335,502 ( 0.00%)      res[2] = a[0] * b[2][0] + a[1] * b[2][1] + a[2] * b[2][2];
            .           }
            .           
            .           static void calculate_normal_dir(const F3DLight_t* light, float coeffs[3]) {
    1,230,174 ( 0.00%)      float light_dir[3] = { light->dir[0] / 127.0f, light->dir[1] / 127.0f, light->dir[2] / 127.0f };
            .           
      447,336 ( 0.00%)      gfx_transposed_matrix_mul(coeffs, light_dir, g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1]);
            .               gfx_normalize_vector(coeffs);
      111,834 ( 0.00%)  }
            .           
            .           static void gfx_matrix_mul(float res[4][4], const float a[4][4], const float b[4][4]) {
            .               float tmp[4][4];
            .               for (int i = 0; i < 4; i++) {
            .                   for (int j = 0; j < 4; j++) {
    2,477,681 ( 0.00%)              tmp[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j] + a[i][3] * b[3][j];
            .                   }
            .               }
      253,547 ( 0.00%)      memcpy(res, tmp, sizeof(tmp));
        8,929 ( 0.00%)  }
            .           
      720,030 ( 0.00%)  static void gfx_sp_matrix(uint8_t parameters, const int32_t* addr) {
            .               float matrix[4][4];
            .           
       72,003 ( 0.00%)      if (auto it = current_mtx_replacements->find((Mtx*)addr); it != current_mtx_replacements->end()) {
            .                   for (int i = 0; i < 4; i++) {
            .                       for (int j = 0; j < 4; j++) {
            .                           float v = it->second.mf[i][j];
            .                           int as_int = (int)(v * 65536.0f);
            .                           matrix[i][j] = as_int * (1.0f / 65536.0f);
            .                       }
            .                   }
            .               } else {
            .           #ifndef GBI_FLOATS
            .                   // Original GBI where fixed point matrices are used
       72,003 ( 0.00%)          for (int i = 0; i < 4; i++) {
            .                       for (int j = 0; j < 4; j += 2) {
      288,012 ( 0.00%)                  int32_t int_part = addr[i * 2 + j / 2];
      288,012 ( 0.00%)                  uint32_t frac_part = addr[8 + i * 2 + j / 2];
    1,008,042 ( 0.00%)                  matrix[i][j] = (int32_t)((int_part & 0xffff0000) | (frac_part >> 16)) / 65536.0f;
    1,800,075 ( 0.00%)                  matrix[i][j + 1] = (int32_t)((int_part << 16) | (frac_part & 0xffff)) / 65536.0f;
            .                       }
            .                   }
            .           #else
            .                   // For a modified GBI where fixed point values are replaced with floats
            .                   memcpy(matrix, addr, sizeof(matrix));
            .           #endif
            .               }
            .           
            .               const auto mtx_projection = get_attr<int8_t>(MTX_PROJECTION);
            .               const auto mtx_load = get_attr<int8_t>(MTX_LOAD);
            .               const auto mtx_push = get_attr<int8_t>(MTX_PUSH);
            .           
      216,009 ( 0.00%)      if (parameters & mtx_projection) {
       87,793 ( 0.00%)          if (parameters & mtx_load) {
       23,964 ( 0.00%)              memcpy(g_rsp.P_matrix, matrix, sizeof(matrix));
            .                   } else {
            .                       gfx_matrix_mul(g_rsp.P_matrix, matrix, g_rsp.P_matrix);
            .                   }
            .               } else { // G_MTX_MODELVIEW
      212,004 ( 0.00%)          if ((parameters & mtx_push) && g_rsp.modelview_matrix_stack_size < 11) {
       13,120 ( 0.00%)              ++g_rsp.modelview_matrix_stack_size;
       26,240 ( 0.00%)              memcpy(g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1],
       26,240 ( 0.00%)                     g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 2], sizeof(matrix));
            .                   }
      128,216 ( 0.00%)          if (parameters & mtx_load) {
      178,274 ( 0.00%)              if (g_rsp.modelview_matrix_stack_size == 0)
            .                           ++g_rsp.modelview_matrix_stack_size;
      228,332 ( 0.00%)              memcpy(g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1], matrix, sizeof(matrix));
            .                   } else {
            .                       gfx_matrix_mul(g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1], matrix,
      306,490 ( 0.00%)                             g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1]);
            .                   }
      128,216 ( 0.00%)          g_rsp.lights_changed = 1;
            .               }
            .               gfx_matrix_mul(g_rsp.MP_matrix, g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1],
            .                              g_rsp.P_matrix);
      504,021 ( 0.00%)  }
            .           
            .           static void gfx_sp_pop_matrix(uint32_t count) {
       19,680 ( 0.00%)      while (count--) {
            .                   if (g_rsp.modelview_matrix_stack_size > 0) {
            .                       --g_rsp.modelview_matrix_stack_size;
       13,120 ( 0.00%)              if (g_rsp.modelview_matrix_stack_size > 0) {
       26,240 ( 0.00%)                  gfx_matrix_mul(g_rsp.MP_matrix, g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1],
            .                                          g_rsp.P_matrix);
            .                       }
            .                   }
            .               }
        6,560 ( 0.00%)      g_rsp.lights_changed = true;
            .           }
            .           
            .           static float gfx_adjust_x_for_aspect_ratio(float x) {
  577,370,824 ( 0.98%)      if (fbActive) {
            .                   return x;
            .               } else {
2,598,437,598 ( 4.41%)          return x * (4.0f / 3.0f) / ((float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height);
            .               }
            .           }
            .           
            .           // Scale the width and height value based on the ratio of the viewport to the native size
            .           static void gfx_adjust_width_height_for_scale(uint32_t& width, uint32_t& height, uint32_t native_width,
            .                                                         uint32_t native_height) {
            .               width = round(width * (gfx_current_dimensions.width / (2.0f * (native_width / 2))));
            .               height = round(height * (gfx_current_dimensions.height / (2.0f * (native_height / 2))));
-- line 1181 ----------------------------------------
-- line 1184 ----------------------------------------
            .                   width = 1;
            .               }
            .               if (height == 0) {
            .                   height = 1;
            .               }
            .           }
            .           
            .           [[always_inline]]
  146,102,688 ( 0.25%)  static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const F3DVtx* vertices) {
            .           #pragma omp parallel for
1,750,375,308 ( 2.97%)      for (size_t i = 0; i < n_vertices; i++, dest_index++) {
            .                   const F3DVtx_t* v = &vertices[i].v;
            .                   const F3DVtx_tn* vn = &vertices[i].n;
            .                   struct LoadedVertex* d = &g_rsp.loaded_vertices[dest_index];
            .           
  577,370,824 ( 0.98%)          if (v == NULL) {
            .                       return;
            .                   }
            .           
2,309,483,296 ( 3.92%)          float x = v->ob[0] * g_rsp.MP_matrix[0][0] + v->ob[1] * g_rsp.MP_matrix[1][0] +
  577,370,824 ( 0.98%)                    v->ob[2] * g_rsp.MP_matrix[2][0] + g_rsp.MP_matrix[3][0];
1,154,741,648 ( 1.96%)          float y = v->ob[0] * g_rsp.MP_matrix[0][1] + v->ob[1] * g_rsp.MP_matrix[1][1] +
            .                             v->ob[2] * g_rsp.MP_matrix[2][1] + g_rsp.MP_matrix[3][1];
1,154,741,648 ( 1.96%)          float z = v->ob[0] * g_rsp.MP_matrix[0][2] + v->ob[1] * g_rsp.MP_matrix[1][2] +
            .                             v->ob[2] * g_rsp.MP_matrix[2][2] + g_rsp.MP_matrix[3][2];
1,154,741,648 ( 1.96%)          float w = v->ob[0] * g_rsp.MP_matrix[0][3] + v->ob[1] * g_rsp.MP_matrix[1][3] +
            .                             v->ob[2] * g_rsp.MP_matrix[2][3] + g_rsp.MP_matrix[3][3];
            .           
            .                   float world_pos[3];
1,443,427,060 ( 2.45%)          if (g_rsp.geometry_mode & G_LIGHTING_POSITIONAL) {
            .                       float(*mtx)[4] = g_rsp.modelview_matrix_stack[g_rsp.modelview_matrix_stack_size - 1];
            .                       world_pos[0] = v->ob[0] * mtx[0][0] + v->ob[1] * mtx[1][0] + v->ob[2] * mtx[2][0] + mtx[3][0];
            .                       world_pos[1] = v->ob[0] * mtx[0][1] + v->ob[1] * mtx[1][1] + v->ob[2] * mtx[2][1] + mtx[3][1];
            .                       world_pos[2] = v->ob[0] * mtx[0][2] + v->ob[1] * mtx[1][2] + v->ob[2] * mtx[2][2] + mtx[3][2];
            .                   }
            .           
            .                   x = gfx_adjust_x_for_aspect_ratio(x);
            .           
1,154,741,648 ( 1.96%)          short U = v->tc[0] * g_rsp.texture_scaling_factor.s >> 16;
2,020,797,884 ( 3.43%)          short V = v->tc[1] * g_rsp.texture_scaling_factor.t >> 16;
            .           
  577,370,824 ( 0.98%)          if (g_rsp.geometry_mode & G_LIGHTING) {
  576,115,144 ( 0.98%)              if (g_rsp.lights_changed) {
  288,504,908 ( 0.49%)                  for (int i = 0; i < g_rsp.current_num_lights - 1; i++) {
      186,390 ( 0.00%)                      calculate_normal_dir(&g_rsp.current_lights[i].l, g_rsp.current_lights_coeffs[i]);
    1,379,286 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) [clone .isra.0] (37,278x)
            .                           }
            .                           /*static const Light_t lookat_x = {{0, 0, 0}, 0, {0, 0, 0}, 0, {127, 0, 0}, 0};
            .                           static const Light_t lookat_y = {{0, 0, 0}, 0, {0, 0, 0}, 0, {0, 127, 0}, 0};*/
      186,390 ( 0.00%)                  calculate_normal_dir(&g_rsp.lookat[0], g_rsp.current_lookat_coeffs[0]);
    1,379,286 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) [clone .isra.0] (37,278x)
      186,390 ( 0.00%)                  calculate_normal_dir(&g_rsp.lookat[1], g_rsp.current_lookat_coeffs[1]);
    1,379,286 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:calculate_normal_dir(F3DLight_t const*, float*) [clone .isra.0] (37,278x)
       74,556 ( 0.00%)                  g_rsp.lights_changed = false;
            .                       }
            .           
1,440,250,582 ( 2.44%)              int r = g_rsp.current_lights[g_rsp.current_num_lights - 1].l.col[0];
  576,115,144 ( 0.98%)              int g = g_rsp.current_lights[g_rsp.current_num_lights - 1].l.col[1];
  288,057,572 ( 0.49%)              int b = g_rsp.current_lights[g_rsp.current_num_lights - 1].l.col[2];
            .           
1,728,345,432 ( 2.93%)              for (int i = 0; i < g_rsp.current_num_lights - 1; i++) {
            .                           float intensity = 0;
            .                           if ((g_rsp.geometry_mode & G_LIGHTING_POSITIONAL) && (g_rsp.current_lights[i].p.unk3 != 0)) {
            .                               // Calculate distance from the light to the vertex
            .                               float dist_vec[3] = { g_rsp.current_lights[i].p.pos[0] - world_pos[0],
            .                                                     g_rsp.current_lights[i].p.pos[1] - world_pos[1],
            .                                                     g_rsp.current_lights[i].p.pos[2] - world_pos[2] };
            .                               float dist_sq =
            .                                   dist_vec[0] * dist_vec[0] + dist_vec[1] * dist_vec[1] +
-- line 1249 ----------------------------------------
-- line 1259 ----------------------------------------
            .                               float light_intensity[3];
            .                               for (int light_i = 0; light_i < 3; light_i++) {
            .                                   light_intensity[light_i] = 4.0f * light_model[light_i] / dist_sq;
            .                                   light_intensity[light_i] = clamp(light_intensity[light_i], -1.0f, 1.0f);
            .                               }
            .           
            .                               // Adjust intensity based on surface normal and sum up total
            .                               float total_intensity =
3,744,748,436 ( 6.35%)                          light_intensity[0] * vn->n[0] + light_intensity[1] * vn->n[1] + light_intensity[2] * vn->n[2];
            .                               total_intensity = clamp(total_intensity, -1.0f, 1.0f);
            .           
            .                               // Attenuate intensity based on attenuation values.
            .                               // Example formula found at https://ogldev.org/www/tutorial20/tutorial20.html
            .                               // Specific coefficients for MM's microcode sourced from GLideN64
            .                               // https://github.com/gonetz/GLideN64/blob/3b43a13a80dfc2eb6357673440b335e54eaa3896/src/gSP.cpp#L636
            .                               float distf = floorf(dist);
            .                               float attenuation = (distf * g_rsp.current_lights[i].p.unk7 * 2.0f +
            .                                                    distf * distf * g_rsp.current_lights[i].p.unkE / 8.0f) /
            .                                                       (float)0xFFFF +
            .                                                   1.0f;
            .                               intensity = total_intensity / attenuation;
            .                           } else {
1,152,230,288 ( 1.95%)                      intensity += vn->n[0] * g_rsp.current_lights_coeffs[i][0];
  288,057,572 ( 0.49%)                      intensity += vn->n[1] * g_rsp.current_lights_coeffs[i][1];
  288,057,572 ( 0.49%)                      intensity += vn->n[2] * g_rsp.current_lights_coeffs[i][2];
  288,057,572 ( 0.49%)                      intensity /= 127.0f;
            .                           }
  576,115,144 ( 0.98%)                  if (intensity > 0.0f) {
  720,423,655 ( 1.22%)                      r += intensity * g_rsp.current_lights[i].l.col[0];
  720,423,655 ( 1.22%)                      g += intensity * g_rsp.current_lights[i].l.col[1];
  720,423,655 ( 1.22%)                      b += intensity * g_rsp.current_lights[i].l.col[2];
            .                           }
            .                       }
            .           
2,016,403,004 ( 3.42%)              d->color.r = r > 255 ? 255 : r;
  864,172,716 ( 1.47%)              d->color.g = g > 255 ? 255 : g;
1,152,230,288 ( 1.95%)              d->color.b = b > 255 ? 255 : b;
            .           
  576,115,144 ( 0.98%)              if (g_rsp.geometry_mode & G_TEXTURE_GEN) {
            .                           float dotx = 0, doty = 0;
            .                           dotx += vn->n[0] * g_rsp.current_lookat_coeffs[0][0];
            .                           dotx += vn->n[1] * g_rsp.current_lookat_coeffs[0][1];
            .                           dotx += vn->n[2] * g_rsp.current_lookat_coeffs[0][2];
            .                           doty += vn->n[0] * g_rsp.current_lookat_coeffs[1][0];
            .                           doty += vn->n[1] * g_rsp.current_lookat_coeffs[1][1];
            .                           doty += vn->n[2] * g_rsp.current_lookat_coeffs[1][2];
            .           
-- line 1305 ----------------------------------------
-- line 1321 ----------------------------------------
            .                               dotx = (dotx + 1.0f) / 4.0f;
            .                               doty = (doty + 1.0f) / 4.0f;
            .                           }
            .           
            .                           U = (int32_t)(dotx * g_rsp.texture_scaling_factor.s);
            .                           V = (int32_t)(doty * g_rsp.texture_scaling_factor.t);
            .                       }
            .                   } else {
    1,255,680 ( 0.00%)              d->color.r = v->cn[0];
    1,255,680 ( 0.00%)              d->color.g = v->cn[1];
    1,255,680 ( 0.00%)              d->color.b = v->cn[2];
            .                   }
            .           
1,443,427,060 ( 2.45%)          d->u = U;
            .                   d->v = V;
            .           
            .                   // trivial clip rejection
            .                   d->clip_rej = 0;
  999,127,708 ( 1.70%)          if (x < -w) {
  288,685,412 ( 0.49%)              d->clip_rej |= 1; // CLIP_LEFT
            .                   }
  803,273,372 ( 1.36%)          if (x > w) {
  655,190,412 ( 1.11%)              d->clip_rej |= 2; // CLIP_RIGHT
            .                   }
  577,370,824 ( 0.98%)          if (y < -w) {
  356,729,996 ( 0.61%)              d->clip_rej |= 4; // CLIP_BOTTOM
            .                   }
  577,370,824 ( 0.98%)          if (y > w) {
  470,583,068 ( 0.80%)              d->clip_rej |= 8; // CLIP_TOP
            .                   }
            .                   // if (z < -w) d->clip_rej |= 16; // CLIP_NEAR
  577,370,824 ( 0.98%)          if (z > w) {
            .                       d->clip_rej |= 32; // CLIP_FAR
            .                   }
            .           
  288,685,412 ( 0.49%)          d->x = x;
            .                   d->y = y;
            .                   d->z = z;
            .                   d->w = w;
            .           
  577,370,824 ( 0.98%)          if (g_rsp.geometry_mode & G_FOG) {
       13,680 ( 0.00%)              if (fabsf(w) < 0.001f) {
            .                           // To avoid division by zero
            .                           w = 0.001f;
            .                       }
            .           
       10,260 ( 0.00%)              float winv = 1.0f / w;
            .                       if (winv < 0.0f) {
       13,680 ( 0.00%)                  winv = std::numeric_limits<int16_t>::max();
            .                       }
            .           
       20,520 ( 0.00%)              float fog_z = z * winv * g_rsp.fog_mul + g_rsp.fog_offset;
       10,260 ( 0.00%)              fog_z = Ship::Math::clamp(fog_z, 0.0f, 255.0f);
       10,260 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/utils/Utils.cpp:Ship::Math::clamp(float, float, float) (3,420x)
  288,692,252 ( 0.49%)              d->color.a = fog_z; // Use alpha variable to store fog factor
            .                   } else {
  577,363,984 ( 0.98%)              d->color.a = v->cn[3];
            .                   }
            .               }
   73,051,344 ( 0.12%)  }
            .           
            .           static void gfx_sp_modify_vertex(uint16_t vtx_idx, uint8_t where, uint32_t val) {
            .               SUPPORT_CHECK(where == G_MWO_POINT_ST);
            .           
            .               int16_t s = (int16_t)(val >> 16);
            .               int16_t t = (int16_t)val;
            .           
            .               struct LoadedVertex* v = &g_rsp.loaded_vertices[vtx_idx];
            .               v->u = s;
            .               v->v = t;
            .           }
            .           
1,278,143,001 ( 2.17%)  static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx, bool is_rect) {
  568,063,556 ( 0.96%)      struct LoadedVertex* v1 = &g_rsp.loaded_vertices[vtx1_idx];
  568,063,556 ( 0.96%)      struct LoadedVertex* v2 = &g_rsp.loaded_vertices[vtx2_idx];
  568,063,556 ( 0.96%)      struct LoadedVertex* v3 = &g_rsp.loaded_vertices[vtx3_idx];
            .               struct LoadedVertex* v_arr[3] = { v1, v2, v3 };
            .           
            .               // if (rand()%2) return;
            .           
1,988,222,446 ( 3.37%)      if (v1->clip_rej & v2->clip_rej & v3->clip_rej) {
            .                   // The whole triangle lies outside the visible area
            .                   return;
            .               }
            .           
            .               const auto cull_both = get_attr<uint32_t>(CULL_BOTH);
            .               const auto cull_front = get_attr<uint32_t>(CULL_FRONT);
            .               const auto cull_back = get_attr<uint32_t>(CULL_BACK);
            .           
   16,360,920 ( 0.03%)      if ((g_rsp.geometry_mode & cull_both) != 0) {
   43,718,818 ( 0.07%)          float dx1 = v1->x / (v1->w) - v2->x / (v2->w);
   19,872,190 ( 0.03%)          float dy1 = v1->y / (v1->w) - v2->y / (v2->w);
   19,872,190 ( 0.03%)          float dx2 = v3->x / (v3->w) - v2->x / (v2->w);
   11,923,314 ( 0.02%)          float dy2 = v3->y / (v3->w) - v2->y / (v2->w);
    7,948,876 ( 0.01%)          float cross = dx1 * dy2 - dy1 * dx2;
            .           
   39,744,380 ( 0.07%)          if ((v1->w < 0) ^ (v2->w < 0) ^ (v3->w < 0)) {
            .                       // If one vertex lies behind the eye, negating cross will give the correct result.
            .                       // If all vertices lie behind the eye, the triangle will be rejected anyway.
        2,912 ( 0.00%)              cross = -cross;
            .                   }
            .           
            .                   // If inverted culling is requested, negate the cross
    7,948,876 ( 0.01%)          if (ucode_handler_index == UcodeHandlers::ucode_f3dex2 &&
            .                       (g_rsp.extra_geometry_mode & G_EX_INVERT_CULLING) == 1) {
            .                       cross = -cross;
            .                   }
            .           
            .                   auto cull_type = g_rsp.geometry_mode & cull_both;
            .           
    7,948,876 ( 0.01%)          if (cull_type == cull_front) {
            .                       if (cross <= 0) {
            .                           return;
            .                       }
    7,948,876 ( 0.01%)          } else if (cull_type == cull_back) {
   14,863,044 ( 0.03%)              if (cross >= 0) {
            .                           return;
            .                       }
            .                   } else if (cull_type == cull_both) {
            .                       // Why is this even an option?
            .                       return;
            .                   }
            .               }
            .           
    2,301,000 ( 0.00%)      bool depth_test = (g_rsp.geometry_mode & G_ZBUFFER) == G_ZBUFFER;
    4,602,000 ( 0.01%)      bool depth_mask = (g_rdp.other_mode_l & Z_UPD) == Z_UPD;
    2,301,000 ( 0.00%)      uint8_t depth_test_and_mask = (depth_test ? 1 : 0) | (depth_mask ? 2 : 0);
    2,301,000 ( 0.00%)      if (depth_test_and_mask != rendering_state.depth_test_and_mask) {
            .                   gfx_flush();
       66,280 ( 0.00%)          gfx_rapi->set_depth_test_and_mask(depth_test, depth_mask);
       49,710 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_depth_test_and_mask(bool, bool) (16,570x)
       16,570 ( 0.00%)          rendering_state.depth_test_and_mask = depth_test_and_mask;
            .               }
            .           
    3,468,070 ( 0.01%)      bool zmode_decal = (g_rdp.other_mode_l & ZMODE_DEC) == ZMODE_DEC;
    2,301,000 ( 0.00%)      if (zmode_decal != rendering_state.decal_mode) {
            .                   gfx_flush();
       36,828 ( 0.00%)          gfx_rapi->set_zmode_decal(zmode_decal);
       24,552 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_zmode_decal(bool) (12,276x)
       12,276 ( 0.00%)          rendering_state.decal_mode = zmode_decal;
            .               }
            .           
    2,301,000 ( 0.00%)      if (g_rdp.viewport_or_scissor_changed) {
      199,620 ( 0.00%)          if (memcmp(&g_rdp.viewport, &rendering_state.viewport, sizeof(g_rdp.viewport)) != 0) {
            .                       gfx_flush();
        3,642 ( 0.00%)              gfx_rapi->set_viewport(g_rdp.viewport.x, g_rdp.viewport.y, g_rdp.viewport.width, g_rdp.viewport.height);
      123,834 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_viewport(int, int, int, int) (607x)
        2,428 ( 0.00%)              rendering_state.viewport = g_rdp.viewport;
            .                   }
      199,620 ( 0.00%)          if (memcmp(&g_rdp.scissor, &rendering_state.scissor, sizeof(g_rdp.scissor)) != 0) {
            .                       gfx_flush();
        3,642 ( 0.00%)              gfx_rapi->set_scissor(g_rdp.scissor.x, g_rdp.scissor.y, g_rdp.scissor.width, g_rdp.scissor.height);
       96,712 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_scissor(int, int, int, int) (607x)
        2,428 ( 0.00%)              rendering_state.scissor = g_rdp.scissor;
            .                   }
       28,864 ( 0.00%)          g_rdp.viewport_or_scissor_changed = false;
            .               }
            .           
            .               uint64_t cc_id = g_rdp.combine_mode;
            .               uint64_t cc_options = 0;
    3,451,500 ( 0.01%)      bool use_alpha = ((g_rdp.other_mode_l & (3 << 20)) == (G_BL_CLR_MEM << 20) &&
    2,301,000 ( 0.00%)                        (g_rdp.other_mode_l & (3 << 16)) == (G_BL_1MA << 16)) ||
    1,049,230 ( 0.00%)                       ((g_rdp.other_mode_l & (3 << 22)) == (G_BL_CLR_MEM << 22) &&
            .                                 (g_rdp.other_mode_l & (3 << 18)) == (G_BL_1MA << 18));
    2,301,000 ( 0.00%)      bool use_fog = (g_rdp.other_mode_l >> 30) == G_BL_CLR_FOG;
    2,301,000 ( 0.00%)      bool texture_edge = (g_rdp.other_mode_l & CVG_X_ALPHA) == CVG_X_ALPHA;
    2,301,000 ( 0.00%)      bool use_noise = (g_rdp.other_mode_l & (3U << G_MDSFT_ALPHACOMPARE)) == G_AC_DITHER;
    2,301,000 ( 0.00%)      bool use_2cyc = (g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE)) == G_CYC_2CYCLE;
            .               bool alpha_threshold = (g_rdp.other_mode_l & (3U << G_MDSFT_ALPHACOMPARE)) == G_AC_THRESHOLD;
            .               bool invisible =
    2,301,000 ( 0.00%)          (g_rdp.other_mode_l & (3 << 24)) == (G_BL_0 << 24) && (g_rdp.other_mode_l & (3 << 20)) == (G_BL_CLR_MEM << 20);
    2,301,000 ( 0.00%)      bool use_grayscale = g_rdp.grayscale;
            .           
    2,301,000 ( 0.00%)      if (texture_edge) {
            .                   use_alpha = true;
            .               }
            .           
    2,098,460 ( 0.00%)      if (use_alpha) {
            .                   cc_options |= SHADER_OPT(ALPHA);
            .               }
    5,800,139 ( 0.01%)      if (use_fog) {
            .                   cc_options |= SHADER_OPT(FOG);
            .               }
            .               if (texture_edge) {
            .                   cc_options |= SHADER_OPT(TEXTURE_EDGE);
            .               }
    2,301,000 ( 0.00%)      if (use_noise) {
            .                   cc_options |= SHADER_OPT(NOISE);
            .               }
            .               if (use_2cyc) {
    4,602,000 ( 0.01%)          cc_options |= SHADER_OPT(_2CYC);
            .               }
            .               if (alpha_threshold) {
    4,602,000 ( 0.01%)          cc_options |= SHADER_OPT(ALPHA_THRESHOLD);
            .               }
            .               if (invisible) {
    4,602,000 ( 0.01%)          cc_options |= SHADER_OPT(INVISIBLE);
            .               }
    2,301,000 ( 0.00%)      if (use_grayscale) {
            .                   cc_options |= SHADER_OPT(GRAYSCALE);
            .               }
    2,301,000 ( 0.00%)      if (g_rdp.loaded_texture[0].masked) {
            .                   cc_options |= SHADER_OPT(TEXEL0_MASK);
            .               }
    2,301,000 ( 0.00%)      if (g_rdp.loaded_texture[1].masked) {
            .                   cc_options |= SHADER_OPT(TEXEL1_MASK);
            .               }
    2,301,000 ( 0.00%)      if (g_rdp.loaded_texture[0].blended) {
            .                   cc_options |= SHADER_OPT(TEXEL0_BLEND);
            .               }
    8,053,500 ( 0.01%)      if (g_rdp.loaded_texture[1].blended) {
            .                   cc_options |= SHADER_OPT(TEXEL1_BLEND);
            .               }
            .           
            .               ColorCombinerKey key;
    1,150,500 ( 0.00%)      key.combine_mode = g_rdp.combine_mode;
            .               key.options = cc_options;
            .           
            .               // If we are not using alpha, clear the alpha components of the combiner as they have no effect
    2,301,000 ( 0.00%)      if (!use_alpha) {
    2,098,460 ( 0.00%)          key.combine_mode &= ~((0xfff << 16) | ((uint64_t)0xfff << 44));
            .               }
            .           
            .               ColorCombiner* comb = gfx_lookup_or_create_color_combiner(key);
            .           
    1,150,500 ( 0.00%)      uint32_t tm = 0;
            .               uint32_t tex_width[2], tex_height[2], tex_width2[2], tex_height2[2];
            .           
   12,655,500 ( 0.02%)      for (int i = 0; i < 2; i++) {
    2,180,232 ( 0.00%)          uint32_t tile = g_rdp.first_tile_index + i;
    4,602,000 ( 0.01%)          if (comb->used_textures[i]) {
    4,360,464 ( 0.01%)              if (g_rdp.textures_changed[i]) {
            .                           gfx_flush();
      280,248 ( 0.00%)                  import_texture(i, tile, false);
   59,983,138 ( 0.10%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:import_texture(int, int, bool) (46,708x)
      186,832 ( 0.00%)                  if (g_rdp.loaded_texture[i].masked) {
            .                               import_texture_mask(SHADER_FIRST_MASK_TEXTURE + i, tile);
            .                           }
       93,416 ( 0.00%)                  if (g_rdp.loaded_texture[i].blended) {
            .                               import_texture(SHADER_FIRST_REPLACEMENT_TEXTURE + i, tile, true);
            .                           }
       46,708 ( 0.00%)                  g_rdp.textures_changed[i] = false;
            .                       }
            .           
    4,360,464 ( 0.01%)              uint8_t cms = g_rdp.texture_tile[tile].cms;
    1,090,116 ( 0.00%)              uint8_t cmt = g_rdp.texture_tile[tile].cmt;
            .           
    3,270,348 ( 0.01%)              uint32_t tex_size_bytes = g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes;
            .                       uint32_t line_size = g_rdp.texture_tile[tile].line_size_bytes;
            .           
    4,360,464 ( 0.01%)              if (line_size == 0) {
            .                           line_size = 1;
            .                       }
            .           
    5,450,580 ( 0.01%)              tex_height[i] = tex_size_bytes / line_size;
    3,418,392 ( 0.01%)              switch (g_rdp.texture_tile[tile].siz) {
            .                           case G_IM_SIZ_4b:
      204,210 ( 0.00%)                      line_size <<= 1;
            .                               break;
            .                           case G_IM_SIZ_8b:
            .                               break;
            .                           case G_IM_SIZ_16b:
    1,016,094 ( 0.00%)                      line_size /= G_IM_SIZ_16b_LINE_BYTES;
    1,016,094 ( 0.00%)                      break;
            .                           case G_IM_SIZ_32b:
        5,952 ( 0.00%)                      line_size /= G_IM_SIZ_32b_LINE_BYTES; // this is 2!
       11,904 ( 0.00%)                      tex_height[i] /= 2;
        5,952 ( 0.00%)                      break;
            .                       }
    1,090,116 ( 0.00%)              tex_width[i] = line_size;
            .           
   10,901,160 ( 0.02%)              tex_width2[i] = (g_rdp.texture_tile[tile].lrs - g_rdp.texture_tile[tile].uls + 4) / 4;
    8,720,928 ( 0.01%)              tex_height2[i] = (g_rdp.texture_tile[tile].lrt - g_rdp.texture_tile[tile].ult + 4) / 4;
            .           
      228,843 ( 0.00%)              uint32_t tex_width1 = tex_width[i] << (cms & G_TX_MIRROR);
      238,251 ( 0.00%)              uint32_t tex_height1 = tex_height[i] << (cmt & G_TX_MIRROR);
            .           
    2,457,444 ( 0.00%)              if ((cms & G_TX_CLAMP) && ((cms & G_TX_MIRROR) || tex_width1 != tex_width2[i])) {
       69,780 ( 0.00%)                  tm |= 1 << 2 * i;
       13,956 ( 0.00%)                  cms &= ~G_TX_CLAMP;
            .                       }
    2,469,988 ( 0.00%)              if ((cmt & G_TX_CLAMP) && ((cmt & G_TX_MIRROR) || tex_height1 != tex_height2[i])) {
       69,780 ( 0.00%)                  tm |= 1 << 2 * i + 1;
    2,194,188 ( 0.00%)                  cmt &= ~G_TX_CLAMP;
            .                       }
            .           
    3,270,348 ( 0.01%)              bool linear_filter = (g_rdp.other_mode_h & (3U << G_MDSFT_TEXTFILT)) != G_TF_POINT;
    5,449,878 ( 0.01%)              if (linear_filter != rendering_state.textures[i]->second.linear_filter ||
    3,269,154 ( 0.01%)                  cms != rendering_state.textures[i]->second.cms || cmt != rendering_state.textures[i]->second.cmt) {
            .                           gfx_flush();
            .           
            .                           // Set the same sampler params on the blended texture. Needed for opengl.
          796 ( 0.00%)                  if (g_rdp.loaded_texture[i].blended) {
        1,194 ( 0.00%)                      gfx_rapi->set_sampler_parameters(SHADER_FIRST_REPLACEMENT_TEXTURE + i, linear_filter, cms, cmt);
            .                           }
            .           
        2,786 ( 0.00%)                  gfx_rapi->set_sampler_parameters(i, linear_filter, cms, cmt);
      829,397 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_sampler_parameters(int, bool, unsigned int, unsigned int) (398x)
          796 ( 0.00%)                  rendering_state.textures[i]->second.linear_filter = linear_filter;
        1,592 ( 0.00%)                  rendering_state.textures[i]->second.cms = cms;
            .                           rendering_state.textures[i]->second.cmt = cmt;
            .                       }
            .                   }
            .               }
            .           
    2,301,000 ( 0.00%)      struct ShaderProgram* prg = comb->prg[tm];
    2,301,000 ( 0.00%)      if (prg == NULL) {
           46 ( 0.00%)          comb->prg[tm] = prg =
          161 ( 0.00%)              gfx_lookup_or_create_shader_program(comb->shader_id0, comb->shader_id1 | tm * SHADER_OPT(TEXEL0_CLAMP_S));
            .               }
    3,451,500 ( 0.01%)      if (prg != rendering_state.shader_program) {
            .                   gfx_flush();
      119,162 ( 0.00%)          gfx_rapi->unload_shader(rendering_state.shader_program);
    6,870,500 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_unload_shader(ShaderProgram*) (27,656x)
       82,968 ( 0.00%)          gfx_rapi->load_shader(prg);
  125,226,633 ( 0.21%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_load_shader(ShaderProgram*) (27,656x)
       82,968 ( 0.00%)          rendering_state.shader_program = prg;
            .               }
    2,301,000 ( 0.00%)      if (use_alpha != rendering_state.alpha_blend) {
            .                   gfx_flush();
       24,225 ( 0.00%)          gfx_rapi->set_use_alpha(use_alpha);
      339,149 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_set_use_alpha(bool) (4,845x)
       14,535 ( 0.00%)          rendering_state.alpha_blend = use_alpha;
            .               }
            .               uint8_t num_inputs;
            .               bool used_textures[2];
            .           
    8,053,500 ( 0.01%)      gfx_rapi->shader_get_info(prg, &num_inputs, used_textures);
    8,053,500 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_shader_get_info(ShaderProgram*, unsigned char*, bool*) (1,150,500x)
            .           
    2,301,000 ( 0.00%)      struct GfxClipParameters clip_parameters = gfx_rapi->get_clip_parameters();
    9,204,000 ( 0.02%)  => /usr/include/c++/14/bits/stl_vector.h:gfx_opengl_get_clip_parameters() (1,150,500x)
            .           
   13,806,000 ( 0.02%)      for (int i = 0; i < 3; i++) {
   10,354,500 ( 0.02%)          float z = v_arr[i]->z, w = v_arr[i]->w;
    8,053,500 ( 0.01%)          if (clip_parameters.z_is_from_0_to_1) {
            .                       z = (z + w) / 2.0f;
            .                   }
            .           
   13,806,000 ( 0.02%)          buf_vbo[buf_vbo_len++] = v_arr[i]->x;
   20,709,000 ( 0.04%)          buf_vbo[buf_vbo_len++] = clip_parameters.invert_y ? -v_arr[i]->y : v_arr[i]->y;
            .                   buf_vbo[buf_vbo_len++] = z;
   10,354,500 ( 0.02%)          buf_vbo[buf_vbo_len++] = w;
            .           
            .                   for (int t = 0; t < 2; t++) {
   26,461,500 ( 0.04%)              if (!used_textures[t]) {
            .                           continue;
            .                       }
    6,543,720 ( 0.01%)              float u = v_arr[i]->u / 32.0f;
    3,271,860 ( 0.01%)              float v = v_arr[i]->v / 32.0f;
            .           
   13,088,952 ( 0.02%)              int shifts = g_rdp.texture_tile[g_rdp.first_tile_index + t].shifts;
    3,271,860 ( 0.01%)              int shiftt = g_rdp.texture_tile[g_rdp.first_tile_index + t].shiftt;
    6,543,720 ( 0.01%)              if (shifts != 0) {
            .                           if (shifts <= 10) {
            .                               u /= 1 << shifts;
            .                           } else {
            .                               u *= 1 << (16 - shifts);
            .                           }
            .                       }
    6,543,720 ( 0.01%)              if (shiftt != 0) {
            .                           if (shiftt <= 10) {
            .                               v /= 1 << shiftt;
            .                           } else {
            .                               v *= 1 << (16 - shiftt);
            .                           }
            .                       }
            .           
   32,718,600 ( 0.06%)              u -= g_rdp.texture_tile[g_rdp.first_tile_index + t].uls / 4.0f;
            .                       v -= g_rdp.texture_tile[g_rdp.first_tile_index + t].ult / 4.0f;
            .           
            .                       if ((g_rdp.other_mode_h & (3U << G_MDSFT_TEXTFILT)) != G_TF_POINT) {
            .                           // Linear filter adds 0.5f to the coordinates
   12,891,192 ( 0.02%)                  if (!is_rect) {
    6,210,528 ( 0.01%)                      u += 0.5f;
            .                               v += 0.5f;
            .                           }
            .                       }
            .           
   22,903,020 ( 0.04%)              buf_vbo[buf_vbo_len++] = u / tex_width[t];
   13,087,440 ( 0.02%)              buf_vbo[buf_vbo_len++] = v / tex_height[t];
            .           
    6,903,000 ( 0.01%)              bool clampS = tm & (1 << 2 * t);
    9,204,000 ( 0.02%)              bool clampT = tm & (1 << 2 * t + 1);
            .           
    9,815,580 ( 0.02%)              if (clampS) {
      334,944 ( 0.00%)                  buf_vbo[buf_vbo_len++] = (tex_width2[t] - 0.5f) / tex_width[t];
            .                       }
            .           
    9,815,580 ( 0.02%)              if (clampT) {
      334,944 ( 0.00%)                  buf_vbo[buf_vbo_len++] = (tex_height2[t] - 0.5f) / tex_height[t];
            .                       }
            .                   }
            .           
    6,903,000 ( 0.01%)          if (use_fog) {
       25,704 ( 0.00%)              buf_vbo[buf_vbo_len++] = g_rdp.fog_color.r / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.fog_color.g / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.fog_color.b / 255.0f;
        3,024 ( 0.00%)              buf_vbo[buf_vbo_len++] = v_arr[i]->color.a / 255.0f; // fog factor (not alpha)
            .                   }
            .           
    6,903,000 ( 0.01%)          if (use_grayscale) {
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.r / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.g / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.b / 255.0f;
            .                       buf_vbo[buf_vbo_len++] = g_rdp.grayscale_color.a / 255.0f; // lerp interpolation factor (not alpha)
            .                   }
            .           
    9,317,118 ( 0.02%)          for (int j = 0; j < num_inputs; j++) {
            .                       struct RGBA* color = 0;
            .                       struct RGBA tmp;
    3,954,024 ( 0.01%)              for (int k = 0; k < 1 + (use_alpha ? 1 : 0); k++) {
    5,177,442 ( 0.01%)                  switch (comb->shader_input_mapping[k][j]) {
            .                                   // Note: CCMUX constants and ACMUX constants used here have same value, which is why this works
            .                                   // (except LOD fraction).
            .                               case G_CCMUX_PRIMITIVE:
      500,400 ( 0.00%)                          color = &g_rdp.prim_color;
            .                                   break;
            .                               case G_CCMUX_SHADE:
    1,426,731 ( 0.00%)                          color = &v_arr[i]->color;
      420,975 ( 0.00%)                          break;
            .                               case G_CCMUX_ENVIRONMENT:
            .                                   color = &g_rdp.env_color;
            .                                   break;
            .                               case G_CCMUX_PRIMITIVE_ALPHA: {
            .                                   tmp.r = tmp.g = tmp.b = g_rdp.prim_color.a;
            .                                   color = &tmp;
            .                                   break;
            .                               }
-- line 1737 ----------------------------------------
-- line 1762 ----------------------------------------
            .                                   color = &tmp;
            .                                   break;
            .                               }
            .                               case G_ACMUX_PRIM_LOD_FRAC:
            .                                   tmp.a = g_rdp.prim_lod_fraction;
            .                                   color = &tmp;
            .                                   break;
            .                               default:
      490,968 ( 0.00%)                          memset(&tmp, 0, sizeof(tmp));
            .                                   color = &tmp;
            .                                   break;
            .                           }
    1,793,604 ( 0.00%)                  if (k == 0) {
    9,941,442 ( 0.02%)                      buf_vbo[buf_vbo_len++] = color->r / 255.0f;
            .                               buf_vbo[buf_vbo_len++] = color->g / 255.0f;
    4,796,610 ( 0.01%)                      buf_vbo[buf_vbo_len++] = color->b / 255.0f;
            .                           } else {
      529,986 ( 0.00%)                      if (use_fog && color == &v_arr[i]->color) {
            .                                   // Shade alpha is 100% for fog
            .                                   buf_vbo[buf_vbo_len++] = 1.0f;
            .                               } else {
    1,324,965 ( 0.00%)                          buf_vbo[buf_vbo_len++] = color->a / 255.0f;
            .                               }
            .                           }
            .                       }
            .                   }
            .           
            .                   // struct RGBA *color = &v_arr[i]->color;
            .                   // buf_vbo[buf_vbo_len++] = color->r / 255.0f;
            .                   // buf_vbo[buf_vbo_len++] = color->g / 255.0f;
            .                   // buf_vbo[buf_vbo_len++] = color->b / 255.0f;
            .                   // buf_vbo[buf_vbo_len++] = color->a / 255.0f;
            .               }
            .           
    5,752,500 ( 0.01%)      if (++buf_vbo_num_tris == MAX_BUFFERED) {
            .                   // if (++buf_vbo_num_tris == 1) {
            .                   gfx_flush();
            .               }
1,136,127,112 ( 1.93%)  }
            .           
            .           static void gfx_sp_geometry_mode(uint32_t clear, uint32_t set) {
            .               g_rsp.geometry_mode &= ~clear;
            .               g_rsp.geometry_mode |= set;
            .           }
            .           
            .           static void gfx_sp_extra_geometry_mode(uint32_t clear, uint32_t set) {
            .               g_rsp.extra_geometry_mode &= ~clear;
            .               g_rsp.extra_geometry_mode |= set;
            .           }
            .           
       75,266 ( 0.00%)  static void gfx_adjust_viewport_or_scissor(XYWidthHeight* area) {
       75,266 ( 0.00%)      if (!fbActive) {
            .                   // Adjust the y origin based on the y-inversion for the active framebuffer
       75,266 ( 0.00%)          GfxClipParameters clipParameters = gfx_rapi->get_clip_parameters();
      301,064 ( 0.00%)  => /usr/include/c++/14/bits/stl_vector.h:gfx_opengl_get_clip_parameters() (37,633x)
      112,899 ( 0.00%)          if (clipParameters.invert_y) {
       75,266 ( 0.00%)              area->y -= area->height;
            .                   } else {
       75,266 ( 0.00%)              area->y = gfx_native_dimensions.height - area->y;
            .                   }
            .           
      564,495 ( 0.00%)          area->width *= RATIO_X;
      376,330 ( 0.00%)          area->height *= RATIO_Y;
      376,330 ( 0.00%)          area->x *= RATIO_X;
      376,330 ( 0.00%)          area->y *= RATIO_Y;
            .           
       75,266 ( 0.00%)          if (!game_renders_to_framebuffer ||
            .                       (gfx_msaa_level > 1 && gfx_current_dimensions.width == gfx_current_game_window_viewport.width &&
       37,633 ( 0.00%)               gfx_current_dimensions.height == gfx_current_game_window_viewport.height)) {
       75,266 ( 0.00%)              area->x += gfx_current_game_window_viewport.x;
      188,165 ( 0.00%)              area->y += gfx_current_window_dimensions.height -
            .                                  (gfx_current_game_window_viewport.y + gfx_current_game_window_viewport.height);
            .                   }
            .               } else {
            .                   area->y = active_fb->second.orig_height - area->y;
            .           
            .                   if (active_fb->second.resize) {
            .                       area->width *= RATIO_X;
            .                       area->height *= RATIO_Y;
            .                       area->x *= RATIO_X;
            .                       area->y *= RATIO_Y;
            .                   }
            .               }
      112,899 ( 0.00%)  }
            .           
            .           static void gfx_calc_and_set_viewport(const F3DVp_t* viewport) {
            .               // 2 bits fraction
       21,672 ( 0.00%)      float width = 2.0f * viewport->vscale[0] / 4.0f;
       14,448 ( 0.00%)      float height = 2.0f * viewport->vscale[1] / 4.0f;
       18,060 ( 0.00%)      float x = (viewport->vtrans[0] / 4.0f) - width / 2.0f;
       14,448 ( 0.00%)      float y = ((viewport->vtrans[1] / 4.0f) + height / 2.0f);
            .           
       18,060 ( 0.00%)      g_rdp.viewport.x = x;
        3,612 ( 0.00%)      g_rdp.viewport.y = y;
       14,448 ( 0.00%)      g_rdp.viewport.width = width;
        3,612 ( 0.00%)      g_rdp.viewport.height = height;
            .           
        7,224 ( 0.00%)      gfx_adjust_viewport_or_scissor(&g_rdp.viewport);
      285,348 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) (3,612x)
            .           
        3,612 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
            .           }
            .           
            .           static void gfx_sp_movemem_f3dex2(uint8_t index, uint8_t offset, const void* data) {
            .               switch (index) {
            .                   case F3DEX2_G_MV_VIEWPORT:
            .                       gfx_calc_and_set_viewport((const F3DVp_t*)data);
            .                       break;
            .                   case F3DEX2_G_MV_LIGHT: {
-- line 1868 ----------------------------------------
-- line 1874 ----------------------------------------
            .                           memcpy(g_rsp.lookat + offset / 24, data, sizeof(F3DLight_t)); // TODO Light?
            .                       }
            .                       break;
            .                   }
            .               }
            .           }
            .           
            .           static void gfx_sp_movemem_f3d(uint8_t index, uint8_t offset, const void* data) {
       61,026 ( 0.00%)      switch (index) {
            .                   case F3DEX_G_MV_VIEWPORT:
            .                       gfx_calc_and_set_viewport((const F3DVp_t*)data);
            .                       break;
            .                   case F3DEX_G_MV_LOOKATY:
            .                   case F3DEX_G_MV_LOOKATX:
            .                       memcpy(g_rsp.lookat + (index - F3DEX_G_MV_LOOKATY) / 2, data, sizeof(F3DLight_t));
            .                       break;
            .                   case F3DEX_G_MV_L0:
-- line 1890 ----------------------------------------
-- line 1891 ----------------------------------------
            .                   case F3DEX_G_MV_L1:
            .                   case F3DEX_G_MV_L2:
            .                   case F3DEX_G_MV_L3:
            .                   case F3DEX_G_MV_L4:
            .                   case F3DEX_G_MV_L5:
            .                   case F3DEX_G_MV_L6:
            .                   case F3DEX_G_MV_L7:
            .                       // NOTE: reads out of bounds if it is an ambient light
       27,378 ( 0.00%)              memcpy(g_rsp.current_lights + (index - F3DEX_G_MV_L0) / 2, data, sizeof(F3DLight_t));
            .                       break;
            .               }
            .           }
            .           
            .           static void gfx_sp_moveword_f3dex2(uint8_t index, uint16_t offset, uintptr_t data) {
            .               switch (index) {
            .                   case G_MW_NUMLIGHT:
            .                       g_rsp.current_num_lights = data / 24 + 1; // add ambient light
-- line 1907 ----------------------------------------
-- line 1914 ----------------------------------------
            .                   case G_MW_SEGMENT:
            .                       int segNumber = offset / 4;
            .                       gSegmentPointers[segNumber] = data;
            .                       break;
            .               }
            .           }
            .           
            .           static void gfx_sp_moveword_f3d(uint8_t index, uint16_t offset, uintptr_t data) {
       99,402 ( 0.00%)      switch (index) {
            .                   case G_MW_NUMLIGHT:
            .                       // Ambient light is included
            .                       // The 31th bit is a flag that lights should be recalculated
        4,842 ( 0.00%)              g_rsp.current_num_lights = (data - 0x80000000U) / 32;
        1,614 ( 0.00%)              g_rsp.lights_changed = 1;
            .                       break;
            .                   case G_MW_FOG:
            .                       g_rsp.fog_mul = (int16_t)(data >> 16);
            .                       g_rsp.fog_offset = (int16_t)data;
            .                       break;
            .                   case G_MW_SEGMENT:
       10,608 ( 0.00%)              int segNumber = offset / 4;
       21,216 ( 0.00%)              gSegmentPointers[segNumber] = data;
            .                       break;
            .               }
            .           }
            .           
            .           static void gfx_sp_texture(uint16_t sc, uint16_t tc, uint8_t level, uint8_t tile, uint8_t on) {
            .               g_rsp.texture_scaling_factor.s = sc;
            .               g_rsp.texture_scaling_factor.t = tc;
            .               if (g_rdp.first_tile_index != tile) {
-- line 1943 ----------------------------------------
-- line 1944 ----------------------------------------
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
            .           
            .               g_rdp.first_tile_index = tile;
            .           }
            .           
            .           static void gfx_dp_set_scissor(uint32_t mode, uint32_t ulx, uint32_t uly, uint32_t lrx, uint32_t lry) {
       21,396 ( 0.00%)      float x = ulx / 4.0f;
       14,264 ( 0.00%)      float y = lry / 4.0f;
       21,396 ( 0.00%)      float width = (lrx - ulx) / 4.0f;
       21,396 ( 0.00%)      float height = (lry - uly) / 4.0f;
            .           
       35,660 ( 0.00%)      g_rdp.scissor.x = x;
        7,132 ( 0.00%)      g_rdp.scissor.y = y;
       28,528 ( 0.00%)      g_rdp.scissor.width = width;
        7,132 ( 0.00%)      g_rdp.scissor.height = height;
            .           
       14,264 ( 0.00%)      gfx_adjust_viewport_or_scissor(&g_rdp.scissor);
      563,428 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) (7,132x)
            .           
        7,132 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
            .           }
            .           
            .           static void gfx_dp_set_texture_image(uint32_t format, uint32_t size, uint32_t width, const char* texPath,
            .                                                uint32_t texFlags, RawTexMetadata rawTexMetdata, const void* addr) {
            .               // fprintf(stderr, "gfx_dp_set_texture_image: %s (width=%d; size=0x%X)\n",
            .               //         rawTexMetdata.resource ? rawTexMetdata.resource->GetInitData()->Path.c_str() : nullptr, width, size);
       99,296 ( 0.00%)      g_rdp.texture_to_load.addr = (const uint8_t*)addr;
       99,296 ( 0.00%)      g_rdp.texture_to_load.siz = size;
      278,752 ( 0.00%)      g_rdp.texture_to_load.width = width;
            .               g_rdp.texture_to_load.tex_flags = texFlags;
            .               g_rdp.texture_to_load.raw_tex_metadata = rawTexMetdata;
            .           }
            .           
            .           static void gfx_dp_set_tile(uint8_t fmt, uint32_t siz, uint32_t line, uint32_t tmem, uint8_t tile, uint32_t palette,
            .                                       uint32_t cmt, uint32_t maskt, uint32_t shiftt, uint32_t cms, uint32_t masks,
            .                                       uint32_t shifts) {
            .               // OTRTODO:
            .               // SUPPORT_CHECK(tmem == 0 || tmem == 256);
            .           
      549,492 ( 0.00%)      if (cms == G_TX_WRAP && masks == G_TX_NOMASK) {
            .                   cms = G_TX_CLAMP;
            .               }
      366,328 ( 0.00%)      if (cmt == G_TX_WRAP && maskt == G_TX_NOMASK) {
            .                   cmt = G_TX_CLAMP;
            .               }
            .           
      732,656 ( 0.00%)      g_rdp.texture_tile[tile].palette = palette; // palette should set upper 4 bits of color index in 4b mode
    2,381,132 ( 0.00%)      g_rdp.texture_tile[tile].fmt = fmt;
            .               g_rdp.texture_tile[tile].siz = siz;
            .               g_rdp.texture_tile[tile].cms = cms;
            .               g_rdp.texture_tile[tile].cmt = cmt;
      732,656 ( 0.00%)      g_rdp.texture_tile[tile].shifts = shifts;
            .               g_rdp.texture_tile[tile].shiftt = shiftt;
      366,328 ( 0.00%)      g_rdp.texture_tile[tile].line_size_bytes = line * 8;
            .           
      183,164 ( 0.00%)      g_rdp.texture_tile[tile].tmem = tmem;
            .               // g_rdp.texture_tile[tile].tmem_index = tmem / 256; // tmem is the 64-bit word offset, so 256 words means 2 kB
            .           
            .               g_rdp.texture_tile[tile].tmem_index =
      366,328 ( 0.00%)          tmem != 0; // assume one texture is loaded at address 0 and another texture at any other address
            .           
      183,164 ( 0.00%)      g_rdp.textures_changed[0] = true;
            .               g_rdp.textures_changed[1] = true;
            .           }
            .           
            .           static void gfx_dp_set_tile_size(uint8_t tile, uint16_t uls, uint16_t ult, uint16_t lrs, uint16_t lrt) {
    1,418,048 ( 0.00%)      g_rdp.texture_tile[tile].uls = uls;
            .               g_rdp.texture_tile[tile].ult = ult;
            .               g_rdp.texture_tile[tile].lrs = lrs;
            .               g_rdp.texture_tile[tile].lrt = lrt;
       88,628 ( 0.00%)      g_rdp.textures_changed[0] = true;
            .               g_rdp.textures_changed[1] = true;
            .           }
            .           
            .           static void gfx_dp_load_tlut(uint8_t tile, uint32_t high_index) {
       14,247 ( 0.00%)      SUPPORT_CHECK(tile == G_TX_LOADTILE);
        9,498 ( 0.00%)      SUPPORT_CHECK(g_rdp.texture_to_load.siz == G_IM_SIZ_16b);
            .               // BENTODO
            .               // SUPPORT_CHECK((g_rdp.texture_tile[tile].tmem == 256 && (high_index <= 127 || high_index == 255)) ||
            .               //              (g_rdp.texture_tile[tile].tmem == 384 && high_index == 127));
            .           
        9,498 ( 0.00%)      if (g_rdp.texture_tile[tile].tmem == 256) {
        9,498 ( 0.00%)          g_rdp.palettes[0] = g_rdp.texture_to_load.addr;
        9,498 ( 0.00%)          if (high_index == 255) {
        9,312 ( 0.00%)              g_rdp.palettes[1] = g_rdp.texture_to_load.addr + 2 * 128;
            .                   }
            .               } else {
            .                   g_rdp.palettes[1] = g_rdp.texture_to_load.addr;
            .               }
            .           }
            .           
      437,100 ( 0.00%)  static void gfx_dp_load_block(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t lrs, uint32_t dxt) {
      145,700 ( 0.00%)      SUPPORT_CHECK(uls == 0);
      145,700 ( 0.00%)      SUPPORT_CHECK(ult == 0);
            .           
            .               // The lrs field rather seems to be number of pixels to load
            .               uint32_t word_size_shift = 0;
      218,550 ( 0.00%)      switch (g_rdp.texture_to_load.siz) {
            .                   case G_IM_SIZ_4b:
            .                       word_size_shift = -1;
            .                       break;
            .                   case G_IM_SIZ_8b:
            .                       word_size_shift = 0;
            .                       break;
            .                   case G_IM_SIZ_16b:
      145,700 ( 0.00%)              word_size_shift = 1;
            .                       break;
            .                   case G_IM_SIZ_32b:
            .                       word_size_shift = 2;
            .                       break;
            .               }
            .               uint32_t orig_size_bytes =
      218,550 ( 0.00%)          word_size_shift > 0 ? (lrs + 1) << word_size_shift : (lrs + 1) >> (-(int64_t)word_size_shift);
       72,850 ( 0.00%)      uint32_t size_bytes = orig_size_bytes;
      728,500 ( 0.00%)      if (g_rdp.texture_to_load.raw_tex_metadata.h_byte_scale != 1 ||
            .                   g_rdp.texture_to_load.raw_tex_metadata.v_pixel_scale != 1) {
            .                   size_bytes *= g_rdp.texture_to_load.raw_tex_metadata.h_byte_scale;
            .                   size_bytes *= g_rdp.texture_to_load.raw_tex_metadata.v_pixel_scale;
            .               }
      801,350 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes = orig_size_bytes;
            .               g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes = size_bytes;
            .               g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes = size_bytes;
            .               g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes = size_bytes;
            .               // assert(size_bytes <= 4096 && "bug: too big texture");
      145,700 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].tex_flags = g_rdp.texture_to_load.tex_flags;
      145,700 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata = g_rdp.texture_to_load.raw_tex_metadata;
      437,100 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr = g_rdp.texture_to_load.addr;
            .               // fprintf(stderr, "gfx_dp_load_block: line_size = 0x%x; orig = 0x%x; bpp=%d; lrs=%d\n", size_bytes,
            .               // orig_size_bytes,
            .               //         g_rdp.texture_to_load.siz, lrs);
            .           
            .               const std::string& texPath =
            .                   g_rdp.texture_to_load.raw_tex_metadata.resource != nullptr
      268,626 ( 0.00%)              ? gfx_get_base_texture_path(g_rdp.texture_to_load.raw_tex_metadata.resource->GetInitData()->Path)
      614,630 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::IResource::GetInitData() (61,463x)
      184,389 ( 0.00%)              : "";
    9,067,185 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_get_base_texture_path(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (61,463x)
            .               auto maskedTextureIter = masked_textures.find(texPath);
      145,700 ( 0.00%)      if (maskedTextureIter != masked_textures.end()) {
      307,315 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = true;
      218,550 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended =
            .                       maskedTextureIter->second.replacementData != nullptr;
            .               } else {
      291,400 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = false;
       72,850 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended = false;
            .               }
            .           
       72,850 ( 0.00%)      g_rdp.textures_changed[g_rdp.texture_tile[tile].tmem_index] = true;
      509,950 ( 0.00%)  }
            .           
            .           static void gfx_dp_load_tile(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t lrs, uint32_t lrt) {
       50,811 ( 0.00%)      SUPPORT_CHECK(tile == G_TX_LOADTILE);
            .           
            .               uint32_t word_size_shift = 0;
       88,732 ( 0.00%)      switch (g_rdp.texture_to_load.siz) {
            .                   case G_IM_SIZ_4b:
            .                       word_size_shift = 0;
            .                       break;
            .                   case G_IM_SIZ_8b:
            .                       word_size_shift = 0;
            .                       break;
            .                   case G_IM_SIZ_16b:
            .                       word_size_shift = 1;
            .                       break;
            .                   case G_IM_SIZ_32b:
            .                       word_size_shift = 2;
            .                       break;
            .               }
            .           
       33,874 ( 0.00%)      uint32_t offset_x = uls >> G_TEXTURE_IMAGE_FRAC;
       33,874 ( 0.00%)      uint32_t offset_y = ult >> G_TEXTURE_IMAGE_FRAC;
       67,748 ( 0.00%)      uint32_t tile_width = ((lrs - uls) >> G_TEXTURE_IMAGE_FRAC) + 1;
       67,748 ( 0.00%)      uint32_t tile_height = ((lrt - ult) >> G_TEXTURE_IMAGE_FRAC) + 1;
       33,874 ( 0.00%)      uint32_t full_image_width = g_rdp.texture_to_load.width + 1;
            .           
       16,937 ( 0.00%)      uint32_t offset_x_in_bytes = offset_x << word_size_shift;
       16,937 ( 0.00%)      uint32_t tile_line_size_bytes = tile_width << word_size_shift;
       16,937 ( 0.00%)      uint32_t full_image_line_size_bytes = full_image_width << word_size_shift;
            .           
       16,937 ( 0.00%)      uint32_t orig_size_bytes = tile_line_size_bytes * tile_height;
       16,937 ( 0.00%)      uint32_t size_bytes = orig_size_bytes;
       33,874 ( 0.00%)      uint32_t start_offset_bytes = full_image_line_size_bytes * offset_y + offset_x_in_bytes;
            .           
       16,937 ( 0.00%)      float h_byte_scale = g_rdp.texture_to_load.raw_tex_metadata.h_byte_scale;
            .               float v_pixel_scale = g_rdp.texture_to_load.raw_tex_metadata.v_pixel_scale;
            .           
      203,244 ( 0.00%)      if (h_byte_scale != 1 || v_pixel_scale != 1) {
            .                   start_offset_bytes = h_byte_scale * (v_pixel_scale * offset_y * full_image_line_size_bytes + offset_x_in_bytes);
            .                   size_bytes *= h_byte_scale * v_pixel_scale;
            .                   full_image_line_size_bytes *= h_byte_scale;
            .                   tile_line_size_bytes *= h_byte_scale;
            .               }
            .           
      169,370 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].orig_size_bytes = orig_size_bytes;
            .               g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].size_bytes = size_bytes;
            .               g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].full_image_line_size_bytes = full_image_line_size_bytes;
            .               g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].line_size_bytes = tile_line_size_bytes;
            .           
            .               //    assert(size_bytes <= 4096 && "bug: too big texture");
       33,874 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].tex_flags = g_rdp.texture_to_load.tex_flags;
       33,874 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].raw_tex_metadata = g_rdp.texture_to_load.raw_tex_metadata;
      101,622 ( 0.00%)      g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].addr = g_rdp.texture_to_load.addr + start_offset_bytes;
            .           
            .               const std::string& texPath =
            .                   g_rdp.texture_to_load.raw_tex_metadata.resource != nullptr
       39,476 ( 0.00%)              ? gfx_get_base_texture_path(g_rdp.texture_to_load.raw_tex_metadata.resource->GetInitData()->Path)
       28,010 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::IResource::GetInitData() (2,801x)
        8,403 ( 0.00%)              : "";
      400,535 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_get_base_texture_path(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (2,801x)
            .               auto maskedTextureIter = masked_textures.find(texPath);
       50,811 ( 0.00%)      if (maskedTextureIter != masked_textures.end()) {
            .                   g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = true;
       50,811 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended =
            .                       maskedTextureIter->second.replacementData != nullptr;
            .               } else {
       67,748 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].masked = false;
       16,937 ( 0.00%)          g_rdp.loaded_texture[g_rdp.texture_tile[tile].tmem_index].blended = false;
            .               }
            .           
      186,307 ( 0.00%)      g_rdp.texture_tile[tile].uls = uls;
            .               g_rdp.texture_tile[tile].ult = ult;
            .               g_rdp.texture_tile[tile].lrs = lrs;
            .               g_rdp.texture_tile[tile].lrt = lrt;
            .           
       16,937 ( 0.00%)      g_rdp.textures_changed[g_rdp.texture_tile[tile].tmem_index] = true;
            .           }
            .           
            .           /*static uint8_t color_comb_component(uint32_t v) {
            .               switch (v) {
            .                   case G_CCMUX_TEXEL0:
            .                       return CC_TEXEL0;
            .                   case G_CCMUX_TEXEL1:
            .                       return CC_TEXEL1;
-- line 2173 ----------------------------------------
-- line 2193 ----------------------------------------
            .                      (color_comb_component(d) << 9);
            .           }
            .           
            .           static void gfx_dp_set_combine_mode(uint32_t rgb, uint32_t alpha) {
            .               g_rdp.combine_mode = rgb | (alpha << 12);
            .           }*/
            .           
            .           static void gfx_dp_set_combine_mode(uint32_t rgb, uint32_t alpha, uint32_t rgb_cyc2, uint32_t alpha_cyc2) {
    1,049,887 ( 0.00%)      g_rdp.combine_mode = rgb | (alpha << 16) | ((uint64_t)rgb_cyc2 << 28) | ((uint64_t)alpha_cyc2 << 44);
            .           }
            .           
            .           static inline uint32_t color_comb(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {
    2,337,894 ( 0.00%)      return (a & 0xf) | ((b & 0xf) << 4) | ((c & 0x1f) << 8) | ((d & 7) << 13);
            .           }
            .           
            .           static inline uint32_t alpha_comb(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {
    2,467,777 ( 0.00%)      return (a & 7) | ((b & 7) << 3) | ((c & 7) << 6) | ((d & 7) << 9);
            .           }
            .           
            .           static void gfx_dp_set_grayscale_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               g_rdp.grayscale_color.r = r;
            .               g_rdp.grayscale_color.g = g;
            .               g_rdp.grayscale_color.b = b;
            .               g_rdp.grayscale_color.a = a;
            .           }
            .           
            .           static void gfx_dp_set_env_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
       10,139 ( 0.00%)      g_rdp.env_color.r = r;
            .               g_rdp.env_color.g = g;
            .               g_rdp.env_color.b = b;
            .               g_rdp.env_color.a = a;
            .           }
            .           
            .           static void gfx_dp_set_prim_color(uint8_t m, uint8_t l, uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               g_rdp.prim_lod_fraction = l;
       26,620 ( 0.00%)      g_rdp.prim_color.r = r;
            .               g_rdp.prim_color.g = g;
            .               g_rdp.prim_color.b = b;
            .               g_rdp.prim_color.a = a;
            .           }
            .           
            .           static void gfx_dp_set_fog_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               g_rdp.fog_color.r = r;
            .               g_rdp.fog_color.g = g;
-- line 2236 ----------------------------------------
-- line 2239 ----------------------------------------
            .           }
            .           
            .           static void gfx_dp_set_blend_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
            .               // TODO: Implement this command..
            .           }
            .           
            .           static void gfx_dp_set_fill_color(uint32_t packed_color) {
            .               uint16_t col16 = (uint16_t)packed_color;
        4,194 ( 0.00%)      uint32_t r = col16 >> 11;
        4,194 ( 0.00%)      uint32_t g = (col16 >> 6) & 0x1f;
        4,194 ( 0.00%)      uint32_t b = (col16 >> 1) & 0x1f;
        1,398 ( 0.00%)      uint32_t a = col16 & 1;
       29,358 ( 0.00%)      g_rdp.fill_color.r = SCALE_5_8(r);
       13,980 ( 0.00%)      g_rdp.fill_color.g = SCALE_5_8(g);
       13,980 ( 0.00%)      g_rdp.fill_color.b = SCALE_5_8(b);
        1,398 ( 0.00%)      g_rdp.fill_color.a = a * 255;
            .           }
            .           
      161,334 ( 0.00%)  static void gfx_draw_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
       26,889 ( 0.00%)      uint32_t saved_other_mode_h = g_rdp.other_mode_h;
       53,778 ( 0.00%)      uint32_t cycle_type = (g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
            .           
       53,778 ( 0.00%)      if (cycle_type == G_CYC_COPY) {
       31,695 ( 0.00%)          g_rdp.other_mode_h = (g_rdp.other_mode_h & ~(3U << G_MDSFT_TEXTFILT)) | G_TF_POINT;
            .               }
            .           
            .               // U10.2 coordinates
       53,778 ( 0.00%)      float ulxf = ulx;
       26,889 ( 0.00%)      float ulyf = uly;
       26,889 ( 0.00%)      float lrxf = lrx;
       53,778 ( 0.00%)      float lryf = lry;
            .           
      242,001 ( 0.00%)      ulxf = ulxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
      215,112 ( 0.00%)      ulyf = -(ulyf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
       53,778 ( 0.00%)      lrxf = lrxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
       53,778 ( 0.00%)      lryf = -(lryf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
            .           
            .               ulxf = gfx_adjust_x_for_aspect_ratio(ulxf);
            .               lrxf = gfx_adjust_x_for_aspect_ratio(lrxf);
            .           
            .               struct LoadedVertex* ul = &g_rsp.loaded_vertices[MAX_VERTICES + 0];
            .               struct LoadedVertex* ll = &g_rsp.loaded_vertices[MAX_VERTICES + 1];
            .               struct LoadedVertex* lr = &g_rsp.loaded_vertices[MAX_VERTICES + 2];
            .               struct LoadedVertex* ur = &g_rsp.loaded_vertices[MAX_VERTICES + 3];
            .           
       53,778 ( 0.00%)      ul->x = ulxf;
            .               ul->y = ulyf;
       53,778 ( 0.00%)      ul->z = -1.0f;
            .               ul->w = 1.0f;
            .           
       53,778 ( 0.00%)      ll->x = ulxf;
            .               ll->y = lryf;
       26,889 ( 0.00%)      ll->z = -1.0f;
            .               ll->w = 1.0f;
            .           
       53,778 ( 0.00%)      lr->x = lrxf;
            .               lr->y = lryf;
       26,889 ( 0.00%)      lr->z = -1.0f;
            .               lr->w = 1.0f;
            .           
       53,778 ( 0.00%)      ur->x = lrxf;
            .               ur->y = ulyf;
       26,889 ( 0.00%)      ur->z = -1.0f;
            .               ur->w = 1.0f;
            .           
            .               // The coordinates for texture rectangle shall bypass the viewport setting
            .               struct XYWidthHeight default_viewport;
            .               if (!fbActive) {
       53,778 ( 0.00%)          default_viewport = { 0, (int16_t)gfx_native_dimensions.height, gfx_native_dimensions.width,
            .                                        gfx_native_dimensions.height };
            .               } else {
            .                   default_viewport = { 0, (int16_t)active_fb->second.orig_height, active_fb->second.orig_width,
            .                                        active_fb->second.orig_height };
            .               }
            .           
       53,778 ( 0.00%)      struct XYWidthHeight viewport_saved = g_rdp.viewport;
       26,889 ( 0.00%)      uint32_t geometry_mode_saved = g_rsp.geometry_mode;
            .           
      134,445 ( 0.00%)      gfx_adjust_viewport_or_scissor(&default_viewport);
    2,124,231 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_adjust_viewport_or_scissor(XYWidthHeight*) (26,889x)
            .           
      107,556 ( 0.00%)      g_rdp.viewport = default_viewport;
       26,889 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
       26,889 ( 0.00%)      g_rsp.geometry_mode = 0;
            .           
      134,445 ( 0.00%)      gfx_sp_tri1(MAX_VERTICES + 0, MAX_VERTICES + 1, MAX_VERTICES + 3, true);
  162,870,028 ( 0.28%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (26,889x)
      134,445 ( 0.00%)      gfx_sp_tri1(MAX_VERTICES + 1, MAX_VERTICES + 2, MAX_VERTICES + 3, true);
   17,799,512 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (26,889x)
            .           
       26,889 ( 0.00%)      g_rsp.geometry_mode = geometry_mode_saved;
       53,778 ( 0.00%)      g_rdp.viewport = viewport_saved;
       26,889 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
            .           
       53,778 ( 0.00%)      if (cycle_type == G_CYC_COPY) {
       10,565 ( 0.00%)          g_rdp.other_mode_h = saved_other_mode_h;
            .               }
      188,223 ( 0.00%)  }
            .           
            .           static void gfx_dp_texture_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry, uint8_t tile, int16_t uls,
            .                                                int16_t ult, int16_t dsdx, int16_t dtdy, bool flip) {
            .               // printf("render %d at %d\n", tile, lrx);
       26,030 ( 0.00%)      uint64_t saved_combine_mode = g_rdp.combine_mode;
      104,120 ( 0.00%)      if ((g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE)) == G_CYC_COPY) {
            .                   // Per RDP Command Summary Set Tile's shift s and this dsdx should be set to 4 texels
            .                   // Divide by 4 to get 1 instead
       10,565 ( 0.00%)          dsdx >>= 2;
            .           
            .                   // Color combiner is turned off in copy mode
            .                   gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_TEXEL0), alpha_comb(0, 0, 0, G_ACMUX_TEXEL0), 0, 0);
            .           
            .                   // Per documentation one extra pixel is added in this modes to each edge
       10,565 ( 0.00%)          lrx += 1 << 2;
       10,565 ( 0.00%)          lry += 1 << 2;
            .               }
            .           
            .               // uls and ult are S10.5
            .               // dsdx and dtdy are S5.10
            .               // lrx, lry, ulx, uly are U10.2
            .               // lrs, lrt are S10.5
       52,060 ( 0.00%)      if (flip) {
            .                   dsdx = -dsdx;
            .                   dtdy = -dtdy;
            .               }
       52,060 ( 0.00%)      int16_t width = !flip ? lrx - ulx : lry - uly;
       52,060 ( 0.00%)      int16_t height = !flip ? lry - uly : lrx - ulx;
      208,240 ( 0.00%)      float lrs = ((uls << 7) + dsdx * width) >> 7;
      234,270 ( 0.00%)      float lrt = ((ult << 7) + dtdy * height) >> 7;
            .           
            .               struct LoadedVertex* ul = &g_rsp.loaded_vertices[MAX_VERTICES + 0];
            .               struct LoadedVertex* ll = &g_rsp.loaded_vertices[MAX_VERTICES + 1];
            .               struct LoadedVertex* lr = &g_rsp.loaded_vertices[MAX_VERTICES + 2];
            .               struct LoadedVertex* ur = &g_rsp.loaded_vertices[MAX_VERTICES + 3];
      156,180 ( 0.00%)      ul->u = uls;
            .               ul->v = ult;
       26,030 ( 0.00%)      lr->u = lrs;
       26,030 ( 0.00%)      lr->v = lrt;
       52,060 ( 0.00%)      if (!flip) {
       52,060 ( 0.00%)          ll->u = uls;
            .                   ll->v = lrt;
       52,060 ( 0.00%)          ur->u = lrs;
            .                   ur->v = ult;
            .               } else {
            .                   ll->u = lrs;
            .                   ll->v = ult;
            .                   ur->u = uls;
            .                   ur->v = lrt;
            .               }
            .           
       26,030 ( 0.00%)      uint8_t saved_tile = g_rdp.first_tile_index;
       52,060 ( 0.00%)      if (saved_tile != tile) {
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
            .               g_rdp.first_tile_index = tile;
            .           
       78,090 ( 0.00%)      gfx_draw_rectangle(ulx, uly, lrx, lry);
  177,076,752 ( 0.30%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_draw_rectangle(int, int, int, int) (26,030x)
       26,030 ( 0.00%)      if (saved_tile != tile) {
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
       26,030 ( 0.00%)      g_rdp.first_tile_index = saved_tile;
       26,030 ( 0.00%)      g_rdp.combine_mode = saved_combine_mode;
            .           }
            .           
            .           static void gfx_dp_image_rectangle(int32_t tile, int32_t w, int32_t h, int32_t ulx, int32_t uly, int16_t uls,
            .                                              int16_t ult, int32_t lrx, int32_t lry, int16_t lrs, int16_t lrt) {
            .           
            .               struct LoadedVertex* ul = &g_rsp.loaded_vertices[MAX_VERTICES + 0];
            .               struct LoadedVertex* ll = &g_rsp.loaded_vertices[MAX_VERTICES + 1];
            .               struct LoadedVertex* lr = &g_rsp.loaded_vertices[MAX_VERTICES + 2];
-- line 2406 ----------------------------------------
-- line 2442 ----------------------------------------
            .               if (saved_tile != tile) {
            .                   g_rdp.textures_changed[0] = true;
            .                   g_rdp.textures_changed[1] = true;
            .               }
            .               g_rdp.first_tile_index = saved_tile;
            .           }
            .           
            .           static void gfx_dp_fill_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
        4,290 ( 0.00%)      if (g_rdp.color_image_address == g_rdp.z_buf_address) {
            .                   // Don't clear Z buffer here since we already did it with glClear
            .                   return;
            .               }
          859 ( 0.00%)      uint32_t mode = (g_rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
            .           
            .               // OTRTODO: This is a bit of a hack for widescreen screen fades, but it'll work for now...
        6,616 ( 0.00%)      if (ulx == 0 && uly == 0 && lrx == (319 * 4) && lry == (239 * 4)) {
          571 ( 0.00%)          ulx = -1024;
          571 ( 0.00%)          uly = -1024;
          571 ( 0.00%)          lrx = 2048;
          571 ( 0.00%)          lry = 2048;
            .               }
            .           
        1,718 ( 0.00%)      if (mode == G_CYC_COPY || mode == G_CYC_FILL) {
            .                   // Per documentation one extra pixel is added in this modes to each edge
          258 ( 0.00%)          lrx += 1 << 2;
          258 ( 0.00%)          lry += 1 << 2;
            .               }
            .           
            .               for (int i = MAX_VERTICES; i < MAX_VERTICES + 4; i++) {
            .                   struct LoadedVertex* v = &g_rsp.loaded_vertices[i];
        4,295 ( 0.00%)          v->color = g_rdp.fill_color;
            .               }
            .           
          859 ( 0.00%)      uint64_t saved_combine_mode = g_rdp.combine_mode;
            .           
          774 ( 0.00%)      if (mode == G_CYC_FILL) {
            .                   gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_SHADE), alpha_comb(0, 0, 0, G_ACMUX_SHADE), 0, 0);
            .               }
            .           
          859 ( 0.00%)      gfx_draw_rectangle(ulx, uly, lrx, lry);
    8,448,179 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_draw_rectangle(int, int, int, int) (859x)
          859 ( 0.00%)      g_rdp.combine_mode = saved_combine_mode;
            .           }
            .           
            .           static void gfx_dp_set_z_image(void* z_buf_address) {
          570 ( 0.00%)      g_rdp.z_buf_address = z_buf_address;
            .           }
            .           
            .           static void gfx_dp_set_color_image(uint32_t format, uint32_t size, uint32_t width, void* address) {
        1,710 ( 0.00%)      g_rdp.color_image_address = address;
            .           }
            .           
            .           static void gfx_sp_set_other_mode(uint32_t shift, uint32_t num_bits, uint64_t mode) {
    1,239,008 ( 0.00%)      uint64_t mask = (((uint64_t)1 << num_bits) - 1) << shift;
            .               uint64_t om = g_rdp.other_mode_l | ((uint64_t)g_rdp.other_mode_h << 32);
      619,504 ( 0.00%)      om = (om & ~mask) | mode;
      309,752 ( 0.00%)      g_rdp.other_mode_l = (uint32_t)om;
            .               g_rdp.other_mode_h = (uint32_t)(om >> 32);
            .           }
            .           
            .           static void gfx_dp_set_other_mode(uint32_t h, uint32_t l) {
            .               g_rdp.other_mode_h = h;
            .               g_rdp.other_mode_l = l;
            .           }
            .           
-- line 2505 ----------------------------------------
-- line 2621 ----------------------------------------
            .           
            .               gfx_dp_texture_rectangle(realX << 2, realY << 2, testX << 2, testY << 2, G_TX_RENDERTILE,
            .                                        g_rdp.texture_tile[0].uls << 3, g_rdp.texture_tile[0].ult << 3, (float)(1 << 10) * realSW,
            .                                        (float)(1 << 10) * realSH, false);
            .           }
            .           
            .           static inline void* seg_addr(uintptr_t w1) {
            .               // Segmented?
   18,971,734 ( 0.03%)      if (w1 & 1) {
       19,040 ( 0.00%)          uint32_t segNum = (uint32_t)(w1 >> 24);
            .           
            .                   uint32_t offset = w1 & 0x00FFFFFE;
            .           
       38,080 ( 0.00%)          if (gSegmentPointers[segNum] != 0) {
       19,040 ( 0.00%)              return (void*)(gSegmentPointers[segNum] + offset);
            .                   } else {
            .                       return (void*)w1;
            .                   }
            .               } else {
    9,260,506 ( 0.02%)          return (void*)w1;
            .               }
            .           }
            .           
            .           #define C0(pos, width) ((cmd->words.w0 >> (pos)) & ((1U << width) - 1))
            .           #define C1(pos, width) ((cmd->words.w1 >> (pos)) & ((1U << width) - 1))
            .           
        3,997 ( 0.00%)  void GfxExecStack::start(F3DGfx* dlist) {
        1,142 ( 0.00%)      while (!cmd_stack.empty())
            .                   cmd_stack.pop();
            .               gfx_path.clear();
            .               cmd_stack.push(dlist);
            .               disp_stack.clear();
        1,713 ( 0.00%)  }
            .           
            .           void GfxExecStack::stop() {
            .               while (!cmd_stack.empty())
            .                   cmd_stack.pop();
            .               gfx_path.clear();
            .           }
            .           
            .           F3DGfx*& GfxExecStack::currCmd() {
-- line 2661 ----------------------------------------
-- line 2681 ----------------------------------------
            .               gfx_path.push_back(caller);
            .           }
            .           
            .           void GfxExecStack::call(F3DGfx* caller, F3DGfx* callee) {
            .               cmd_stack.push(callee);
            .               gfx_path.push_back(caller);
            .           }
            .           
    1,545,864 ( 0.00%)  F3DGfx* GfxExecStack::ret() {
      257,644 ( 0.00%)      F3DGfx* cmd = cmd_stack.top();
            .           
            .               cmd_stack.pop();
      515,288 ( 0.00%)      if (!gfx_path.empty()) {
            .                   gfx_path.pop_back();
            .               }
            .           
    1,029,434 ( 0.00%)      while (cmd_stack.size() > 0 && cmd_stack.top() == nullptr) {
            .                   cmd_stack.pop();
            .                   if (!gfx_path.empty()) {
            .                       gfx_path.pop_back();
            .                   }
            .               }
            .               return cmd;
    1,545,864 ( 0.00%)  }
            .           
            .           void gfx_set_framebuffer(int fb, float noise_scale);
            .           void gfx_reset_framebuffer();
            .           void gfx_copy_framebuffer(int fb_dst_id, int fb_src_id, bool copyOnce, bool* hasCopiedPtr);
            .           
            .           // The main type of the handler function. These function will take a pointer to a pointer to a Gfx. It needs to be a
            .           // double pointer because we sometimes need to increment and decrement the underlying pointer Returns false if the
            .           // current opcode should be incremented after the handler ends.
-- line 2712 ----------------------------------------
-- line 2716 ----------------------------------------
            .               g_rsp.fog_mul = 0;
            .               g_rsp.fog_offset = 0;
            .               return false;
            .           }
            .           
            .           bool gfx_cull_dl_handler_f3dex2(F3DGfx** cmd) {
            .               // TODO:
            .               return false;
       72,352 ( 0.00%)  }
            .           
      443,764 ( 0.00%)  bool gfx_marker_handler_otr(F3DGfx** cmd0) {
      332,823 ( 0.00%)      (*cmd0)++;
            .               F3DGfx* cmd = (*cmd0);
      332,823 ( 0.00%)      const uint64_t hash = ((uint64_t)(cmd)->words.w0 << 32) + (cmd)->words.w1;
      110,941 ( 0.00%)      std::string dlName = ResourceGetNameByCrc(hash);
   15,082,625 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (110,941x)
      110,941 ( 0.00%)      markerOn = true;
            .               return false;
      665,646 ( 0.00%)  }
            .           
            .           bool gfx_invalidate_tex_cache_handler_f3dex2(F3DGfx** cmd) {
            .               const uintptr_t texAddr = (*cmd)->words.w1;
            .           
            .               if (texAddr == 0) {
            .                   gfx_texture_cache_clear();
            .               } else {
            .                   gfx_texture_cache_delete((const uint8_t*)texAddr);
            .               }
            .               return false;
            .           }
            .           
       93,205 ( 0.00%)  bool gfx_noop_handler_f3dex2(F3DGfx** cmd0) {
       13,315 ( 0.00%)      F3DGfx* cmd = *cmd0;
       13,315 ( 0.00%)      const char* filename = (const char*)(cmd)->words.w1;
       66,575 ( 0.00%)      uint32_t p = C0(16, 8);
       26,630 ( 0.00%)      uint32_t l = C0(0, 16);
       26,630 ( 0.00%)      if (p == 7) {
            .                   g_exec_stack.openDisp(filename, l);
       26,630 ( 0.00%)      } else if (p == 8) {
            .                   if (g_exec_stack.disp_stack.size() == 0) {
            .                       SPDLOG_WARN("CLOSE_DISPS without matching open {}:{}", p, l);
            .                   } else {
            .                       g_exec_stack.closeDisp();
            .                   }
            .               }
            .               return false;
      119,835 ( 0.00%)  }
            .           
            .           bool gfx_mtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               uintptr_t mtxAddr = cmd->words.w1;
            .           
            .               gfx_sp_matrix(C0(0, 8) ^ F3DEX2_G_MTX_PUSH, (const int32_t*)seg_addr(mtxAddr));
            .               return false;
            .           }
            .           // Seems to be the same for all other non F3DEX2 microcodes...
       72,003 ( 0.00%)  bool gfx_mtx_handler_f3d(F3DGfx** cmd0) {
       72,003 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .               uintptr_t mtxAddr = cmd->words.w1;
            .           
      216,009 ( 0.00%)      gfx_sp_matrix(C0(16, 8), (const int32_t*)seg_addr(cmd->words.w1));
   18,898,550 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_matrix(unsigned char, int const*) (72,003x)
            .               return false;
      216,009 ( 0.00%)  }
            .           
            .           bool gfx_mtx_otr_handler_custom_f3dex2(F3DGfx** cmd0) {
            .               (*cmd0)++;
            .               F3DGfx* cmd = *cmd0;
            .           
            .               const uint64_t hash = ((uint64_t)cmd->words.w0 << 32) + cmd->words.w1;
            .           
            .               const int32_t* mtx = (const int32_t*)ResourceGetDataByCrc(hash);
-- line 2785 ----------------------------------------
-- line 2815 ----------------------------------------
            .           }
            .           
            .           bool gfx_pop_mtx_handler_f3d(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_pop_matrix(1);
            .           
            .               return false;
       19,680 ( 0.00%)  }
            .           
            .           bool gfx_movemem_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_movemem_f3dex2(C0(0, 8), C0(8, 8) * 8, seg_addr(cmd->words.w1));
            .           
            .               return false;
            .           }
            .           
        3,612 ( 0.00%)  bool gfx_movemem_handler_f3d(F3DGfx** cmd0) {
        6,654 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
       19,962 ( 0.00%)      gfx_sp_movemem_f3d(C0(16, 8), 0, seg_addr(cmd->words.w1));
            .           
            .               return false;
       16,920 ( 0.00%)  }
            .           
            .           bool gfx_movemem_handler_otr(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               const uint8_t index = C1(24, 8);
            .               const uint8_t offset = C1(16, 8);
            .               const uint8_t hasOffset = C1(8, 8);
            .           
-- line 2847 ----------------------------------------
-- line 2863 ----------------------------------------
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_moveword_f3dex2(C0(16, 8), C0(0, 16), cmd->words.w1);
            .           
            .               return false;
            .           }
            .           
            .           bool gfx_moveword_handler_f3d(F3DGfx** cmd0) {
       23,639 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
       47,278 ( 0.00%)      gfx_sp_moveword_f3d(C0(0, 8), C0(8, 16), cmd->words.w1);
            .           
            .               return false;
       47,278 ( 0.00%)  }
            .           
            .           bool gfx_texture_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_texture(C1(16, 16), C1(0, 16), C0(11, 3), C0(8, 3), C0(1, 7));
            .           
            .               return false;
            .           }
            .           
            .           // Seems to be the same for all other non F3DEX2 microcodes...
    1,420,922 ( 0.00%)  bool gfx_texture_handler_f3d(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_texture(C1(16, 16), C1(0, 16), C0(11, 3), C0(8, 3), C0(0, 8));
            .           
            .               return false;
            .           }
            .           
            .           // Almost all versions of the microcode have their own version of this opcode
-- line 2895 ----------------------------------------
-- line 2896 ----------------------------------------
            .           bool gfx_vtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), (const F3DVtx*)seg_addr(cmd->words.w1));
            .           
            .               return false;
            .           }
            .           
    9,099,361 ( 0.02%)  bool gfx_vtx_handler_f3dex(F3DGfx** cmd0) {
    9,099,361 ( 0.02%)      F3DGfx* cmd = *cmd0;
   72,794,888 ( 0.12%)      gfx_sp_vertex(C0(10, 6), C0(17, 7), (const F3DVtx*)seg_addr(cmd->words.w1));
43,734,419,271 (74.20%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) (9,099,361x)
            .           
            .               return false;
   27,298,083 ( 0.05%)  }
            .           
            .           bool gfx_vtx_handler_f3d(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_vertex((C0(0, 16)) / sizeof(F3DVtx), C0(16, 4), (const F3DVtx*)seg_addr(cmd->words.w1));
            .           
            .               return false;
            .           }
            .           
      128,228 ( 0.00%)  bool gfx_vtx_hash_handler_custom(F3DGfx** cmd0) {
            .               // Offset added to the start of the vertices
       64,114 ( 0.00%)      const uintptr_t offset = (*cmd0)->words.w1;
            .               // This is a two-part display list command, so increment the instruction pointer so we can get the CRC64
            .               // hash from the second
       64,114 ( 0.00%)      (*cmd0)++;
          294 ( 0.00%)      const uint64_t hash = ((uint64_t)(*cmd0)->words.w0 << 32) + (*cmd0)->words.w1;
            .           
            .               // We need to know if the offset is a cached pointer or not. An offset greater than one million is not a
            .               // real offset, so it must be a real pointer
       64,114 ( 0.00%)      if (offset > 0xFFFFF) {
       31,959 ( 0.00%)          (*cmd0)--;
            .                   F3DGfx* cmd = *cmd0;
      287,631 ( 0.00%)          gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), (F3DVtx*)offset);
   30,016,443 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) (31,959x)
       31,959 ( 0.00%)          (*cmd0)++;
            .               } else {
           98 ( 0.00%)          F3DVtx* vtx = (F3DVtx*)ResourceGetDataByCrc(hash);
      253,487 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByCrc (98x)
            .           
          196 ( 0.00%)          if (vtx != NULL) {
           98 ( 0.00%)              vtx = (F3DVtx*)((char*)vtx + offset);
            .           
          294 ( 0.00%)              (*cmd0)--;
            .                       F3DGfx* cmd = *cmd0;
            .           
            .                       // TODO: WTF??
           98 ( 0.00%)              cmd->words.w1 = (uintptr_t)vtx;
            .           
          784 ( 0.00%)              gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), vtx);
      127,201 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_vertex(unsigned long, unsigned long, F3DVtx const*) (98x)
           98 ( 0.00%)              (*cmd0)++;
            .                   }
            .               }
            .               return false;
      160,285 ( 0.00%)  }
            .           
            .           bool gfx_vtx_otr_filepath_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               char* fileName = (char*)cmd->words.w1;
            .               cmd++;
            .               size_t vtxCnt = cmd->words.w0;
            .               size_t vtxIdxOff = cmd->words.w1 >> 16;
            .               size_t vtxDataOff = cmd->words.w1 & 0xFFFF;
-- line 2959 ----------------------------------------
-- line 2990 ----------------------------------------
            .           // The original F3D microcode doesn't seem to have this opcode. Glide handles it as part of moveword
            .           bool gfx_modify_vtx_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               gfx_sp_modify_vertex(C0(1, 15), C0(16, 8), (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
            .           // F3D, F3DEX, and F3DEX2 do the same thing but F3DEX2 has its own opcode number
    1,295,046 ( 0.00%)  bool gfx_dl_handler_common(F3DGfx** cmd0) {
      215,841 ( 0.00%)      F3DGfx* cmd = *cmd0;
      215,841 ( 0.00%)      F3DGfx* subGFX = (F3DGfx*)seg_addr(cmd->words.w1);
      863,364 ( 0.00%)      if (C0(16, 1) == 0) {
            .                   // Push return address
      647,523 ( 0.00%)          if (subGFX != nullptr) {
            .                       g_exec_stack.call(*cmd0, subGFX);
            .                   }
            .               } else {
            .                   (*cmd0) = subGFX;
            .                   g_exec_stack.branch(cmd);
            .                   return true; // shortcut cmd increment
            .               }
      215,841 ( 0.00%)      return false;
    1,510,887 ( 0.00%)  }
            .           
      247,392 ( 0.00%)  bool gfx_dl_otr_hash_handler_custom(F3DGfx** cmd0) {
       41,232 ( 0.00%)      F3DGfx* cmd = *cmd0;
       82,464 ( 0.00%)      if (C0(16, 1) == 0) {
            .                   // Push return address
       82,464 ( 0.00%)          (*cmd0)++;
            .           
      123,696 ( 0.00%)          uint64_t hash = ((uint64_t)(*cmd0)->words.w0 << 32) + (*cmd0)->words.w1;
            .           
       41,232 ( 0.00%)          F3DGfx* gfx = (F3DGfx*)ResourceGetDataByCrc(hash);
   76,615,961 ( 0.13%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByCrc (41,232x)
            .           
       82,464 ( 0.00%)          if (gfx != 0) {
            .                       g_exec_stack.call(cmd, gfx);
            .                   }
            .               } else {
            .                   assert(0 && "????");
            .                   (*cmd0) = (F3DGfx*)seg_addr((*cmd0)->words.w1);
            .                   return true;
            .               }
            .               return false;
      329,856 ( 0.00%)  }
            .           bool gfx_dl_index_handler(F3DGfx** cmd0) {
            .               // Compute seg addr by converting an index value to a offset value
            .               // handling 32 vs 64 bit size differences for Gfx
            .               // adding 1 to trigger the segaddr flow
            .               F3DGfx* cmd = (*cmd0);
            .               uint8_t segNum = (uint8_t)(cmd->words.w1 >> 24);
            .               uint32_t index = (uint32_t)(cmd->words.w1 & 0x00FFFFFF);
            .               uintptr_t segAddr = (segNum << 24) | (index * sizeof(F3DGfx)) + 1;
-- line 3041 ----------------------------------------
-- line 3080 ----------------------------------------
            .                       g_exec_stack.branch(cmd);
            .                       return true; // shortcut cmd increment
            .                   }
            .               }
            .               return false;
            .           }
            .           
            .           // F3D, F3DEX, and F3DEX2 do the same thing but F3DEX2 has its own opcode number
      515,288 ( 0.00%)  bool gfx_end_dl_handler_common(F3DGfx** cmd0) {
      257,644 ( 0.00%)      markerOn = false;
      772,932 ( 0.00%)      *cmd0 = g_exec_stack.ret();
   12,363,486 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::ret() (257,644x)
            .               return true;
      772,932 ( 0.00%)  }
            .           
            .           bool gfx_set_prim_depth_handler_rdp(F3DGfx** cmd) {
            .               // TODO Implement this command...
            .               return false;
            .           }
            .           
            .           // Only on F3DEX2
            .           bool gfx_geometry_mode_handler_f3dex2(F3DGfx** cmd0) {
-- line 3100 ----------------------------------------
-- line 3130 ----------------------------------------
            .           bool gfx_tri1_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_tri1(C0(16, 8) / 2, C0(8, 8) / 2, C0(0, 8) / 2, false);
            .           
            .               return false;
            .           }
            .           
       52,793 ( 0.00%)  bool gfx_tri1_handler_f3dex(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
      633,516 ( 0.00%)      gfx_sp_tri1(C1(17, 7), C1(9, 7), C1(1, 7), false);
  165,650,709 ( 0.28%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (52,793x)
            .           
            .               return false;
      158,379 ( 0.00%)  }
            .           
            .           bool gfx_tri1_handler_f3d(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_tri1(C1(16, 8) / 10, C1(8, 8) / 10, C1(0, 8) / 10, false);
            .           
            .               return false;
            .           }
            .           
            .           // F3DEX, and F3DEX2 share a tri2 function, however F3DEX has a different quad function.
   70,954,659 ( 0.12%)  bool gfx_tri2_handler_f3dex(F3DGfx** cmd0) {
   70,954,659 ( 0.12%)      F3DGfx* cmd = *cmd0;
            .           
  780,501,249 ( 1.32%)      gfx_sp_tri1(C0(17, 7), C0(9, 7), C0(1, 7), false);
4,142,536,327 ( 7.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (70,954,659x)
  780,501,249 ( 1.32%)      gfx_sp_tri1(C1(17, 7), C1(9, 7), C1(1, 7), false);
3,758,241,047 ( 6.38%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_sp_tri1(unsigned char, unsigned char, unsigned char, bool) (70,954,659x)
            .               return false;
  212,863,977 ( 0.36%)  }
            .           
            .           bool gfx_quad_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_tri1(C0(16, 8) / 2, C0(8, 8) / 2, C0(0, 8) / 2, false);
            .               gfx_sp_tri1(C1(16, 8) / 2, C1(8, 8) / 2, C1(0, 8) / 2, false);
            .               return false;
            .           }
-- line 3169 ----------------------------------------
-- line 3179 ----------------------------------------
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_set_other_mode(31 - C0(8, 8) - C0(0, 8), C0(0, 8) + 1, cmd->words.w1);
            .           
            .               return false;
            .           }
            .           
            .           bool gfx_othermode_l_handler_f3d(F3DGfx** cmd0) {
       89,494 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      178,988 ( 0.00%)      gfx_sp_set_other_mode(C0(8, 8), C0(0, 8), cmd->words.w1);
            .           
            .               return false;
      178,988 ( 0.00%)  }
            .           
            .           bool gfx_othermode_h_handler_f3dex2(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_sp_set_other_mode(63 - C0(8, 8) - C0(0, 8), C0(0, 8) + 1, (uint64_t)cmd->words.w1 << 32);
            .           
            .               return false;
            .           }
            .           
            .           // Only on F3DEX and older
      779,300 ( 0.00%)  bool gfx_set_geometry_mode_handler_f3dex(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               gfx_sp_geometry_mode(0, (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
            .           // Only on F3DEX and older
    1,073,100 ( 0.00%)  bool gfx_clear_geometry_mode_handler_f3dex(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               gfx_sp_geometry_mode((uint32_t)cmd->words.w1, 0);
            .               return false;
            .           }
            .           
            .           bool gfx_othermode_h_handler_f3d(F3DGfx** cmd0) {
      220,258 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    1,101,290 ( 0.00%)      gfx_sp_set_other_mode(C0(8, 8) + 32, C0(0, 8), (uint64_t)cmd->words.w1 << 32);
            .           
            .               return false;
      440,516 ( 0.00%)  }
            .           
      717,824 ( 0.00%)  bool gfx_set_timg_handler_rdp(F3DGfx** cmd0) {
       89,728 ( 0.00%)      F3DGfx* cmd = *cmd0;
       89,728 ( 0.00%)      uintptr_t i = (uintptr_t)seg_addr(cmd->words.w1);
            .           
            .               char* imgData = (char*)i;
       32,727 ( 0.00%)      uint32_t texFlags = 0;
       51,767 ( 0.00%)      RawTexMetadata rawTexMetdata = {};
            .           
       19,040 ( 0.00%)      if ((i & 1) != 1) {
      439,120 ( 0.00%)          if (gfx_check_image_signature(imgData) == 1) {
   10,249,116 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_check_image_signature(char const*) (89,728x)
            .                       std::shared_ptr<LUS::Texture> tex = std::static_pointer_cast<LUS::Texture>(
      684,012 ( 0.00%)                  Ship::Context::GetInstance()->GetResourceManager()->LoadResourceProcess(imgData));
   48,000,994 ( 0.08%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (57,001x)
    1,197,021 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (57,001x)
      570,010 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetResourceManager() (57,001x)
            .           
      114,002 ( 0.00%)              if (tex == nullptr) {
            .                           (*cmd0)++;
            .                           return false;
            .                       }
            .           
       57,001 ( 0.00%)              i = (uintptr_t) reinterpret_cast<char*>(tex->ImageData);
       57,001 ( 0.00%)              texFlags = tex->Flags;
       57,001 ( 0.00%)              rawTexMetdata.width = tex->Width;
       57,001 ( 0.00%)              rawTexMetdata.height = tex->Height;
       57,001 ( 0.00%)              rawTexMetdata.h_byte_scale = tex->HByteScale;
       57,001 ( 0.00%)              rawTexMetdata.v_pixel_scale = tex->VPixelScale;
       57,001 ( 0.00%)              rawTexMetdata.type = tex->Type;
            .                       rawTexMetdata.resource = tex;
            .                   }
            .               }
            .           
      448,640 ( 0.00%)      gfx_dp_set_texture_image(C0(21, 3), C0(19, 2), C0(0, 10), imgData, texFlags, rawTexMetdata, (void*)i);
            .           
            .               return false;
      807,552 ( 0.00%)  }
            .           
       86,112 ( 0.00%)  bool gfx_set_timg_otr_hash_handler_custom(F3DGfx** cmd0) {
        9,568 ( 0.00%)      uintptr_t addr = (*cmd0)->words.w1;
       19,136 ( 0.00%)      (*cmd0)++;
       38,272 ( 0.00%)      uint64_t hash = ((uint64_t)(*cmd0)->words.w0 << 32) + (uint64_t)(*cmd0)->words.w1;
            .           
       19,136 ( 0.00%)      const char* fileName = ResourceGetNameByCrc(hash);
    1,282,411 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (9,568x)
            .               uint32_t texFlags = 0;
            .               RawTexMetadata rawTexMetadata = {};
            .           
       19,136 ( 0.00%)      if (fileName == nullptr) {
            .                   (*cmd0)++;
            .                   return false;
            .               }
            .           
            .               std::shared_ptr<LUS::Texture> texture = std::static_pointer_cast<LUS::Texture>(
      143,520 ( 0.00%)          Ship::Context::GetInstance()->GetResourceManager()->LoadResourceProcess(ResourceGetNameByCrc(hash)));
    6,477,844 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (9,568x)
    1,282,411 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (9,568x)
      200,928 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (9,568x)
       95,680 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetResourceManager() (9,568x)
       28,704 ( 0.00%)      if (texture != nullptr) {
        9,568 ( 0.00%)          texFlags = texture->Flags;
        9,568 ( 0.00%)          rawTexMetadata.width = texture->Width;
            .                   rawTexMetadata.height = texture->Height;
        9,568 ( 0.00%)          rawTexMetadata.h_byte_scale = texture->HByteScale;
            .                   rawTexMetadata.v_pixel_scale = texture->VPixelScale;
        9,568 ( 0.00%)          rawTexMetadata.type = texture->Type;
            .                   rawTexMetadata.resource = texture;
            .           
            .                   // #if _DEBUG && 0
            .                   // tex = reinterpret_cast<char*>(texture->imageData);
            .                   // ResourceMgr_GetNameByCRC(hash, fileName);
            .                   // fprintf(stderr, "G_SETTIMG_OTR_HASH: %s (%dx%d) size=0x%x, %08X\n", fileName, texture->Width,
            .                   //         texture->Height, texture->ImageDataSize, hash);
            .                   // #else
            .                   char* tex = NULL;
            .                   // #endif
            .           
            .                   // OTRTODO: We have disabled caching for now to fix a texture corruption issue with HD texture
            .                   // support. In doing so, there is a potential performance hit since we are not caching lookups. We
            .                   // need to do proper profiling to see whether or not it is worth it to keep the caching system.
            .           
       19,136 ( 0.00%)          tex = reinterpret_cast<char*>(texture->ImageData);
            .           
       38,272 ( 0.00%)          if (tex != nullptr) {
            .                       (*cmd0)--;
            .                       uintptr_t oldData = (*cmd0)->words.w1;
            .                       // TODO: wtf??
        9,568 ( 0.00%)              (*cmd0)->words.w1 = (uintptr_t)tex;
            .           
            .                       // if (ourHash != (uint64_t)-1) {
            .                       //     auto res = ResourceLoad(ourHash);
            .                       // }
            .           
            .                       (*cmd0)++;
            .                   }
            .           
       28,704 ( 0.00%)          (*cmd0)--;
            .                   F3DGfx* cmd = (*cmd0);
        9,568 ( 0.00%)          uint32_t fmt = C0(21, 3);
       19,136 ( 0.00%)          uint32_t size = C0(19, 2);
       19,136 ( 0.00%)          uint32_t width = C0(0, 10);
            .           
            .                   if (tex != NULL) {
            .                       gfx_dp_set_texture_image(fmt, size, width, fileName, texFlags, rawTexMetadata, tex);
            .                   }
            .               } else {
            .                   SPDLOG_ERROR("G_SETTIMG_OTR_HASH: Texture is null");
            .               }
            .           
        9,568 ( 0.00%)      (*cmd0)++;
            .               return false;
       86,112 ( 0.00%)  }
            .           
            .           bool gfx_set_timg_otr_filepath_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               const char* fileName = (char*)cmd->words.w1;
            .           
            .               uint32_t texFlags = 0;
            .               RawTexMetadata rawTexMetadata = {};
            .           
-- line 3334 ----------------------------------------
-- line 3435 ----------------------------------------
            .           
            .           bool gfx_set_grayscale_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               g_rdp.grayscale = cmd->words.w1;
            .               return false;
            .           }
            .           
       72,850 ( 0.00%)  bool gfx_load_block_handler_rdp(F3DGfx** cmd0) {
       72,850 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      874,200 ( 0.00%)      gfx_dp_load_block(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
   25,768,636 ( 0.04%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dp_load_block(unsigned char, unsigned int, unsigned int, unsigned int, unsigned int) [clone .isra.0] (72,850x)
            .               return false;
      218,550 ( 0.00%)  }
            .           
      118,559 ( 0.00%)  bool gfx_load_tile_handler_rdp(F3DGfx** cmd0) {
       16,937 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      203,244 ( 0.00%)      gfx_dp_load_tile(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
            .               return false;
      152,433 ( 0.00%)  }
            .           
      732,656 ( 0.00%)  bool gfx_set_tile_handler_rdp(F3DGfx** cmd0) {
      183,164 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
    4,395,936 ( 0.01%)      gfx_dp_set_tile(C0(21, 3), C0(19, 2), C0(9, 9), C0(0, 9), C1(24, 3), C1(20, 4), C1(18, 2), C1(14, 4), C1(10, 4),
      915,820 ( 0.00%)                      C1(8, 2), C1(4, 4), C1(0, 4));
            .               return false;
    1,098,984 ( 0.00%)  }
            .           
            .           bool gfx_set_tile_size_handler_rdp(F3DGfx** cmd0) {
       88,628 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      620,396 ( 0.00%)      gfx_dp_set_tile_size(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
            .               return false;
      177,256 ( 0.00%)  }
            .           
        4,749 ( 0.00%)  bool gfx_load_tlut_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
       28,494 ( 0.00%)      gfx_dp_load_tlut(C1(24, 3), C1(14, 10));
            .               return false;
       14,247 ( 0.00%)  }
            .           
            .           bool gfx_set_env_color_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
       20,278 ( 0.00%)      gfx_dp_set_env_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
       20,278 ( 0.00%)  }
            .           
            .           bool gfx_set_prim_color_handler_rdp(F3DGfx** cmd0) {
       26,620 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
       79,860 ( 0.00%)      gfx_dp_set_prim_color(C0(8, 8), C0(0, 8), C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
       53,240 ( 0.00%)  }
            .           
            .           bool gfx_set_fog_color_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_dp_set_fog_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
            .           }
            .           
-- line 3499 ----------------------------------------
-- line 3502 ----------------------------------------
            .           
            .               gfx_dp_set_blend_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
            .           }
            .           
            .           bool gfx_set_fill_color_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
        2,796 ( 0.00%)      gfx_dp_set_fill_color((uint32_t)cmd->words.w1);
            .               return false;
        2,796 ( 0.00%)  }
            .           
            .           bool gfx_set_intensity_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .           
            .               gfx_dp_set_grayscale_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
            .               return false;
            .           }
            .           
            .           bool gfx_set_combine_handler_rdp(F3DGfx** cmd0) {
      129,883 ( 0.00%)      F3DGfx* cmd = *cmd0;
            .           
      519,532 ( 0.00%)      gfx_dp_set_combine_mode(
    2,078,128 ( 0.00%)          color_comb(C0(20, 4), C1(28, 4), C0(15, 5), C1(15, 3)), alpha_comb(C0(12, 3), C1(12, 3), C0(9, 3), C1(9, 3)),
    1,688,479 ( 0.00%)          color_comb(C0(5, 4), C1(24, 4), C0(0, 5), C1(6, 3)), alpha_comb(C1(21, 3), C1(3, 3), C1(18, 3), C1(0, 3)));
            .               return false;
      259,766 ( 0.00%)  }
            .           
      156,180 ( 0.00%)  bool gfx_tex_rect_and_flip_handler_rdp(F3DGfx** cmd0) {
       26,030 ( 0.00%)      F3DGfx* cmd = *cmd0;
       78,090 ( 0.00%)      int8_t opcode = (int8_t)(cmd->words.w0 >> 24);
            .               int32_t lrx, lry, tile, ulx, uly;
            .               uint32_t uls, ult, dsdx, dtdy;
            .           
       78,090 ( 0.00%)      lrx = C0(12, 12);
       26,030 ( 0.00%)      lry = C0(0, 12);
       78,090 ( 0.00%)      tile = C1(24, 3);
       78,090 ( 0.00%)      ulx = C1(12, 12);
       52,060 ( 0.00%)      uly = C1(0, 12);
            .               // TODO make sure I don't need to increment cmd0
            .               ++(*cmd0);
            .               cmd = *cmd0;
      104,120 ( 0.00%)      uls = C1(16, 16);
            .               ult = C1(0, 16);
       52,060 ( 0.00%)      ++(*cmd0);
            .               cmd = *cmd0;
      104,120 ( 0.00%)      dsdx = C1(16, 16);
            .               dtdy = C1(0, 16);
            .           
       26,030 ( 0.00%)      gfx_dp_texture_rectangle(ulx, uly, lrx, lry, tile, uls, ult, dsdx, dtdy, opcode == RDP_G_TEXRECTFLIP);
            .               return false;
      260,300 ( 0.00%)  }
            .           
            .           bool gfx_tex_rect_wide_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *cmd0;
            .               int8_t opcode = (int8_t)(cmd->words.w0 >> 24);
            .               int32_t lrx, lry, tile, ulx, uly;
            .               uint32_t uls, ult, dsdx, dtdy;
            .           
            .               lrx = static_cast<int32_t>((C0(0, 24) << 8)) >> 8;
-- line 3561 ----------------------------------------
-- line 3593 ----------------------------------------
            .               y1 = C0(0, 16);
            .               s1 = C1(16, 16);
            .               t1 = C1(0, 16);
            .               gfx_dp_image_rectangle(tile, iw, ih, x0, y0, s0, t0, x1, y1, s1, t1);
            .           
            .               return false;
            .           }
            .           
          859 ( 0.00%)  bool gfx_fill_rect_handler_rdp(F3DGfx** cmd0) {
        1,430 ( 0.00%)      F3DGfx* cmd = *(cmd0);
            .           
       11,824 ( 0.00%)      gfx_dp_fill_rectangle(C1(12, 12), C1(0, 12), C0(12, 12), C0(0, 12));
            .               return false;
        3,719 ( 0.00%)  }
            .           
            .           bool gfx_fill_wide_rect_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .               int32_t lrx, lry, ulx, uly;
            .           
            .               lrx = (int32_t)(C0(0, 24) << 8) >> 8;
            .               lry = (int32_t)(C1(0, 24) << 8) >> 8;
            .               cmd = ++(*cmd0);
            .               ulx = (int32_t)(C0(0, 24) << 8) >> 8;
            .               uly = (int32_t)(C1(0, 24) << 8) >> 8;
            .               gfx_dp_fill_rectangle(ulx, uly, lrx, lry);
            .           
            .               return false;
            .           }
            .           
        7,132 ( 0.00%)  bool gfx_set_scissor_handler_rdp(F3DGfx** cmd0) {
        7,132 ( 0.00%)      F3DGfx* cmd = *(cmd0);
            .           
       78,452 ( 0.00%)      gfx_dp_set_scissor(C1(24, 2), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
            .               return false;
       21,396 ( 0.00%)  }
            .           
            .           bool gfx_set_z_img_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .           
        1,140 ( 0.00%)      gfx_dp_set_z_image(seg_addr(cmd->words.w1));
            .               return false;
        1,140 ( 0.00%)  }
            .           
            .           bool gfx_set_c_img_handler_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .           
        3,420 ( 0.00%)      gfx_dp_set_color_image(C0(21, 3), C0(19, 2), C0(0, 11), seg_addr(cmd->words.w1));
            .               return false;
        3,420 ( 0.00%)  }
            .           
            .           bool gfx_rdp_set_other_mode_rdp(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .           
            .               gfx_dp_set_other_mode(C0(0, 24), (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
-- line 3649 ----------------------------------------
-- line 3674 ----------------------------------------
            .           
            .           bool gfx_extra_geometry_mode_handler_custom(F3DGfx** cmd0) {
            .               F3DGfx* cmd = *(cmd0);
            .           
            .               gfx_sp_extra_geometry_mode(~C0(0, 24), (uint32_t)cmd->words.w1);
            .               return false;
            .           }
            .           
      613,976 ( 0.00%)  bool gfx_stubbed_command_handler(F3DGfx** cmd0) {
            .               return false;
            .           }
            .           
            .           bool gfx_spnoop_command_handler_f3dex2(F3DGfx** cmd0) {
            .               return false;
            .           }
            .           
            .           class UcodeHandler {
-- line 3690 ----------------------------------------
-- line 3695 ----------------------------------------
            .                             std::pair<const char*, GfxOpcodeHandlerFunc>(nullptr, nullptr));
            .           
            .                   for (const auto& [opcode, handler] : initializer) {
            .                       mHandlers[static_cast<uint8_t>(opcode)] = handler;
            .                   }
            .               }
            .           
            .               inline bool contains(int8_t opcode) const {
  165,326,480 ( 0.28%)          return mHandlers[static_cast<uint8_t>(opcode)].first != nullptr;
            .               }
            .           
            .               inline std::pair<const char*, GfxOpcodeHandlerFunc> at(int8_t opcode) const {
  164,938,884 ( 0.28%)          return mHandlers[static_cast<uint8_t>(opcode)];
            .               }
            .           
            .             private:
            .               std::pair<const char*, GfxOpcodeHandlerFunc> mHandlers[std::numeric_limits<uint8_t>::max() + 1];
            .           };
            .           
            .           static constexpr UcodeHandler rdpHandlers = {
            .               { RDP_G_TEXRECT, { "G_TEXRECT", gfx_tex_rect_and_flip_handler_rdp } },           // G_TEXRECT (-28)
-- line 3715 ----------------------------------------
-- line 3885 ----------------------------------------
            .               // Loaded ucode must be in range of the supported ucode_handlers
            .               assert(ucode < ucode_max);
            .               ucode_handler_index = ucode;
            .           }
            .           
            .           static void gfx_step() {
            .               auto& cmd = g_exec_stack.currCmd();
            .               auto cmd0 = cmd;
  330,652,960 ( 0.56%)      int8_t opcode = (int8_t)(cmd->words.w0 >> 24);
            .           
  165,326,480 ( 0.28%)      if (opcode == F3DEX2_G_LOAD_UCODE) {
            .                   gfx_set_ucode_handler((UcodeHandlers)(cmd->words.w0 & 0xFFFFFF));
            .                   ++cmd;
            .                   return;
            .                   // Instead of having a handler for each ucode for switching ucode, just check for it early and return.
            .               }
            .           
  165,326,480 ( 0.28%)      if (otrHandlers.contains(opcode)) {
      193,798 ( 0.00%)          if (otrHandlers.at(opcode).second(&cmd)) {
   78,265,655 ( 0.13%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dl_otr_hash_handler_custom(F3DGfx**) (41,232x)
   40,821,637 ( 0.07%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_marker_handler_otr(F3DGfx**) (110,941x)
   31,231,495 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_vtx_hash_handler_custom(F3DGfx**) (32,057x)
   13,269,743 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_timg_otr_hash_handler_custom(F3DGfx**) (9,568x)
            .                       return;
            .                   }
  164,938,884 ( 0.28%)      } else if (rdpHandlers.contains(opcode)) {
    1,935,912 ( 0.00%)          if (rdpHandlers.at(opcode).second(&cmd)) {
  179,565,832 ( 0.30%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tex_rect_and_flip_handler_rdp(F3DGfx**) (26,030x)
   84,492,823 ( 0.14%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_timg_handler_rdp(F3DGfx**) (89,728x)
   27,007,086 ( 0.05%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_load_block_handler_rdp(F3DGfx**) (72,850x)
   13,187,808 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_handler_rdp(F3DGfx**) (183,164x)
   10,520,523 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_combine_handler_rdp(F3DGfx**) (129,883x)
    8,490,198 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_fill_rect_handler_rdp(F3DGfx**) (1,430x)
    3,586,510 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_load_tile_handler_rdp(F3DGfx**) (16,937x)
    2,392,956 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_tile_size_handler_rdp(F3DGfx**) (88,628x)
      855,840 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_scissor_handler_rdp(F3DGfx**) (7,132x)
      613,976 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_stubbed_command_handler(F3DGfx**) (306,988x)
      186,340 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_prim_color_handler_rdp(F3DGfx**) (26,620x)
      109,041 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_load_tlut_handler_rdp(F3DGfx**) (4,749x)
       78,288 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_fill_color_handler_rdp(F3DGfx**) (1,398x)
       50,695 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_env_color_handler_rdp(F3DGfx**) (10,139x)
       13,680 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_c_img_handler_rdp(F3DGfx**) (1,710x)
        4,560 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_z_img_handler_rdp(F3DGfx**) (570x)
            .                       return;
            .                   }
  244,504,458 ( 0.41%)      } else if (ucode_handler_index < ucode_handlers.size()) {
  326,005,944 ( 0.55%)          if (ucode_handlers[ucode_handler_index]->contains(opcode)) {
  328,329,452 ( 0.56%)              if (ucode_handlers[ucode_handler_index]->at(opcode).second(&cmd)) {
43,880,009,047 (74.45%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_vtx_handler_f3dex(F3DGfx**) (9,099,361x)
9,816,553,167 (16.65%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tri2_handler_f3dex(F3DGfx**) (70,954,659x)
  166,495,397 ( 0.28%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_tri1_handler_f3dex(F3DGfx**) (52,793x)
   19,690,583 ( 0.03%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_mtx_handler_f3d(F3DGfx**) (72,003x)
   14,682,282 ( 0.02%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_end_dl_handler_common(F3DGfx**) (257,644x)
    8,633,726 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_dl_handler_common(F3DGfx**) (215,841x)
    3,303,870 ( 0.01%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_othermode_h_handler_f3d(F3DGfx**) (220,258x)
    1,420,922 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_handler_f3d(F3DGfx**) (118,379x)
    1,073,928 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_othermode_l_handler_f3d(F3DGfx**) (89,494x)
    1,073,100 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_clear_geometry_mode_handler_f3dex(F3DGfx**) (178,850x)
      779,300 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_set_geometry_mode_handler_f3dex(F3DGfx**) (155,860x)
      560,058 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_movemem_handler_f3d(F3DGfx**) (6,654x)
      386,135 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_noop_handler_f3dex2(F3DGfx**) (13,315x)
      262,400 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_pop_mtx_handler_f3d(F3DGfx**) (6,560x)
      255,877 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_moveword_handler_f3d(F3DGfx**) (23,639x)
       72,352 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_cull_dl_handler_f3dex2(F3DGfx**) (36,176x)
            .                           return;
            .                       }
            .                   } else {
            .                       SPDLOG_CRITICAL("Unhandled OP code: 0x{:X}, for loaded ucode: {}", (uint8_t)opcode,
            .                                       (uint32_t)ucode_handler_index);
            .                   }
            .               } else {
            .                   SPDLOG_CRITICAL("Unhandled OP code: 0x{:X}, invalid ucode: {}", (uint8_t)opcode, (uint32_t)ucode_handler_index);
            .               }
            .           
   82,405,596 ( 0.14%)      ++cmd;
            .           }
            .           
            .           static void gfx_sp_reset() {
          571 ( 0.00%)      g_rsp.modelview_matrix_stack_size = 1;
          571 ( 0.00%)      g_rsp.current_num_lights = 2;
            .               g_rsp.lights_changed = true;
            .           }
            .           
            .           void gfx_get_dimensions(uint32_t* width, uint32_t* height, int32_t* posX, int32_t* posY) {
            .               gfx_wapi->get_dimensions(width, height, posX, posY);
            .           }
            .           
            .           void gfx_init(struct GfxWindowManagerAPI* wapi, struct GfxRenderingAPI* rapi, const char* game_name,
           19 ( 0.00%)                bool start_in_fullscreen, uint32_t width, uint32_t height, uint32_t posX, uint32_t posY) {
            1 ( 0.00%)      gfx_wapi = wapi;
            1 ( 0.00%)      gfx_rapi = rapi;
           11 ( 0.00%)      gfx_wapi->init(game_name, rapi->get_name(), start_in_fullscreen, width, height, posX, posY);
  194,081,361 ( 0.33%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_init(char const*, char const*, bool, unsigned int, unsigned int, int, int) (1x)
            2 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_name() (1x)
            4 ( 0.00%)      gfx_rapi->init();
       98,363 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_init() (1x)
           10 ( 0.00%)      gfx_rapi->update_framebuffer_parameters(0, width, height, 1, false, true, true, true);
          391 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_update_framebuffer_parameters(int, unsigned int, unsigned int, unsigned int, bool, bool, bool, bool) (1x)
            .           #ifdef __APPLE__
            .               gfx_current_dimensions.internal_mul = 1;
            .           #else
            6 ( 0.00%)      gfx_current_dimensions.internal_mul = CVarGetFloat(CVAR_INTERNAL_RESOLUTION, 1);
          849 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/consolevariablebridge.cpp:CVarGetFloat (1x)
            .           #endif
            4 ( 0.00%)      gfx_msaa_level = CVarGetInteger(CVAR_MSAA_VALUE, 1);
          266 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/consolevariablebridge.cpp:CVarGetInteger (1x)
            .           
            2 ( 0.00%)      gfx_current_dimensions.width = width;
            .               gfx_current_dimensions.height = height;
            .           
            3 ( 0.00%)      game_framebuffer = gfx_rapi->create_framebuffer();
       25,389 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_create_framebuffer() (1x)
            3 ( 0.00%)      game_framebuffer_msaa_resolved = gfx_rapi->create_framebuffer();
       22,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_create_framebuffer() (1x)
            .           
            2 ( 0.00%)      gfx_native_dimensions.width = SCREEN_WIDTH;
            .               gfx_native_dimensions.height = SCREEN_HEIGHT;
            .           
            .               for (int i = 0; i < 16; i++) {
            5 ( 0.00%)          gSegmentPointers[i] = 0;
            .               }
            .           
            2 ( 0.00%)      if (tex_upload_buffer == nullptr) {
            .                   // We cap texture max to 8k, because why would you need more?
            3 ( 0.00%)          int max_tex_size = min(8192, gfx_rapi->get_max_texture_size());
          145 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_get_max_texture_size() (1x)
            7 ( 0.00%)          tex_upload_buffer = (uint8_t*)malloc(max_tex_size * max_tex_size * 4);
          434 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (1x)
            .               }
            .           
            1 ( 0.00%)      ucode_handler_index = UcodeHandlers::ucode_f3dex2;
            9 ( 0.00%)  }
            .           
            .           void gfx_destroy(void) {
            .               // TODO: should also destroy rapi, and any other resources acquired in fast3d
            .               free(tex_upload_buffer);
            .               gfx_wapi->destroy();
            .           
            .               // Texture cache and loaded textures store references to Resources which need to be unreferenced.
            .               gfx_texture_cache_clear();
            .               g_rdp.texture_to_load.raw_tex_metadata.resource = nullptr;
            .               g_rdp.loaded_texture[0].raw_tex_metadata.resource = nullptr;
            .               g_rdp.loaded_texture[1].raw_tex_metadata.resource = nullptr;
            .           }
            .           
            .           struct GfxRenderingAPI* gfx_get_current_rendering_api(void) {
            .               return gfx_rapi;
            2 ( 0.00%)  }
            .           
        2,850 ( 0.00%)  void gfx_start_frame(void) {
        1,140 ( 0.00%)      gfx_wapi->handle_events();
   59,349,034 ( 0.10%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_handle_events() (570x)
        3,420 ( 0.00%)      gfx_wapi->get_dimensions(&gfx_current_window_dimensions.width, &gfx_current_window_dimensions.height,
       59,280 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_get_dimensions(unsigned int*, unsigned int*, int*, int*) (570x)
            .                                        &gfx_current_window_position_x, &gfx_current_window_position_y);
        1,710 ( 0.00%)      if (gfx_current_dimensions.height == 0) {
            .                   // Avoid division by zero
            .                   gfx_current_dimensions.height = 1;
            .               }
        5,130 ( 0.00%)      gfx_current_dimensions.aspect_ratio = (float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height;
            .           
            .               // Update the framebuffer sizes when the viewport or native dimension changes
        2,276 ( 0.00%)      if (gfx_current_dimensions.width != gfx_prev_dimensions.width ||
        1,704 ( 0.00%)          gfx_current_dimensions.height != gfx_prev_dimensions.height ||
        2,272 ( 0.00%)          gfx_native_dimensions.width != gfx_prev_native_dimensions.width ||
            .                   gfx_native_dimensions.height != gfx_prev_native_dimensions.height) {
            .           
            6 ( 0.00%)          for (auto& fb : framebuffers) {
            .                       uint32_t width = fb.second.orig_width, height = fb.second.orig_height;
            .                       if (fb.second.resize) {
            .                           gfx_adjust_width_height_for_scale(width, height, fb.second.native_width, fb.second.native_height);
            .                       }
            .                       if (width != fb.second.applied_width || height != fb.second.applied_height) {
            .                           gfx_rapi->update_framebuffer_parameters(fb.first, width, height, 1, true, true, true, true);
            .                           fb.second.applied_width = width;
            .                           fb.second.applied_height = height;
            .                       }
            .                   }
            .               }
            .           
        1,140 ( 0.00%)      gfx_prev_dimensions = gfx_current_dimensions;
        2,280 ( 0.00%)      gfx_prev_native_dimensions = gfx_native_dimensions;
            .           
        2,280 ( 0.00%)      bool different_size = gfx_current_dimensions.width != gfx_current_game_window_viewport.width ||
            .                                     gfx_current_dimensions.height != gfx_current_game_window_viewport.height;
        1,710 ( 0.00%)      if (different_size || gfx_msaa_level > 1) {
            .                   game_renders_to_framebuffer = true;
            .                   if (different_size) {
            .                       gfx_rapi->update_framebuffer_parameters(game_framebuffer, gfx_current_dimensions.width,
            .                                                               gfx_current_dimensions.height, gfx_msaa_level, true, true, true,
            .                                                               true);
            .                   } else {
            .                       // MSAA framebuffer needs to be resolved to an equally sized target when complete, which must therefore
            .                       // match the window size
-- line 4030 ----------------------------------------
-- line 4032 ----------------------------------------
            .                                                               gfx_current_window_dimensions.height, gfx_msaa_level, false, true,
            .                                                               true, true);
            .                   }
            .                   if (gfx_msaa_level > 1 && different_size) {
            .                       gfx_rapi->update_framebuffer_parameters(game_framebuffer_msaa_resolved, gfx_current_dimensions.width,
            .                                                               gfx_current_dimensions.height, 1, false, false, false, false);
            .                   }
            .               } else {
        1,140 ( 0.00%)          game_renders_to_framebuffer = false;
            .               }
            .           
          570 ( 0.00%)      fbActive = 0;
        3,420 ( 0.00%)  }
            .           
            .           GfxExecStack g_exec_stack = {};
            .           
        7,994 ( 0.00%)  void gfx_run(Gfx* commands, const std::unordered_map<Mtx*, MtxF>& mtx_replacements) {
            .               gfx_sp_reset();
        6,281 ( 0.00%)      Ship::Context::GetInstance()->GetWindow()->GetGui()->DrawMenu();
   71,630,279 ( 0.12%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/gui/Gui.cpp:Ship::Gui::DrawMenu() (571x)
       11,991 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetWindow() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Window::GetGui() (571x)
            .           
            .               // puts("New frame");
            .               get_pixel_depth_pending.clear();
            .               get_pixel_depth_cached.clear();
            .           
        2,284 ( 0.00%)      if (!gfx_wapi->start_frame()) {
        1,142 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_start_frame() (571x)
            .                   dropped_frame = true;
            .                   Ship::Context::GetInstance()->GetWindow()->GetGui()->StartFrame();
            .                   Ship::Context::GetInstance()->GetWindow()->GetGui()->EndFrame();
            .                   return;
            .               }
          571 ( 0.00%)      dropped_frame = false;
            .           
          571 ( 0.00%)      current_mtx_replacements = &mtx_replacements;
            .           
        6,281 ( 0.00%)      gfx_rapi->update_framebuffer_parameters(0, gfx_current_window_dimensions.width,
      223,261 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_update_framebuffer_parameters(int, unsigned int, unsigned int, unsigned int, bool, bool, bool, bool) (571x)
            .                                                       gfx_current_window_dimensions.height, 1, false, true, true,
        1,142 ( 0.00%)                                              !game_renders_to_framebuffer);
        2,284 ( 0.00%)      gfx_rapi->start_frame();
        1,142 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_start_frame() (571x)
        5,139 ( 0.00%)      gfx_rapi->start_draw_to_framebuffer(game_renders_to_framebuffer ? game_framebuffer : 0,
      208,415 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_start_draw_to_framebuffer(int, float) (571x)
        1,713 ( 0.00%)                                          (float)gfx_current_dimensions.height / gfx_native_dimensions.height);
        1,142 ( 0.00%)      gfx_rapi->clear_framebuffer();
    7,806,615 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_clear_framebuffer() (571x)
          571 ( 0.00%)      g_rdp.viewport_or_scissor_changed = true;
        1,142 ( 0.00%)      rendering_state.viewport = {};
        1,142 ( 0.00%)      rendering_state.scissor = {};
            .           
        2,855 ( 0.00%)      auto dbg = Ship::Context::GetInstance()->GetGfxDebugger();
       11,991 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetGfxDebugger() (571x)
        1,713 ( 0.00%)      g_exec_stack.start((F3DGfx*)commands);
       15,988 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:GfxExecStack::start(F3DGfx*) (571x)
  165,327,622 ( 0.28%)      while (!g_exec_stack.cmd_stack.empty()) {
   82,663,240 ( 0.14%)          auto cmd = g_exec_stack.cmd_stack.top();
            .           
  330,652,960 ( 0.56%)          if (dbg->IsDebugging()) {
  165,326,480 ( 0.28%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/debug/GfxDebugger.cpp:Fast::GfxDebugger::IsDebugging() const (82,663,240x)
            .                       g_exec_stack.gfx_path.push_back(cmd);
            .                       if (dbg->HasBreakPoint(g_exec_stack.gfx_path)) {
            .                           // On a breakpoint with the active framebuffer still set, we need to reset back to prevent
            .                           // soft locking the renderer
            .                           if (fbActive) {
            .                               fbActive = 0;
            .                               gfx_rapi->start_draw_to_framebuffer(game_renders_to_framebuffer ? game_framebuffer : 0, 1);
            .                           }
-- line 4090 ----------------------------------------
-- line 4092 ----------------------------------------
            .                           break;
            .                       }
            .                       g_exec_stack.gfx_path.pop_back();
            .                   }
            .                   gfx_step();
            .               }
            .           
            .               gfx_flush();
          571 ( 0.00%)      gfxFramebuffer = 0;
            .               currentDir = std::stack<std::string>();
            .           
        1,142 ( 0.00%)      if (game_renders_to_framebuffer) {
            .                   gfx_rapi->start_draw_to_framebuffer(0, 1);
            .                   gfx_rapi->clear_framebuffer();
            .           
            .                   if (gfx_msaa_level > 1) {
            .                       bool different_size = gfx_current_dimensions.width != gfx_current_game_window_viewport.width ||
            .                                             gfx_current_dimensions.height != gfx_current_game_window_viewport.height;
            .           
            .                       if (different_size) {
-- line 4111 ----------------------------------------
-- line 4112 ----------------------------------------
            .                           gfx_rapi->resolve_msaa_color_buffer(game_framebuffer_msaa_resolved, game_framebuffer);
            .                           gfxFramebuffer = (uintptr_t)gfx_rapi->get_framebuffer_texture_id(game_framebuffer_msaa_resolved);
            .                       } else {
            .                           gfx_rapi->resolve_msaa_color_buffer(0, game_framebuffer);
            .                       }
            .                   } else {
            .                       gfxFramebuffer = (uintptr_t)gfx_rapi->get_framebuffer_texture_id(game_framebuffer);
            .                   }
        1,142 ( 0.00%)      } else if (fbActive) {
            .                   // Failsafe reset to main framebuffer to prevent softlocking the renderer
            .                   fbActive = 0;
            .                   gfx_rapi->start_draw_to_framebuffer(0, 1);
            .           
            .                   assert(0 && "active framebuffer was never reset back to original");
            .               }
            .           
        6,281 ( 0.00%)      Ship::Context::GetInstance()->GetWindow()->GetGui()->StartFrame();
    4,245,656 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/gui/Gui.cpp:Ship::Gui::StartFrame() (571x)
       11,991 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetWindow() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Window::GetGui() (571x)
        5,710 ( 0.00%)      Ship::Context::GetInstance()->GetWindow()->GetGui()->RenderViewports();
   41,185,837 ( 0.07%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/window/gui/Gui.cpp:Ship::Gui::RenderViewports() (571x)
       11,991 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetWindow() (571x)
        5,710 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Window::GetGui() (571x)
        1,142 ( 0.00%)      gfx_rapi->end_frame();
    6,332,299 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_end_frame() (571x)
        1,142 ( 0.00%)      gfx_wapi->swap_buffers_begin();
   20,588,502 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_swap_buffers_begin() (571x)
        5,710 ( 0.00%)  }
            .           
          571 ( 0.00%)  void gfx_end_frame(void) {
        1,142 ( 0.00%)      if (!dropped_frame) {
        1,142 ( 0.00%)          gfx_rapi->finish_render();
          571 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_finish_render() (571x)
        1,713 ( 0.00%)          gfx_wapi->swap_buffers_end();
          571 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_swap_buffers_end() (571x)
            .               }
          571 ( 0.00%)  }
            .           
            .           void gfx_set_target_ucode(UcodeHandlers ucode) {
            1 ( 0.00%)      ucode_handler_index = ucode;
            1 ( 0.00%)  }
            .           
            .           void gfx_set_target_fps(int fps) {
        1,142 ( 0.00%)      gfx_wapi->set_target_fps(fps);
        1,142 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_set_target_fps(int) (571x)
            .           }
            .           
            .           void gfx_set_maximum_frame_latency(int latency) {
        1,142 ( 0.00%)      gfx_wapi->set_maximum_frame_latency(latency);
          571 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_sdl2.cpp:gfx_sdl_set_maximum_frame_latency(int) (571x)
            .           }
            .           
            .           extern "C" int gfx_create_framebuffer(uint32_t width, uint32_t height, uint32_t native_width, uint32_t native_height,
            .                                                 uint8_t resize) {
            .               uint32_t orig_width = width, orig_height = height;
            .               if (resize) {
            .                   gfx_adjust_width_height_for_scale(width, height, native_width, native_height);
            .               }
-- line 4158 ----------------------------------------
-- line 4255 ----------------------------------------
            .           
            .           void gfx_push_current_dir(char* path) {
            .               if (gfx_check_image_signature(path) == 1)
            .                   path = &path[7];
            .           
            .               currentDir.push(GetPathWithoutFileName(path));
            .           }
            .           
      269,184 ( 0.00%)  int32_t gfx_check_image_signature(const char* imgData) {
            .               uintptr_t i = (uintptr_t)(imgData);
            .           
            .               if ((i & 1) == 1) {
            .                   return 0;
            .               }
            .           
      358,912 ( 0.00%)      if (i != 0) {
      807,552 ( 0.00%)          return Ship::Context::GetInstance()->GetResourceManager()->OtrSignatureCheck(imgData);
    3,070,876 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::OtrSignatureCheck(char const*) (89,728x)
    1,884,288 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (89,728x)
      897,280 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetResourceManager() (89,728x)
            .               }
            .           
            .               return 0;
      269,184 ( 0.00%)  }
            .           
            .           void gfx_register_blended_texture(const char* name, uint8_t* mask, uint8_t* replacement) {
            .               if (gfx_check_image_signature(name)) {
            .                   name += 7;
            .               }
            .           
            .               if (gfx_check_image_signature(reinterpret_cast<char*>(replacement))) {
            .                   LUS::Texture* tex = std::static_pointer_cast<LUS::Texture>(
-- line 4283 ----------------------------------------
-- line 4292 ----------------------------------------
            .           }
            .           
            .           void gfx_unregister_blended_texture(const char* name) {
            .               if (gfx_check_image_signature(name)) {
            .                   name += 7;
            .               }
            .           
            .               masked_textures.erase(name);
           22 ( 0.00%)  }
        9,041 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_pc.cpp:__static_initialization_and_destruction_0() (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/hashtable.h
--------------------------------------------------------------------------------
Ir                  

-- line 298 ----------------------------------------
         .                 using __node_builder_t =
         .           	__detail::_NodeBuilder<_ExtractKey>;
         .           
         .                 // Simple RAII type for managing a node containing an element
         .                 struct _Scoped_node
         .                 {
         .           	// Take ownership of a node with a constructed element.
         .           	_Scoped_node(__node_ptr __n, __hashtable_alloc* __h)
       111 ( 0.00%)  	: _M_h(__h), _M_node(__n) { }
         .           
         .           	// Allocate a node and construct an element within it.
         .           	template<typename... _Args>
         .           	  _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
    16,572 ( 0.00%)  	  : _M_h(__h),
    16,572 ( 0.00%)  	    _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
         .           	  { }
         .           
         .           	// Destroy element and deallocate node.
    33,286 ( 0.00%)  	~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };
         .           
         .           	_Scoped_node(const _Scoped_node&) = delete;
         .           	_Scoped_node& operator=(const _Scoped_node&) = delete;
         .           
         .           	__hashtable_alloc* _M_h;
         .           	__node_ptr _M_node;
         .                 };
         .           
-- line 324 ----------------------------------------
-- line 401 ----------------------------------------
         .                 // qualified.
         .                 // Note that we can't leave hashtable with 0 bucket without adding
         .                 // numerous checks in the code to avoid 0 modulus.
         .                 __node_base_ptr		_M_single_bucket	= nullptr;
         .           
         .                 void
         .                 _M_update_bbegin()
         .                 {
         6 ( 0.00%)  	if (auto __begin = _M_begin())
    13,218 ( 0.00%)  	  _M_buckets[_M_bucket_index(*__begin)] = &_M_before_begin;
         .                 }
         .           
         .                 void
         .                 _M_update_bbegin(__node_ptr __n)
         .                 {
     4,406 ( 0.00%)  	_M_before_begin._M_nxt = __n;
         .           	_M_update_bbegin();
         .                 }
         .           
         .                 bool
         .                 _M_uses_single_bucket(__buckets_ptr __bkts) const
     7,207 ( 0.00%)        { return __builtin_expect(__bkts == &_M_single_bucket, false); }
         .           
         .                 bool
         .                 _M_uses_single_bucket() const
         .                 { return _M_uses_single_bucket(_M_buckets); }
         .           
         .                 static constexpr size_t
         .                 __small_size_threshold() noexcept
         .                 {
-- line 430 ----------------------------------------
-- line 433 ----------------------------------------
         .                 }
         .           
         .                 __hashtable_alloc&
         .                 _M_base_alloc() { return *this; }
         .           
         .                 __buckets_ptr
         .                 _M_allocate_buckets(size_type __bkt_count)
         .                 {
    36,988 ( 0.00%)  	if (__builtin_expect(__bkt_count == 1, false))
         .           	  {
    13,972 ( 0.00%)  	    _M_single_bucket = nullptr;
    41,932 ( 0.00%)  	    return &_M_single_bucket;
         .           	  }
         .           
         .           	return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
         .                 }
         .           
         .                 void
         .                 _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
         .                 {
    49,369 ( 0.00%)  	if (_M_uses_single_bucket(__bkts))
         .           	  return;
         .           
         .           	__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
         .                 }
         .           
         .                 void
         .                 _M_deallocate_buckets()
    38,154 ( 0.00%)        { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
         .           
         .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
         .                 // their before begin node.
         .                 __node_ptr
         .                 _M_bucket_begin(size_type __bkt) const
         .                 {
         .           	__node_base_ptr __n = _M_buckets[__bkt];
         .           	return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;
         .                 }
         .           
         .                 __node_ptr
         1 ( 0.00%)        _M_begin() const
    75,189 ( 0.00%)        { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }
         .           
         .                 // Assign *this using another _Hashtable instance. Whether elements
         .                 // are copied or moved depends on the _Ht reference.
         .                 template<typename _Ht>
         .           	void
         .           	_M_assign_elements(_Ht&&);
         .           
         .                 template<typename _Ht, typename _NodeGenerator>
-- line 482 ----------------------------------------
-- line 491 ----------------------------------------
         .           
         .                 void
         .                 _M_reset() noexcept;
         .           
         .                 _Hashtable(const _Hash& __h, const _Equal& __eq,
         .           		 const allocator_type& __a)
         .                 : __hashtable_base(__h, __eq),
         .           	__hashtable_alloc(__node_alloc_type(__a)),
        27 ( 0.00%)  	__enable_default_ctor(_Enable_default_constructor_tag{})
         .                 { }
         .           
         .                 template<bool _No_realloc = true>
         .           	static constexpr bool
         .           	_S_nothrow_move()
         .           	{
         .           #if __cplusplus <= 201402L
         .           	  return __and_<__bool_constant<_No_realloc>,
-- line 507 ----------------------------------------
-- line 531 ----------------------------------------
         .                 template<typename _InputIterator>
         .           	_Hashtable(_InputIterator __first, _InputIterator __last,
         .           		   size_type __bkt_count_hint,
         .           		   const _Hash&, const _Equal&, const allocator_type&,
         .           		   false_type __uks);
         .           
         .               public:
         .                 // Constructor, destructor, assignment, swap
     2,922 ( 0.00%)        _Hashtable() = default;
         .           
         .                 _Hashtable(const _Hashtable&);
         .           
         .                 _Hashtable(const _Hashtable&, const allocator_type&);
         .           
         .                 explicit
         .                 _Hashtable(size_type __bkt_count_hint,
         .           		 const _Hash& __hf = _Hash(),
-- line 547 ----------------------------------------
-- line 578 ----------------------------------------
         .           	{ }
         .           
         .                 _Hashtable(initializer_list<value_type> __l,
         .           		 size_type __bkt_count_hint = 0,
         .           		 const _Hash& __hf = _Hash(),
         .           		 const key_equal& __eql = key_equal(),
         .           		 const allocator_type& __a = allocator_type())
         .                 : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
        53 ( 0.00%)  		   __hf, __eql, __a, __unique_keys{})
    25,863 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_Hashtable<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const*>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const*, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> const*, unsigned long, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, unsigned int> > const&, std::integral_constant<bool, true>) (1x)
     4,756 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_Hashtable<std::pair<Attribute const, std::any> const*>(std::pair<Attribute const, std::any> const*, std::pair<Attribute const, std::any> const*, unsigned long, std::hash<Attribute> const&, std::equal_to<Attribute> const&, std::allocator<std::pair<Attribute const, std::any> > const&, std::integral_constant<bool, true>) (2x)
         .                 { }
         .           
         .                 _Hashtable&
         .                 operator=(const _Hashtable& __ht);
         .           
         .                 _Hashtable&
         .                 operator=(_Hashtable&& __ht)
         .                 noexcept(__node_alloc_traits::_S_nothrow_move()
-- line 594 ----------------------------------------
-- line 649 ----------------------------------------
         .                 { return const_iterator(_M_begin()); }
         .           
         .                 const_iterator
         .                 cend() const noexcept
         .                 { return const_iterator(nullptr); }
         .           
         .                 size_type
         .                 size() const noexcept
 4,209,916 ( 0.01%)        { return _M_element_count; }
         .           
         .                 _GLIBCXX_NODISCARD bool
         .                 empty() const noexcept
         .                 { return size() == 0; }
         .           
         .                 allocator_type
         .                 get_allocator() const noexcept
         .                 { return allocator_type(this->_M_node_allocator()); }
-- line 665 ----------------------------------------
-- line 796 ----------------------------------------
         .               private:
         .                 // Bucket index computation helpers.
         .                 size_type
         .                 _M_bucket_index(const __node_value_type& __n) const noexcept
         .                 { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
         .           
         .                 size_type
         .                 _M_bucket_index(__hash_code __c) const
25,399,640 ( 0.04%)        { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }
         .           
         .                 __node_base_ptr
         .                 _M_find_before_node(const key_type&);
         .           
         .                 // Find and insert helper functions and types
         .                 // Find the node before the one matching the criteria.
         .                 __node_base_ptr
         .                 _M_find_before_node(size_type, const key_type&, __hash_code) const;
-- line 812 ----------------------------------------
-- line 814 ----------------------------------------
         .                 template<typename _Kt>
         .           	__node_base_ptr
         .           	_M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;
         .           
         .                 __node_ptr
         .                 _M_find_node(size_type __bkt, const key_type& __key,
         .           		   __hash_code __c) const
         .                 {
   235,151 ( 0.00%)  	__node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
 1,641,304 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<TextureCacheKey, std::pair<TextureCacheKey const, TextureCacheValue>, std::allocator<std::pair<TextureCacheKey const, TextureCacheValue> >, std::__detail::_Select1st, std::equal_to<TextureCacheKey>, TextureCacheKey::Hasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_find_before_node(unsigned long, TextureCacheKey const&, unsigned long) const [clone .isra.0] (47,108x)
    95,024 ( 0.00%)  	if (__before_n)
13,316,132 ( 0.02%)  	  return static_cast<__node_ptr>(__before_n->_M_nxt);
        17 ( 0.00%)  	return nullptr;
         .                 }
         .           
         .                 template<typename _Kt>
         .           	__node_ptr
         .           	_M_find_node_tr(size_type __bkt, const _Kt& __key,
         .           			__hash_code __c) const
         .           	{
         .           	  auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
-- line 833 ----------------------------------------
-- line 835 ----------------------------------------
         .           	    return static_cast<__node_ptr>(__before_n->_M_nxt);
         .           	  return nullptr;
         .           	}
         .           
         .                 // Insert a node at the beginning of a bucket.
         .                 void
         .                 _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
         .                 {
   256,326 ( 0.00%)  	if (_M_buckets[__bkt])
         .           	  {
         .           	    // Bucket is not empty, we just need to insert the new node
         .           	    // after the bucket before begin.
    50,846 ( 0.00%)  	    __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
    50,846 ( 0.00%)  	    _M_buckets[__bkt]->_M_nxt = __node;
         .           	  }
         .           	else
         .           	  {
         .           	    // The bucket is empty, the new node is inserted at the
         .           	    // beginning of the singly-linked list and the bucket will
         .           	    // contain _M_before_begin pointer.
    51,148 ( 0.00%)  	    __node->_M_nxt = _M_before_begin._M_nxt;
    25,574 ( 0.00%)  	    _M_before_begin._M_nxt = __node;
         .           
    76,102 ( 0.00%)  	    if (__node->_M_nxt)
         .           	      // We must update former begin bucket that is pointing to
         .           	      // _M_before_begin.
    25,528 ( 0.00%)  	      _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;
         .           
    76,514 ( 0.00%)  	    _M_buckets[__bkt] = &_M_before_begin;
         .           	  }
         .                 }
         .           
         .                 // Remove the bucket first node
         .                 void
         .                 _M_remove_bucket_begin(size_type __bkt, __node_ptr __next_n,
         .           			     size_type __next_bkt)
         .                 {
         .           	if (!__next_n)
         .           	  _M_buckets[__bkt] = nullptr;
         2 ( 0.00%)  	else if (__next_bkt != __bkt)
         .           	  {
         .           	    _M_buckets[__next_bkt] = _M_buckets[__bkt];
         1 ( 0.00%)  	    _M_buckets[__bkt] = nullptr;
         .           	  }
         .                 }
         .           
         .                 // Get the node before __n in the bucket __bkt
         .                 __node_base_ptr
         .                 _M_get_previous_node(size_type __bkt, __node_ptr __n);
         .           
         .                 pair<__node_ptr, __hash_code>
-- line 885 ----------------------------------------
-- line 1016 ----------------------------------------
         .           
         .                 // LWG 2059.
         .                 iterator
         .                 erase(iterator __it)
         .                 { return erase(const_iterator(__it)); }
         .           
         .                 size_type
         .                 erase(const key_type& __k)
        43 ( 0.00%)        { return _M_erase(__unique_keys{}, __k); }
     2,143 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::CVar> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_erase(std::integral_constant<bool, true>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [clone .isra.0] (14x)
         .           
         .                 iterator
         .                 erase(const_iterator, const_iterator);
         .           
         .                 void
         .                 clear() noexcept;
         .           
         .                 // Set number of buckets keeping it appropriate for container's number
-- line 1032 ----------------------------------------
-- line 1246 ----------------------------------------
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _Hashtable(size_type __bkt_count_hint,
         .           	       const _Hash& __h, const _Equal& __eq, const allocator_type& __a)
         .               : _Hashtable(__h, __eq, __a)
         .               {
        28 ( 0.00%)        auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
         8 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/hashtable_c++0x.cc:std::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const (1x)
        10 ( 0.00%)        if (__bkt_count > _M_bucket_count)
         .           	{
         .           	  _M_buckets = _M_allocate_buckets(__bkt_count);
         .           	  _M_bucket_count = __bkt_count;
         .           	}
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _InputIterator>
        55 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .                 _Hashtable(_InputIterator __f, _InputIterator __l,
         .           		 size_type __bkt_count_hint,
         .           		 const _Hash& __h, const _Equal& __eq,
         .           		 const allocator_type& __a, true_type /* __uks */)
         .                 : _Hashtable(__bkt_count_hint, __h, __eq, __a)
        40 ( 0.00%)        { this->insert(__f, __l); }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _InputIterator>
         .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1282 ----------------------------------------
-- line 1308 ----------------------------------------
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               operator=(const _Hashtable& __ht)
         .               -> _Hashtable&
         .               {
         3 ( 0.00%)        if (&__ht == this)
         .           	return *this;
         .           
         .                 if (__node_alloc_traits::_S_propagate_on_copy_assign())
         .           	{
         .           	  auto& __this_alloc = this->_M_node_allocator();
         .           	  auto& __that_alloc = __ht._M_node_allocator();
         .           	  if (!__node_alloc_traits::_S_always_equal()
         .           	      && __this_alloc != __that_alloc)
-- line 1324 ----------------------------------------
-- line 1346 ----------------------------------------
         .           		  __throw_exception_again;
         .           		}
         .           	      return *this;
         .           	    }
         .           	  std::__alloc_on_copy(__this_alloc, __that_alloc);
         .           	}
         .           
         .                 // Reuse allocated buckets and nodes.
         1 ( 0.00%)        _M_assign_elements(__ht);
        81 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:void std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> >::_M_assign_elements<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&>(std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&) (1x)
         .                 return *this;
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _Ht>
         .                 void
         9 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .                 _M_assign_elements(_Ht&& __ht)
         .                 {
         1 ( 0.00%)  	__buckets_ptr __former_buckets = nullptr;
         1 ( 0.00%)  	std::size_t __former_bucket_count = _M_bucket_count;
         .           	__rehash_guard_t __rehash_guard(_M_rehash_policy);
         .           
         3 ( 0.00%)  	if (_M_bucket_count != __ht._M_bucket_count)
         .           	  {
         1 ( 0.00%)  	    __former_buckets = _M_buckets;
         .           	    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
         .           	    _M_bucket_count = __ht._M_bucket_count;
         .           	  }
         .           	else
         6 ( 0.00%)  	  __builtin_memset(_M_buckets, 0,
        13 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
         .           			   _M_bucket_count * sizeof(__node_base_ptr));
         .           
         .           	__try
         .           	  {
         .           	    __hashtable_base::operator=(std::forward<_Ht>(__ht));
         2 ( 0.00%)  	    _M_element_count = __ht._M_element_count;
         2 ( 0.00%)  	    _M_rehash_policy = __ht._M_rehash_policy;
         .           	    __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
         1 ( 0.00%)  	    _M_before_begin._M_nxt = nullptr;
         7 ( 0.00%)  	    _M_assign(std::forward<_Ht>(__ht), __roan);
        21 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:void std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> >::_M_assign<std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&, std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<unsigned int, false> > > >(std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> > const&, std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<unsigned int, false> > > const&) (1x)
         2 ( 0.00%)  	    if (__former_buckets)
         .           	      _M_deallocate_buckets(__former_buckets, __former_bucket_count);
         .           	    __rehash_guard._M_guarded_obj = nullptr;
         .           	  }
         .           	__catch(...)
         .           	  {
         .           	    if (__former_buckets)
         .           	      {
         .           		// Restore previous buckets.
-- line 1398 ----------------------------------------
-- line 1399 ----------------------------------------
         .           		_M_deallocate_buckets();
         .           		_M_buckets = __former_buckets;
         .           		_M_bucket_count = __former_bucket_count;
         .           	      }
         .           	    __builtin_memset(_M_buckets, 0,
         .           			     _M_bucket_count * sizeof(__node_base_ptr));
         .           	    __throw_exception_again;
         .           	  }
         8 ( 0.00%)        }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _Ht, typename _NodeGenerator>
         .                 void
   164,601 ( 0.00%)        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .                 _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)
         .                 {
    27,188 ( 0.00%)  	__buckets_ptr __buckets = nullptr;
    36,757 ( 0.00%)  	if (!_M_buckets)
    72,723 ( 0.00%)  	  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);
         .           
         .           	__try
         .           	  {
    55,182 ( 0.00%)  	    if (!__ht._M_before_begin._M_nxt)
         .           	      return;
         .           
         .           	    // First deal with the special first node pointed to by
         .           	    // _M_before_begin.
         .           	    __node_ptr __ht_n = __ht._M_begin();
         .           	    __node_ptr __this_n
         .           	      = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
         .           	    this->_M_copy_code(*__this_n, *__ht_n);
         .           	    _M_update_bbegin(__this_n);
         .           
         .           	    // Then deal with other nodes.
         .           	    __node_ptr __prev_n = __this_n;
    33,248 ( 0.00%)  	    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
         .           	      {
         .           		__this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
    10,416 ( 0.00%)  		__prev_n->_M_nxt = __this_n;
         .           		this->_M_copy_code(*__this_n, *__ht_n);
         .           		size_type __bkt = _M_bucket_index(*__this_n);
    41,664 ( 0.00%)  		if (!_M_buckets[__bkt])
    10,416 ( 0.00%)  		  _M_buckets[__bkt] = __prev_n;
         .           		__prev_n = __this_n;
         .           	      }
         .           	  }
         .           	__catch(...)
         .           	  {
         .           	    clear();
         .           	    if (__buckets)
         .           	      _M_deallocate_buckets();
         .           	    __throw_exception_again;
         .           	  }
   145,420 ( 0.00%)        }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_reset() noexcept
         .               {
         .                 _M_rehash_policy._M_reset();
         3 ( 0.00%)        _M_bucket_count = 1;
         3 ( 0.00%)        _M_single_bucket = nullptr;
         4 ( 0.00%)        _M_buckets = &_M_single_bucket;
         3 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
         3 ( 0.00%)        _M_element_count = 0;
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 1480 ----------------------------------------
-- line 1533 ----------------------------------------
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _Hashtable(const _Hashtable& __ht)
         .               : __hashtable_base(__ht),
         .                 __map_base(__ht),
         .                 __rehash_base(__ht),
         .                 __hashtable_alloc(
         .           	__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
         .                 __enable_default_ctor(__ht),
    18,393 ( 0.00%)        _M_buckets(nullptr),
    36,786 ( 0.00%)        _M_bucket_count(__ht._M_bucket_count),
    36,786 ( 0.00%)        _M_element_count(__ht._M_element_count),
    66,323 ( 0.00%)        _M_rehash_policy(__ht._M_rehash_policy)
         .               {
         .                 __alloc_node_gen_t __alloc_node_gen(*this);
    36,695 ( 0.00%)        _M_assign(__ht, __alloc_node_gen);
   372,528 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:void std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_assign<std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true> > > >(std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerAxisDirectionMapping> >, true> > > const&) [clone .isra.0] (6,368x)
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1555 ----------------------------------------
-- line 1556 ----------------------------------------
         .               _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
         .           	       true_type /* alloc always equal */)
         .               noexcept(_S_nothrow_move())
         .               : __hashtable_base(__ht),
         .                 __map_base(__ht),
         .                 __rehash_base(__ht),
         .                 __hashtable_alloc(std::move(__a)),
         .                 __enable_default_ctor(__ht),
         6 ( 0.00%)        _M_buckets(__ht._M_buckets),
         6 ( 0.00%)        _M_bucket_count(__ht._M_bucket_count),
         3 ( 0.00%)        _M_before_begin(__ht._M_before_begin._M_nxt),
         6 ( 0.00%)        _M_element_count(__ht._M_element_count),
         9 ( 0.00%)        _M_rehash_policy(__ht._M_rehash_policy)
         .               {
         .                 // Update buckets if __ht is using its single bucket.
         7 ( 0.00%)        if (__ht._M_uses_single_bucket())
         .           	{
         6 ( 0.00%)  	  _M_buckets = &_M_single_bucket;
         9 ( 0.00%)  	  _M_single_bucket = __ht._M_single_bucket;
         .           	}
         .           
         .                 // Fix bucket containing the _M_before_begin pointer that can't be moved.
         .                 _M_update_bbegin();
         .           
         .                 __ht._M_reset();
         .               }
         .           
-- line 1582 ----------------------------------------
-- line 1646 ----------------------------------------
         .           	  __ht.clear();
         .           	}
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
    43,196 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               ~_Hashtable() noexcept
         .               {
         .                 // Getting a bucket index from a node shall not throw because it is used
         .                 // in methods (erase, swap...) that shall not throw. Need a complete
         .                 // type to check this, so do it in the destructor not at class scope.
         .                 static_assert(noexcept(declval<const __hash_code_base_access&>()
         .           			._M_bucket_index(declval<const __node_value_type&>(),
         .           					 (std::size_t)0)),
         .           		    "Cache the hash code or qualify your functors involved"
         .           		    " in hash code and bucket index computation with noexcept");
         .           
    22,289 ( 0.00%)        clear();
   752,220 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<Ship::ControllerButtonMapping> > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::clear() (11,144x)
         .                 _M_deallocate_buckets();
    41,576 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1677 ----------------------------------------
-- line 1715 ----------------------------------------
         .                 __x._M_update_bbegin();
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
        28 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               find(const key_type& __k)
         .               -> iterator
         .               {
   593,186 ( 0.00%)        if (size() <= __small_size_threshold())
         .           	{
     1,432 ( 0.00%)  	  for (auto __it = _M_begin(); __it; __it = __it->_M_next())
         .           	    if (this->_M_key_equals(__k, *__it))
         .           	      return iterator(__it);
         .           	  return end();
         .           	}
         .           
         .                 __hash_code __code = this->_M_hash_code(__k);
         .                 std::size_t __bkt = _M_bucket_index(__code);
         .                 return iterator(_M_find_node(__bkt, __k, __code));
        47 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
     6,665 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               find(const key_type& __k) const
         .               -> const_iterator
         .               {
50,509,461 ( 0.09%)        if (size() <= __small_size_threshold())
         .           	{
   217,539 ( 0.00%)  	  for (auto __it = _M_begin(); __it; __it = __it->_M_next())
         .           	    if (this->_M_key_equals(__k, *__it))
         .           	      return const_iterator(__it);
         .           	  return end();
         .           	}
         .           
         .                 __hash_code __code = this->_M_hash_code(__k);
         .                 std::size_t __bkt = _M_bucket_index(__code);
         .                 return const_iterator(_M_find_node(__bkt, __k, __code));
24,981,411 ( 0.04%)      }
         .           
         .           #if __cplusplus > 201703L
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _Kt, typename, typename>
         .                 auto
-- line 1770 ----------------------------------------
-- line 2029 ----------------------------------------
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_find_before_node(const key_type& __k)
         .               -> __node_base_ptr
         .               {
         1 ( 0.00%)        __node_base_ptr __prev_p = &_M_before_begin;
         3 ( 0.00%)        if (!__prev_p->_M_nxt)
         .           	return nullptr;
         .           
         .                 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);
         2 ( 0.00%)  	   __p != nullptr;
         .           	   __p = __p->_M_next())
         .           	{
         .           	  if (this->_M_key_equals(__k, *__p))
         .           	    return __prev_p;
         .           
         .           	  __prev_p = __p;
         .           	}
         .           
-- line 2050 ----------------------------------------
-- line 2053 ----------------------------------------
         .           
         .             // Find the node before the one whose key compares equal to k in the bucket
         .             // bkt. Return nullptr if no node is found.
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
    94,243 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_find_before_node(size_type __bkt, const key_type& __k,
         .           			__hash_code __code) const
         .               -> __node_base_ptr
         .               {
51,064,923 ( 0.09%)        __node_base_ptr __prev_p = _M_buckets[__bkt];
51,036,668 ( 0.09%)        if (!__prev_p)
       796 ( 0.00%)  	return nullptr;
         .           
25,544,362 ( 0.04%)        for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
   141,629 ( 0.00%)  	   __p = __p->_M_next())
         .           	{
         .           	  if (this->_M_equals(__k, __code, *__p))
    46,306 ( 0.00%)  	    return __prev_p;
         .           
 1,040,352 ( 0.00%)  	  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
         .           	    break;
   208,035 ( 0.00%)  	  __prev_p = __p;
         .           	}
         .           
         .                 return nullptr;
    94,243 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _Kt>
         .                 auto
         .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .                 _M_find_before_node_tr(size_type __bkt, const _Kt& __k,
         .           			     __hash_code __code) const
         .                 -> __node_base_ptr
         .                 {
        42 ( 0.00%)  	__node_base_ptr __prev_p = _M_buckets[__bkt];
        54 ( 0.00%)  	if (!__prev_p)
         .           	  return nullptr;
         .           
         8 ( 0.00%)  	for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
        10 ( 0.00%)  	     __p = __p->_M_next())
         .           	  {
         .           	    if (this->_M_equals_tr(__k, __code, *__p))
         .           	      return __prev_p;
         .           
        81 ( 0.00%)  	    if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
         .           	      break;
        15 ( 0.00%)  	    __prev_p = __p;
         .           	  }
         .           
         .           	return nullptr;
         .                 }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
-- line 2117 ----------------------------------------
-- line 2138 ----------------------------------------
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .                 _M_emplace(true_type /* __uks */, _Args&&... __args)
         .                 -> pair<iterator, bool>
         .                 {
         .           	// First build the node to get access to the hash code
         .           	_Scoped_node __node { this, std::forward<_Args>(__args)...  };
         .           	const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());
         .           	const size_type __size = size();
       804 ( 0.00%)  	if (__size <= __small_size_threshold())
         .           	  {
         2 ( 0.00%)  	    for (auto __it = _M_begin(); __it; __it = __it->_M_next())
         .           	      if (this->_M_key_equals(__k, *__it))
         .           		// There is already an equivalent node, no insertion
         .           		return { iterator(__it), false };
         .           	  }
         .           
         .           	__hash_code __code = this->_M_hash_code(__k);
         .           	size_type __bkt = _M_bucket_index(__code);
         .           	if (__size > __small_size_threshold())
         .           	  if (__node_ptr __p = _M_find_node(__bkt, __k, __code))
         .           	    // There is already an equivalent node, no insertion
         .           	    return { iterator(__p), false };
         .           
         .           	// Insert the node
         .           	auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
         .           	__node._M_node = nullptr;
       804 ( 0.00%)  	return { __pos, true };
         .                 }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename... _Args>
         .                 auto
-- line 2172 ----------------------------------------
-- line 2216 ----------------------------------------
         .                 return { __hint, this->_M_hash_code(__k) };
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
   597,614 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
         .           			  __node_ptr __node, size_type __n_elt)
         .               -> iterator
         .               {
    50,668 ( 0.00%)        __rehash_guard_t __rehash_guard(_M_rehash_policy);
         .                 std::pair<bool, std::size_t> __do_rehash
   205,224 ( 0.00%)  	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
     6,940 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/hashtable_c++0x.cc:std::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const (402x)
         .           					  __n_elt);
         .           
   101,994 ( 0.00%)        if (__do_rehash.first)
         .           	{
       101 ( 0.00%)  	  _M_rehash(__do_rehash.second, true_type{});
         .           	  __bkt = _M_bucket_index(__code);
         .           	}
         .           
         .                 __rehash_guard._M_guarded_obj = nullptr;
         .                 this->_M_store_code(*__node, __code);
         .           
         .                 // Always insert at the beginning of the bucket.
         .                 _M_insert_bucket_begin(__bkt, __node);
    51,025 ( 0.00%)        ++_M_element_count;
         .                 return iterator(__node);
   448,209 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2256 ----------------------------------------
-- line 2312 ----------------------------------------
         .                 auto
         .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .                 _M_insert_unique(_Kt&& __k, _Arg&& __v,
         .           		       const _NodeGenerator& __node_gen)
         .                 -> pair<iterator, bool>
         .                 {
         .           	const size_type __size = size();
       106 ( 0.00%)  	if (__size <= __small_size_threshold())
       540 ( 0.00%)  	  for (auto __it = _M_begin(); __it; __it = __it->_M_next())
         .           	    if (this->_M_key_equals_tr(__k, *__it))
         .           	      return { iterator(__it), false };
         .           
         .           	__hash_code __code = this->_M_hash_code_tr(__k);
         .           	size_type __bkt = _M_bucket_index(__code);
         .           
         .           	if (__size > __small_size_threshold())
         2 ( 0.00%)  	  if (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))
         .           	    return { iterator(__node), false };
         .           
         .           	_Scoped_node __node {
         .           	  __node_builder_t::_S_build(std::forward<_Kt>(__k),
         .           				     std::forward<_Arg>(__v),
         .           				     __node_gen),
         .           	  this
         .           	};
         .           	auto __pos
       259 ( 0.00%)  	  = _M_insert_unique_node(__bkt, __code, __node._M_node);
       587 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Ship::Direction, std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<Ship::Direction>, std::hash<Ship::Direction>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<Ship::Direction const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*, unsigned long) (4x)
         .           	__node._M_node = nullptr;
         .           	return { __pos, true };
         .                 }
         .           
         .             // Insert v unconditionally.
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
-- line 2347 ----------------------------------------
-- line 2393 ----------------------------------------
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n)
         .               -> iterator
         .               {
         6 ( 0.00%)        if (__prev_n == _M_buckets[__bkt])
         4 ( 0.00%)  	_M_remove_bucket_begin(__bkt, __n->_M_next(),
         2 ( 0.00%)  	  __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);
         .                 else if (__n->_M_nxt)
         .           	{
         .           	  size_type __next_bkt = _M_bucket_index(*__n->_M_next());
         .           	  if (__next_bkt != __bkt)
         .           	    _M_buckets[__next_bkt] = __prev_n;
         .           	}
         .           
         3 ( 0.00%)        __prev_n->_M_nxt = __n->_M_nxt;
         .                 iterator __result(__n->_M_next());
         .                 this->_M_deallocate_node(__n);
         2 ( 0.00%)        --_M_element_count;
         .           
         .                 return __result;
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
       137 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_erase(true_type /* __uks */, const key_type& __k)
         .               -> size_type
         .               {
         .                 __node_base_ptr __prev_n;
         .                 __node_ptr __n;
         .                 std::size_t __bkt;
        30 ( 0.00%)        if (size() <= __small_size_threshold())
         .           	{
         .           	  __prev_n = _M_find_before_node(__k);
         .           	  if (!__prev_n)
         .           	    return 0;
         .           
         .           	  // We found a matching node, erase it.
         1 ( 0.00%)  	  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
         .           	  __bkt = _M_bucket_index(*__n);
         .           	}
         .                 else
         .           	{
         .           	  __hash_code __code = this->_M_hash_code(__k);
         .           	  __bkt = _M_bucket_index(__code);
         .           
         .           	  // Look for the node before the first matching node.
         .           	  __prev_n = _M_find_before_node(__bkt, __k, __code);
         .           	  if (!__prev_n)
         .           	    return 0;
         .           
         .           	  // We found a matching node, erase it.
         1 ( 0.00%)  	  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
         .           	}
         .           
         .                 _M_erase(__bkt, __prev_n, __n);
         .                 return 1;
       120 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2466 ----------------------------------------
-- line 2572 ----------------------------------------
         .                 return iterator(__n);
         .               }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               void
    66,977 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               clear() noexcept
         .               {
         .                 this->_M_deallocate_nodes(_M_begin());
   117,427 ( 0.00%)        __builtin_memset(_M_buckets, 0,
     4,345 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
         .           		       _M_bucket_count * sizeof(__node_base_ptr));
    19,576 ( 0.00%)        _M_element_count = 0;
    19,572 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
    66,974 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2597 ----------------------------------------
-- line 2617 ----------------------------------------
         .           	   typename _RehashPolicy, typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
         .               _M_rehash(size_type __bkt_count, true_type /* __uks */)
         .               {
         .                 __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
         .                 __node_ptr __p = _M_begin();
       101 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
       101 ( 0.00%)        std::size_t __bbegin_bkt = 0;
   122,892 ( 0.00%)        while (__p)
         .           	{
         .           	  __node_ptr __next = __p->_M_next();
         .           	  std::size_t __bkt
         .           	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
   245,372 ( 0.00%)  	  if (!__new_buckets[__bkt])
         .           	    {
    94,808 ( 0.00%)  	      __p->_M_nxt = _M_before_begin._M_nxt;
    47,404 ( 0.00%)  	      _M_before_begin._M_nxt = __p;
    47,503 ( 0.00%)  	      __new_buckets[__bkt] = &_M_before_begin;
    94,808 ( 0.00%)  	      if (__p->_M_nxt)
    47,349 ( 0.00%)  		__new_buckets[__bbegin_bkt] = __p;
    94,808 ( 0.00%)  	      __bbegin_bkt = __bkt;
         .           	    }
         .           	  else
         .           	    {
    27,878 ( 0.00%)  	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    27,878 ( 0.00%)  	      __new_buckets[__bkt]->_M_nxt = __p;
         .           	    }
         .           
         .           	  __p = __next;
         .           	}
         .           
         .                 _M_deallocate_buckets();
       101 ( 0.00%)        _M_bucket_count = __bkt_count;
       101 ( 0.00%)        _M_buckets = __new_buckets;
         .               }
         .           
         .             // Rehash when there can be equivalent elements, preserve their relative
         .             // order.
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
-- line 2660 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imstb_truetype.h
--------------------------------------------------------------------------------
Ir               

-- line 1283 ----------------------------------------
      .           
      .           // on platforms that don't allow misaligned reads, if we want to allow
      .           // truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE
      .           
      .           #define ttBYTE(p)     (* (stbtt_uint8 *) (p))
      .           #define ttCHAR(p)     (* (stbtt_int8 *) (p))
      .           #define ttFixed(p)    ttLONG(p)
      .           
178,664 ( 0.00%)  static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
 58,904 ( 0.00%)  static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
      .           static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
      .           static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
      .           
      .           #define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
      .           #define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
      .           
      .           static int stbtt__isfont(stbtt_uint8 *font)
      .           {
      .              // check the version number
      6 ( 0.00%)     if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
      4 ( 0.00%)     if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
      4 ( 0.00%)     if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
     16 ( 0.00%)     if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
      .              if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
      .              return 0;
      .           }
      .           
      .           // @OPTIMIZE: binary search
      .           static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
     18 ( 0.00%)  {
     54 ( 0.00%)     stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
     18 ( 0.00%)     stbtt_uint32 tabledir = fontstart + 12;
      .              stbtt_int32 i;
    600 ( 0.00%)     for (i=0; i < num_tables; ++i) {
      .                 stbtt_uint32 loc = tabledir + 16*i;
    802 ( 0.00%)        if (stbtt_tag(data+loc+0, tag))
     28 ( 0.00%)           return ttULONG(data+loc+8);
      .              }
      4 ( 0.00%)     return 0;
      4 ( 0.00%)  }
      .           
      .           static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
      .           {
      .              // if it's just a font, there's only one valid index
      .              if (stbtt__isfont(font_collection))
      8 ( 0.00%)        return index == 0 ? 0 : -1;
      .           
      .              // check if it's a TTC
      .              if (stbtt_tag(font_collection, "ttcf")) {
      .                 // version 1?
      .                 if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
      .                    stbtt_int32 n = ttLONG(font_collection+8);
      .                    if (index >= n)
      .                       return -1;
-- line 1336 ----------------------------------------
-- line 1385 ----------------------------------------
      .              return info->svg;
      .           }
      .           
      .           static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
      .           {
      .              stbtt_uint32 cmap, t;
      .              stbtt_int32 i,numTables;
      .           
      2 ( 0.00%)     info->data = data;
      2 ( 0.00%)     info->fontstart = fontstart;
      8 ( 0.00%)     info->cff = stbtt__new_buf(NULL, 0);
      .           
     10 ( 0.00%)     cmap = stbtt__find_table(data, fontstart, "cmap");       // required
     96 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
     10 ( 0.00%)     info->loca = stbtt__find_table(data, fontstart, "loca"); // required
    192 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
     10 ( 0.00%)     info->head = stbtt__find_table(data, fontstart, "head"); // required
    144 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
     10 ( 0.00%)     info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
    132 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
     10 ( 0.00%)     info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
    168 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
     10 ( 0.00%)     info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
    192 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
      8 ( 0.00%)     info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
    232 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
      8 ( 0.00%)     info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
    236 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
      .           
     34 ( 0.00%)     if (!cmap || !info->head || !info->hhea || !info->hmtx)
      .                 return 0;
      6 ( 0.00%)     if (info->glyf) {
      .                 // required for truetype
      6 ( 0.00%)        if (!info->loca) return 0;
      .              } else {
      .                 // initialization for CFF / Type2 fonts (OTF)
      .                 stbtt__buf b, topdict, topdictidx;
      .                 stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      .                 stbtt_uint32 cff;
      .           
      .                 cff = stbtt__find_table(data, fontstart, "CFF ");
      .                 if (!cff) return 0;
-- line 1418 ----------------------------------------
-- line 1453 ----------------------------------------
      .                    info->fontdicts = stbtt__cff_get_index(&b);
      .                    info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      .                 }
      .           
      .                 stbtt__buf_seek(&b, charstrings);
      .                 info->charstrings = stbtt__cff_get_index(&b);
      .              }
      .           
     14 ( 0.00%)     t = stbtt__find_table(data, fontstart, "maxp");
    208 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__find_table(unsigned char*, unsigned int, char const*) (2x)
     10 ( 0.00%)     if (t)
      6 ( 0.00%)        info->numGlyphs = ttUSHORT(data+t+4);
      .              else
      2 ( 0.00%)        info->numGlyphs = 0xffff;
      .           
      2 ( 0.00%)     info->svg = -1;
      .           
      .              // find a cmap encoding table we understand *now* to avoid searching
      .              // later. (todo: could make this installable)
      .              // the same regardless of glyph.
      8 ( 0.00%)     numTables = ttUSHORT(data + cmap + 2);
      2 ( 0.00%)     info->index_map = 0;
     30 ( 0.00%)     for (i=0; i < numTables; ++i) {
      .                 stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      .                 // find an encoding we understand:
     32 ( 0.00%)        switch(ttUSHORT(data+encoding_record)) {
      .                    case STBTT_PLATFORM_ID_MICROSOFT:
      6 ( 0.00%)              switch (ttUSHORT(data+encoding_record+2)) {
      .                          case STBTT_MS_EID_UNICODE_BMP:
      .                          case STBTT_MS_EID_UNICODE_FULL:
      .                             // MS/Unicode
      .                             info->index_map = cmap + ttULONG(data+encoding_record+4);
      .                             break;
      .                       }
      .                       break;
      .                   case STBTT_PLATFORM_ID_UNICODE:
      .                       // Mac/iOS has these
      .                       // all the encodingIDs are unicode, so we don't bother to check it
     12 ( 0.00%)              info->index_map = cmap + ttULONG(data+encoding_record+4);
      .                       break;
      .                 }
      .              }
      6 ( 0.00%)     if (info->index_map == 0)
      .                 return 0;
      .           
      6 ( 0.00%)     info->indexToLocFormat = ttUSHORT(data+info->head + 50);
      .              return 1;
      .           }
      .           
 11,060 ( 0.00%)  STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
      .           {
      .              stbtt_uint8 *data = info->data;
      .              stbtt_uint32 index_map = info->index_map;
      .           
  5,530 ( 0.00%)     stbtt_uint16 format = ttUSHORT(data + index_map + 0);
 11,060 ( 0.00%)     if (format == 0) { // apple byte encoding
      .                 stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      .                 if (unicode_codepoint < bytes-6)
      .                    return ttBYTE(data + index_map + 6 + unicode_codepoint);
  5,530 ( 0.00%)        return 0;
      .              } else if (format == 6) {
      .                 stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      .                 stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      .                 if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
      .                    return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      .                 return 0;
      .              } else if (format == 2) {
      .                 STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      .                 return 0;
      .              } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
  5,530 ( 0.00%)        stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
 16,590 ( 0.00%)        stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
  2,765 ( 0.00%)        stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
  2,765 ( 0.00%)        stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
      .           
      .                 // do a binary search of the segments
  5,530 ( 0.00%)        stbtt_uint32 endCount = index_map + 14;
      .                 stbtt_uint32 search = endCount;
      .           
  5,530 ( 0.00%)        if (unicode_codepoint > 0xffff)
      .                    return 0;
      .           
      .                 // they lie from endCount .. endCount + segCount
      .                 // but searchRange is the nearest power of two, so...
 19,355 ( 0.00%)        if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
  8,295 ( 0.00%)           search += rangeShift*2;
      .           
      .                 // now decrement to bias correctly to find smallest
  2,765 ( 0.00%)        search -= 2;
 29,160 ( 0.00%)        while (entrySelector) {
      .                    stbtt_uint16 end;
 11,815 ( 0.00%)           searchRange >>= 1;
 70,890 ( 0.00%)           end = ttUSHORT(data + search + searchRange*2);
 11,815 ( 0.00%)           if (unicode_codepoint > end)
 35,445 ( 0.00%)              search += searchRange*2;
      .                    --entrySelector;
      .                 }
      .                 search += 2;
      .           
      .                 {
      .                    stbtt_uint16 offset, start, last;
  5,530 ( 0.00%)           stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
      .           
 16,590 ( 0.00%)           start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
  5,412 ( 0.00%)           last = ttUSHORT(data + endCount + 2*item);
 16,413 ( 0.00%)           if (unicode_codepoint < start || unicode_codepoint > last)
      .                       return 0;
      .           
 10,824 ( 0.00%)           offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
  5,412 ( 0.00%)           if (offset == 0)
 18,942 ( 0.00%)              return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
      .           
      .                    return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      .                 }
      .              } else if (format == 12 || format == 13) {
      .                 stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      .                 stbtt_int32 low,high;
      .                 low = 0; high = (stbtt_int32)ngroups;
      .                 // Binary search the right group.
-- line 1570 ----------------------------------------
-- line 1584 ----------------------------------------
      .                          return start_glyph;
      .                    }
      .                 }
      .                 return 0; // not found
      .              }
      .              // @TODO
      .              STBTT_assert(0);
      .              return 0;
 11,060 ( 0.00%)  }
      .           
      .           STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
      .           {
      .              return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
      .           }
      .           
      .           static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
      .           {
 56,058 ( 0.00%)     v->type = type;
342,586 ( 0.00%)     v->x = (stbtt_int16) x;
      .              v->y = (stbtt_int16) y;
 28,733 ( 0.00%)     v->cx = (stbtt_int16) cx;
      .              v->cy = (stbtt_int16) cy;
 34,187 ( 0.00%)  }
      .           
      .           static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
      .           {
      .              int g1,g2;
      .           
 10,824 ( 0.00%)     STBTT_assert(!info->cff.size);
      .           
  7,268 ( 0.00%)     if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
 10,824 ( 0.00%)     if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
      .           
  7,216 ( 0.00%)     if (info->indexToLocFormat == 0) {
 16,176 ( 0.00%)        g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
  3,568 ( 0.00%)        g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
      .              } else {
 16,296 ( 0.00%)        g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
  2,716 ( 0.00%)        g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
      .              }
      .           
  7,216 ( 0.00%)     return g1==g2 ? -1 : g1; // if length is 0, return -1
  3,608 ( 0.00%)  }
      .           
      .           static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
      .           
      .           STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
      .           {
  8,118 ( 0.00%)     if (info->cff.size) {
      .                 stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
      .              } else {
  2,706 ( 0.00%)        int g = stbtt__GetGlyfOffset(info, glyph_index);
 69,636 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyfOffset(stbtt_fontinfo const*, int) (2,706x)
  5,412 ( 0.00%)        if (g < 0) return 0;
      .           
 10,668 ( 0.00%)        if (x0) *x0 = ttSHORT(info->data + g + 2);
  5,334 ( 0.00%)        if (y0) *y0 = ttSHORT(info->data + g + 4);
  5,334 ( 0.00%)        if (x1) *x1 = ttSHORT(info->data + g + 6);
  5,334 ( 0.00%)        if (y1) *y1 = ttSHORT(info->data + g + 8);
      .              }
      .              return 1;
      .           }
      .           
      .           STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
      .           {
      .              return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
      .           }
-- line 1649 ----------------------------------------
-- line 1657 ----------------------------------------
      .              g = stbtt__GetGlyfOffset(info, glyph_index);
      .              if (g < 0) return 1;
      .              numberOfContours = ttSHORT(info->data + g);
      .              return numberOfContours == 0;
      .           }
      .           
      .           static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
      .               stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
 39,543 ( 0.00%)  {
 11,298 ( 0.00%)     if (start_off) {
    986 ( 0.00%)        if (was_off)
 36,904 ( 0.00%)           stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
    923 ( 0.00%)        stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
      .              } else {
 10,312 ( 0.00%)        if (was_off)
      .                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      .                 else
      .                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
      .              }
      .              return num_vertices;
 16,947 ( 0.00%)  }
      .           
      .           static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
 11,726 ( 0.00%)  {
      .              stbtt_int16 numberOfContours;
      .              stbtt_uint8 *endPtsOfContours;
    902 ( 0.00%)     stbtt_uint8 *data = info->data;
      .              stbtt_vertex *vertices=0;
      .              int num_vertices=0;
  1,804 ( 0.00%)     int g = stbtt__GetGlyfOffset(info, glyph_index);
 23,212 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyfOffset(stbtt_fontinfo const*, int) (902x)
      .           
    902 ( 0.00%)     *pvertices = NULL;
      .           
  1,817 ( 0.00%)     if (g < 0) return 0;
      .           
  1,778 ( 0.00%)     numberOfContours = ttSHORT(data + g);
      .           
  2,667 ( 0.00%)     if (numberOfContours > 0) {
  9,779 ( 0.00%)        stbtt_uint8 flags=0,flagcount;
  2,667 ( 0.00%)        stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      .                 stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      .                 stbtt_uint8 *points;
  1,778 ( 0.00%)        endPtsOfContours = (data + g + 10);
  5,334 ( 0.00%)        ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
  2,667 ( 0.00%)        points = data + g + 10 + numberOfContours * 2 + 2 + ins;
      .           
  2,667 ( 0.00%)        n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
      .           
    889 ( 0.00%)        m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
  5,334 ( 0.00%)        vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
233,132 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
  3,556 ( 0.00%)        if (vertices == 0)
      .                    return 0;
      .           
    889 ( 0.00%)        next_move = 0;
    889 ( 0.00%)        flagcount=0;
      .           
      .                 // in first pass, we load uninterpreted data into the allocated array
      .                 // above, shifted to the end of the array so we won't overwrite it when
      .                 // we create our final data starting from the front
      .           
      .                 off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
      .           
      .                 // first load flags
      .           
188,654 ( 0.00%)        for (i=0; i < n; ++i) {
 24,442 ( 0.00%)           if (flagcount == 0) {
106,404 ( 0.00%)              flags = *points++;
111,042 ( 0.00%)              if (flags & 8)
 13,914 ( 0.00%)                 flagcount = *points++;
      .                    } else
  6,771 ( 0.00%)              --flagcount;
 62,292 ( 0.00%)           vertices[off+i].type = flags;
      .                 }
      .           
      .                 // now load x coordinates
  2,667 ( 0.00%)        x=0;
188,654 ( 0.00%)        for (i=0; i < n; ++i) {
 62,292 ( 0.00%)           flags = vertices[off+i].type;
249,168 ( 0.00%)           if (flags & 2) {
 37,441 ( 0.00%)              stbtt_int16 dx = *points++;
224,646 ( 0.00%)              x += (flags & 16) ? dx : -dx; // ???
      .                    } else {
 49,702 ( 0.00%)              if (!(flags & 16)) {
 44,130 ( 0.00%)                 x = x + (stbtt_int16) (points[0]*256 + points[1]);
  7,355 ( 0.00%)                 points += 2;
      .                       }
      .                    }
 62,292 ( 0.00%)           vertices[off+i].x = (stbtt_int16) x;
      .                 }
      .           
      .                 // now load y coordinates
  2,667 ( 0.00%)        y=0;
186,876 ( 0.00%)        for (i=0; i < n; ++i) {
 62,292 ( 0.00%)           flags = vertices[off+i].type;
249,168 ( 0.00%)           if (flags & 4) {
 40,249 ( 0.00%)              stbtt_int16 dy = *points++;
241,494 ( 0.00%)              y += (flags & 32) ? dy : -dy; // ???
      .                    } else {
 44,086 ( 0.00%)              if (!(flags & 32)) {
 35,214 ( 0.00%)                 y = y + (stbtt_int16) (points[0]*256 + points[1]);
  5,869 ( 0.00%)                 points += 2;
      .                       }
      .                    }
 62,292 ( 0.00%)           vertices[off+i].y = (stbtt_int16) y;
      .                 }
      .           
      .                 // now convert them to our format
  3,556 ( 0.00%)        num_vertices=0;
  5,334 ( 0.00%)        sx = sy = cx = cy = scx = scy = 0;
187,765 ( 0.00%)        for (i=0; i < n; ++i) {
498,336 ( 0.00%)           flags = vertices[off+i].type;
124,584 ( 0.00%)           x     = (stbtt_int16) vertices[off+i].x;
 62,292 ( 0.00%)           y     = (stbtt_int16) vertices[off+i].y;
      .           
124,584 ( 0.00%)           if (next_move == i) {
 11,298 ( 0.00%)              if (i != 0)
 90,440 ( 0.00%)                 num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
139,593 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__close_shape(stbtt_vertex*, int, int, int, int, int, int, int, int, int) (4,760x)
      .           
      .                       // now start the new one
  5,649 ( 0.00%)              start_off = !(flags & 1);
 16,947 ( 0.00%)              if (start_off) {
      .                          // if we start off with an off-curve point, then when we need to find a point on the curve
      .                          // where we can start, and we need to save some state for when we wraparound.
  1,479 ( 0.00%)                 scx = x;
    493 ( 0.00%)                 scy = y;
  1,479 ( 0.00%)                 if (!(vertices[off+i+1].type & 1)) {
      .                             // next point is also a curve point, so interpolate an on-point curve
  3,451 ( 0.00%)                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
  1,972 ( 0.00%)                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
      .                          } else {
      .                             // otherwise just use the next point as our start point
      .                             sx = (stbtt_int32) vertices[off+i+1].x;
      .                             sy = (stbtt_int32) vertices[off+i+1].y;
      .                             ++i; // we're using point i+1 as the starting point, so skip it
      .                          }
      .                       } else {
      .                          sx = x;
      .                          sy = y;
      .                       }
 39,543 ( 0.00%)              stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
  5,649 ( 0.00%)              was_off = 0;
 39,543 ( 0.00%)              next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
 16,947 ( 0.00%)              ++j;
      .                    } else {
113,286 ( 0.00%)              if (!(flags & 1)) { // if it's a curve
 53,664 ( 0.00%)                 if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
220,104 ( 0.00%)                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
 39,145 ( 0.00%)                 cx = x;
 26,832 ( 0.00%)                 cy = y;
 24,626 ( 0.00%)                 was_off = 1;
      .                       } else {
 59,622 ( 0.00%)                 if (was_off)
 89,433 ( 0.00%)                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
      .                          else
      .                             stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
 59,622 ( 0.00%)                 was_off = 0;
      .                       }
      .                    }
      .                 }
 13,335 ( 0.00%)        num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 29,362 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__close_shape(stbtt_vertex*, int, int, int, int, int, int, int, int, int) (889x)
      .              } else if (numberOfContours < 0) {
      .                 // Compound shapes.
      .                 int more = 1;
      .                 stbtt_uint8 *comp = data + g + 10;
      .                 num_vertices = 0;
      .                 vertices = 0;
      .                 while (more) {
      .                    stbtt_uint16 flags, gidx;
-- line 1824 ----------------------------------------
-- line 1890 ----------------------------------------
      .                    }
      .                    // More components ?
      .                    more = flags & (1<<5);
      .                 }
      .              } else {
      .                 // numberOfCounters == 0, do nothing
      .              }
      .           
    889 ( 0.00%)     *pvertices = vertices;
    889 ( 0.00%)     return num_vertices;
  9,922 ( 0.00%)  }
      .           
      .           typedef struct
      .           {
      .              int bounds;
      .              int started;
      .              float first_x, first_y;
      .              float x, y;
      .              stbtt_int32 min_x, max_x, min_y, max_y;
-- line 1908 ----------------------------------------
-- line 2296 ----------------------------------------
      .              if (y0)  *y0 = r ? c.min_y : 0;
      .              if (x1)  *x1 = r ? c.max_x : 0;
      .              if (y1)  *y1 = r ? c.max_y : 0;
      .              return r ? c.num_vertices : 0;
      .           }
      .           
      .           STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
      .           {
  4,510 ( 0.00%)     if (!info->cff.size)
  2,706 ( 0.00%)        return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
5,250,913 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__GetGlyphShapeTT(stbtt_fontinfo const*, int, stbtt_vertex**) (902x)
      .              else
  1,804 ( 0.00%)        return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
      .           }
      .           
      .           STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
      .           {
  4,510 ( 0.00%)     stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
  2,706 ( 0.00%)     if (glyph_index < numOfLongHorMetrics) {
  3,618 ( 0.00%)        if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      .                 if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
      .              } else {
    892 ( 0.00%)        if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
    223 ( 0.00%)        if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
      .              }
      .           }
      .           
      .           STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)
      .           {
      .              stbtt_uint8 *data = info->data + info->kern;
      .           
      .              // we only look at the first table. it must be 'horizontal' and format 0.
-- line 2326 ----------------------------------------
-- line 2659 ----------------------------------------
      .              *x0 = ttSHORT(info->data + info->head + 36);
      .              *y0 = ttSHORT(info->data + info->head + 38);
      .              *x1 = ttSHORT(info->data + info->head + 40);
      .              *y1 = ttSHORT(info->data + info->head + 42);
      .           }
      .           
      .           STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
      .           {
     44 ( 0.00%)     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
     28 ( 0.00%)     return (float) height / fheight;
      .           }
      .           
      .           STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
      .           {
      .              int unitsPerEm = ttUSHORT(info->data + info->head + 18);
      .              return pixels / unitsPerEm;
      .           }
      .           
-- line 2676 ----------------------------------------
-- line 2718 ----------------------------------------
      .              return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);
      .           }
      .           
      .           //////////////////////////////////////////////////////////////////////////////
      .           //
      .           // antialiasing software rasterizer
      .           //
      .           
 35,178 ( 0.00%)  STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
      .           {
      .              int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
      .              if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      .                 // e.g. space character
    117 ( 0.00%)        if (ix0) *ix0 = 0;
    117 ( 0.00%)        if (iy0) *iy0 = 0;
    104 ( 0.00%)        if (ix1) *ix1 = 0;
    104 ( 0.00%)        if (iy1) *iy1 = 0;
      .              } else {
      .                 // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
 21,336 ( 0.00%)        if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
 21,336 ( 0.00%)        if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
 16,002 ( 0.00%)        if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
 17,780 ( 0.00%)        if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
      .              }
 18,942 ( 0.00%)  }
      .           
      .           STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
      .           {
  6,314 ( 0.00%)     stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
111,066 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBoxSubpixel.constprop.0 (902x)
      .           }
      .           
      .           STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
      .           {
      .              stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
      .           }
      .           
      .           STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
-- line 2754 ----------------------------------------
-- line 2769 ----------------------------------------
      .           {
      .              struct stbtt__hheap_chunk *head;
      .              void   *first_free;
      .              int    num_remaining_in_head_chunk;
      .           } stbtt__hheap;
      .           
      .           static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
      .           {
 80,846 ( 0.00%)     if (hh->first_free) {
      .                 void *p = hh->first_free;
 25,806 ( 0.00%)        hh->first_free = * (void **) p;
 25,806 ( 0.00%)        return p;
      .              } else {
 29,234 ( 0.00%)        if (hh->num_remaining_in_head_chunk == 0) {
      .                    int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
  5,334 ( 0.00%)           stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
343,892 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
  1,778 ( 0.00%)           if (c == NULL)
      .                       return NULL;
  2,665 ( 0.00%)           c->next = hh->head;
  3,556 ( 0.00%)           hh->head = c;
  2,661 ( 0.00%)           hh->num_remaining_in_head_chunk = count;
      .                 }
 13,728 ( 0.00%)        --hh->num_remaining_in_head_chunk;
 84,146 ( 0.00%)        return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
      .              }
      .           }
      .           
      .           static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
      .           {
 35,162 ( 0.00%)     *(void **) p = hh->first_free;
 35,162 ( 0.00%)     hh->first_free = p;
      .           }
      .           
      .           static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
      .           {
      .              stbtt__hheap_chunk *c = hh->head;
  3,556 ( 0.00%)     while (c) {
  1,778 ( 0.00%)        stbtt__hheap_chunk *n = c->next;
    889 ( 0.00%)        STBTT_free(c, userdata);
224,917 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
    889 ( 0.00%)        c = n;
      .              }
      .           }
      .           
      .           typedef struct stbtt__edge {
      .              float x0,y0, x1,y1;
      .              int invert;
      .           } stbtt__edge;
      .           
-- line 2816 ----------------------------------------
-- line 2857 ----------------------------------------
      .              z->next = 0;
      .              z->direction = e->invert ? 1 : -1;
      .              return z;
      .           }
      .           #elif STBTT_RASTERIZER_VERSION == 2
      .           static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
      .           {
      .              stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
204,790 ( 0.00%)     float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
 14,617 ( 0.00%)     STBTT_assert(z != NULL);
      .              //STBTT_assert(e->y0 <= start_point);
      .              if (!z) return z;
 40,423 ( 0.00%)     z->fdx = dxdy;
263,107 ( 0.00%)     z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
 80,846 ( 0.00%)     z->fx = e->x0 + dxdy * (start_point - e->y0);
161,692 ( 0.00%)     z->fx -= off_x;
262,612 ( 0.00%)     z->direction = e->invert ? 1.0f : -1.0f;
      .              z->sy = e->y0;
 40,423 ( 0.00%)     z->ey = e->y1;
 40,423 ( 0.00%)     z->next = 0;
      .              return z;
      .           }
      .           #else
      .           #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
      .           #endif
      .           
      .           #if STBTT_RASTERIZER_VERSION == 1
      .           // note: this routine clips fills that extend off the edges... ideally this
-- line 2884 ----------------------------------------
-- line 3025 ----------------------------------------
      .              if (scanline != scanline_data)
      .                 STBTT_free(scanline, userdata);
      .           }
      .           
      .           #elif STBTT_RASTERIZER_VERSION == 2
      .           
      .           // the edge passed in here does not cross the vertical line at x or the vertical line at x+1
      .           // (i.e. it has already been clipped to those)
 51,971 ( 0.00%)  static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
      .           {
104,592 ( 0.00%)     if (y0 == y1) return;
 31,714 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) [clone .part.0] [clone .isra.0] (818x)
278,644 ( 0.00%)     STBTT_assert(y0 < y1);
472,556 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) [clone .part.0] [clone .isra.0] (11,387x)
103,942 ( 0.00%)     STBTT_assert(e->sy <= e->ey);
103,942 ( 0.00%)     if (y0 > e->ey) return;
103,700 ( 0.00%)     if (y1 < e->sy) return;
155,037 ( 0.00%)     if (y0 < e->sy) {
149,592 ( 0.00%)        x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
 24,932 ( 0.00%)        y0 = e->sy;
      .              }
103,358 ( 0.00%)     if (y1 > e->ey) {
 86,952 ( 0.00%)        x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
 14,492 ( 0.00%)        y1 = e->ey;
      .              }
      .           
258,395 ( 0.00%)     if (x0 == x)
129,328 ( 0.00%)        STBTT_assert(x1 <= x+1);
116,082 ( 0.00%)     else if (x0 == x+1)
    602 ( 0.00%)        STBTT_assert(x1 >= x);
 76,786 ( 0.00%)     else if (x0 <= x)
 52,926 ( 0.00%)        STBTT_assert(x1 <= x);
 23,860 ( 0.00%)     else if (x0 >= x+1)
  7,960 ( 0.00%)        STBTT_assert(x1 >= x+1);
      .              else
 31,800 ( 0.00%)        STBTT_assert(x1 >= x && x1 <= x+1);
      .           
 26,572 ( 0.00%)     if (x0 <= x && x1 <= x)
195,825 ( 0.00%)        scanline[x] += e->direction * (y1-y0);
    774 ( 0.00%)     else if (x0 >= x+1 && x1 >= x+1)
      .                 ;
      .              else {
 15,900 ( 0.00%)        STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
 91,982 ( 0.00%)        scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
      .              }
103,942 ( 0.00%)  }
      .           
      .           static float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)
      .           {
104,404 ( 0.00%)     STBTT_assert(top_width >= 0);
 85,788 ( 0.00%)     STBTT_assert(bottom_width >= 0);
104,404 ( 0.00%)     return (top_width + bottom_width) / 2.0f * height;
      .           }
      .           
      .           static float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)
      .           {
 85,788 ( 0.00%)     return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);
      .           }
      .           
      .           static float stbtt__sized_triangle_area(float height, float width)
      .           {
 18,616 ( 0.00%)     return height * width / 2;
      .           }
      .           
      .           static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
 83,400 ( 0.00%)  {
  6,950 ( 0.00%)     float y_bottom = y_top+1;
      .           
143,983 ( 0.00%)     while (e) {
      .                 // brute force every pixel
      .           
      .                 // compute intersection points with top & bottom
195,465 ( 0.00%)        STBTT_assert(e->ey >= y_top);
      .           
325,775 ( 0.00%)        if (e->fdx == 0) {
 65,155 ( 0.00%)           float x0 = e->fx;
 86,128 ( 0.00%)           if (x0 < len) {
 39,766 ( 0.00%)              if (x0 >= 0) {
238,596 ( 0.00%)                 stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
790,359 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) [clone .part.0] [clone .isra.0] (19,883x)
218,713 ( 0.00%)                 stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
736,023 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__handle_clipped_edge(float*, int, stbtt__active_edge*, float, float, float, float) [clone .part.0] [clone .isra.0] (19,883x)
      .                       } else {
      .                          stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
      .                       }
      .                    }
      .                 } else {
      .                    float x0 = e->fx;
      .                    float dx = e->fdx;
 43,623 ( 0.00%)           float xb = x0 + dx;
      .                    float x_top, x_bottom;
      .                    float sy0,sy1;
 18,616 ( 0.00%)           float dy = e->fdy;
130,869 ( 0.00%)           STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
      .           
      .                    // compute endpoints of line segment clipped to this scanline (if the
      .                    // line segment starts on this scanline. x0 is the intersection of the
      .                    // line with y_top, but that may be off the line segment.
 87,246 ( 0.00%)           if (e->sy > y_top) {
 60,972 ( 0.00%)              x_top = x0 + dx * (e->sy - y_top);
      .                       sy0 = e->sy;
      .                    } else {
 26,274 ( 0.00%)              x_top = x0;
 13,137 ( 0.00%)              sy0 = y_top;
      .                    }
 87,246 ( 0.00%)           if (e->ey < y_bottom) {
 58,816 ( 0.00%)              x_bottom = x0 + dx * (e->ey - y_top);
      .                       sy1 = e->ey;
      .                    } else {
 28,430 ( 0.00%)              x_bottom = xb;
 14,215 ( 0.00%)              sy1 = y_bottom;
      .                    }
      .           
476,289 ( 0.00%)           if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
      .                       // from here on, we don't have to range check x values
      .           
171,576 ( 0.00%)              if ((int) x_top == (int) x_bottom) {
      .                          float height;
      .                          // simple case, only spans one pixel
      .                          int x = (int) x_top;
 48,556 ( 0.00%)                 height = (sy1 - sy0) * e->direction;
 97,112 ( 0.00%)                 STBTT_assert(x >= 0 && x < len);
194,224 ( 0.00%)                 scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
 72,834 ( 0.00%)                 scanline_fill[x] += height; // everything right of this pixel is filled
      .                       } else {
      .                          int x,x1,x2;
      .                          float y_crossing, y_final, step, sign, area;
      .                          // covers 2+ pixels
 37,232 ( 0.00%)                 if (x_top > x_bottom) {
      .                             // flip scanline vertically; signed area is the same
      .                             float t;
  9,541 ( 0.00%)                    sy0 = y_bottom - (sy0 - y_top);
 38,164 ( 0.00%)                    sy1 = y_bottom - (sy1 - y_top);
 19,082 ( 0.00%)                    t = sy0, sy0 = sy1, sy1 = t;
 19,082 ( 0.00%)                    t = x_bottom, x_bottom = x_top, x_top = t;
  9,541 ( 0.00%)                    dx = -dx;
  9,541 ( 0.00%)                    dy = -dy;
 19,082 ( 0.00%)                    t = x0, x0 = xb, xb = t;
      .                          }
 55,848 ( 0.00%)                 STBTT_assert(dy >= 0);
 37,232 ( 0.00%)                 STBTT_assert(dx >= 0);
      .           
      .                          x1 = (int) x_top;
      .                          x2 = (int) x_bottom;
      .                          // compute intersection with y axis at x1+1
 93,080 ( 0.00%)                 y_crossing = y_top + dy * (x1+1 - x0);
      .           
      .                          // compute intersection with y axis at x2
 55,848 ( 0.00%)                 y_final = y_top + dy * (x2 - x0);
      .           
      .                          //           x1    x_top                            x2    x_bottom
      .                          //     y_top  +------|-----+------------+------------+--------|---+------------+
      .                          //            |            |            |            |            |            |
      .                          //            |            |            |            |            |            |
      .                          //       sy0  |      Txxxxx|............|............|............|............|
      .                          // y_crossing |            *xxxxx.......|............|............|............|
      .                          //            |            |     xxxxx..|............|............|............|
-- line 3177 ----------------------------------------
-- line 3182 ----------------------------------------
      .                          //            |            |            |            |            |            |
      .                          //            |            |            |            |            |            |
      .                          //  y_bottom  +------------+------------+------------+------------+------------+
      .                          //
      .                          // goal is to measure the area covered by '.' in each pixel
      .           
      .                          // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
      .                          // @TODO: maybe test against sy1 rather than y_bottom?
 18,616 ( 0.00%)                 if (y_crossing > y_bottom)
      .                             y_crossing = y_bottom;
      .           
 18,616 ( 0.00%)                 sign = e->direction;
      .           
      .                          // area of the rectangle covered from sy0..y_crossing
 37,232 ( 0.00%)                 area = sign * (y_crossing-sy0);
      .           
      .                          // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
130,312 ( 0.00%)                 scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
      .           
      .                          // check if final y_crossing is blown up; no test case for this
 37,232 ( 0.00%)                 if (y_final > y_bottom) {
      .                             int denom = (x2 - (x1+1));
     33 ( 0.00%)                    y_final = y_bottom;
     99 ( 0.00%)                    if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
     57 ( 0.00%)                       dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
      .                             }
      .                          }
      .           
      .                          // in second pixel, area covered by line segment found in first pixel
      .                          // is always a rectangle 1 wide * the height of that line segment; this
      .                          // is exactly what the variable 'area' stores. it also gets a contribution
      .                          // from the line segment within it. the THIRD pixel will get the first
      .                          // pixel's rectangle contribution, the second pixel's rectangle contribution,
      .                          // and its own contribution. the 'own contribution' is the same in every pixel except
      .                          // the leftmost and rightmost, a trapezoid that slides down in each pixel.
      .                          // the second pixel's contribution to the third pixel will be the
      .                          // rectangle 1 wide times the height change in the second pixel, which is dy.
      .           
 18,616 ( 0.00%)                 step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
      .                          // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
      .                          // so the area advances by 'step' every time
      .           
 56,405 ( 0.00%)                 for (x = x1+1; x < x2; ++x) {
 53,172 ( 0.00%)                    scanline[x] += area + step/2; // area of trapezoid is 1*step/2
  6,391 ( 0.00%)                    area += step;
      .                          }
 74,464 ( 0.00%)                 STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
 55,848 ( 0.00%)                 STBTT_assert(sy1 > y_final-0.01f);
      .           
      .                          // area covered in the last pixel is the rectangle from all the pixels to the left,
      .                          // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
148,928 ( 0.00%)                 scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
      .           
      .                          // the rest of the line is filled based on the total height of the line segment in this pixel
 74,464 ( 0.00%)                 scanline_fill[x2] += sign * (sy1-sy0);
      .                       }
      .                    } else {
      .                       // if edge goes outside of box we're drawing, we require
      .                       // clipping logic. since this does not match the intended use
      .                       // of this library, we use a different, very slow brute
      .                       // force implementation
      .                       // note though that this does happen some of the time because
      .                       // x_top and x_bottom can be extrapolated at the top & bottom of
      .                       // the shape and actually lie outside the bounding box
      .                       int x;
 29,802 ( 0.00%)              for (x=0; x < len; ++x) {
      .                          // cases:
      .                          //
      .                          // there can be up to two intersections with the pixel. any intersection
      .                          // with left or right edges can be handled by splitting into two (or three)
      .                          // regions. intersections with top & bottom do not necessitate case-wise logic.
      .                          //
      .                          // the old way of doing this found the intersections with the left & right edges,
      .                          // then used some simple logic to produce up to three segments in sorted order
      .                          // from top-to-bottom. however, this had a problem: if an x edge was epsilon
      .                          // across the x border, then the corresponding y position might not be distinct
      .                          // from the other y segment, and it might ignored as an empty segment. to avoid
      .                          // that, we need to explicitly produce segments based on x positions.
      .           
      .                          // rename variables to clearly-defined pairs
      .                          float y0 = y_top;
 22,512 ( 0.00%)                 float x1 = (float) (x);
 33,768 ( 0.00%)                 float x2 = (float) (x+1);
      .                          float x3 = xb;
      .                          float y3 = y_bottom;
      .           
      .                          // x = e->x + e->dx * (y-y_top)
      .                          // (y-y_top) = (x - e->x) / e->dx
      .                          // y = (x - e->x) / e->dx + y_top
 45,024 ( 0.00%)                 float y1 = (x - x0) / dx + y_top;
 33,768 ( 0.00%)                 float y2 = (x+1 - x0) / dx + y_top;
      .           
 36,052 ( 0.00%)                 if (x0 < x1 && x3 > x2) {         // three segments descending down-right
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 35,884 ( 0.00%)                 } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
    522 ( 0.00%)                 } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
    398 ( 0.00%)                 } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 34,520 ( 0.00%)                 } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
  8,374 ( 0.00%)                 } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
      .                             stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
      .                          } else {  // one segment
      .                             stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
      .                          }
      .                       }
      .                    }
      .                 }
104,921 ( 0.00%)        e = e->next;
      .              }
 55,600 ( 0.00%)  }
      .           
      .           // directly AA rasterize edges w/o supersampling
      .           static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
      .           {
  2,667 ( 0.00%)     stbtt__hheap hh = { 0, 0, 0 };
    889 ( 0.00%)     stbtt__active_edge *active = NULL;
    889 ( 0.00%)     int y,j=0, i;
      .              float scanline_data[129], *scanline, *scanline2;
      .           
      .              STBTT__NOTUSED(vsubsample);
      .           
  1,778 ( 0.00%)     if (result->w > 64)
      .                 scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
      .              else
  2,667 ( 0.00%)        scanline = scanline_data;
      .           
  4,445 ( 0.00%)     scanline2 = scanline + result->w;
      .           
      .              y = off_y;
  8,001 ( 0.00%)     e[n].y0 = (float) (off_y + result->h) + 1;
      .           
 30,491 ( 0.00%)     while (j < result->h) {
      .                 // find center of pixel for this scanline
 34,780 ( 0.00%)        float scan_y_top    = y + 0.0f;
 27,824 ( 0.00%)        float scan_y_bottom = y + 1.0f;
  6,061 ( 0.00%)        stbtt__active_edge **step = &active;
      .           
 48,692 ( 0.00%)        STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
 88,195 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6,956x)
 39,225 ( 0.00%)        STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
 97,195 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6,956x)
      .           
      .                 // update all active edges;
      .                 // remove all active edges that terminate before the top of this scanline
242,286 ( 0.00%)        while (*step) {
      .                    stbtt__active_edge * z = *step;
119,788 ( 0.00%)           if (z->ey <= scan_y_top) {
 70,324 ( 0.00%)              *step = z->next; // delete from list
117,608 ( 0.00%)              STBTT_assert(z->direction);
 35,162 ( 0.00%)              z->direction = 0;
      .                       stbtt__hheap_free(&hh, z);
      .                    } else {
 24,732 ( 0.00%)              step = &((*step)->next); // advance through list
      .                    }
      .                 }
      .           
      .                 // insert all edges that start before the bottom of this scanline
162,067 ( 0.00%)        while (e->y0 <= scan_y_bottom) {
161,692 ( 0.00%)           if (e->y0 != e->y1) {
      .                       stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
      .                       if (z != NULL) {
  4,445 ( 0.00%)                 if (j == 0 && off_y != 0) {
 12,144 ( 0.00%)                    if (z->ey < scan_y_top) {
      .                                // this can happen due to subpixel positioning and some kind of fp rounding error i think
      .                                z->ey = scan_y_top;
      .                             }
      .                          }
 80,846 ( 0.00%)                 STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
      .                          // insert at front
 80,846 ( 0.00%)                 z->next = active;
 40,423 ( 0.00%)                 active = z;
      .                       }
      .                    }
 40,423 ( 0.00%)           ++e;
      .                 }
      .           
      .                 // now process all active edges
 20,868 ( 0.00%)        if (active)
 83,400 ( 0.00%)           stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
7,421,757 ( 0.01%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__fill_active_edges_new(float*, float*, int, stbtt__active_edge*, float) (6,950x)
      .           
      .                 {
      .                    float sum = 0;
411,996 ( 0.00%)           for (i=0; i < result->w; ++i) {
      .                       float k;
      .                       int m;
 87,357 ( 0.00%)              sum += scanline2[i];
 87,357 ( 0.00%)              k = scanline[i] + sum;
174,714 ( 0.00%)              k = (float) STBTT_fabs(k)*255 + 0.5f;
 87,357 ( 0.00%)              m = (int) k;
262,071 ( 0.00%)              if (m > 255) m = 255;
184,741 ( 0.00%)              result->pixels[j*result->stride + i] = (unsigned char) m;
      .                    }
      .                 }
      .                 // advance all the edges
      .                 step = &active;
244,139 ( 0.00%)        while (*step) {
      .                    stbtt__active_edge *z = *step;
195,465 ( 0.00%)           z->fx += z->fdx; // advance to position for current scanline
      .                    step = &((*step)->next); // advance through list
      .                 }
      .           
      .                 ++y;
 13,912 ( 0.00%)        ++j;
      .              }
      .           
      .              stbtt__hheap_cleanup(&hh, userdata);
      .           
  3,556 ( 0.00%)     if (scanline != scanline_data)
      .                 STBTT_free(scanline, userdata);
      .           }
      .           #else
      .           #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
      .           #endif
      .           
      .           #define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
      .           
      .           static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
      .           {
      .              int i,j;
163,837 ( 0.00%)     for (i=1; i < n; ++i) {
118,602 ( 0.00%)        stbtt__edge t = p[i], *a = &t;
 79,068 ( 0.00%)        j = i;
294,584 ( 0.00%)        while (j > 0) {
      .                    stbtt__edge *b = &p[j-1];
      .                    int c = STBTT__COMPARE(a,b);
366,684 ( 0.00%)           if (!c) break;
337,744 ( 0.00%)           p[j] = p[j-1];
      .                    --j;
      .                 }
 75,584 ( 0.00%)        if (i != j)
 80,613 ( 0.00%)           p[j] = t;
      .              }
      .           }
      .           
      .           static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
 17,310 ( 0.00%)  {
      .              /* threshold for transitioning to insertion sort */
 19,358 ( 0.00%)     while (n > 12) {
      .                 stbtt__edge t;
      .                 int c01,c12,c,m,i,j;
      .           
      .                 /* compute median of three */
  8,790 ( 0.00%)        m = n >> 1;
 30,765 ( 0.00%)        c01 = STBTT__COMPARE(&p[0],&p[m]);
 26,370 ( 0.00%)        c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      .                 /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
  8,790 ( 0.00%)        if (c01 != c12) {
      .                    /* otherwise, we'll need to swap something else to middle */
      .                    int z;
  4,952 ( 0.00%)           c = STBTT__COMPARE(&p[0],&p[n-1]);
      .                    /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
      .                    /* 0<mid && mid>n:  0>n => 0; 0<n => n */
 11,175 ( 0.00%)           z = (c == c12) ? 0 : n-1;
 14,856 ( 0.00%)           t = p[z];
  9,904 ( 0.00%)           p[z] = p[m];
  4,952 ( 0.00%)           p[m] = t;
      .                 }
      .                 /* now p[m] is the median-of-three */
      .                 /* swap it to the beginning so it won't move around */
 33,241 ( 0.00%)        t = p[0];
 17,580 ( 0.00%)        p[0] = p[m];
  8,790 ( 0.00%)        p[m] = t;
      .           
      .                 /* partition loop */
      .                 i=1;
      .                 j=n-1;
      .                 for(;;) {
      .                    /* handling of equality is crucial here */
      .                    /* for sentinels & efficiency with duplicates */
      .                    for (;;++i) {
475,481 ( 0.00%)              if (!STBTT__COMPARE(&p[i], &p[0])) break;
      .                    }
 58,668 ( 0.00%)           for (;;--j) {
359,703 ( 0.00%)              if (!STBTT__COMPARE(&p[0], &p[j])) break;
      .                    }
      .                    /* make sure we haven't crossed */
 59,164 ( 0.00%)           if (i >= j) break;
125,935 ( 0.00%)           t = p[i];
100,748 ( 0.00%)           p[i] = p[j];
 50,374 ( 0.00%)           p[j] = t;
      .           
      .                    ++i;
 50,374 ( 0.00%)           --j;
      .                 }
      .                 /* recurse on smaller side, iterate on larger */
 17,580 ( 0.00%)        if (j < (n-i)) {
  4,827 ( 0.00%)           stbtt__sort_edges_quicksort(p,j);
223,032 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int)'2 (1,165x)
    982 ( 0.00%)           p = p+i;
  1,964 ( 0.00%)           n = n-i;
      .                 } else {
  5,572 ( 0.00%)           stbtt__sort_edges_quicksort(p+i, n-i);
197,948 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int)'2 (1,683x)
      .                    n = j;
      .                 }
      .              }
 15,100 ( 0.00%)  }
      .           
      .           static void stbtt__sort_edges(stbtt__edge *p, int n)
      .           {
  4,445 ( 0.00%)     stbtt__sort_edges_quicksort(p, n);
1,543,305 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__sort_edges_quicksort(stbtt__edge*, int) (889x)
      .              stbtt__sort_edges_ins_sort(p, n);
      .           }
      .           
      .           typedef struct
      .           {
      .              float x,y;
      .           } stbtt__point;
      .           
      .           static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
      .           {
  4,925 ( 0.00%)     float y_scale_inv = invert ? -scale_y : scale_y;
      .              stbtt__edge *e;
      .              int n,i,j,k,m;
      .           #if STBTT_RASTERIZER_VERSION == 1
      .              int vsubsample = result->h < 8 ? 15 : 5;
      .           #elif STBTT_RASTERIZER_VERSION == 2
      .              int vsubsample = 1;
      .           #else
      .              #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
      .           #endif
      .              // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
      .           
      .              // now we have to blow out the windings into explicit edge lists
    649 ( 0.00%)     n = 0;
 15,591 ( 0.00%)     for (i=0; i < windings; ++i)
  6,962 ( 0.00%)        n += wcount[i];
      .           
  8,001 ( 0.00%)     e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
186,565 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
  1,778 ( 0.00%)     if (e == 0) return;
    889 ( 0.00%)     n = 0;
      .           
  1,778 ( 0.00%)     m=0;
 16,947 ( 0.00%)     for (i=0; i < windings; ++i) {
 16,947 ( 0.00%)        stbtt__point *p = pts + m;
 11,298 ( 0.00%)        m += wcount[i];
  5,649 ( 0.00%)        j = wcount[i]-1;
411,073 ( 0.00%)        for (k=0; k < wcount[i]; j=k++) {
      .                    int a=k,b=j;
      .                    // skip the edge if horizontal
449,008 ( 0.00%)           if (p[j].y == p[k].y)
      .                       continue;
      .                    // add edge from j to k to the list
121,269 ( 0.00%)           e[n].invert = 0;
161,417 ( 0.00%)           if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
 60,497 ( 0.00%)              e[n].invert = 1;
      .                       a=j,b=k;
      .                    }
250,539 ( 0.00%)           e[n].x0 = p[a].x * scale_x + shift_x;
 40,423 ( 0.00%)           e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
 40,423 ( 0.00%)           e[n].x1 = p[b].x * scale_x + shift_x;
 40,423 ( 0.00%)           e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
 40,423 ( 0.00%)           ++n;
      .                 }
      .              }
      .           
      .              // now sort the edges by their highest point (should snap to integer, and then by x)
      .              //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
      .              stbtt__sort_edges(e, n);
      .           
      .              // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
      .              stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
      .           
  1,778 ( 0.00%)     STBTT_free(e, userdata);
146,362 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
      .           }
      .           
      .           static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
      .           {
224,504 ( 0.00%)     if (!points) return; // during first pass, it's unallocated
145,294 ( 0.00%)     points[n].x = x;
 55,990 ( 0.00%)     points[n].y = y;
      .           }
      .           
      .           // tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
  3,264 ( 0.00%)  static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
      .           {
      .              // midpoint
227,344 ( 0.00%)     float mx = (x0 + 2*x1 + x2)/4;
219,688 ( 0.00%)     float my = (y0 + 2*y1 + y2)/4;
      .              // versus directly drawn line
164,766 ( 0.00%)     float dx = (x0+x2)/2 - mx;
109,844 ( 0.00%)     float dy = (y0+y2)/2 - my;
    544 ( 0.00%)     if (n > 16) // 65536 segments on one curve better be enough!
      .                 return 1;
219,688 ( 0.00%)     if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
  2,584 ( 0.00%)        stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
  6,052 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__tesselate_curve(stbtt__point*, int*, float, float, float, float, float, float, float, int) [clone .isra.0] (136x)
  3,536 ( 0.00%)        stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
  6,052 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt__tesselate_curve(stbtt__point*, int*, float, float, float, float, float, float, float, int) [clone .isra.0] (136x)
      .              } else {
 54,786 ( 0.00%)        stbtt__add_point(points, *num_points,x2,y2);
109,572 ( 0.00%)        *num_points = *num_points+1;
      .              }
      .              return 1;
  1,360 ( 0.00%)  }
      .           
      .           static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
      .           {
      .              // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
      .              float dx0 = x1-x0;
      .              float dy0 = y1-y0;
      .              float dx1 = x2-x1;
      .              float dy1 = y2-y1;
-- line 3589 ----------------------------------------
-- line 3594 ----------------------------------------
      .              float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
      .              float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
      .              float flatness_squared = longlen*longlen-shortlen*shortlen;
      .           
      .              if (n > 16) // 65536 segments on one curve better be enough!
      .                 return;
      .           
      .              if (flatness_squared > objspace_flatness_squared) {
  1,778 ( 0.00%)        float x01 = (x0+x1)/2;
      .                 float y01 = (y0+y1)/2;
      .                 float x12 = (x1+x2)/2;
      .                 float y12 = (y1+y2)/2;
      .                 float x23 = (x2+x3)/2;
      .                 float y23 = (y2+y3)/2;
      .           
      .                 float xa = (x01+x12)/2;
      .                 float ya = (y01+y12)/2;
-- line 3610 ----------------------------------------
-- line 3621 ----------------------------------------
      .                 *num_points = *num_points+1;
      .              }
      .           }
      .           
      .           // returns number of contours
      .           static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
      .           {
      .              stbtt__point *points=0;
    889 ( 0.00%)     int num_points=0;
      .           
  1,778 ( 0.00%)     float objspace_flatness_squared = objspace_flatness * objspace_flatness;
    170 ( 0.00%)     int i,n=0,start=0, pass;
      .           
      .              // count how many "moves" there are to get the contour count
 48,438 ( 0.00%)     for (i=0; i < num_verts; ++i)
156,600 ( 0.00%)        if (vertices[i].type == STBTT_vmove)
    343 ( 0.00%)           ++n;
      .           
      .              *num_contours = n;
  1,778 ( 0.00%)     if (n == 0) return 0;
      .           
  6,223 ( 0.00%)     *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
 60,429 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
      .           
  1,778 ( 0.00%)     if (*contour_lengths == 0) {
      .                 *num_contours = 0;
      .                 return 0;
      .              }
      .           
      .              // make two passes through the points so we don't need to realloc
  3,556 ( 0.00%)     for (pass=0; pass < 2; ++pass) {
  3,556 ( 0.00%)        float x=0,y=0;
      .                 if (pass == 1) {
  4,445 ( 0.00%)           points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
 69,952 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (889x)
  5,334 ( 0.00%)           if (points == NULL) goto error;
      .                 }
  3,556 ( 0.00%)        num_points = 0;
  1,778 ( 0.00%)        n= -1;
336,348 ( 0.00%)        for (i=0; i < num_verts; ++i) {
601,082 ( 0.00%)           switch (vertices[i].type) {
      .                       case STBTT_vmove:
      .                          // start the next contour
 22,596 ( 0.00%)                 if (n >= 0)
 47,600 ( 0.00%)                    (*contour_lengths)[n] = num_points - start;
 11,298 ( 0.00%)                 ++n;
 11,298 ( 0.00%)                 start = num_points;
      .           
 56,490 ( 0.00%)                 x = vertices[i].x, y = vertices[i].y;
 22,596 ( 0.00%)                 stbtt__add_point(points, num_points++, x,y);
      .                          break;
      .                       case STBTT_vline:
230,840 ( 0.00%)                 x = vertices[i].x, y = vertices[i].y;
138,504 ( 0.00%)                 stbtt__add_point(points, num_points++, x, y);
      .                          break;
      .                       case STBTT_vcurve:
491,850 ( 0.00%)                 stbtt__tesselate_curve(points, &num_points, x,y,
      .                                                   vertices[i].cx, vertices[i].cy,
      .                                                   vertices[i].x,  vertices[i].y,
      .                                                   objspace_flatness_squared, 0);
163,950 ( 0.00%)                 x = vertices[i].x, y = vertices[i].y;
      .                          break;
      .                       case STBTT_vcubic:
      .                          stbtt__tesselate_cubic(points, &num_points, x,y,
      .                                                   vertices[i].cx, vertices[i].cy,
      .                                                   vertices[i].cx1, vertices[i].cy1,
      .                                                   vertices[i].x,  vertices[i].y,
      .                                                   objspace_flatness_squared, 0);
      .                          x = vertices[i].x, y = vertices[i].y;
      .                          break;
      .                    }
      .                 }
 14,224 ( 0.00%)        (*contour_lengths)[n] = num_points - start;
      .              }
      .           
      .              return points;
      .           error:
      .              STBTT_free(points, userdata);
      .              STBTT_free(*contour_lengths, userdata);
      .              *contour_lengths = 0;
      .              *num_contours = 0;
-- line 3699 ----------------------------------------
-- line 3700 ----------------------------------------
      .              return NULL;
      .           }
      .           
      .           STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
      .           {
      .              float scale            = scale_x > scale_y ? scale_y : scale_x;
      .              int winding_count      = 0;
      .              int *winding_lengths   = NULL;
  9,779 ( 0.00%)     stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
  1,778 ( 0.00%)     if (windings) {
      .                 stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
  1,778 ( 0.00%)        STBTT_free(winding_lengths, userdata);
 92,456 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
  2,667 ( 0.00%)        STBTT_free(windings, userdata);
 96,288 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (889x)
      .              }
      .           }
      .           
      .           STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
      .           {
      .              STBTT_free(bitmap, userdata);
      .           }
      .           
-- line 3720 ----------------------------------------
-- line 3765 ----------------------------------------
      .           
      .           STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
      .           {
      .              int ix0,iy0;
      .              stbtt_vertex *vertices;
      .              int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
      .              stbtt__bitmap gbm;
      .           
  9,020 ( 0.00%)     stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
 99,483 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBoxSubpixel.constprop.0 (902x)
      .              gbm.pixels = output;
      .              gbm.w = out_w;
      .              gbm.h = out_h;
      .              gbm.stride = out_stride;
      .           
  6,262 ( 0.00%)     if (gbm.w && gbm.h)
  5,360 ( 0.00%)        stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
      .           
  1,804 ( 0.00%)     STBTT_free(vertices, info->userdata);
138,285 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (902x)
      .           }
      .           
      .           STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
      .           {
      .              stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
      .           }
      .           
      .           STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
-- line 3790 ----------------------------------------
-- line 3959 ----------------------------------------
      .           //
      .           // bitmap baking
      .           //
      .           // This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
      .           // stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.
      .           
      .           STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
      .           {
      4 ( 0.00%)     stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
     69 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
      3 ( 0.00%)     int            num_nodes = pw - padding;
      3 ( 0.00%)     stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
    372 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
      .           
      4 ( 0.00%)     if (context == NULL || nodes == NULL) {
      .                 if (context != NULL) STBTT_free(context, alloc_context);
      .                 if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      .                 return 0;
      .              }
      .           
      .              spc->user_allocator_context = alloc_context;
      .              spc->width = pw;
      .              spc->height = ph;
-- line 3979 ----------------------------------------
-- line 3981 ----------------------------------------
      .              spc->pack_info = context;
      .              spc->nodes = nodes;
      .              spc->padding = padding;
      .              spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
      .              spc->h_oversample = 1;
      .              spc->v_oversample = 1;
      .              spc->skip_missing = 0;
      .           
      3 ( 0.00%)     stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
      .           
      .              if (pixels)
      .                 STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
      .           
      .              return 1;
      .           }
      .           
      .           STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
      .           {
      3 ( 0.00%)     STBTT_free(spc->nodes    , spc->user_allocator_context);
    228 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
      2 ( 0.00%)     STBTT_free(spc->pack_info, spc->user_allocator_context);
    104 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
      .           }
      .           
      .           STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
      .           {
      .              STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
      .              STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
      .              if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      .                 spc->h_oversample = h_oversample;
-- line 4008 ----------------------------------------
-- line 4015 ----------------------------------------
      .              spc->skip_missing = skip;
      .           }
      .           
      .           #define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)
      .           
      .           static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
      .           {
      .              unsigned char buffer[STBTT_MAX_OVERSAMPLE];
  2,037 ( 0.00%)     int safe_w = w - kernel_width;
      .              int j;
  1,358 ( 0.00%)     STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
 20,069 ( 0.00%)     for (j=0; j < h; ++j) {
      .                 int i;
      .                 unsigned int total;
 86,193 ( 0.00%)        STBTT_memset(buffer, 0, kernel_width);
      .           
  5,337 ( 0.00%)        total = 0;
      .           
      .                 // make kernel_width a constant in common cases so compiler can optimize out the divide
 26,685 ( 0.00%)        switch (kernel_width) {
      .                    case 2:
364,853 ( 0.00%)              for (i=0; i <= safe_w; ++i) {
554,435 ( 0.00%)                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];
237,615 ( 0.00%)                 buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
237,615 ( 0.00%)                 pixels[i] = (unsigned char) (total / 2);
      .                       }
      .                       break;
      .                    case 3:
  5,337 ( 0.00%)              for (i=0; i <= safe_w; ++i) {
      .                          total += pixels[i] - buffer[i & STBTT__OVER_MASK];
      .                          buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
      .                          pixels[i] = (unsigned char) (total / 3);
      .                       }
      .                       break;
      .                    case 4:
      .                       for (i=0; i <= safe_w; ++i) {
      .                          total += pixels[i] - buffer[i & STBTT__OVER_MASK];
      .                          buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
      .                          pixels[i] = (unsigned char) (total / 4);
      .                       }
      .                       break;
      .                    case 5:
     16 ( 0.00%)              for (i=0; i <= safe_w; ++i) {
      .                          total += pixels[i] - buffer[i & STBTT__OVER_MASK];
      .                          buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
      .                          pixels[i] = (unsigned char) (total / 5);
      .                       }
      .                       break;
      .                    default:
      .                       for (i=0; i <= safe_w; ++i) {
      .                          total += pixels[i] - buffer[i & STBTT__OVER_MASK];
      .                          buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
      .                          pixels[i] = (unsigned char) (total / kernel_width);
      .                       }
      .                       break;
      .                 }
      .           
 58,707 ( 0.00%)        for (; i < w; ++i) {
 10,674 ( 0.00%)           STBTT_assert(pixels[i] == 0);
 21,348 ( 0.00%)           total -= buffer[i & STBTT__OVER_MASK];
 21,348 ( 0.00%)           pixels[i] = (unsigned char) (total / kernel_width);
      .                 }
      .           
  8,712 ( 0.00%)        pixels += stride_in_bytes;
      .              }
    675 ( 0.00%)  }
      .           
      .           static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
      .           {
      .              unsigned char buffer[STBTT_MAX_OVERSAMPLE];
      .              int safe_h = h - kernel_width;
      .              int j;
      .              STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
      .              for (j=0; j < w; ++j) {
-- line 4088 ----------------------------------------
-- line 4138 ----------------------------------------
      .                 }
      .           
      .                 pixels += 1;
      .              }
      .           }
      .           
      .           static float stbtt__oversample_shift(int oversample)
      .           {
      8 ( 0.00%)     if (!oversample)
      4 ( 0.00%)        return 0.0f;
      .           
      .              // The prefilter is a box filter of width "oversample",
      .              // which shifts phase by (oversample - 1)/2 pixels in
      .              // oversampled space. We want to shift in the opposite
      .              // direction to counter this.
     30 ( 0.00%)     return (float)-(oversample - 1) / (2.0f * (float)oversample);
      .           }
      .           
      .           // rects array must be big enough to accommodate all characters in the given ranges
      .           STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
      .           {
      .              int i,j,k;
      .              int missing_glyph_added = 0;
      .           
-- line 4161 ----------------------------------------
-- line 4218 ----------------------------------------
      .              int i,j,k, missing_glyph = -1, return_value = 1;
      .           
      .              // save current values
      .              int old_h_over = spc->h_oversample;
      .              int old_v_over = spc->v_oversample;
      .           
      .              k = 0;
      .              for (i=0; i < num_ranges; ++i) {
      2 ( 0.00%)        float fh = ranges[i].font_size;
      6 ( 0.00%)        float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      .                 float recip_h,recip_v,sub_x,sub_y;
      4 ( 0.00%)        spc->h_oversample = ranges[i].h_oversample;
      4 ( 0.00%)        spc->v_oversample = ranges[i].v_oversample;
     14 ( 0.00%)        recip_h = 1.0f / spc->h_oversample;
     10 ( 0.00%)        recip_v = 1.0f / spc->v_oversample;
      .                 sub_x = stbtt__oversample_shift(spc->h_oversample);
      .                 sub_y = stbtt__oversample_shift(spc->v_oversample);
  7,232 ( 0.00%)        for (j=0; j < ranges[i].num_chars; ++j) {
      .                    stbrp_rect *r = &rects[k];
  9,020 ( 0.00%)           if (r->was_packed && r->w != 0 && r->h != 0) {
  4,510 ( 0.00%)              stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
      .                       int advance, lsb, x0,y0,x1,y1;
  4,510 ( 0.00%)              int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
 11,726 ( 0.00%)              int glyph = stbtt_FindGlyphIndex(info, codepoint);
162,713 ( 0.00%)  => build/_deps/imgui-src/imstb_truetype.h:stbtt_FindGlyphIndex.isra.0 (902x)
      .                       stbrp_coord pad = (stbrp_coord) spc->padding;
      .           
      .                       // pad on left and top
      .                       r->x += pad;
  2,706 ( 0.00%)              r->y += pad;
  4,510 ( 0.00%)              r->w -= pad;
      .                       r->h -= pad;
      .                       stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
  4,510 ( 0.00%)              stbtt_GetGlyphBitmapBox(info, glyph,
      .                                               scale * spc->h_oversample,
      .                                               scale * spc->v_oversample,
      .                                               &x0,&y0,&x1,&y1);
      .                       stbtt_MakeGlyphBitmapSubpixel(info,
  8,001 ( 0.00%)                                            spc->pixels + r->x + r->y*spc->stride_in_bytes,
  3,608 ( 0.00%)                                            r->w - spc->h_oversample+1,
  2,714 ( 0.00%)                                            r->h - spc->v_oversample+1,
      .                                                     spc->stride_in_bytes,
      .                                                     scale * spc->h_oversample,
      .                                                     scale * spc->v_oversample,
      .                                                     0,0,
      .                                                     glyph);
      .           
  1,804 ( 0.00%)              if (spc->h_oversample > 1)
  9,040 ( 0.00%)                 stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
      .                                             r->w, r->h, spc->stride_in_bytes,
      .                                             spc->h_oversample);
      .           
  1,804 ( 0.00%)              if (spc->v_oversample > 1)
  2,700 ( 0.00%)                 stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
      .                                             r->w, r->h, spc->stride_in_bytes,
      .                                             spc->v_oversample);
      .           
 12,628 ( 0.00%)              bc->x0       = (stbtt_int16)  r->x;
      .                       bc->y0       = (stbtt_int16)  r->y;
    902 ( 0.00%)              bc->x1       = (stbtt_int16) (r->x + r->w);
    902 ( 0.00%)              bc->y1       = (stbtt_int16) (r->y + r->h);
  3,608 ( 0.00%)              bc->xadvance =                scale * advance;
  8,118 ( 0.00%)              bc->xoff     =       (float)  x0 * recip_h + sub_x;
  4,510 ( 0.00%)              bc->yoff     =       (float)  y0 * recip_v + sub_y;
  2,706 ( 0.00%)              bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
  3,608 ( 0.00%)              bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
      .           
      .                       if (glyph == 0)
  4,510 ( 0.00%)                 missing_glyph = j;
    902 ( 0.00%)           } else if (spc->skip_missing) {
      .                       return_value = 0;
      .                    } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
      .                       ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
      .                    } else {
      .                       return_value = 0; // if any fail, report failure
      .                    }
      .           
      .                    ++k;
-- line 4294 ----------------------------------------
-- line 4365 ----------------------------------------
      .              stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
      .              *ascent  = (float) i_ascent  * scale;
      .              *descent = (float) i_descent * scale;
      .              *lineGap = (float) i_lineGap * scale;
      .           }
      .           
      .           STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
      .           {
  6,314 ( 0.00%)     float ipw = 1.0f / pw, iph = 1.0f / ph;
      .              const stbtt_packedchar *b = chardata + char_index;
      .           
      .              if (align_to_integer) {
      .                 float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      .                 float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      .                 q->x0 = x;
      .                 q->y0 = y;
      .                 q->x1 = x + b->xoff2 - b->xoff;
      .                 q->y1 = y + b->yoff2 - b->yoff;
      .              } else {
    902 ( 0.00%)        q->x0 = *xpos + b->xoff;
    902 ( 0.00%)        q->y0 = *ypos + b->yoff;
    902 ( 0.00%)        q->x1 = *xpos + b->xoff2;
    902 ( 0.00%)        q->y1 = *ypos + b->yoff2;
      .              }
      .           
  1,804 ( 0.00%)     q->s0 = b->x0 * ipw;
  1,804 ( 0.00%)     q->t0 = b->y0 * iph;
  1,804 ( 0.00%)     q->s1 = b->x1 * ipw;
  1,804 ( 0.00%)     q->t1 = b->y1 * iph;
      .           
      .              *xpos += b->xadvance;
      .           }
      .           
      .           //////////////////////////////////////////////////////////////////////////////
      .           //
      .           // sdf computation
      .           //
-- line 4401 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_opengl.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 87 ----------------------------------------
        .           static int8_t last_depth_test;
        .           static int8_t last_depth_mask;
        .           static int8_t last_zmode_decal;
        .           
        .           GLint max_msaa_level = 1;
        .           GLuint pixel_depth_rb, pixel_depth_fb;
        .           size_t pixel_depth_rb_size;
        .           
        1 ( 0.00%)  static int gfx_opengl_get_max_texture_size() {
        .               GLint max_texture_size;
        4 ( 0.00%)      glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max_texture_size);
      137 ( 0.00%)  => ???:0x0000000004a815c0 (1x)
        .               return max_texture_size;
        3 ( 0.00%)  }
        .           
        .           static const char* gfx_opengl_get_name() {
        .               return "OpenGL";
        2 ( 0.00%)  }
        .           
        .           static struct GfxClipParameters gfx_opengl_get_clip_parameters(void) {
5,940,665 ( 0.01%)      return { false, framebuffers[current_framebuffer].invert_y };
2,376,266 ( 0.00%)  }
        .           
        .           static void gfx_opengl_vertex_array_set_attribs(struct ShaderProgram* prg) {
   27,675 ( 0.00%)      size_t num_floats = prg->num_floats;
   55,350 ( 0.00%)      size_t pos = 0;
        .           
  375,462 ( 0.00%)      for (int i = 0; i < prg->num_attribs; i++) {
  240,088 ( 0.00%)          glEnableVertexAttribArray(prg->attrib_locations[i]);
7,046,932 ( 0.01%)  => ???:0x0000000004a80a40 (80,028x)
      945 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  695,578 ( 0.00%)          glVertexAttribPointer(prg->attrib_locations[i], prg->attrib_sizes[i], GL_FLOAT, GL_FALSE,
19,377,299 ( 0.03%)  => ???:0x0000000004a86ec0 (80,028x)
      940 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .                                         num_floats * sizeof(float), (void*)(pos * sizeof(float)));
  160,056 ( 0.00%)          pos += prg->attrib_sizes[i];
        .               }
        .           }
        .           
        .           static void gfx_opengl_set_uniforms(struct ShaderProgram* prg) {
  110,704 ( 0.00%)      glUniform1i(prg->frame_count_location, frame_count);
1,107,000 ( 0.00%)  => ???:0x0000000004a85a20 (27,675x)
      868 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  110,704 ( 0.00%)      glUniform1f(prg->noise_scale_location, current_noise_scale);
1,107,000 ( 0.00%)  => ???:0x0000000004a859e0 (27,675x)
      822 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           }
        .           
  110,696 ( 0.00%)  static void gfx_opengl_unload_shader(struct ShaderProgram* old_prg) {
   55,350 ( 0.00%)      if (old_prg != NULL) {
  430,796 ( 0.00%)          for (int i = 0; i < old_prg->num_attribs; i++) {
  240,079 ( 0.00%)              glDisableVertexAttribArray(old_prg->attrib_locations[i]);
5,927,110 ( 0.01%)  => ???:0x0000000004a80680 (80,025x)
      969 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .                   }
        .               }
  110,697 ( 0.00%)  }
        .           
  166,050 ( 0.00%)  static void gfx_opengl_load_shader(struct ShaderProgram* new_prg) {
        .               // if (!new_prg) return;
   83,029 ( 0.00%)      glUseProgram(new_prg->opengl_program_id);
94,513,834 ( 0.16%)  => ???:0x0000000004a86060 (27,675x)
      826 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .               gfx_opengl_vertex_array_set_attribs(new_prg);
        .               gfx_opengl_set_uniforms(new_prg);
  138,375 ( 0.00%)  }
        .           
        .           static void append_str(char* buf, size_t* len, const char* str) {
    8,334 ( 0.00%)      while (*str != '\0') {
    4,656 ( 0.00%)          buf[(*len)++] = *str++;
        .               }
        .           }
        .           
        .           static void append_line(char* buf, size_t* len, const char* str) {
   59,383 ( 0.00%)      while (*str != '\0') {
   56,824 ( 0.00%)          buf[(*len)++] = *str++;
        .               }
    1,472 ( 0.00%)      buf[(*len)++] = '\n';
        1 ( 0.00%)  }
        .           
        .           #define RAND_NOISE "((random(vec3(floor(gl_FragCoord.xy * noise_scale), float(frame_count))) + 1.0) / 2.0)"
        .           
        .           static const char* shader_item_to_str(uint32_t item, bool with_alpha, bool only_alpha, bool inputs_have_alpha,
        .                                                 bool first_cycle, bool hint_single_element) {
       90 ( 0.00%)      if (!only_alpha) {
      136 ( 0.00%)          switch (item) {
        .                       case SHADER_0:
        .                           return with_alpha ? "vec4(0.0, 0.0, 0.0, 0.0)" : "vec3(0.0, 0.0, 0.0)";
        .                       case SHADER_1:
        5 ( 0.00%)                  return with_alpha ? "vec4(1.0, 1.0, 1.0, 1.0)" : "vec3(1.0, 1.0, 1.0)";
        .                       case SHADER_INPUT_1:
       76 ( 0.00%)                  return with_alpha || !inputs_have_alpha ? "vInput1" : "vInput1.rgb";
        .                       case SHADER_INPUT_2:
       14 ( 0.00%)                  return with_alpha || !inputs_have_alpha ? "vInput2" : "vInput2.rgb";
        .                       case SHADER_INPUT_3:
        .                           return with_alpha || !inputs_have_alpha ? "vInput3" : "vInput3.rgb";
        .                       case SHADER_INPUT_4:
        .                           return with_alpha || !inputs_have_alpha ? "vInput4" : "vInput4.rgb";
        .                       case SHADER_TEXEL0:
       91 ( 0.00%)                  return first_cycle ? (with_alpha ? "texVal0" : "texVal0.rgb")
        .                                              : (with_alpha ? "texVal1" : "texVal1.rgb");
        .                       case SHADER_TEXEL0A:
        .                           return first_cycle
        4 ( 0.00%)                             ? (hint_single_element ? "texVal0.a"
        .                                                             : (with_alpha ? "vec4(texVal0.a, texVal0.a, texVal0.a, texVal0.a)"
        .                                                                           : "vec3(texVal0.a, texVal0.a, texVal0.a)"))
        .                                      : (hint_single_element ? "texVal1.a"
        .                                                             : (with_alpha ? "vec4(texVal1.a, texVal1.a, texVal1.a, texVal1.a)"
        .                                                                           : "vec3(texVal1.a, texVal1.a, texVal1.a)"));
        .                       case SHADER_TEXEL1A:
        .                           return first_cycle
        .                                      ? (hint_single_element ? "texVal1.a"
-- line 185 ----------------------------------------
-- line 187 ----------------------------------------
        .                                                                           : "vec3(texVal1.a, texVal1.a, texVal1.a)"))
        .                                      : (hint_single_element ? "texVal0.a"
        .                                                             : (with_alpha ? "vec4(texVal0.a, texVal0.a, texVal0.a, texVal0.a)"
        .                                                                           : "vec3(texVal0.a, texVal0.a, texVal0.a)"));
        .                       case SHADER_TEXEL1:
        .                           return first_cycle ? (with_alpha ? "texVal1" : "texVal1.rgb")
        .                                              : (with_alpha ? "texVal0" : "texVal0.rgb");
        .                       case SHADER_COMBINED:
        5 ( 0.00%)                  return with_alpha ? "texel" : "texel.rgb";
        .                       case SHADER_NOISE:
        .                           return with_alpha ? "vec4(" RAND_NOISE ", " RAND_NOISE ", " RAND_NOISE ", " RAND_NOISE ")"
        .                                             : "vec3(" RAND_NOISE ", " RAND_NOISE ", " RAND_NOISE ")";
        .                   }
        .               } else {
       44 ( 0.00%)          switch (item) {
        .                       case SHADER_0:
        .                           return "0.0";
        .                       case SHADER_1:
        .                           return "1.0";
        .                       case SHADER_INPUT_1:
        8 ( 0.00%)                  return "vInput1.a";
        .                       case SHADER_INPUT_2:
        .                           return "vInput2.a";
        .                       case SHADER_INPUT_3:
        .                           return "vInput3.a";
        .                       case SHADER_INPUT_4:
        .                           return "vInput4.a";
        .                       case SHADER_TEXEL0:
       35 ( 0.00%)                  return first_cycle ? "texVal0.a" : "texVal1.a";
        .                       case SHADER_TEXEL0A:
        .                           return first_cycle ? "texVal0.a" : "texVal1.a";
        .                       case SHADER_TEXEL1A:
        1 ( 0.00%)                  return first_cycle ? "texVal1.a" : "texVal0.a";
        .                       case SHADER_TEXEL1:
        .                           return first_cycle ? "texVal1.a" : "texVal0.a";
        .                       case SHADER_COMBINED:
        .                           return "texel.a";
        .                       case SHADER_NOISE:
        .                           return RAND_NOISE;
        .                   }
        .               }
        .               return "";
       10 ( 0.00%)  }
        .           
        .           #undef RAND_NOISE
        .           
      112 ( 0.00%)  static void append_formula(char* buf, size_t* len, uint8_t c[2][4], bool do_single, bool do_multiply, bool do_mix,
        .                                      bool with_alpha, bool only_alpha, bool opt_alpha, bool first_cycle) {
       68 ( 0.00%)      if (do_single) {
       97 ( 0.00%)          append_str(buf, len,
      155 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (13x)
        .                              shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, first_cycle, false));
       28 ( 0.00%)      } else if (do_multiply) {
      100 ( 0.00%)          append_str(buf, len,
      129 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (11x)
       28 ( 0.00%)                     shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .                   append_str(buf, len, " * ");
       44 ( 0.00%)          append_str(buf, len,
      115 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (11x)
        .                              shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, first_cycle, true));
        6 ( 0.00%)      } else if (do_mix) {
        .                   append_str(buf, len, "mix(");
        8 ( 0.00%)          append_str(buf, len,
       22 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (2x)
        .                              shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .                   append_str(buf, len, ", ");
        8 ( 0.00%)          append_str(buf, len,
       25 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (2x)
        .                              shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .                   append_str(buf, len, ", ");
        8 ( 0.00%)          append_str(buf, len,
       25 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (2x)
        .                              shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, first_cycle, true));
        .                   append_str(buf, len, ")");
        .               } else {
        .                   append_str(buf, len, "(");
        4 ( 0.00%)          append_str(buf, len,
       11 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        .                              shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .                   append_str(buf, len, " - ");
        4 ( 0.00%)          append_str(buf, len,
       12 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        .                              shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .                   append_str(buf, len, ") * ");
        4 ( 0.00%)          append_str(buf, len,
       13 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        .                              shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, first_cycle, true));
        .                   append_str(buf, len, " + ");
        4 ( 0.00%)          append_str(buf, len,
       12 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:shader_item_to_str(unsigned int, bool, bool, bool, bool, bool) (1x)
        .                              shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, first_cycle, false));
        .               }
       42 ( 0.00%)  }
        .           
      323 ( 0.00%)  static struct ShaderProgram* gfx_opengl_create_and_load_new_shader(uint64_t shader_id0, uint32_t shader_id1) {
        .               struct CCFeatures cc_features;
       38 ( 0.00%)      gfx_cc_get_features(shader_id0, shader_id1, &cc_features);
    7,002 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_cc.cpp:gfx_cc_get_features(unsigned long, unsigned int, CCFeatures*) (19x)
        .           
        .               char vs_buf[1024];
        .               char fs_buf[6000];
       19 ( 0.00%)      size_t vs_len = 0;
       19 ( 0.00%)      size_t fs_len = 0;
       19 ( 0.00%)      size_t num_floats = 4;
        .           
        .               // Vertex shader
        .           #if defined(__APPLE__)
        .               append_line(vs_buf, &vs_len, "#version 410 core");
        .               append_line(vs_buf, &vs_len, "in vec4 aVtxPos;");
        .           #elif defined(USE_OPENGLES)
        .               append_line(vs_buf, &vs_len, "#version 300 es");
        .               append_line(vs_buf, &vs_len, "in vec4 aVtxPos;");
        .           #else
        .               append_line(vs_buf, &vs_len, "#version 110");
        .               append_line(vs_buf, &vs_len, "attribute vec4 aVtxPos;");
        .           #endif
        .               for (int i = 0; i < 2; i++) {
       76 ( 0.00%)          if (cc_features.used_textures[i]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                       vs_len += sprintf(vs_buf + vs_len, "in vec2 aTexCoord%d;\n", i);
        .                       vs_len += sprintf(vs_buf + vs_len, "out vec2 vTexCoord%d;\n", i);
        .           #else
      119 ( 0.00%)              vs_len += sprintf(vs_buf + vs_len, "attribute vec2 aTexCoord%d;\n", i);
    8,812 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
      119 ( 0.00%)              vs_len += sprintf(vs_buf + vs_len, "varying vec2 vTexCoord%d;\n", i);
    8,812 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .           #endif
       29 ( 0.00%)              num_floats += 2;
        .                       for (int j = 0; j < 2; j++) {
       68 ( 0.00%)                  if (cc_features.clamp[i][j]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                               vs_len += sprintf(vs_buf + vs_len, "in float aTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
        .                               vs_len += sprintf(vs_buf + vs_len, "out float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
        .           #else
       48 ( 0.00%)                      vs_len += sprintf(vs_buf + vs_len, "attribute float aTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
    4,236 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
       48 ( 0.00%)                      vs_len += sprintf(vs_buf + vs_len, "varying float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
    4,236 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
        .           #endif
        9 ( 0.00%)                      num_floats += 1;
        .                           }
        .                       }
        .                   }
        .               }
       40 ( 0.00%)      if (cc_features.opt_fog) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(vs_buf, &vs_len, "in vec4 aFog;");
        .                   append_line(vs_buf, &vs_len, "out vec4 vFog;");
        .           #else
        .                   append_line(vs_buf, &vs_len, "attribute vec4 aFog;");
        .                   append_line(vs_buf, &vs_len, "varying vec4 vFog;");
        .           #endif
        1 ( 0.00%)          num_floats += 4;
        .               }
        .           
       38 ( 0.00%)      if (cc_features.opt_grayscale) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(vs_buf, &vs_len, "in vec4 aGrayscaleColor;");
        .                   append_line(vs_buf, &vs_len, "out vec4 vGrayscaleColor;");
        .           #else
        .                   append_line(vs_buf, &vs_len, "attribute vec4 aGrayscaleColor;");
        .                   append_line(vs_buf, &vs_len, "varying vec4 vGrayscaleColor;");
        .           #endif
        .                   num_floats += 4;
        .               }
        .           
      108 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   vs_len += sprintf(vs_buf + vs_len, "in vec%d aInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
        .                   vs_len += sprintf(vs_buf + vs_len, "out vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
        .           #else
      310 ( 0.00%)          vs_len += sprintf(vs_buf + vs_len, "attribute vec%d aInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
   15,066 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (18x)
      198 ( 0.00%)          vs_len += sprintf(vs_buf + vs_len, "varying vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
   15,066 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (18x)
        .           #endif
       54 ( 0.00%)          num_floats += cc_features.opt_alpha ? 4 : 3;
        .               }
        .               append_line(vs_buf, &vs_len, "void main() {");
        .               for (int i = 0; i < 2; i++) {
       76 ( 0.00%)          if (cc_features.used_textures[i]) {
      153 ( 0.00%)              vs_len += sprintf(vs_buf + vs_len, "vTexCoord%d = aTexCoord%d;\n", i, i);
   14,003 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .                       for (int j = 0; j < 2; j++) {
       69 ( 0.00%)                  if (cc_features.clamp[i][j]) {
       69 ( 0.00%)                      vs_len += sprintf(vs_buf + vs_len, "vTexClamp%s%d = aTexClamp%s%d;\n", j == 0 ? "S" : "T", i,
    7,194 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
        .                                                 j == 0 ? "S" : "T", i);
        .                           }
        .                       }
        .                   }
        .               }
       40 ( 0.00%)      if (cc_features.opt_fog) {
        .                   append_line(vs_buf, &vs_len, "vFog = aFog;");
        .               }
       38 ( 0.00%)      if (cc_features.opt_grayscale) {
        .                   append_line(vs_buf, &vs_len, "vGrayscaleColor = aGrayscaleColor;");
        .               }
      127 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
      198 ( 0.00%)          vs_len += sprintf(vs_buf + vs_len, "vInput%d = aInput%d;\n", i + 1, i + 1);
   15,066 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (18x)
        .               }
        .               append_line(vs_buf, &vs_len, "gl_Position = aVtxPos;");
        .           #if defined(USE_OPENGLES) // workaround for no GL_DEPTH_CLAMP
        .               append_line(vs_buf, &vs_len, "gl_Position.z *= 0.3f;");
        .           #endif
        .               append_line(vs_buf, &vs_len, "}");
        .           
        .               // Fragment shader
-- line 375 ----------------------------------------
-- line 377 ----------------------------------------
        .               append_line(fs_buf, &fs_len, "#version 410 core");
        .           #elif defined(USE_OPENGLES)
        .               append_line(fs_buf, &fs_len, "#version 300 es");
        .               append_line(fs_buf, &fs_len, "precision mediump float;");
        .           #else
        .               append_line(fs_buf, &fs_len, "#version 130");
        .           #endif
        .               for (int i = 0; i < 2; i++) {
       76 ( 0.00%)          if (cc_features.used_textures[i]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                       fs_len += sprintf(fs_buf + fs_len, "in vec2 vTexCoord%d;\n", i);
        .           #else
      153 ( 0.00%)              fs_len += sprintf(fs_buf + fs_len, "varying vec2 vTexCoord%d;\n", i);
    8,812 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .           #endif
        .                       for (int j = 0; j < 2; j++) {
       69 ( 0.00%)                  if (cc_features.clamp[i][j]) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                               fs_len += sprintf(fs_buf + fs_len, "in float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
        .           #else
       63 ( 0.00%)                      fs_len += sprintf(fs_buf + fs_len, "varying float vTexClamp%s%d;\n", j == 0 ? "S" : "T", i);
    4,236 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
        .           #endif
        .                           }
        .                       }
        .                   }
        .               }
       38 ( 0.00%)      if (cc_features.opt_fog) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "in vec4 vFog;");
        .           #else
        .                   append_line(fs_buf, &fs_len, "varying vec4 vFog;");
        .           #endif
        .               }
       38 ( 0.00%)      if (cc_features.opt_grayscale) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "in vec4 vGrayscaleColor;");
        .           #else
        .                   append_line(fs_buf, &fs_len, "varying vec4 vGrayscaleColor;");
        .           #endif
        .               }
      127 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   fs_len += sprintf(fs_buf + fs_len, "in vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
        .           #else
      234 ( 0.00%)          fs_len += sprintf(fs_buf + fs_len, "varying vec%d vInput%d;\n", cc_features.opt_alpha ? 4 : 3, i + 1);
   15,066 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (18x)
        .           #endif
        .               }
       89 ( 0.00%)      if (cc_features.used_textures[0]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTex0;");
        .               }
       40 ( 0.00%)      if (cc_features.used_textures[1]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTex1;");
        .               }
       38 ( 0.00%)      if (cc_features.used_masks[0]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexMask0;");
        .               }
       38 ( 0.00%)      if (cc_features.used_masks[1]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexMask1;");
        .               }
       38 ( 0.00%)      if (cc_features.used_blend[0]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexBlend0;");
        .               }
       38 ( 0.00%)      if (cc_features.used_blend[1]) {
        .                   append_line(fs_buf, &fs_len, "uniform sampler2D uTexBlend1;");
        .               }
        .           
        .               append_line(fs_buf, &fs_len, "uniform int frame_count;");
        .               append_line(fs_buf, &fs_len, "uniform float noise_scale;");
        .           
        .               append_line(fs_buf, &fs_len, "float random(in vec3 value) {");
        .               append_line(fs_buf, &fs_len, "    float random = dot(sin(value), vec3(12.9898, 78.233, 37.719));");
        .               append_line(fs_buf, &fs_len, "    return fract(sin(random) * 143758.5453);");
        .               append_line(fs_buf, &fs_len, "}");
        .           
       76 ( 0.00%)      if (current_filter_mode == FILTER_THREE_POINT) {
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "#define TEX_OFFSET(off) texture(tex, texCoord - (off)/texSize)");
        .           #else
        .                   append_line(fs_buf, &fs_len, "#define TEX_OFFSET(off) texture2D(tex, texCoord - (off)/texSize)");
        .           #endif
        .                   append_line(fs_buf, &fs_len, "vec4 filter3point(in sampler2D tex, in vec2 texCoord, in vec2 texSize) {");
        .                   append_line(fs_buf, &fs_len, "    vec2 offset = fract(texCoord*texSize - vec2(0.5));");
        .                   append_line(fs_buf, &fs_len, "    offset -= step(1.0, offset.x + offset.y);");
-- line 458 ----------------------------------------
-- line 480 ----------------------------------------
        .           
        .               append_line(fs_buf, &fs_len, "void main() {");
        .           
        .               // Reference approach to color wrapping as per GLideN64
        .               // Return wrapped value of x in interval [low, high)
        .               append_line(fs_buf, &fs_len, "#define WRAP(x, low, high) mod((x)-(low), (high)-(low)) + (low)");
        .           
        .               for (int i = 0; i < 2; i++) {
       76 ( 0.00%)          if (cc_features.used_textures[i]) {
       67 ( 0.00%)              bool s = cc_features.clamp[i][0], t = cc_features.clamp[i][1];
        .           
        .           #if defined(USE_OPENGLES)
        .                       fs_len += sprintf(fs_buf + fs_len, "vec2 texSize%d = vec2(textureSize(uTex%d, 0));\n", i, i);
        .           #else
      170 ( 0.00%)              fs_len += sprintf(fs_buf + fs_len, "vec2 texSize%d = textureSize(uTex%d, 0);\n", i, i);
   13,918 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .           #endif
        .           
       95 ( 0.00%)              if (!s && !t) {
      190 ( 0.00%)                  fs_len += sprintf(fs_buf + fs_len, "vec2 vTexCoordAdj%d = vTexCoord%d;\n", i, i);
   11,506 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (14x)
      912 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_formula(char*, unsigned long*, unsigned char (*) [4], bool, bool, bool, bool, bool, bool, bool) [clone .part.0] (4x)
        .                       } else {
        6 ( 0.00%)                  if (s && t) {
       42 ( 0.00%)                      fs_len += sprintf(fs_buf + fs_len,
    5,169 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (3x)
        .                                                 "vec2 vTexCoordAdj%d = clamp(vTexCoord%d, 0.5 / texSize%d, "
        .                                                 "vec2(vTexClampS%d, vTexClampT%d));\n",
        .                                                 i, i, i, i, i);
        .                           } else if (s) {
        .                               fs_len += sprintf(fs_buf + fs_len,
        .                                                 "vec2 vTexCoordAdj%d = vec2(clamp(vTexCoord%d.s, 0.5 / "
        .                                                 "texSize%d.s, vTexClampS%d), vTexCoord%d.t);\n",
        .                                                 i, i, i, i, i);
-- line 509 ----------------------------------------
-- line 510 ----------------------------------------
        .                           } else {
        .                               fs_len += sprintf(fs_buf + fs_len,
        .                                                 "vec2 vTexCoordAdj%d = vec2(vTexCoord%d.s, clamp(vTexCoord%d.t, "
        .                                                 "0.5 / texSize%d.t, vTexClampT%d));\n",
        .                                                 i, i, i, i, i);
        .                           }
        .                       }
        .           
      204 ( 0.00%)              fs_len += sprintf(fs_buf + fs_len, "vec4 texVal%d = hookTexture2D(uTex%d, vTexCoordAdj%d, texSize%d);\n", i,
   24,283 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
        .                                         i, i, i);
       34 ( 0.00%)              if (cc_features.used_masks[i]) {
        .           #ifdef USE_OPENGLES
        .                           fs_len += sprintf(fs_buf + fs_len, "vec2 maskSize%d = vec2(textureSize(uTexMask%d, 0));\n", i, i);
        .           #else
        .                           fs_len += sprintf(fs_buf + fs_len, "vec2 maskSize%d = textureSize(uTexMask%d, 0);\n", i, i);
        .           #endif
        .                           fs_len +=
        .                               sprintf(fs_buf + fs_len,
        .                                       "vec4 maskVal%d = hookTexture2D(uTexMask%d, vTexCoordAdj%d, maskSize%d);\n", i, i, i, i);
-- line 528 ----------------------------------------
-- line 534 ----------------------------------------
        .                               fs_len += sprintf(fs_buf + fs_len, "vec4 blendVal%d = vec4(0, 0, 0, 0);\n", i);
        .                           }
        .           
        .                           fs_len += sprintf(fs_buf + fs_len, "texVal%d = mix(texVal%d, blendVal%d, maskVal%d.a);\n", i, i, i, i);
        .                       }
        .                   }
        .               }
        .           
      114 ( 0.00%)      append_line(fs_buf, &fs_len, cc_features.opt_alpha ? "vec4 texel;" : "vec3 texel;");
      120 ( 0.00%)      for (int c = 0; c < (cc_features.opt_2cyc ? 2 : 1); c++) {
        5 ( 0.00%)          if (c == 1) {
        3 ( 0.00%)              if (cc_features.opt_alpha) {
        .                           if (cc_features.c[c][1][2] == SHADER_COMBINED) {
        .                               append_line(fs_buf, &fs_len, "texel.a = WRAP(texel.a, -1.01, 1.01);");
        .                           } else {
        .                               append_line(fs_buf, &fs_len, "texel.a = WRAP(texel.a, -0.51, 1.51);");
        .                           }
        .                       }
        .           
        7 ( 0.00%)              if (cc_features.c[c][0][2] == SHADER_COMBINED) {
        .                           append_line(fs_buf, &fs_len, "texel.rgb = WRAP(texel.rgb, -1.01, 1.01);");
        .                       } else {
        .                           append_line(fs_buf, &fs_len, "texel.rgb = WRAP(texel.rgb, -0.51, 1.51);");
        .                       }
        .                   }
        .           
        .                   append_str(fs_buf, &fs_len, "texel = ");
       66 ( 0.00%)          if (!cc_features.color_alpha_same[c] && cc_features.opt_alpha) {
        .                       append_str(fs_buf, &fs_len, "vec4(");
        .                       append_formula(fs_buf, &fs_len, cc_features.c[c], cc_features.do_single[c][0],
        .                                      cc_features.do_multiply[c][0], cc_features.do_mix[c][0], false, false, true, c == 0);
        .                       append_str(fs_buf, &fs_len, ", ");
        .                       append_formula(fs_buf, &fs_len, cc_features.c[c], cc_features.do_single[c][1],
        .                                      cc_features.do_multiply[c][1], cc_features.do_mix[c][1], true, true, true, c == 0);
        .                       append_str(fs_buf, &fs_len, ")");
        .                   } else {
       20 ( 0.00%)              append_formula(fs_buf, &fs_len, cc_features.c[c], cc_features.do_single[c][0],
       40 ( 0.00%)                             cc_features.do_multiply[c][0], cc_features.do_mix[c][0], cc_features.opt_alpha, false,
        .                                      cc_features.opt_alpha, c == 0);
        .                   }
        .                   append_line(fs_buf, &fs_len, ";");
        .               }
        .           
        .               append_str(fs_buf, &fs_len, "texel = WRAP(texel, -0.51, 1.51);");
        .               append_str(fs_buf, &fs_len, "texel = clamp(texel, 0.0, 1.0);");
        .               // TODO discard if alpha is 0?
       57 ( 0.00%)      if (cc_features.opt_fog) {
        3 ( 0.00%)          if (cc_features.opt_alpha) {
        .                       append_line(fs_buf, &fs_len, "texel = vec4(mix(texel.rgb, vFog.rgb, vFog.a), texel.a);");
        .                   } else {
        .                       append_line(fs_buf, &fs_len, "texel = mix(texel, vFog.rgb, vFog.a);");
        .                   }
        .               }
        .           
       44 ( 0.00%)      if (cc_features.opt_texture_edge && cc_features.opt_alpha) {
        .                   append_line(fs_buf, &fs_len, "if (texel.a > 0.19) texel.a = 1.0; else discard;");
        .               }
        .           
       60 ( 0.00%)      if (cc_features.opt_alpha && cc_features.opt_noise) {
        .                   append_line(fs_buf, &fs_len,
        .                               "texel.a *= floor(clamp(random(vec3(floor(gl_FragCoord.xy * noise_scale), float(frame_count))) + "
        .                               "texel.a, 0.0, 1.0));");
        .               }
        .           
      168 ( 0.00%)      if (cc_features.opt_grayscale) {
    3,031 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:append_formula(char*, unsigned long*, unsigned char (*) [4], bool, bool, bool, bool, bool, bool, bool) [clone .part.0] (10x)
        .                   append_line(fs_buf, &fs_len, "float intensity = (texel.r + texel.g + texel.b) / 3.0;");
        .                   append_line(fs_buf, &fs_len, "vec3 new_texel = vGrayscaleColor.rgb * intensity;");
        .                   append_line(fs_buf, &fs_len, "texel.rgb = mix(texel.rgb, new_texel, vGrayscaleColor.a);");
        .               }
        .           
        .               if (cc_features.opt_alpha) {
       28 ( 0.00%)          if (cc_features.opt_alpha_threshold) {
        .                       append_line(fs_buf, &fs_len, "if (texel.a < 8.0 / 256.0) discard;");
        .                   }
       26 ( 0.00%)          if (cc_features.opt_invisible) {
        .                       append_line(fs_buf, &fs_len, "texel.a = 0.0;");
        .                   }
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "outColor = texel;");
        .           #else
        .                   append_line(fs_buf, &fs_len, "gl_FragColor = texel;");
        .           #endif
        .               } else {
-- line 616 ----------------------------------------
-- line 617 ----------------------------------------
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .                   append_line(fs_buf, &fs_len, "outColor = vec4(texel, 1.0);");
        .           #else
        .                   append_line(fs_buf, &fs_len, "gl_FragColor = vec4(texel, 1.0);");
        .           #endif
        .               }
        .               append_line(fs_buf, &fs_len, "}");
        .           
       38 ( 0.00%)      vs_buf[vs_len] = '\0';
       19 ( 0.00%)      fs_buf[fs_len] = '\0';
        .           
        .               /*puts("Vertex shader:");
        .               puts(vs_buf);
        .               puts("Fragment shader:");
        .               puts(fs_buf);
        .               puts("End");*/
        .           
       38 ( 0.00%)      const GLchar* sources[2] = { vs_buf, fs_buf };
       57 ( 0.00%)      const GLint lengths[2] = { (GLint)vs_len, (GLint)fs_len };
        .               GLint success;
        .           
       80 ( 0.00%)      GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
   32,209 ( 0.00%)  => ???:0x0000000004a80280 (19x)
      894 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      118 ( 0.00%)      glShaderSource(vertex_shader, 1, &sources[0], &lengths[0]);
   34,156 ( 0.00%)  => ???:0x0000000004a84cc0 (19x)
      886 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       61 ( 0.00%)      glCompileShader(vertex_shader);
  132,001 ( 0.00%)  => ???:0x0000000004a7fee0 (19x)
      894 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      118 ( 0.00%)      glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);
      842 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    2,090 ( 0.00%)  => ???:0x0000000004a81ca0 (19x)
       57 ( 0.00%)      if (!success) {
        .                   GLint max_length = 0;
        .                   glGetShaderiv(vertex_shader, GL_INFO_LOG_LENGTH, &max_length);
        .                   char error_log[1024];
        .                   // fprintf(stderr, "Vertex shader compilation failed\n");
        .                   glGetShaderInfoLog(vertex_shader, max_length, &max_length, &error_log[0]);
        .                   // fprintf(stderr, "%s\n", &error_log[0]);
        .                   abort();
        .               }
        .           
       76 ( 0.00%)      GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
   32,709 ( 0.00%)  => ???:0x0000000004a80280 (19x)
      114 ( 0.00%)      glShaderSource(fragment_shader, 1, &sources[1], &lengths[1]);
  136,170 ( 0.00%)  => ???:0x0000000004a84cc0 (19x)
       57 ( 0.00%)      glCompileShader(fragment_shader);
  254,355 ( 0.00%)  => ???:0x0000000004a7fee0 (19x)
       95 ( 0.00%)      glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);
    2,090 ( 0.00%)  => ???:0x0000000004a81ca0 (19x)
       57 ( 0.00%)      if (!success) {
        .                   GLint max_length = 0;
        .                   glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &max_length);
        .                   char error_log[1024];
        .                   fprintf(stderr, "Fragment shader compilation failed\n");
        .                   glGetShaderInfoLog(fragment_shader, max_length, &max_length, &error_log[0]);
        .                   fprintf(stderr, "%s\n", &error_log[0]);
        .                   abort();
        .               }
        .           
       80 ( 0.00%)      GLuint shader_program = glCreateProgram();
  186,047 ( 0.00%)  => ???:0x0000000004a801e0 (19x)
      854 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       80 ( 0.00%)      glAttachShader(shader_program, vertex_shader);
    3,430 ( 0.00%)  => ???:0x0000000004a7f0c0 (19x)
      936 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       76 ( 0.00%)      glAttachShader(shader_program, fragment_shader);
    8,288 ( 0.00%)  => ???:0x0000000004a7f0c0 (19x)
       61 ( 0.00%)      glLinkProgram(shader_program);
16,962,018 ( 0.03%)  => ???:0x0000000004a82ae0 (19x)
      933 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           
        .               size_t cnt = 0;
        .           
        .               struct ShaderProgram* prg = &shader_program_pool[make_pair(shader_id0, shader_id1)];
       99 ( 0.00%)      prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aVtxPos");
    5,956 ( 0.00%)  => ???:0x0000000004a812a0 (19x)
      918 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       19 ( 0.00%)      prg->attrib_sizes[cnt] = 4;
       19 ( 0.00%)      ++cnt;
        .           
        .               for (int i = 0; i < 2; i++) {
       76 ( 0.00%)          if (cc_features.used_textures[i]) {
        .                       char name[32];
      119 ( 0.00%)              sprintf(name, "aTexCoord%d", i);
    8,183 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (17x)
       85 ( 0.00%)              prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
    5,259 ( 0.00%)  => ???:0x0000000004a812a0 (17x)
       17 ( 0.00%)              prg->attrib_sizes[cnt] = 2;
       16 ( 0.00%)              ++cnt;
        .           
        .                       for (int j = 0; j < 2; j++) {
       68 ( 0.00%)                  if (cc_features.clamp[i][j]) {
       42 ( 0.00%)                      sprintf(name, "aTexClamp%s%d", j == 0 ? "S" : "T", i);
    4,014 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (6x)
       30 ( 0.00%)                      prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
    2,213 ( 0.00%)  => ???:0x0000000004a812a0 (6x)
        6 ( 0.00%)                      prg->attrib_sizes[cnt] = 1;
       12 ( 0.00%)                      ++cnt;
        .                           }
        .                       }
        .                   }
        .               }
        .           
       38 ( 0.00%)      if (cc_features.opt_fog) {
        5 ( 0.00%)          prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aFog");
      266 ( 0.00%)  => ???:0x0000000004a812a0 (1x)
        1 ( 0.00%)          prg->attrib_sizes[cnt] = 4;
        1 ( 0.00%)          ++cnt;
        .               }
        .           
       38 ( 0.00%)      if (cc_features.opt_grayscale) {
        .                   prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aGrayscaleColor");
        .                   prg->attrib_sizes[cnt] = 4;
        .                   ++cnt;
        .               }
        .           
      209 ( 0.00%)      for (int i = 0; i < cc_features.num_inputs; i++) {
        .                   char name[16];
      126 ( 0.00%)          sprintf(name, "aInput%d", i + 1);
    8,802 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/sprintf.c:sprintf (18x)
       90 ( 0.00%)          prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
    5,196 ( 0.00%)  => ???:0x0000000004a812a0 (18x)
       54 ( 0.00%)          prg->attrib_sizes[cnt] = cc_features.opt_alpha ? 4 : 3;
       18 ( 0.00%)          ++cnt;
        .               }
        .           
       38 ( 0.00%)      prg->opengl_program_id = shader_program;
       19 ( 0.00%)      prg->num_inputs = cc_features.num_inputs;
       38 ( 0.00%)      prg->used_textures[0] = cc_features.used_textures[0];
        .               prg->used_textures[1] = cc_features.used_textures[1];
        .               prg->used_textures[2] = cc_features.used_masks[0];
        .               prg->used_textures[3] = cc_features.used_masks[1];
       38 ( 0.00%)      prg->used_textures[4] = cc_features.used_blend[0];
        .               prg->used_textures[5] = cc_features.used_blend[1];
       19 ( 0.00%)      prg->num_floats = num_floats;
       19 ( 0.00%)      prg->num_attribs = cnt;
        .           
      118 ( 0.00%)      prg->frame_count_location = glGetUniformLocation(shader_program, "frame_count");
    4,256 ( 0.00%)  => ???:0x0000000004a820a0 (19x)
      931 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       95 ( 0.00%)      prg->noise_scale_location = glGetUniformLocation(shader_program, "noise_scale");
    4,256 ( 0.00%)  => ???:0x0000000004a820a0 (19x)
        .           
       38 ( 0.00%)      gfx_opengl_load_shader(prg);
   92,904 ( 0.00%)  => libultraship/src/graphic/Fast3D/gfx_opengl.cpp:gfx_opengl_load_shader(ShaderProgram*) (19x)
        .           
       38 ( 0.00%)      if (cc_features.used_textures[0]) {
       80 ( 0.00%)          GLint sampler_location = glGetUniformLocation(shader_program, "uTex0");
    4,192 ( 0.00%)  => ???:0x0000000004a820a0 (16x)
       64 ( 0.00%)          glUniform1i(sampler_location, 0);
    4,160 ( 0.00%)  => ???:0x0000000004a85a20 (16x)
        .               }
       38 ( 0.00%)      if (cc_features.used_textures[1]) {
        5 ( 0.00%)          GLint sampler_location = glGetUniformLocation(shader_program, "uTex1");
      304 ( 0.00%)  => ???:0x0000000004a820a0 (1x)
        4 ( 0.00%)          glUniform1i(sampler_location, 1);
       40 ( 0.00%)  => ???:0x0000000004a85a20 (1x)
        .               }
       38 ( 0.00%)      if (cc_features.used_masks[0]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexMask0");
        .                   glUniform1i(sampler_location, 2);
        .               }
       38 ( 0.00%)      if (cc_features.used_masks[1]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexMask1");
        .                   glUniform1i(sampler_location, 3);
        .               }
       38 ( 0.00%)      if (cc_features.used_blend[0]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexBlend0");
        .                   glUniform1i(sampler_location, 4);
        .               }
       38 ( 0.00%)      if (cc_features.used_blend[1]) {
        .                   GLint sampler_location = glGetUniformLocation(shader_program, "uTexBlend1");
        .                   glUniform1i(sampler_location, 5);
        .               }
        .           
        .               return prg;
      190 ( 0.00%)  }
        .           
        .           static struct ShaderProgram* gfx_opengl_lookup_shader(uint64_t shader_id0, uint32_t shader_id1) {
        .               auto it = shader_program_pool.find(make_pair(shader_id0, shader_id1));
        4 ( 0.00%)      return it == shader_program_pool.end() ? nullptr : &it->second;
       20 ( 0.00%)  }
        .           
        .           static void gfx_opengl_shader_get_info(struct ShaderProgram* prg, uint8_t* num_inputs, bool used_textures[2]) {
2,301,000 ( 0.00%)      *num_inputs = prg->num_inputs;
2,301,000 ( 0.00%)      used_textures[0] = prg->used_textures[0];
2,301,000 ( 0.00%)      used_textures[1] = prg->used_textures[1];
1,150,500 ( 0.00%)  }
        .           
      402 ( 0.00%)  static GLuint gfx_opengl_new_texture(void) {
        .               GLuint ret;
    1,608 ( 0.00%)      glGenTextures(1, &ret);
  133,962 ( 0.00%)  => ???:0x0000000004a810a0 (402x)
        .               return ret;
    1,206 ( 0.00%)  }
        .           
        .           static void gfx_opengl_delete_texture(uint32_t texID) {
        .               glDeleteTextures(1, &texID);
        .           }
        .           
   93,416 ( 0.00%)  static void gfx_opengl_select_texture(int tile, GLuint texture_id) {
  140,128 ( 0.00%)      glActiveTexture(GL_TEXTURE0 + tile);
  794,036 ( 0.00%)  => ???:0x0000000004a7f040 (46,708x)
      882 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  186,832 ( 0.00%)      glBindTexture(GL_TEXTURE_2D, texture_id);
9,870,058 ( 0.02%)  => ???:0x0000000004a7f360 (46,708x)
   46,708 ( 0.00%)  }
        .           
    1,206 ( 0.00%)  static void gfx_opengl_upload_texture(const uint8_t* rgba32_buf, uint32_t width, uint32_t height) {
    3,618 ( 0.00%)      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, rgba32_buf);
6,010,661 ( 0.01%)  => ???:0x0000000004a85480 (402x)
      804 ( 0.00%)  }
        .           
        .           #ifdef USE_OPENGLES
        .           #define GL_MIRROR_CLAMP_TO_EDGE 0x8743
        .           #endif
        .           
        .           static uint32_t gfx_cm_to_opengl(uint32_t val) {
        .               switch (val) {
        .                   case G_TX_NOMIRROR | G_TX_CLAMP:
-- line 797 ----------------------------------------
-- line 801 ----------------------------------------
        .                   case G_TX_MIRROR | G_TX_CLAMP:
        .                       return GL_MIRROR_CLAMP_TO_EDGE;
        .                   case G_TX_NOMIRROR | G_TX_WRAP:
        .                       return GL_REPEAT;
        .               }
        .               return 0;
        .           }
        .           
    4,800 ( 0.00%)  static void gfx_opengl_set_sampler_parameters(int tile, bool linear_filter, uint32_t cms, uint32_t cmt) {
    3,004 ( 0.00%)      const GLint filter = linear_filter && current_filter_mode == FILTER_LINEAR ? GL_LINEAR : GL_NEAREST;
    2,400 ( 0.00%)      glActiveTexture(GL_TEXTURE0 + tile);
   13,600 ( 0.00%)  => ???:0x0000000004a7f040 (800x)
    4,000 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filter);
  500,486 ( 0.00%)  => ???:0x0000000004a85580 (800x)
    7,200 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
  492,426 ( 0.00%)  => ???:0x0000000004a85580 (800x)
    6,400 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, gfx_cm_to_opengl(cms));
  407,474 ( 0.00%)  => ???:0x0000000004a85580 (800x)
    3,200 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, gfx_cm_to_opengl(cmt));
  397,459 ( 0.00%)  => ???:0x0000000004a85580 (800x)
    2,400 ( 0.00%)  }
        .           
        .           static void gfx_opengl_set_depth_test_and_mask(bool depth_test, bool z_upd) {
   16,570 ( 0.00%)      current_depth_test = depth_test;
   16,570 ( 0.00%)      current_depth_mask = z_upd;
   16,570 ( 0.00%)  }
        .           
        .           static void gfx_opengl_set_zmode_decal(bool zmode_decal) {
   12,276 ( 0.00%)      current_zmode_decal = zmode_decal;
   12,276 ( 0.00%)  }
        .           
        .           static void gfx_opengl_set_viewport(int x, int y, int width, int height) {
    1,218 ( 0.00%)      glViewport(x, y, width, height);
  121,794 ( 0.00%)  => ???:0x0000000004a86fe0 (607x)
      822 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           }
        .           
        .           static void gfx_opengl_set_scissor(int x, int y, int width, int height) {
    1,218 ( 0.00%)      glScissor(x, y, width, height);
   94,684 ( 0.00%)  => ???:0x0000000004a84980 (607x)
      810 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           }
        .           
        .           static void gfx_opengl_set_use_alpha(bool use_alpha) {
    9,690 ( 0.00%)      if (use_alpha) {
    9,691 ( 0.00%)          glEnable(GL_BLEND);
  155,072 ( 0.00%)  => ???:0x0000000004a809e0 (2,423x)
        .               } else {
    4,844 ( 0.00%)          glDisable(GL_BLEND);
  159,852 ( 0.00%)  => ???:0x0000000004a80620 (2,422x)
        .               }
        .           }
        .           
  387,702 ( 0.00%)  static void gfx_opengl_draw_triangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) {
  432,099 ( 0.00%)      if (current_depth_test != last_depth_test || current_depth_mask != last_depth_mask) {
   16,570 ( 0.00%)          last_depth_test = current_depth_test;
   16,570 ( 0.00%)          last_depth_mask = current_depth_mask;
        .           
   33,140 ( 0.00%)          if (current_depth_test || last_depth_mask) {
   47,886 ( 0.00%)              glEnable(GL_DEPTH_TEST);
1,011,242 ( 0.00%)  => ???:0x0000000004a809e0 (15,658x)
   78,290 ( 0.00%)              glDepthMask(last_depth_mask ? GL_TRUE : GL_FALSE);
  623,647 ( 0.00%)  => ???:0x0000000004a80560 (15,658x)
  156,580 ( 0.00%)              glDepthFunc(current_depth_test ? (current_zmode_decal ? GL_LEQUAL : GL_LESS) : GL_ALWAYS);
  689,839 ( 0.00%)  => ???:0x0000000004a80540 (15,658x)
        .                   } else {
    2,736 ( 0.00%)              glDisable(GL_DEPTH_TEST);
   65,664 ( 0.00%)  => ???:0x0000000004a80620 (912x)
        .                   }
        .               }
        .           
  193,851 ( 0.00%)      if (current_zmode_decal != last_zmode_decal) {
   12,276 ( 0.00%)          last_zmode_decal = current_zmode_decal;
   24,552 ( 0.00%)          if (current_zmode_decal) {
        .                       // SSDB = SlopeScaledDepthBias 120 leads to -2 at 240p which is the same as N64 mode which has very little
        .                       // fighting
        .                       const int n64modeFactor = 120;
        .                       const int noVanishFactor = 100;
        .                       GLfloat SSDB = -2;
   42,966 ( 0.00%)              switch (CVarGetInteger(CVAR_Z_FIGHTING_MODE, 0)) {
1,669,536 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/consolevariablebridge.cpp:CVarGetInteger (6,138x)
        .                           // scaled z-fighting (N64 mode like)
        .                           case 1:
        .                               if (framebuffers.size() >
        .                                   current_framebuffer) { // safety check for vector size can probably be removed
        .                                   SSDB = -1.0f * (GLfloat)framebuffers[current_framebuffer].height / n64modeFactor;
        .                               }
        .                               break;
        .                           // no vanishing paths
-- line 873 ----------------------------------------
-- line 875 ----------------------------------------
        .                               if (framebuffers.size() >
        .                                   current_framebuffer) { // safety check for vector size can probably be removed
        .                                   SSDB = -1.0f * (GLfloat)framebuffers[current_framebuffer].height / noVanishFactor;
        .                               }
        .                               break;
        .                           // disabled
        .                           case 0:
        .                           default:
    6,138 ( 0.00%)                      SSDB = -2;
        .                       }
   18,418 ( 0.00%)              glPolygonOffset(SSDB, -2);
  208,692 ( 0.00%)  => ???:0x0000000004a83a80 (6,138x)
      846 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
   18,414 ( 0.00%)              glEnable(GL_POLYGON_OFFSET_FILL);
  331,452 ( 0.00%)  => ???:0x0000000004a809e0 (6,138x)
        .                   } else {
   24,552 ( 0.00%)              glPolygonOffset(0, 0);
  227,106 ( 0.00%)  => ???:0x0000000004a83a80 (6,138x)
   24,552 ( 0.00%)              glDisable(GL_POLYGON_OFFSET_FILL);
  331,452 ( 0.00%)  => ???:0x0000000004a80620 (6,138x)
        .                   }
        .               }
        .           
        .               // printf("flushing %d tris\n", buf_vbo_num_tris);
  387,706 ( 0.00%)      glBufferData(GL_ARRAY_BUFFER, sizeof(float) * buf_vbo_len, buf_vbo, GL_STREAM_DRAW);
378,710,115 ( 0.64%)  => ???:0x0000000004a7f5c0 (64,617x)
      867 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  323,089 ( 0.00%)      glDrawArrays(GL_TRIANGLES, 0, 3 * buf_vbo_num_tris);
229,279,984 ( 0.39%)  => ???:0x0000000004a80700 (64,617x)
      826 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
  193,851 ( 0.00%)  }
        .           
        3 ( 0.00%)  static void gfx_opengl_init(void) {
        .           #ifndef __linux__
        .               glewInit();
        .           #endif
        .           
        8 ( 0.00%)      glGenBuffers(1, &opengl_vbo);
      826 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      215 ( 0.00%)  => ???:0x0000000004a80fc0 (1x)
        8 ( 0.00%)      glBindBuffer(GL_ARRAY_BUFFER, opengl_vbo);
      870 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      900 ( 0.00%)  => ???:0x0000000004a7f1a0 (1x)
        .           
        .           #if defined(__APPLE__) || defined(USE_OPENGLES)
        .               glGenVertexArrays(1, &opengl_vao);
        .               glBindVertexArray(opengl_vao);
        .           #endif
        .           
        .           #ifndef USE_OPENGLES // not supported on gles
        7 ( 0.00%)      glEnable(GL_DEPTH_CLAMP);
      820 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       84 ( 0.00%)  => ???:0x0000000004a809e0 (1x)
        .           #endif
        7 ( 0.00%)      glDepthFunc(GL_LEQUAL);
      879 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       46 ( 0.00%)  => ???:0x0000000004a80540 (1x)
        8 ( 0.00%)      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      863 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       52 ( 0.00%)  => ???:0x0000000004a7f500 (1x)
        .           
        .               framebuffers.resize(1); // for the default screen buffer
        .           
        8 ( 0.00%)      glGenRenderbuffers(1, &pixel_depth_rb);
      941 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      213 ( 0.00%)  => ???:0x0000000004a81060 (1x)
        8 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, pixel_depth_rb);
      969 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    3,037 ( 0.00%)  => ???:0x0000000004a7f300 (1x)
       10 ( 0.00%)      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 1, 1);
      930 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    5,501 ( 0.00%)  => ???:0x0000000004a847a0 (1x)
        4 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, 0);
      103 ( 0.00%)  => ???:0x0000000004a7f300 (1x)
        .           
        8 ( 0.00%)      glGenFramebuffers(1, &pixel_depth_fb);
      921 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      681 ( 0.00%)  => ???:0x0000000004a80fe0 (1x)
        8 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, pixel_depth_fb);
   26,355 ( 0.00%)  => ???:0x0000000004a7f280 (1x)
      900 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       10 ( 0.00%)      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, pixel_depth_rb);
   36,802 ( 0.00%)  => ???:0x0000000004a80ec0 (1x)
      969 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        4 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, 0);
   13,308 ( 0.00%)  => ???:0x0000000004a7f280 (1x)
        .           
        1 ( 0.00%)      pixel_depth_rb_size = 1;
        .           
        8 ( 0.00%)      glGetIntegerv(GL_MAX_SAMPLES, &max_msaa_level);
      850 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      131 ( 0.00%)  => ???:0x0000000004a815c0 (1x)
        3 ( 0.00%)  }
        .           
        .           static void gfx_opengl_on_resize(void) {
        .           }
        .           
        .           static void gfx_opengl_start_frame(void) {
      571 ( 0.00%)      frame_count++;
      571 ( 0.00%)  }
        .           
        .           static void gfx_opengl_end_frame(void) {
    1,146 ( 0.00%)      glFlush();
6,330,346 ( 0.01%)  => ???:0x0000000004a80d20 (571x)
      807 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           }
        .           
      571 ( 0.00%)  static void gfx_opengl_finish_render(void) {
        .           }
        .           
       14 ( 0.00%)  static int gfx_opengl_create_framebuffer() {
        .               GLuint clrbuf;
       12 ( 0.00%)      glGenTextures(1, &clrbuf);
      842 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      842 ( 0.00%)  => ???:0x0000000004a810a0 (2x)
       12 ( 0.00%)      glBindTexture(GL_TEXTURE_2D, clrbuf);
    6,456 ( 0.00%)  => ???:0x0000000004a7f360 (2x)
      887 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       28 ( 0.00%)      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
   11,613 ( 0.00%)  => ???:0x0000000004a85480 (2x)
      834 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       16 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      939 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    2,172 ( 0.00%)  => ???:0x0000000004a85580 (2x)
       10 ( 0.00%)      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      414 ( 0.00%)  => ???:0x0000000004a85580 (2x)
        8 ( 0.00%)      glBindTexture(GL_TEXTURE_2D, 0);
      444 ( 0.00%)  => ???:0x0000000004a7f360 (2x)
        .           
        .               GLuint clrbuf_msaa;
        8 ( 0.00%)      glGenRenderbuffers(1, &clrbuf_msaa);
    1,117 ( 0.00%)  => ???:0x0000000004a81060 (2x)
        .           
        .               GLuint rbo;
        8 ( 0.00%)      glGenRenderbuffers(1, &rbo);
      400 ( 0.00%)  => ???:0x0000000004a81060 (2x)
        8 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    8,395 ( 0.00%)  => ???:0x0000000004a7f300 (2x)
       12 ( 0.00%)      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 1, 1);
   10,570 ( 0.00%)  => ???:0x0000000004a847a0 (2x)
        8 ( 0.00%)      glBindRenderbuffer(GL_RENDERBUFFER, 0);
      206 ( 0.00%)  => ???:0x0000000004a7f300 (2x)
        .           
        .               GLuint fbo;
        8 ( 0.00%)      glGenFramebuffers(1, &fbo);
      684 ( 0.00%)  => ???:0x0000000004a80fe0 (2x)
        .           
        .               size_t i = framebuffers.size();
        .               framebuffers.resize(i + 1);
        .           
       12 ( 0.00%)      framebuffers[i].fbo = fbo;
        .               framebuffers[i].clrbuf = clrbuf;
        .               framebuffers[i].clrbuf_msaa = clrbuf_msaa;
        .               framebuffers[i].rbo = rbo;
        .           
        2 ( 0.00%)      return i;
       16 ( 0.00%)  }
        .           
        .           static void gfx_opengl_update_framebuffer_parameters(int fb_id, uint32_t width, uint32_t height, uint32_t msaa_level,
        .                                                                bool opengl_invert_y, bool render_target, bool has_depth_buffer,
    5,720 ( 0.00%)                                                       bool can_extract_depth) {
      572 ( 0.00%)      Framebuffer& fb = framebuffers[fb_id];
        .           
        .               width = max(width, 1U);
        .               height = max(height, 1U);
        .               msaa_level = min(msaa_level, (uint32_t)max_msaa_level);
        .           
    2,288 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, fb.fbo);
  197,340 ( 0.00%)  => ???:0x0000000004a7f280 (572x)
        .           
    1,716 ( 0.00%)      if (fb_id != 0) {
        .                   if (fb.width != width || fb.height != height || fb.msaa_level != msaa_level) {
        .                       if (msaa_level <= 1) {
        .                           glBindTexture(GL_TEXTURE_2D, fb.clrbuf);
        .                           glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
        .                           glBindTexture(GL_TEXTURE_2D, 0);
        .                           glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fb.clrbuf, 0);
        .                       } else {
        .                           glBindRenderbuffer(GL_RENDERBUFFER, fb.clrbuf_msaa);
-- line 999 ----------------------------------------
-- line 1016 ----------------------------------------
        .           
        .                   if (!fb.has_depth_buffer && has_depth_buffer) {
        .                       glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, fb.rbo);
        .                   } else if (fb.has_depth_buffer && !has_depth_buffer) {
        .                       glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, 0);
        .                   }
        .               }
        .           
      572 ( 0.00%)      fb.width = width;
      572 ( 0.00%)      fb.height = height;
      572 ( 0.00%)      fb.has_depth_buffer = has_depth_buffer;
      572 ( 0.00%)      fb.msaa_level = msaa_level;
      572 ( 0.00%)      fb.invert_y = opengl_invert_y;
    4,576 ( 0.00%)  }
        .           
      571 ( 0.00%)  void gfx_opengl_start_draw_to_framebuffer(int fb_id, float noise_scale) {
      571 ( 0.00%)      Framebuffer& fb = framebuffers[fb_id];
        .           
    2,284 ( 0.00%)      if (noise_scale != 0.0f) {
    2,284 ( 0.00%)          current_noise_scale = 1.0f / noise_scale;
        .               }
    2,284 ( 0.00%)      glBindFramebuffer(GL_FRAMEBUFFER, fb.fbo);
  196,995 ( 0.00%)  => ???:0x0000000004a7f280 (571x)
      571 ( 0.00%)      current_framebuffer = fb_id;
    1,142 ( 0.00%)  }
        .           
      571 ( 0.00%)  void gfx_opengl_clear_framebuffer() {
    1,717 ( 0.00%)      glDisable(GL_SCISSOR_TEST);
1,282,229 ( 0.00%)  => ???:0x0000000004a80620 (571x)
      818 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,717 ( 0.00%)      glDepthMask(GL_TRUE);
   22,003 ( 0.00%)  => ???:0x0000000004a80560 (571x)
      822 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,717 ( 0.00%)      glClear(GL_DEPTH_BUFFER_BIT);
5,357,712 ( 0.01%)  => ???:0x0000000004a7f6c0 (571x)
      854 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    2,855 ( 0.00%)      glDepthMask(current_depth_mask ? GL_TRUE : GL_FALSE);
   22,840 ( 0.00%)  => ???:0x0000000004a80560 (571x)
    1,713 ( 0.00%)      glEnable(GL_SCISSOR_TEST);
1,108,476 ( 0.00%)  => ???:0x0000000004a809e0 (571x)
      571 ( 0.00%)  }
        .           
        .           void gfx_opengl_resolve_msaa_color_buffer(int fb_id_target, int fb_id_source) {
        .               Framebuffer& fb_dst = framebuffers[fb_id_target];
        .               Framebuffer& fb_src = framebuffers[fb_id_source];
        .               glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fb_dst.fbo);
        .               glBindFramebuffer(GL_READ_FRAMEBUFFER, fb_src.fbo);
        .           
        .               // Disabled for blit
-- line 1055 ----------------------------------------
-- line 1213 ----------------------------------------
        .               }
        .           
        .               glBindFramebuffer(GL_FRAMEBUFFER, current_framebuffer);
        .           
        .               return res;
        .           }
        .           
        .           void gfx_opengl_set_texture_filter(FilteringMode mode) {
        1 ( 0.00%)      current_filter_mode = mode;
        1 ( 0.00%)      gfx_texture_cache_clear();
       50 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/graphic/Fast3D/gfx_pc.cpp:gfx_texture_cache_clear (1x)
        .           }
        .           
        .           FilteringMode gfx_opengl_get_texture_filter(void) {
        .               return current_filter_mode;
        .           }
        .           
        .           struct GfxRenderingAPI gfx_opengl_api = { gfx_opengl_get_name,
        .                                                     gfx_opengl_get_max_texture_size,
-- line 1230 ----------------------------------------
-- line 1256 ----------------------------------------
        .                                                     gfx_opengl_clear_framebuffer,
        .                                                     gfx_opengl_read_framebuffer_to_cpu,
        .                                                     gfx_opengl_resolve_msaa_color_buffer,
        .                                                     gfx_opengl_get_pixel_depth,
        .                                                     gfx_opengl_get_framebuffer_texture_id,
        .                                                     gfx_opengl_select_texture_fb,
        .                                                     gfx_opengl_delete_texture,
        .                                                     gfx_opengl_set_texture_filter,
        2 ( 0.00%)                                            gfx_opengl_get_texture_filter };
        .           
        .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/public/bridge/resourcebridge.cpp
--------------------------------------------------------------------------------
Ir                 

        .           #include "public/bridge/resourcebridge.h"
        .           #include "Context.h"
        .           #include <string>
        .           #include <algorithm>
        .           #include "utils/StrHash64.h"
        .           
  474,864 ( 0.00%)  std::shared_ptr<Ship::IResource> ResourceLoad(const char* name) {
  712,296 ( 0.00%)      return Ship::Context::GetInstance()->GetResourceManager()->LoadResource(name);
85,812,907 ( 0.15%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (59,358x)
1,246,518 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (59,358x)
  593,580 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetResourceManager() (59,358x)
  474,864 ( 0.00%)  }
        .           
        .           std::shared_ptr<Ship::IResource> ResourceLoad(uint64_t crc) {
        .               auto name = ResourceGetNameByCrc(crc);
        .           
        .               if (name == nullptr || strlen(name) == 0) {
        .                   SPDLOG_TRACE("ResourceLoad: Unknown crc {}\n", crc);
        .                   return nullptr;
        .               }
-- line 17 ----------------------------------------
-- line 20 ----------------------------------------
        .           }
        .           
        .           extern "C" {
        .           
        .           uint64_t ResourceGetCrcByName(const char* name) {
        .               return CRC64(name);
        .           }
        .           
  685,628 ( 0.00%)  const char* ResourceGetNameByCrc(uint64_t crc) {
        .               const std::string* hashStr =
2,056,884 ( 0.00%)          Ship::Context::GetInstance()->GetResourceManager()->GetArchiveManager()->HashToString(crc);
4,472,276 ( 0.01%)  => /usr/include/c++/14/bits/hashtable.h:Ship::ArchiveManager::HashToString[abi:cxx11](unsigned long) const (171,407x)
3,599,547 ( 0.01%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (171,407x)
1,714,070 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetResourceManager() (171,407x)
1,714,070 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::ResourceManager::GetArchiveManager() (171,407x)
  342,814 ( 0.00%)      return hashStr != nullptr ? hashStr->c_str() : nullptr;
  857,035 ( 0.00%)  }
        .           
        .           size_t ResourceGetSizeByName(const char* name) {
        .               auto resource = ResourceLoad(name);
        .           
        .               if (resource == nullptr) {
        .                   return 0;
        .               }
        .           
-- line 40 ----------------------------------------
-- line 54 ----------------------------------------
        .           
        .               return resource->GetInitData()->IsCustom;
        .           }
        .           
        .           uint8_t ResourceGetIsCustomByCrc(uint64_t crc) {
        .               return ResourceGetIsCustomByName(ResourceGetNameByCrc(crc));
        .           }
        .           
   47,202 ( 0.00%)  void* ResourceGetDataByName(const char* name) {
  114,128 ( 0.00%)      auto resource = ResourceLoad(name);
69,495,319 ( 0.12%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceLoad(char const*) (41,330x)
        .           
  114,128 ( 0.00%)      if (resource == nullptr) {
        .                   return nullptr;
        .               }
        .           
  171,192 ( 0.00%)      return resource->GetRawPointer();
  247,392 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<Gfx>::GetRawPointer() (41,232x)
      588 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.h:Ship::Resource<Vtx>::GetRawPointer() (98x)
   47,202 ( 0.00%)  }
        .           
  123,990 ( 0.00%)  void* ResourceGetDataByCrc(uint64_t crc) {
   41,330 ( 0.00%)      auto name = ResourceGetNameByCrc(crc);
5,679,599 ( 0.01%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetNameByCrc (41,330x)
        .           
  206,650 ( 0.00%)      if (name == nullptr || strlen(name) == 0) {
        .                   SPDLOG_TRACE("ResourceGetDataByCrc: Unknown crc 0x{:X}\n", crc);
        .                   return nullptr;
        .               }
        .           
        .               return ResourceGetDataByName(name);
  123,990 ( 0.00%)  }
        .           
        .           uint16_t ResourceGetTexWidthByName(const char* name) {
        .               const auto res = static_pointer_cast<LUS::Texture>(ResourceLoad(name));
        .           
        .               if (res != nullptr) {
        .                   return res->Width;
        .               }
        .           
-- line 89 ----------------------------------------
-- line 119 ----------------------------------------
        .               if (res != nullptr) {
        .                   return res->Height;
        .               }
        .           
        .               SPDLOG_ERROR("Given texture path is a non-existent resource");
        .               return -1;
        .           }
        .           
   18,352 ( 0.00%)  size_t ResourceGetTexSizeByName(const char* name) {
    4,588 ( 0.00%)      const auto res = static_pointer_cast<LUS::Texture>(ResourceLoad(name));
4,409,614 ( 0.01%)  => libultraship/src/public/bridge/resourcebridge.cpp:ResourceLoad(char const*) (2,294x)
        .           
    4,588 ( 0.00%)      if (res != nullptr) {
    2,294 ( 0.00%)          return res->ImageDataSize;
        .               }
        .           
        .               SPDLOG_ERROR("Given texture path is a non-existent resource");
        .               return -1;
   16,058 ( 0.00%)  }
        .           
        .           size_t ResourceGetTexSizeByCrc(uint64_t crc) {
        .               const auto res = static_pointer_cast<LUS::Texture>(ResourceLoad(crc));
        .           
        .               if (res != nullptr) {
        .                   return res->ImageDataSize;
        .               }
        .           
-- line 144 ----------------------------------------
-- line 195 ----------------------------------------
        .           
        .           void ResourceUnloadDirectory(const char* name) {
        .               Ship::Context::GetInstance()->GetResourceManager()->UnloadDirectory(name);
        .           }
        .           
        .           uint32_t ResourceDoesOtrFileExist() {
        .               return Ship::Context::GetInstance()->GetResourceManager()->DidLoadSuccessfully();
        .           }
        1 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/racing/math_util.c
--------------------------------------------------------------------------------
Ir                 

-- line 38 ----------------------------------------
        .           UNUSED void func_802B4FF0() {
        .           }
        .           
        .           /**
        .            * Inserts matrix into the rsp. Position, rotation and mode of where to render the next object and check number of
        .            * object already render Note that gMatrixObjectCount gets reset at the beginning of the game loop. So no cleanup needs
        .            * to be performed.
        .            */
  186,276 ( 0.00%)  s32 render_set_position(Mat4 arg0, s32 arg1) {
  186,276 ( 0.00%)      if (gMatrixObjectCount >= MTX_OBJECT_POOL_SIZE) {
   46,569 ( 0.00%)          return 0;
        .               }
  372,552 ( 0.00%)      mtxf_to_mtx(&gGfxPool->mtxObject[gMatrixObjectCount], arg0);
1,723,053 ( 0.00%)  => src/racing/math_util.c:mtxf_to_mtx (46,569x)
  232,845 ( 0.00%)      switch (arg1) { /* irregular */
        .                   case 0:
  240,054 ( 0.00%)              gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
        .                       break;
        .                   case 1:
  325,983 ( 0.00%)              gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_PUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
        .                       break;
        .                   case 3:
   39,360 ( 0.00%)              gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_PUSH | G_MTX_MUL | G_MTX_MODELVIEW);
        .                       break;
        .                   case 2:
        .                       gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxObject[gMatrixObjectCount++]),
        .                                 G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
        .                       break;
        .               }
        .               return 1;
  232,845 ( 0.00%)  }
        .           
        .           f32 func_802B51E8(Vec3f arg0, Vec3f arg1) {
        .               f32 sub_y;
        .               f32 sub_z;
        .               f32 sub_x;
        .           
        .               sub_x = arg1[0] - arg0[0];
        .               sub_y = arg1[1] - arg0[1];
        .               sub_z = arg1[2] - arg0[2];
        .               return (sub_x * sub_x) + (sub_y * sub_y) + sub_z + sub_z;
        .           }
        .           
   23,264 ( 0.00%)  s32 get_angle_between_two_vectors(Vec3f arg0, Vec3f arg1) {
        .               f32 temp_v1;
        .               f32 temp_v2;
   46,528 ( 0.00%)      temp_v1 = arg1[0] - arg0[0];
   23,264 ( 0.00%)      temp_v2 = arg1[2] - arg0[2];
        .           
   69,792 ( 0.00%)      return atan2s(temp_v1, temp_v2);
  713,513 ( 0.00%)  => src/racing/math_util.c:atan2s (23,264x)
   46,528 ( 0.00%)  }
        .           
        .           // get_angle_between_two_vectors
        .           u32 func_802B5258(Vec3f arg0, Vec3s arg1) {
        .               f32 temp_v1;
        .               f32 temp_v2;
        .               temp_v1 = arg1[0] - arg0[0];
        .               temp_v2 = arg1[2] - arg0[2];
        .           
        .               return atan2s(temp_v1, temp_v2);
        .           }
        .           
        .           void vec3f_set(Vec3f arg0, f32 arg1, f32 arg2, f32 arg3) {
   13,372 ( 0.00%)      arg0[0] = arg1;
        .               arg0[1] = arg2;
    6,686 ( 0.00%)      arg0[2] = arg3;
    6,686 ( 0.00%)  }
        .           
        .           void vec3s_set(Vec3s arg0, s16 arg1, s16 arg2, s16 arg3) {
       72 ( 0.00%)      arg0[0] = arg1;
        .               arg0[1] = arg2;
       18 ( 0.00%)      arg0[2] = arg3;
       18 ( 0.00%)  }
        .           
        .           // These functions have bogus return values.
        .           // Disable the compiler warning.
        .           #pragma GCC diagnostic push
        .           
        .           #ifdef __GNUC__
        .           #if defined(__clang__)
        .           #pragma GCC diagnostic ignored "-Wreturn-stack-address"
        .           #else
        .           #pragma GCC diagnostic ignored "-Wreturn-local-addr"
        .           #endif
        .           #endif
        .           
        .           void* vec3f_copy_return(Vec3f dest, Vec3f src) {
      116 ( 0.00%)      dest[0] = src[0];
      116 ( 0.00%)      dest[1] = src[1];
      116 ( 0.00%)      dest[2] = src[2];
        .               //! @warning function returns address of local variable
        .               return &dest;
      116 ( 0.00%)  }
        .           
        .           void vec3s_copy(Vec3s dest, Vec3s src) {
       58 ( 0.00%)      dest[0] = src[0];
       58 ( 0.00%)      dest[1] = src[1];
       58 ( 0.00%)      dest[2] = src[2];
       29 ( 0.00%)  }
        .           
        .           UNUSED void* vec3f_set_return(Vec3f dest, f32 x, f32 y, f32 z) {
        .               dest[0] = x;
        .               dest[1] = y;
        .               dest[2] = z;
        .               return &dest;
        .           }
        .           
-- line 146 ----------------------------------------
-- line 152 ----------------------------------------
        .               for (row = 0; row < 4; row++) {
        .                   for (column = 0; column < 4; column++) {
        .                       mat2[row][column] = mat1[row][column];
        .                   }
        .               }
        .           }
        .           
        .           // mtxf_copy
    7,036 ( 0.00%)  void mtxf_copy_n_element(s32* dest, s32* src, s32 n) {
  239,224 ( 0.00%)      while (n-- > 0) {
   28,144 ( 0.00%)          *dest++ = *src++;
        .               }
   14,072 ( 0.00%)  }
        .           
        .           // Transform a matrix to a matrix identity
        .           void mtxf_identity(Mat4 mtx) {
        .               register s32 i;
        .               register s32 k;
        .           
   15,024 ( 0.00%)      for (i = 0; i < 4; i++) {
        .                   for (k = 0; k < 4; k++) {
   60,096 ( 0.00%)              mtx[i][k] = (i == k) ? 1.0f : 0.0f;
        .                   }
        .               }
   15,024 ( 0.00%)  }
        .           
        .           // Add a translation vector to a matrix, mat is the matrix to add, dest is the destination matrix, pos is the
        .           // translation vector
        .           void add_translate_mat4_vec3f(Mat4 mat, Mat4 dest, Vec3f pos) {
        .               dest[3][0] = mat[3][0] + pos[0];
        .               dest[3][1] = mat[3][1] + pos[1];
        .               dest[3][2] = mat[3][2] + pos[2];
        .               dest[3][3] = mat[3][3];
-- line 184 ----------------------------------------
-- line 206 ----------------------------------------
        .           // Light version of add_translate_mat4_vec3f
        .           UNUSED void add_translate_mat4_vec3f_lite(Mat4 mat, Mat4 dest, Vec3f pos) {
        .               dest[3][0] = mat[3][0] + pos[0];
        .               dest[3][1] = mat[3][1] + pos[1];
        .               dest[3][2] = mat[3][2] + pos[2];
        .           }
        .           
        .           // create a translation matrix
   35,180 ( 0.00%)  void mtxf_translate(Mat4 dest, Vec3f b) {
    7,036 ( 0.00%)      mtxf_identity(dest);
   42,216 ( 0.00%)  => src/racing/math_util.c:mtxf_identity (7,036x)
   14,072 ( 0.00%)      dest[3][0] = b[0];
   14,072 ( 0.00%)      dest[3][1] = b[1];
   14,072 ( 0.00%)      dest[3][2] = b[2];
   28,144 ( 0.00%)  }
        .           
        .           // Note the use of `2` which generates diff asm than just using floats (2.0f).
    7,616 ( 0.00%)  void func_802B5564(Mat4 arg0, u16* arg1, f32 arg2, f32 arg3, f32 arg4, f32 arg5, f32 arg6) {
        .               f32 temp;
        .               s32 i, j;
      476 ( 0.00%)      mtxf_identity(arg0);
    2,856 ( 0.00%)  => src/racing/math_util.c:mtxf_identity (476x)
    2,856 ( 0.00%)      arg2 *= 0.017453292222222222;
    2,380 ( 0.00%)      temp = cosf(arg2 / 2) / sinf(arg2 / 2);
   12,852 ( 0.00%)  => ???:0x000000000007c940 (476x)
      952 ( 0.00%)      arg0[0][0] = temp / arg3;
      476 ( 0.00%)      arg0[1][1] = temp;
    3,332 ( 0.00%)      arg0[2][2] = (arg4 + arg5) / (arg4 - arg5);
      476 ( 0.00%)      arg0[2][3] = -1.0f;
    1,904 ( 0.00%)      arg0[3][2] = (2 * arg4 * arg5) / (arg4 - arg5);
      952 ( 0.00%)      arg0[3][3] = 0.0f;
        .           
        .               for (i = 0; i < 4; i++) {
        .                   for (j = 0; j < 4; j++) {
    1,904 ( 0.00%)              arg0[i][j] *= arg6;
        .                   }
        .               }
        .           
      952 ( 0.00%)      if (arg1 != 0) {
    1,428 ( 0.00%)          if ((arg4 + arg5) <= 2.0) {
      476 ( 0.00%)              *arg1 = 0xFFFF;
        .                   } else {
    4,284 ( 0.00%)              *arg1 = 131072.0 / (arg4 + arg5);
        .                       if (*arg1 <= 0) {
        .                           *arg1 = 1;
        .                       }
        .                   }
        .               }
    3,332 ( 0.00%)  }
        .           
        .           // Appears to only be for the skybox. mtxf_lookat from sm64 with some modifications.
        .           void func_802B5794(Mat4 mtx, Vec3f from, Vec3f to) {
        .               // register from sm64 but not required for matching.
        .               register f32 invLength;
        .               f32 xColY;
        .               f32 yColY;
        .               f32 zColY;
-- line 259 ----------------------------------------
-- line 263 ----------------------------------------
        .               f32 xColX;
        .               f32 yColX;
        .               f32 zColX;
        .           
        .               xColY = 0.0f;
        .               yColY = 1.0f;
        .               zColY = 0.0f;
        .           
      952 ( 0.00%)      xColZ = to[0] - from[0];
      952 ( 0.00%)      yColZ = to[1] - from[1];
      952 ( 0.00%)      zColZ = to[2] - from[2];
        .           
    3,332 ( 0.00%)      invLength = -1.0 / sqrtf(xColZ * xColZ + yColZ * yColZ + zColZ * zColZ);
      476 ( 0.00%)      xColZ *= invLength;
      476 ( 0.00%)      yColZ *= invLength;
      476 ( 0.00%)      zColZ *= invLength;
        .           
    1,428 ( 0.00%)      xColX = yColY * zColZ - zColY * yColZ;
      952 ( 0.00%)      yColX = zColY * xColZ - xColY * zColZ;
      952 ( 0.00%)      zColX = xColY * yColZ - yColY * xColZ;
        .           
    2,380 ( 0.00%)      invLength = 1.0 / sqrtf(xColX * xColX + yColX * yColX + zColX * zColX);
        .           
      476 ( 0.00%)      xColX *= invLength;
      476 ( 0.00%)      yColX *= invLength;
      476 ( 0.00%)      zColX *= invLength;
        .           
      952 ( 0.00%)      xColY = yColZ * zColX - zColZ * yColX;
      952 ( 0.00%)      yColY = zColZ * xColX - xColZ * zColX;
      952 ( 0.00%)      zColY = xColZ * yColX - yColZ * xColX;
        .           
    2,380 ( 0.00%)      invLength = 1.0 / sqrtf(xColY * xColY + yColY * yColY + zColY * zColY);
      476 ( 0.00%)      xColY *= invLength;
      476 ( 0.00%)      yColY *= invLength;
      476 ( 0.00%)      zColY *= invLength;
        .           
      476 ( 0.00%)      mtx[0][0] = xColX;
      476 ( 0.00%)      mtx[1][0] = yColX;
      476 ( 0.00%)      mtx[2][0] = zColX;
    1,904 ( 0.00%)      mtx[3][0] = -(from[0] * xColX + from[1] * yColX + from[2] * zColX);
        .           
      476 ( 0.00%)      mtx[0][1] = xColY;
      476 ( 0.00%)      mtx[1][1] = yColY;
      476 ( 0.00%)      mtx[2][1] = zColY;
    1,904 ( 0.00%)      mtx[3][1] = -(from[0] * xColY + from[1] * yColY + from[2] * zColY);
        .           
      476 ( 0.00%)      mtx[0][2] = xColZ;
      476 ( 0.00%)      mtx[1][2] = yColZ;
      476 ( 0.00%)      mtx[2][2] = zColZ;
    1,904 ( 0.00%)      mtx[3][2] = -(from[0] * xColZ + from[1] * yColZ + from[2] * zColZ);
        .           
      476 ( 0.00%)      mtx[0][3] = 0.0f;
      476 ( 0.00%)      mtx[1][3] = 0.0f;
      476 ( 0.00%)      mtx[2][3] = 0.0f;
      476 ( 0.00%)      mtx[3][3] = 1.0f;
      476 ( 0.00%)  }
        .           
        .           // create a rotation matrix around the x axis
   32,800 ( 0.00%)  void mtxf_rotate_x(Mat4 mat, s16 angle) {
   26,240 ( 0.00%)      f32 sin_theta = sins(angle);
   32,800 ( 0.00%)  => src/racing/math_util.c:sins (6,560x)
   19,680 ( 0.00%)      f32 cos_theta = coss(angle);
   39,360 ( 0.00%)  => src/racing/math_util.c:coss (6,560x)
        .           
   32,800 ( 0.00%)      mtxf_identity(mat);
   39,360 ( 0.00%)  => src/racing/math_util.c:mtxf_identity (6,560x)
    6,560 ( 0.00%)      mat[1][1] = cos_theta;
        .               mat[1][2] = sin_theta;
   32,800 ( 0.00%)      mat[2][1] = -sin_theta;
        .               mat[2][2] = cos_theta;
        .           
        .               /*
        .                * 1, 0, 0, 0,
        .                * 0, cos_theta, sin_theta, 0,
        .                * 0, -sin_theta, cos_theta, 0,
        .                * 0, 0, 0, 1
        .                */
   32,800 ( 0.00%)  }
        .           
        .           // create a rotation matrix around the y axis
        .           void mtxf_rotate_y(Mat4 mat, s16 angle) {
        .               f32 sin_theta = sins(angle);
        .               f32 cos_theta = coss(angle);
        .           
        .               mtxf_identity(mat);
        .               mat[0][0] = cos_theta;
-- line 345 ----------------------------------------
-- line 417 ----------------------------------------
        .               arg2[1] = sp2C;
        .               arg2[2] = -(sp28 * temp_f10);
        .           }
        .           
        .           void func_802B5D30(s16 arg0, s16 arg1, s32 arg2) {
        .               func_802B5D64((Lights1*) 0x9000000, arg0, arg1, arg2);
        .           }
        .           
    7,616 ( 0.00%)  void func_802B5D64(Lights1* addr, s16 arg1, s16 arg2, s32 arg3) {
        .               UNUSED s32 pad;
        .               f32 sp48;
        .               f32 sp44;
        .               f32 sp40;
        .               UNUSED s32 pad2[2];
        .               f32 temp_f10;
        .               s32 var_v0;
        .               s8 sp2C[3];
        .               Lights1* var_s0;
        .           
        .               var_s0 = (Lights1*) addr;
    3,808 ( 0.00%)      sp48 = sins(arg2);
    4,760 ( 0.00%)  => src/racing/math_util.c:sins (952x)
    2,856 ( 0.00%)      sp44 = coss(arg2);
    5,712 ( 0.00%)  => src/racing/math_util.c:coss (952x)
    3,808 ( 0.00%)      sp40 = sins(arg1);
    4,760 ( 0.00%)  => src/racing/math_util.c:sins (952x)
    2,856 ( 0.00%)      temp_f10 = coss(arg1);
    5,712 ( 0.00%)  => src/racing/math_util.c:coss (952x)
    6,664 ( 0.00%)      sp2C[0] = sp44 * sp40 * 120.0f;
    2,856 ( 0.00%)      sp2C[1] = 120.0f * sp48;
    1,904 ( 0.00%)      sp2C[2] = sp44 * temp_f10 * -120.0f;
    8,568 ( 0.00%)      for (var_v0 = 0; var_v0 < arg3; var_v0++, var_s0++) {
      952 ( 0.00%)          var_s0->l[0].l.dir[0] = sp2C[0];
        .                   var_s0->l[0].l.dir[1] = sp2C[1];
      952 ( 0.00%)          var_s0->l[0].l.dir[2] = sp2C[2];
        .               }
    5,712 ( 0.00%)  }
        .           
        .           // multiply a matrix with a number
        .           void mtxf_scale(Mat4 mat, f32 coef) {
        .               mat[0][0] *= coef;
        .               mat[1][0] *= coef;
        .               mat[2][0] *= coef;
        .               mat[0][1] *= coef;
        .               mat[1][1] *= coef;
        .               mat[2][1] *= coef;
        .               mat[0][2] *= coef;
        .               mat[1][2] *= coef;
        .               mat[2][2] *= coef;
        .           }
        .           
        .           // look like create a translation and rotation matrix with arg1 position and arg2 rotation
  270,067 ( 0.00%)  void mtxf_pos_rotation_xyz(Mat4 out, Vec3f pos, Vec3s orientation) {
        .               f32 sine1;
        .               f32 cosine1;
        .               f32 sine2;
        .               f32 cosine2;
        .               f32 sine3;
        .               f32 cosine3;
        .           
  115,743 ( 0.00%)      sine1 = sins(orientation[0]);
  192,905 ( 0.00%)  => src/racing/math_util.c:sins (38,581x)
  115,743 ( 0.00%)      cosine1 = coss(orientation[0]);
  231,486 ( 0.00%)  => src/racing/math_util.c:coss (38,581x)
  115,743 ( 0.00%)      sine2 = sins(orientation[1]);
  192,905 ( 0.00%)  => src/racing/math_util.c:sins (38,581x)
  115,743 ( 0.00%)      cosine2 = coss(orientation[1]);
  231,486 ( 0.00%)  => src/racing/math_util.c:coss (38,581x)
  115,743 ( 0.00%)      sine3 = sins(orientation[2]);
  192,905 ( 0.00%)  => src/racing/math_util.c:sins (38,581x)
   77,162 ( 0.00%)      cosine3 = coss(orientation[2]);
  231,486 ( 0.00%)  => src/racing/math_util.c:coss (38,581x)
  308,648 ( 0.00%)      out[0][0] = (cosine2 * cosine3) + ((sine1 * sine2) * sine3);
  115,743 ( 0.00%)      out[1][0] = (-cosine2 * sine3) + ((sine1 * sine2) * cosine3);
  115,743 ( 0.00%)      out[2][0] = cosine1 * sine2;
   77,162 ( 0.00%)      out[3][0] = pos[0];
   77,162 ( 0.00%)      out[0][1] = cosine1 * sine3;
   77,162 ( 0.00%)      out[1][1] = cosine1 * cosine3;
   77,162 ( 0.00%)      out[2][1] = -sine1;
   77,162 ( 0.00%)      out[3][1] = pos[1];
  154,324 ( 0.00%)      out[0][2] = (-sine2 * cosine3) + ((sine1 * cosine2) * sine3);
  115,743 ( 0.00%)      out[1][2] = (sine2 * sine3) + ((sine1 * cosine2) * cosine3);
   77,162 ( 0.00%)      out[2][2] = cosine1 * cosine2;
   77,162 ( 0.00%)      out[3][2] = pos[2];
   38,581 ( 0.00%)      out[0][3] = 0.0f;
   38,581 ( 0.00%)      out[1][3] = 0.0f;
   38,581 ( 0.00%)      out[2][3] = 0.0f;
   38,581 ( 0.00%)      out[3][3] = 1.0f;
  192,905 ( 0.00%)  }
        .           
        .           UNUSED void func_802B60B4(Mat4 arg0, Vec3s arg1, Vec3s arg2) {
        .               f32 sine1;
        .               f32 cosine1;
        .               f32 sine2;
        .               f32 cosine2;
        .               f32 sine3;
        .               f32 cosine3;
-- line 503 ----------------------------------------
-- line 568 ----------------------------------------
        .           }
        .           
        .           // translate the vector with a matrix
        .           void mtxf_translate_vec3f_mat3(Vec3f pos, Mat3 mat) {
        .               f32 new_x;
        .               f32 new_y;
        .               f32 new_z;
        .           
   88,572 ( 0.00%)      new_x = (mat[0][0] * pos[0]) + (mat[0][1] * pos[1]) + (mat[0][2] * pos[2]);
   44,286 ( 0.00%)      new_y = (mat[1][0] * pos[0]) + (mat[1][1] * pos[1]) + (mat[1][2] * pos[2]);
   44,286 ( 0.00%)      new_z = (mat[2][0] * pos[0]) + (mat[2][1] * pos[1]) + (mat[2][2] * pos[2]);
        .           
   14,762 ( 0.00%)      pos[0] = new_x;
   14,762 ( 0.00%)      pos[1] = new_y;
   14,762 ( 0.00%)      pos[2] = new_z;
   14,762 ( 0.00%)  }
        .           
        .           // translate the vector with a matrix (with a matrix 4x4)
        .           void mtxf_translate_vec3f_mat4(Vec3f pos, Mat4 mat) {
        .               f32 new_x;
        .               f32 new_y;
        .               f32 new_z;
        .           
    2,856 ( 0.00%)      new_x = (mat[0][0] * pos[0]) + (mat[0][1] * pos[1]) + (mat[0][2] * pos[2]);
    1,428 ( 0.00%)      new_y = (mat[1][0] * pos[0]) + (mat[1][1] * pos[1]) + (mat[1][2] * pos[2]);
    1,428 ( 0.00%)      new_z = (mat[2][0] * pos[0]) + (mat[2][1] * pos[1]) + (mat[2][2] * pos[2]);
        .           
      476 ( 0.00%)      pos[0] = new_x;
      476 ( 0.00%)      pos[1] = new_y;
      476 ( 0.00%)      pos[2] = new_z;
      476 ( 0.00%)  }
        .           
        .           UNUSED void func_802B64B0(UNUSED s32 arg0, UNUSED s32 arg1, UNUSED s32 arg2, UNUSED s32 arg3) {
        .           }
        .           
        .           void func_802B64C4(Vec3f arg0, s16 arg1) {
        .               f32 sp2C = sins(arg1);
        .               f32 temp_f0 = coss(arg1);
        .           
-- line 606 ----------------------------------------
-- line 608 ----------------------------------------
        .               f32 temp2 = arg0[1];
        .               f32 temp3 = arg0[2];
        .           
        .               arg0[0] = temp_f0 * temp1 - (sp2C * temp3);
        .               arg0[1] = temp2;
        .               arg0[2] = sp2C * temp1 + (temp_f0 * temp3);
        .           }
        .           
   81,718 ( 0.00%)  void calculate_orientation_matrix(Mat3 dest, f32 arg1, f32 arg2, f32 arg3, s16 rotationAngle) {
        .               Mat3 mtx_rot_y;
        .               Mat3 matrix;
        .               s32 i, j;
        .               f32 a;
        .               f32 b;
        .               f32 c;
        .               f32 d;
        .               UNUSED s32 pad[3];
        .               f32 sinValue;
        .               f32 cossValue;
        .           
   25,144 ( 0.00%)      sinValue = sins(rotationAngle);
   31,430 ( 0.00%)  => src/racing/math_util.c:sins (6,286x)
   18,858 ( 0.00%)      cossValue = coss(rotationAngle);
   37,716 ( 0.00%)  => src/racing/math_util.c:coss (6,286x)
        .               mtx_rot_y[0][0] = cossValue;
        .               mtx_rot_y[2][1] = 0;
        .               mtx_rot_y[1][2] = 0;
        .           
        .               mtx_rot_y[1][1] = 1;
        .               mtx_rot_y[2][0] = sinValue;
   25,144 ( 0.00%)      mtx_rot_y[0][2] = -sinValue;
        .           
        .               mtx_rot_y[2][2] = cossValue;
        .               mtx_rot_y[1][0] = 0;
        .               mtx_rot_y[0][1] = 0;
        .           
   94,290 ( 0.00%)      if (arg2 == 1) { // set matrix to identity
        .           
        .                   for (i = 0; i < 3; i++) {
        .                       for (j = 0; j < 3; j++) {
        .                           matrix[i][j] = (i == j) ? 1.0f : 0.0f;
        .                       }
        .                   }
        .           
        .               } else if (arg2 == -1) { // set matrix to identity with the second column negative
-- line 650 ----------------------------------------
-- line 659 ----------------------------------------
        .           
        .               } else {
        .                   a = (f32) - (360.0 - ((f64) (calculate_vector_angle_xy(arg2) * 180.0f) / M_PI));
        .                   b = -arg3 / sqrtf((arg1 * arg1) + (arg3 * arg3));
        .                   c = 0;
        .                   d = arg1 / sqrtf((arg1 * arg1) + (arg3 * arg3));
        .                   calculate_rotation_matrix(matrix, a, b, c, d);
        .               }
   62,860 ( 0.00%)      dest[0][0] = (mtx_rot_y[0][0] * matrix[0][0]) + (mtx_rot_y[0][1] * matrix[1][0]) + (mtx_rot_y[0][2] * matrix[2][0]);
        .               dest[1][0] = (mtx_rot_y[1][0] * matrix[0][0]) + (mtx_rot_y[1][1] * matrix[1][0]) + (mtx_rot_y[1][2] * matrix[2][0]);
   12,572 ( 0.00%)      dest[2][0] = (mtx_rot_y[2][0] * matrix[0][0]) + (mtx_rot_y[2][1] * matrix[1][0]) + (mtx_rot_y[2][2] * matrix[2][0]);
        .           
   18,858 ( 0.00%)      dest[0][1] = (mtx_rot_y[0][0] * matrix[0][1]) + (mtx_rot_y[0][1] * matrix[1][1]) + (mtx_rot_y[0][2] * matrix[2][1]);
        .               dest[1][1] = (mtx_rot_y[1][0] * matrix[0][1]) + (mtx_rot_y[1][1] * matrix[1][1]) + (mtx_rot_y[1][2] * matrix[2][1]);
   12,572 ( 0.00%)      dest[2][1] = (mtx_rot_y[2][0] * matrix[0][1]) + (mtx_rot_y[2][1] * matrix[1][1]) + (mtx_rot_y[2][2] * matrix[2][1]);
        .           
   12,572 ( 0.00%)      dest[0][2] = (mtx_rot_y[0][0] * matrix[0][2]) + (mtx_rot_y[0][1] * matrix[1][2]) + (mtx_rot_y[0][2] * matrix[2][2]);
        .               dest[1][2] = (mtx_rot_y[1][0] * matrix[0][2]) + (mtx_rot_y[1][1] * matrix[1][2]) + (mtx_rot_y[1][2] * matrix[2][2]);
   25,144 ( 0.00%)      dest[2][2] = (mtx_rot_y[2][0] * matrix[0][2]) + (mtx_rot_y[2][1] * matrix[1][2]) + (mtx_rot_y[2][2] * matrix[2][2]);
   44,002 ( 0.00%)  }
        .           
        .           // include in calculate_orientation_matrix
        .           UNUSED void func_802B68F8(Mat3 matrix, f32 arg1, f32 arg2, f32 arg3) {
        .               s32 i, j;
        .               f32 a;
        .               f32 b;
        .               f32 c;
        .               f32 d;
-- line 686 ----------------------------------------
-- line 807 ----------------------------------------
        .               arg0[2][2] = cosine1 * cosine2;
        .               arg0[3][2] = arg1[2];
        .               arg0[0][3] = 0.0f;
        .               arg0[1][3] = 0.0f;
        .               arg0[2][3] = 0.0f;
        .               arg0[3][3] = 1.0f;
        .           }
        .           
   28,144 ( 0.00%)  void mtxf_multiplication(Mat4 dest, Mat4 mat1, Mat4 mat2) {
        .               Mat4 product;
   14,072 ( 0.00%)      product[0][0] =
  168,864 ( 0.00%)          (mat1[0][0] * mat2[0][0]) + (mat1[0][1] * mat2[1][0]) + (mat1[0][2] * mat2[2][0]) + (mat1[0][3] * mat2[3][0]);
        .               product[0][1] =
        .                   (mat1[0][0] * mat2[0][1]) + (mat1[0][1] * mat2[1][1]) + (mat1[0][2] * mat2[2][1]) + (mat1[0][3] * mat2[3][1]);
        .               product[0][2] =
        .                   (mat1[0][0] * mat2[0][2]) + (mat1[0][1] * mat2[1][2]) + (mat1[0][2] * mat2[2][2]) + (mat1[0][3] * mat2[3][2]);
        .               product[0][3] =
        .                   (mat1[0][0] * mat2[0][3]) + (mat1[0][1] * mat2[1][3]) + (mat1[0][2] * mat2[2][3]) + (mat1[0][3] * mat2[3][3]);
        .               product[1][0] =
        .                   (mat1[1][0] * mat2[0][0]) + (mat1[1][1] * mat2[1][0]) + (mat1[1][2] * mat2[2][0]) + (mat1[1][3] * mat2[3][0]);
-- line 826 ----------------------------------------
-- line 841 ----------------------------------------
        .               product[3][0] =
        .                   (mat1[3][0] * mat2[0][0]) + (mat1[3][1] * mat2[1][0]) + (mat1[3][2] * mat2[2][0]) + (mat1[3][3] * mat2[3][0]);
        .               product[3][1] =
        .                   (mat1[3][0] * mat2[0][1]) + (mat1[3][1] * mat2[1][1]) + (mat1[3][2] * mat2[2][1]) + (mat1[3][3] * mat2[3][1]);
        .               product[3][2] =
        .                   (mat1[3][0] * mat2[0][2]) + (mat1[3][1] * mat2[1][2]) + (mat1[3][2] * mat2[2][2]) + (mat1[3][3] * mat2[3][2]);
        .               product[3][3] =
        .                   (mat1[3][0] * mat2[0][3]) + (mat1[3][1] * mat2[1][3]) + (mat1[3][2] * mat2[2][3]) + (mat1[3][3] * mat2[3][3]);
   28,144 ( 0.00%)      mtxf_copy_n_element((s32*) dest, (s32*) product, 16);
  288,476 ( 0.00%)  => src/racing/math_util.c:mtxf_copy_n_element (7,036x)
   14,072 ( 0.00%)  }
        .           
        .           /**
        .            * Convert float matrix 'src' to fixed point matrix 'dest'.
        .            * The float matrix may not contain entries larger than 65536 or the console
        .            * crashes. The fixed point matrix has entries with a 16-bit integer part, so
        .            * the floating point numbers are multiplied by 2^16 before being cast to a s32
        .            * integer. If this doesn't fit, the N64 and iQue consoles will throw an
        .            * exception. On Wii and Wii U Virtual Console the value will simply be clamped
        .            * and no crashes occur.
        .            */
   93,138 ( 0.00%)  void mtxf_to_mtx(Mtx* dest, Mat4 src) {
        .           #ifdef AVOID_UB
        .               // Avoid type-casting which is technically UB by calling the equivalent
        .               // guMtxF2L function. This helps little-endian systems, as well.
   93,138 ( 0.00%)      guMtxF2L(src, dest);
1,536,777 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guMtxF2L.c:guMtxF2L (46,569x)
        .           #else
        .               s32 asFixedPoint;
        .               register s32 i;
        .               register s16* a3 = (s16*) dest;      // all integer parts stored in first 16 bytes
        .               register s16* t0 = (s16*) dest + 16; // all fraction parts stored in last 16 bytes
        .               register f32* t1 = (f32*) src;
        .           
        .               for (i = 0; i < 16; i++) {
-- line 873 ----------------------------------------
-- line 883 ----------------------------------------
        .            *
        .            * Helper function for atan2s. Does a look up of the arctangent of y/x assuming
        .            * the resulting angle is in range [0, 0x2000] (1/8 of a circle).
        .            */
        .           
        .           u16 atan2_lookup(f32 y, f32 x) {
        .               u16 ret;
        .           
  189,828 ( 0.00%)      if (x == 0) {
        .                   ret = gArctanTable[0];
        .               } else {
  142,371 ( 0.00%)          if (1000000.0f < y / x) {
        .                       if (y > 0.0f) {
        .                           ret = 0x4000;
        .                       } else {
        .                           ret = 0xC000;
        .                       }
        .                   } else {
  284,742 ( 0.00%)              ret = gArctanTable[(s32) (y / x * 1024 + 0.5f)];
        .                   }
        .               }
        .               return ret;
   47,457 ( 0.00%)  }
        .           
        .           /**
        .            * Compute the angle from (0, 0) to (x, y) as a u16. Given that terrain is in
        .            * the xz-plane, this is commonly called with (z, x) to get a yaw angle.
        .            * sm64 but x, y swapped and returns u16.
        .            */
  142,371 ( 0.00%)  u16 atan2s(f32 x, f32 y) {
        .               u16 ret;
  142,371 ( 0.00%)      if (x >= 0) {
   81,016 ( 0.00%)          if (y >= 0) {
   56,396 ( 0.00%)              if (y >= x) {
   23,231 ( 0.00%)                  ret = atan2_lookup(x, y);
  325,234 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (23,231x)
        .                       } else {
   29,802 ( 0.00%)                  ret = 0x4000 - atan2_lookup(y, x);
   69,538 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (4,967x)
        .                       }
        .                   } else {
   12,310 ( 0.00%)              y = -y;
   24,620 ( 0.00%)              if (y < x) {
   11,985 ( 0.00%)                  ret = 0x4000 + atan2_lookup(y, x);
   55,930 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (3,995x)
        .                       } else {
   49,890 ( 0.00%)                  ret = 0x8000 - atan2_lookup(x, y);
  116,410 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (8,315x)
        .                       }
        .                   }
        .               } else {
   13,898 ( 0.00%)          x = -x;
   13,898 ( 0.00%)          if (y < 0) {
    4,364 ( 0.00%)              y = -y;
    8,728 ( 0.00%)              if (y >= x) {
   15,356 ( 0.00%)                  ret = 0x8000 + atan2_lookup(x, y);
   53,746 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (3,839x)
        .                       } else {
    3,675 ( 0.00%)                  ret = 0xC000 - atan2_lookup(y, x);
    7,350 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (525x)
        .                       }
        .                   } else {
    5,170 ( 0.00%)              if (y < x) {
    5,540 ( 0.00%)                  ret = 0xC000 + atan2_lookup(y, x);
   19,390 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (1,385x)
        .                       } else {
    3,600 ( 0.00%)                  ret = -atan2_lookup(x, y);
   16,800 ( 0.00%)  => src/racing/math_util.c:atan2_lookup (1,200x)
        .                       }
        .                   }
        .               }
        .               return ret;
   71,683 ( 0.00%)  }
        .           
        .           f32 atan2f(f32 arg0, f32 arg1) {
        .               return atan2s(arg0, arg1);
        .           }
        .           
        .           #ifndef NON_MATCHING // The decomp does not support fabs
        .           UNUSED f32 func_802B79F0(f32 arg0, f32 arg1) {
        .               f64 halfpi;
-- line 955 ----------------------------------------
-- line 997 ----------------------------------------
        .               return ((atan2f(arg0, arg1) * 32768.0f) / M_PI);
        .           }
        .           
        .           UNUSED void func_802B7C18(f32 arg0) {
        .               atan2f(arg0, 1.0f);
        .           }
        .           
        .           s16 func_802B7C40(f32 arg0) {
   21,224 ( 0.00%)      return atan2s(arg0, 1.0f);
  275,912 ( 0.00%)  => src/racing/math_util.c:atan2s (10,612x)
        .           }
        .           
        .           UNUSED void func_802B7C6C(f32 arg0) {
        .               atan2f(arg0, sqrtf(1.0 - (arg0 * arg0)));
        .           }
        .           
    5,980 ( 0.00%)  s16 func_802B7CA8(f32 arg0) {
   47,840 ( 0.00%)      return atan2s(arg0, sqrtf(1.0 - (arg0 * arg0)));
  155,486 ( 0.00%)  => src/racing/math_util.c:atan2s (5,980x)
        .           }
        .           
        .           f32 calculate_vector_angle_xy(f32 vectorX) {
        .               return atan2f(sqrtf(1.0 - (vectorX * vectorX)), vectorX);
        .           }
        .           
        .           UNUSED s16 func_802B7D28(f32 arg0) {
        .               return atan2f(sqrtf(1.0 - (f64) (arg0 * arg0)), arg0) * 32768.0f / M_PI;
        .           }
        .           
        .           u16 random_u16(void) {
        .               u16 temp1, temp2;
        .           
  287,475 ( 0.00%)      if (gRandomSeed16 == 22026) {
        .                   gRandomSeed16 = 0;
        .               }
        .           
  114,990 ( 0.00%)      temp1 = (gRandomSeed16 & 0x00FF) << 8;
   57,495 ( 0.00%)      temp1 = temp1 ^ gRandomSeed16;
        .           
  114,990 ( 0.00%)      gRandomSeed16 = ((temp1 & 0x00FF) << 8) + ((temp1 & 0xFF00) >> 8);
        .           
  172,485 ( 0.00%)      temp1 = ((temp1 & 0x00FF) << 1) ^ gRandomSeed16;
  114,990 ( 0.00%)      temp2 = (temp1 >> 1) ^ 0xFF80;
        .           
  114,990 ( 0.00%)      if ((temp1 & 1) == 0) {
   57,444 ( 0.00%)          if (temp2 == 43605) {
        .                       gRandomSeed16 = 0;
        .                   } else {
  143,661 ( 0.00%)              gRandomSeed16 = temp2 ^ 0x1FF4;
        .                   }
        .               } else {
   57,546 ( 0.00%)          gRandomSeed16 = temp2 ^ 0x8180;
        .               }
        .           
        .               return gRandomSeed16;
   57,495 ( 0.00%)  }
        .           
   57,462 ( 0.00%)  u16 random_int(u16 arg0) {
  632,082 ( 0.00%)      return arg0 * (((f32) random_u16()) / 65535.0);
1,292,814 ( 0.00%)  => src/racing/math_util.c:random_u16 (57,462x)
  114,924 ( 0.00%)  }
        .           
        .           s16 func_802B7F34(f32 arg0, f32 arg1, f32 arg2, f32 arg3) {
        9 ( 0.00%)      return atan2s(arg2 - arg0, arg3 - arg1);
       98 ( 0.00%)  => src/racing/math_util.c:atan2s (3x)
        .           }
        .           
        3 ( 0.00%)  void func_802B7F7C(Vec3f arg0, Vec3f arg1, Vec3s dest) {
        1 ( 0.00%)      f32 x1 = arg0[0];
        2 ( 0.00%)      f32 y1 = arg0[1];
        1 ( 0.00%)      f32 z1 = arg0[2];
        .           
        1 ( 0.00%)      f32 x2 = arg1[0];
        2 ( 0.00%)      f32 y2 = arg1[1];
        1 ( 0.00%)      f32 z2 = arg1[2];
        .           
        8 ( 0.00%)      dest[1] = func_802B7F34(z1, x1, z2, x2);
       35 ( 0.00%)  => src/racing/math_util.c:func_802B7F34 (1x)
        8 ( 0.00%)      dest[0] = func_802B7F34(y1, z1, y2, z2);
       36 ( 0.00%)  => src/racing/math_util.c:func_802B7F34 (1x)
        8 ( 0.00%)      dest[2] = func_802B7F34(x1, y1, x2, y2);
       36 ( 0.00%)  => src/racing/math_util.c:func_802B7F34 (1x)
        3 ( 0.00%)  }
        .           
        .           f32 sins(u16 arg0) {
1,947,440 ( 0.00%)      return gSineTable[arg0 >> 4];
  486,860 ( 0.00%)  }
        .           
        .           f32 coss(u16 arg0) {
2,311,345 ( 0.00%)      return gCosineTable[arg0 >> 4];
  462,269 ( 0.00%)  }
        .           
        .           s32 is_visible_between_angle(u16 arg0, u16 arg1, u16 arg2) {
        .               if (arg1 < arg0) {
   51,404 ( 0.00%)          if (arg1 >= arg2) {
        .                       return 0;
        .                   }
  179,914 ( 0.00%)          if (arg2 >= arg0) {
        .                       return 0;
        .                   }
        .               } else {
        .                   if ((arg1 >= arg2) && (arg2 >= arg0)) {
        .                       return 0;
        .                   }
        .               }
        .               return 1;
   77,106 ( 0.00%)  }
        .           
        .           /**
        .            * Determines whether an object is within the render distance of a camera.
        .            *
        .            * @param cameraPos       The position of the camera in 3D space.
        .            * @param objectPos       The position of the object in 3D space.
        .            * @param orientationY    The orientation angle of the object around the Y-axis.
        .            * @param minDistance     The minimum distance at which the object is considered within render distance.
        .            * @param fov             The field of view (FOV) of the camera.
        .            * @param maxDistance     The maximum render distance.
        .            * @return                The distance between the camera and the object if it's within render distance,
        .            *                        or -1.0f if it exceeds the render distance.
        .            */
        .           
        .           f32 is_within_render_distance(Vec3f cameraPos, Vec3f objectPos, u16 orientationY, f32 minDistance, f32 fov,
   68,870 ( 0.00%)                                f32 maxDistance) {
        .               u16 angleObject;
        .               UNUSED u16 pad;
        .               u16 temp_v0;
        .               f32 distanceX;
        .               f32 distance;
        .               f32 distanceY;
        .               s32 plus_fov_angle;
        .               s32 minus_fov_angle;
        .               u16 temp;
        .               UNUSED s32 pad2[3];
   27,498 ( 0.00%)      u16 extended_fov = ((u16) fov * 0xB6);
        .           
   27,548 ( 0.00%)      distanceX = objectPos[0] - cameraPos[0];
   13,774 ( 0.00%)      distanceX = distanceX * distanceX;
   27,548 ( 0.00%)      if (maxDistance < distanceX) {
    9,666 ( 0.00%)          return -1.0f;
        .               }
        .           
   41,322 ( 0.00%)      distanceY = objectPos[2] - cameraPos[2];
   13,774 ( 0.00%)      distanceY = distanceY * distanceY;
   27,548 ( 0.00%)      if (maxDistance < distanceY) {
        .                   return -1.0f;
        .               }
        .           
   13,774 ( 0.00%)      distance = distanceX + distanceY;
   41,322 ( 0.00%)      if (distance < minDistance) {
        .                   return distance;
        .               }
        .           
   41,247 ( 0.00%)      if (distance > maxDistance) {
        .                   return -1.0f;
        .               }
        .           
   27,498 ( 0.00%)      angleObject = get_angle_between_two_vectors(cameraPos, objectPos);
  552,117 ( 0.00%)  => src/racing/math_util.c:get_angle_between_two_vectors (13,749x)
        .               minus_fov_angle = (orientationY - extended_fov);
        .               plus_fov_angle = (orientationY + extended_fov);
        .           
   88,206 ( 0.00%)      if (minDistance == 0.0f) {
   96,243 ( 0.00%)          if (is_visible_between_angle((orientationY + extended_fov), (orientationY - extended_fov), angleObject) == 1) {
        .                       return distance;
        .                   }
        .                   return -1.0f;
        .               }
        .           
   64,296 ( 0.00%)      if (is_visible_between_angle((u16) plus_fov_angle, (u16) minus_fov_angle, angleObject) == 1) {
   96,444 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (8,037x)
        .                   return distance;
        .               }
   23,920 ( 0.00%)      temp_v0 = func_802B7CA8(minDistance / distance);
  209,306 ( 0.00%)  => src/racing/math_util.c:func_802B7CA8 (5,980x)
    5,980 ( 0.00%)      temp = angleObject + temp_v0;
        .           
   41,860 ( 0.00%)      if (is_visible_between_angle(plus_fov_angle, minus_fov_angle, temp) == 1) {
   71,760 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (5,980x)
        .                   return distance;
        .               }
        .           
    5,973 ( 0.00%)      temp = angleObject - temp_v0;
   84,075 ( 0.00%)      if (is_visible_between_angle(plus_fov_angle, minus_fov_angle, temp) == 1) {
  140,220 ( 0.00%)  => src/racing/math_util.c:is_visible_between_angle (11,685x)
        .                   return distance;
        .               }
        .               return -1.0f;
   96,418 ( 0.00%)  }
        .           
        .           // No idea if arg1 is actually a Mat4 or not, but since this function is unused
        .           // its impossible to know with certainty either way, very close of func_802B5D64
        .           UNUSED void func_802B8414(uintptr_t addr, Mat4 arg1, s16 arg2, s16 arg3, s32 arg4) {
        .               UNUSED s32 pad;
        .               Vec3f sp40;
        .               s8 sp3C[3];
        .               s32 var_v0;
-- line 1180 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_function.h
--------------------------------------------------------------------------------
Ir                  

-- line 367 ----------------------------------------
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct equal_to : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
         .                 operator()(const _Tp& __x, const _Tp& __y) const
25,193,805 ( 0.04%)        { return __x == __y; }
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct not_equal_to : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
-- line 383 ----------------------------------------
-- line 396 ----------------------------------------
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct less : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
   146,942 ( 0.00%)        operator()(const _Tp& __x, const _Tp& __y) const
        31 ( 0.00%)        { return __x < __y; }
         .               };
         .           
         .             /// One of the @link comparison_functors comparison functors@endlink.
         .             template<typename _Tp>
         .               struct greater_equal : public binary_function<_Tp, _Tp, bool>
         .               {
         .                 _GLIBCXX14_CONSTEXPR
         .                 bool
-- line 413 ----------------------------------------
-- line 1172 ----------------------------------------
         .               : public unary_function<_Pair, typename _Pair::first_type>
         .               {
         .                 typename _Pair::first_type&
         .                 operator()(_Pair& __x) const
         .                 { return __x.first; }
         .           
         .                 const typename _Pair::first_type&
         .                 operator()(const _Pair& __x) const
        19 ( 0.00%)        { return __x.first; }
         .           
         .           #if __cplusplus >= 201103L
         .                 template<typename _Pair2>
         .                   typename _Pair2::first_type&
         .                   operator()(_Pair2& __x) const
         .                   { return __x.first; }
         .           
         .                 template<typename _Pair2>
-- line 1188 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir                  

-- line 105 ----------------------------------------
         .           
         .               template<typename _Pair>
         .                 struct __1st_type<_Pair&>
         .                 { using type = typename __1st_type<_Pair>::type&; };
         .           
         .               template<typename _Tp>
         .                 typename __1st_type<_Tp>::type&&
         .                 operator()(_Tp&& __x) const noexcept
       401 ( 0.00%)        { return std::forward<_Tp>(__x).first; }
         .             };
         .           
         .             template<typename _ExKey, typename _Value>
         .               struct _ConvertToValueType;
         .           
         .             template<typename _Value>
         .               struct _ConvertToValueType<_Identity, _Value>
         .               {
-- line 121 ----------------------------------------
-- line 154 ----------------------------------------
         .               struct _NodeBuilder<_Select1st>
         .               {
         .                 template<typename _Kt, typename _Arg, typename _NodeGenerator>
         .           	static auto
         .           	_S_build(_Kt&& __k, _Arg&& __arg, const _NodeGenerator& __node_gen)
         .           	-> typename _NodeGenerator::__node_ptr
         .           	{
         .           	  return __node_gen(std::forward<_Kt>(__k),
        14 ( 0.00%)  			    std::forward<_Arg>(__arg).second);
         .           	}
         .               };
         .           
         .             template<>
         .               struct _NodeBuilder<_Identity>
         .               {
         .                 template<typename _Kt, typename _Arg, typename _NodeGenerator>
         .           	static auto
-- line 170 ----------------------------------------
-- line 311 ----------------------------------------
         .              *  template parameter of class template _Hashtable controls whether
         .              *  nodes also store a hash code. In some cases (e.g. strings) this
         .              *  may be a performance win.
         .              */
         .             struct _Hash_node_base
         .             {
         .               _Hash_node_base* _M_nxt;
         .           
    84,925 ( 0.00%)      _Hash_node_base() noexcept : _M_nxt() { }
         .           
         3 ( 0.00%)      _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
         .             };
         .           
         .             /**
         .              *  struct _Hash_node_value_base
         .              *
         .              *  Node type with the value to store.
         .              */
         .             template<typename _Value>
-- line 329 ----------------------------------------
-- line 378 ----------------------------------------
         .              *  Primary template struct _Hash_node.
         .              */
         .             template<typename _Value, bool _Cache_hash_code>
         .               struct _Hash_node
         .               : _Hash_node_base
         .               , _Hash_node_value<_Value, _Cache_hash_code>
         .               {
         .                 _Hash_node*
    76,600 ( 0.00%)        _M_next() const noexcept
   170,986 ( 0.00%)        { return static_cast<_Hash_node*>(this->_M_nxt); }
         .               };
         .           
         .             /// Base class for node iterators.
         .             template<typename _Value, bool _Cache_hash_code>
         .               struct _Node_iterator_base
         .               {
         .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
         .           
         .                 __node_type* _M_cur;
         .           
         .                 _Node_iterator_base() : _M_cur(nullptr) { }
       659 ( 0.00%)        _Node_iterator_base(__node_type* __p) noexcept
         .                 : _M_cur(__p) { }
         .           
         .                 void
         .                 _M_incr() noexcept
         .                 { _M_cur = _M_cur->_M_next(); }
         .           
         .                 friend bool
         .                 operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
-- line 407 ----------------------------------------
-- line 526 ----------------------------------------
         .             {
         .               typedef std::size_t first_argument_type;
         .               typedef std::size_t second_argument_type;
         .               typedef std::size_t result_type;
         .           
         .               result_type
         .               operator()(first_argument_type __num,
         .           	       second_argument_type __den) const noexcept
89,642,792 ( 0.15%)      { return __num % __den; }
         .             };
         .           
         .             /// Default ranged hash function H.  In principle it should be a
         .             /// function object composed from objects of type H1 and H2 such that
         .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
         .             /// h1 and h2.  So instead we'll just use a tag to tell class template
         .             /// hashtable to do that composition.
         .             struct _Default_ranged_hash { };
-- line 542 ----------------------------------------
-- line 543 ----------------------------------------
         .           
         .             /// Default value for rehash policy.  Bucket size is (usually) the
         .             /// smallest prime that keeps the load factor small enough.
         .             struct _Prime_rehash_policy
         .             {
         .               using __has_load_factor = true_type;
         .           
         .               _Prime_rehash_policy(float __z = 1.0) noexcept
       832 ( 0.00%)      : _M_max_load_factor(__z), _M_next_resize(0) { }
         .           
         .               float
         .               max_load_factor() const noexcept
         .               { return _M_max_load_factor; }
         .           
         .               // Return a bucket size no smaller than n.
         .               std::size_t
         .               _M_next_bkt(std::size_t __n) const;
-- line 559 ----------------------------------------
-- line 570 ----------------------------------------
         .               std::pair<bool, std::size_t>
         .               _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
         .           		   std::size_t __n_ins) const;
         .           
         .               typedef std::size_t _State;
         .           
         .               _State
         .               _M_state() const
    51,012 ( 0.00%)      { return _M_next_resize; }
         .           
         .               void
         .               _M_reset() noexcept
         3 ( 0.00%)      { _M_next_resize = 0; }
         .           
         .               void
         .               _M_reset(_State __state)
         .               { _M_next_resize = __state; }
         .           
         .               static const std::size_t _S_growth_factor = 2;
         .           
         .               float		_M_max_load_factor;
-- line 590 ----------------------------------------
-- line 813 ----------------------------------------
         .           	if (!__ite._M_cur)
         .           	  __throw_out_of_range(__N("unordered_map::at"));
         .           	return __ite->second;
         .                 }
         .           
         .                 const mapped_type&
         .                 at(const key_type& __k) const
         .                 {
49,946,796 ( 0.08%)  	auto __ite = static_cast<const __hashtable*>(this)->find(__k);
220,872,420 ( 0.37%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<Attribute, std::pair<Attribute const, std::any>, std::allocator<std::pair<Attribute const, std::any> >, std::__detail::_Select1st, std::equal_to<Attribute>, std::hash<Attribute>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::find(Attribute const&) const [clone .isra.0] (12,270,690x)
24,973,398 ( 0.04%)  	if (!__ite._M_cur)
         .           	  __throw_out_of_range(__N("unordered_map::at"));
         .           	return __ite->second;
         .                 }
         .               };
         .           
         .             template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
   361,244 ( 0.00%)      _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
         .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
         .               operator[](const key_type& __k)
         .               -> mapped_type&
         .               {
         .                 __hashtable* __h = static_cast<__hashtable*>(this);
         .                 __hash_code __code = __h->_M_hash_code(__k);
         .                 std::size_t __bkt = __h->_M_bucket_index(__code);
    48,312 ( 0.00%)        if (auto __node = __h->_M_find_node(__bkt, __k, __code))
    24,155 ( 0.00%)  	return __node->_M_v().second;
         .           
         .                 typename __hashtable::_Scoped_node __node {
         .           	__h,
         .           	std::piecewise_construct,
         .           	std::tuple<const key_type&>(__k),
         .           	std::tuple<>()
         .                 };
         .                 auto __pos
   182,291 ( 0.00%)  	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
 1,671,863 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*, unsigned long) (16,551x)
         .                 __node._M_node = nullptr;
    50,360 ( 0.00%)        return __pos->second;
   297,642 ( 0.00%)      }
         .           
         .             template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
     5,994 ( 0.00%)      _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
         .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
         .               operator[](key_type&& __k)
         .               -> mapped_type&
         .               {
         .                 __hashtable* __h = static_cast<__hashtable*>(this);
         .                 __hash_code __code = __h->_M_hash_code(__k);
         .                 std::size_t __bkt = __h->_M_bucket_index(__code);
     1,158 ( 0.00%)        if (auto __node = __h->_M_find_node(__bkt, __k, __code))
       579 ( 0.00%)  	return __node->_M_v().second;
         .           
         .                 typename __hashtable::_Scoped_node __node {
         .           	__h,
         .           	std::piecewise_construct,
         .           	std::forward_as_tuple(std::move(__k)),
         .           	std::tuple<>()
         .                 };
         .                 auto __pos
    83,202 ( 0.00%)  	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
 1,677,908 ( 0.00%)  => /usr/include/c++/14/bits/hashtable.h:std::_Hashtable<unsigned long, std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<unsigned long const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, false>*, unsigned long) (16,554x)
         .                 __node._M_node = nullptr;
    16,629 ( 0.00%)        return __pos->second;
     5,994 ( 0.00%)      }
         .           
         .             // Partial specialization for unordered_map<const T, U>, see PR 104174.
         .             template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits, bool __uniq>
         .               struct _Map_base<const _Key, pair<const _Key, _Val>,
         .           		     _Alloc, _Select1st, _Equal, _Hash,
         .           		     _RangeHash, _Unused, _RehashPolicy, _Traits, __uniq>
-- line 888 ----------------------------------------
-- line 1010 ----------------------------------------
         .                 void
         .                 _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           		   _Hash, _RangeHash, _Unused,
         .           		   _RehashPolicy, _Traits>::
         .                 _M_insert_range(_InputIterator __first, _InputIterator __last,
         .           		      const _NodeGetter& __node_gen, true_type __uks)
         .                 {
         .           	__hashtable& __h = _M_conjure_hashtable();
       200 ( 0.00%)  	for (; __first != __last; ++__first)
         .           	  __h._M_insert(*__first, __node_gen, __uks);
         .                 }
         .           
         .             template<typename _Key, typename _Value, typename _Alloc,
         .           	   typename _ExtractKey, typename _Equal,
         .           	   typename _Hash, typename _RangeHash, typename _Unused,
         .           	   typename _RehashPolicy, typename _Traits>
         .               template<typename _InputIterator, typename _NodeGetter>
-- line 1026 ----------------------------------------
-- line 1327 ----------------------------------------
         .           
         .                 _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
         .           
         .                 __hash_code
         .                 _M_hash_code(const _Key& __k) const
         .                 {
         .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
         .           	    "hash function must be invocable with an argument of key type");
   171,103 ( 0.00%)  	return _M_hash()(__k);
         .                 }
         .           
         .                 template<typename _Kt>
         .           	__hash_code
         .           	_M_hash_code_tr(const _Kt& __k) const
         .           	{
         .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
         .           	    "hash function must be invocable with an argument of key type");
        20 ( 0.00%)  	  return _M_hash()(__k);
         .           	}
         .           
         .                 __hash_code
         .                 _M_hash_code(const _Hash_node_value<_Value, false>& __n) const
         .                 { return _M_hash_code(_ExtractKey{}(__n._M_v())); }
         .           
         .                 __hash_code
         .                 _M_hash_code(const _Hash_node_value<_Value, true>& __n) const
-- line 1352 ----------------------------------------
-- line 1367 ----------------------------------------
         .           			    __bkt_count);
         .                 }
         .           
         .                 std::size_t
         .                 _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
         .           		      std::size_t __bkt_count) const
         .           	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
         .           							(std::size_t)0)) )
    94,673 ( 0.00%)        { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
         .           
         .                 void
         .                 _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
         .                 { }
         .           
         .                 void
         .                 _M_copy_code(_Hash_node_code_cache<false>&,
         .           		   const _Hash_node_code_cache<false>&) const
         .                 { }
         .           
         .                 void
         .                 _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
       831 ( 0.00%)        { __n._M_hash_code = __c; }
         .           
         .                 void
         .                 _M_copy_code(_Hash_node_code_cache<true>& __to,
         .           		   const _Hash_node_code_cache<true>& __from) const
     7,208 ( 0.00%)        { __to._M_hash_code = __from._M_hash_code; }
         .           
         .                 void
         .                 _M_swap(_Hash_code_base& __x)
         .                 { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }
         .           
         .                 const _Hash&
         .                 _M_hash() const { return __ebo_hash::_M_cget(); }
         .               };
-- line 1401 ----------------------------------------
-- line 1710 ----------------------------------------
         .           
         .                 static bool
         .                 _S_node_equals(const _Hash_node_code_cache<false>&,
         .           		     const _Hash_node_code_cache<false>&)
         .                 { return true; }
         .           
         .                 static bool
         .                 _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
 1,456,959 ( 0.00%)        { return __c == __n._M_hash_code; }
         .           
         .                 static bool
         .                 _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
         .           		     const _Hash_node_code_cache<true>& __rhn)
         .                 { return __lhn._M_hash_code == __rhn._M_hash_code; }
         .           
         .               protected:
         .                 _Hashtable_base() = default;
-- line 1726 ----------------------------------------
-- line 1751 ----------------------------------------
         .           	    "key equality predicate must be invocable with two arguments of "
         .           	    "key type");
         .           	  return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
         .           	}
         .           
         .                 bool
         .                 _M_equals(const _Key& __k, __hash_code __c,
         .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
51,168,938 ( 0.09%)        { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
         .           
         .                 template<typename _Kt>
         .           	bool
         .           	_M_equals_tr(const _Kt& __k, __hash_code __c,
         .           		     const _Hash_node_value<_Value,
         .           					    __hash_cached::value>& __n) const
        36 ( 0.00%)  	{ return _S_equals(__c, __n) && _M_key_equals_tr(__k, __n); }
         .           
         .                 bool
         .                 _M_node_equals(
         .           	const _Hash_node_value<_Value, __hash_cached::value>& __lhn,
         .           	const _Hash_node_value<_Value, __hash_cached::value>& __rhn) const
         .                 {
         .           	return _S_node_equals(__lhn, __rhn)
         .           	  && _M_key_equals(_ExtractKey{}(__lhn._M_v()), __rhn);
-- line 1774 ----------------------------------------
-- line 2050 ----------------------------------------
         .                 __n->~__node_type();
         .                 __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
         .               }
         .           
         .             template<typename _NodeAlloc>
         .               void
         .               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
         .               {
    69,616 ( 0.00%)        while (__n)
         .           	{
         .           	  __node_ptr __tmp = __n;
         .           	  __n = __n->_M_next();
         .           	  _M_deallocate_node(__tmp);
         .           	}
         .               }
         .           
         .             template<typename _NodeAlloc>
-- line 2066 ----------------------------------------
-- line 2067 ----------------------------------------
         .               auto
         .               _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
         .               -> __buckets_ptr
         .               {
         .                 __buckets_alloc_type __alloc(_M_node_allocator());
         .           
         .                 auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
         .                 __buckets_ptr __p = std::__to_address(__ptr);
    22,548 ( 0.00%)        __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
     6,577 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6x)
         .                 return __p;
         .               }
         .           
         .             template<typename _NodeAlloc>
         .               void
         .               _Hashtable_alloc<_NodeAlloc>::
         .               _M_deallocate_buckets(__buckets_ptr __bkts,
         .           			  std::size_t __bkt_count)
-- line 2083 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/future
--------------------------------------------------------------------------------
Ir                 

-- line 228 ----------------------------------------
        .                 _Result_base(const _Result_base&) = delete;
        .                 _Result_base& operator=(const _Result_base&) = delete;
        .           
        .                 // _M_destroy() allows derived classes to control deallocation
        .                 virtual void _M_destroy() = 0;
        .           
        .                 struct _Deleter
        .                 {
  258,290 ( 0.00%)  	void operator()(_Result_base* __fr) const { __fr->_M_destroy(); }
17,558,608 ( 0.03%)  => /usr/include/c++/14/future:std::__future_base::_Result<std::shared_ptr<Ship::IResource> >::_M_destroy() (129,091x)
        .                 };
        .           
        .               protected:
        .                 _Result_base();
        .                 virtual ~_Result_base();
        .               };
        .           
        .               /// A unique_ptr for result objects.
-- line 244 ----------------------------------------
-- line 251 ----------------------------------------
        .                 {
        .                 private:
        .           	__gnu_cxx::__aligned_buffer<_Res>	_M_storage;
        .           	bool 					_M_initialized;
        .           
        .                 public:
        .           	typedef _Res result_type;
        .           
1,416,795 ( 0.00%)  	_Result() noexcept : _M_initialized() { }
  247,980 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/future.cc:std::__future_base::_Result_base::_Result_base() (41,330x)
        .           
        .           	~_Result()
        .           	{
  258,182 ( 0.00%)  	  if (_M_initialized)
        .           	    _M_value().~_Res();
1,032,732 ( 0.00%)  	}
12,006,261 ( 0.02%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/del_ops.cc:operator delete(void*, unsigned long) (129,091x)
  903,637 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/future.cc:std::__future_base::_Result_base::~_Result_base() (129,091x)
    1,430 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           
        .           	// Return lvalue, future will add const or rvalue-reference
        .           	_Res&
        .           	_M_value() noexcept { return *_M_storage._M_ptr(); }
        .           
        .           	void
        .           	_M_set(const _Res& __res)
        .           	{
        .           	  ::new (_M_storage._M_addr()) _Res(__res);
  128,556 ( 0.00%)  	  _M_initialized = true;
        .           	}
        .           
        .           	void
        .           	_M_set(_Res&& __res)
        .           	{
        .           	  ::new (_M_storage._M_addr()) _Res(std::move(__res));
      535 ( 0.00%)  	  _M_initialized = true;
        .           	}
        .           
        .                 private:
1,420,001 ( 0.00%)  	void _M_destroy() { delete this; }
        .               };
        .           
        .               /// A result object that uses an allocator.
        .               template<typename _Res, typename _Alloc>
        .                 struct _Result_alloc final : _Result<_Res>, _Alloc
        .                 {
        .           	using __allocator_type = __alloc_rebind<_Alloc, _Result_alloc>;
        .           
-- line 294 ----------------------------------------
-- line 339 ----------------------------------------
        .                 };
        .           
        .                 _Ptr_type			_M_result;
        .                 __atomic_futex_unsigned<>	_M_status;
        .                 atomic_flag         	_M_retrieved = ATOMIC_FLAG_INIT;
        .                 once_flag			_M_once;
        .           
        .               public:
  129,091 ( 0.00%)        _State_baseV2() noexcept : _M_result(), _M_status(_Status::__not_ready)
        .           	{ }
        .                 _State_baseV2(const _State_baseV2&) = delete;
        .                 _State_baseV2& operator=(const _State_baseV2&) = delete;
  516,364 ( 0.00%)        virtual ~_State_baseV2() = default;
        .           
        .                 _Result_base&
        .                 wait()
        .                 {
        .           	// Run any deferred function or join any asynchronous thread:
  387,273 ( 0.00%)  	_M_complete_async();
  129,091 ( 0.00%)  => /usr/include/c++/14/future:std::__future_base::_State_baseV2::_M_complete_async() (129,091x)
        .           	// Acquire MO makes sure this synchronizes with the thread that made
        .           	// the future ready.
  258,182 ( 0.00%)  	_M_status._M_load_when_equal(_Status::__ready, memory_order_acquire);
        .           	return *_M_result;
        .                 }
        .           
        .                 template<typename _Rep, typename _Period>
        .                   future_status
        .                   wait_for(const chrono::duration<_Rep, _Period>& __rel)
        .                   {
        .           	  // First, check if the future has been made ready.  Use acquire MO
-- line 368 ----------------------------------------
-- line 424 ----------------------------------------
        .           	  return future_status::timeout;
        .           	}
        .           
        .                 // Provide a result to the shared state and make it ready.
        .                 // Calls at most once: _M_result = __res();
        .                 void
        .                 _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)
        .                 {
  129,091 ( 0.00%)  	bool __did_set = false;
        .                   // all calls to this function are serialized,
        .                   // side-effects of invoking __res only happen once
  387,273 ( 0.00%)  	call_once(_M_once, &_State_baseV2::_M_do_set, this,
  387,273 ( 0.00%)  		  std::__addressof(__res), std::__addressof(__did_set));
  258,182 ( 0.00%)  	if (__did_set)
        .           	  // Use release MO to synchronize with observers of the ready state.
        .           	  _M_status._M_store_notify_all(_Status::__ready,
        .           					memory_order_release);
        .           	else if (!__ignore_failure)
        .                     __throw_future_error(int(future_errc::promise_already_satisfied));
        .                 }
        .           
        .                 // Provide a result to the shared state but delay making it ready
-- line 445 ----------------------------------------
-- line 461 ----------------------------------------
        .           	__mr->_M_set();
        .           	__mr.release();
        .                 }
        .           
        .                 // Abandon this shared state.
        .                 void
        .                 _M_break_promise(_Ptr_type __res)
        .                 {
  258,074 ( 0.00%)  	if (static_cast<bool>(__res))
        .           	  {
        .           	    __res->_M_error =
        .           	      make_exception_ptr(future_error(future_errc::broken_promise));
        .           	    // This function is only called when the last asynchronous result
        .           	    // provider is abandoning this shared state, so noone can be
        .           	    // trying to make the shared state ready at the same time, and
        .           	    // we can access _M_result directly instead of through call_once.
        .           	    _M_result.swap(__res);
-- line 477 ----------------------------------------
-- line 480 ----------------------------------------
        .           					  memory_order_release);
        .           	  }
        .                 }
        .           
        .                 // Called when this object is first passed to a future.
        .                 void
        .                 _M_set_retrieved_flag()
        .                 {
  258,182 ( 0.00%)  	if (_M_retrieved.test_and_set())
        .           	  __throw_future_error(int(future_errc::future_already_retrieved));
        .                 }
        .           
        .                 template<typename _Res, typename _Arg>
        .                   struct _Setter;
        .           
        .                 // set lvalues
        .                 template<typename _Res, typename _Arg>
-- line 496 ----------------------------------------
-- line 500 ----------------------------------------
        .                     // or promise<R&>::set_value(R&)
        .                     static_assert(is_same<_Res, _Arg&>::value  // promise<R&>
        .                         || is_same<const _Res, _Arg>::value,   // promise<R>
        .                         "Invalid specialisation");
        .           
        .           	  // Used by std::promise to copy construct the result.
        .                     typename promise<_Res>::_Ptr_type operator()() const
        .                     {
  128,556 ( 0.00%)              _M_promise->_M_storage->_M_set(*_M_arg);
  128,556 ( 0.00%)              return std::move(_M_promise->_M_storage);
        .                     }
        .                     promise<_Res>*    _M_promise;
        .                     _Arg*             _M_arg;
        .                   };
        .           
        .                 // set rvalues
        .                 template<typename _Res>
        .                   struct _Setter<_Res, _Res&&>
        .                   {
        .           	  // Used by std::promise to move construct the result.
        .                     typename promise<_Res>::_Ptr_type operator()() const
        .                     {
    1,070 ( 0.00%)              _M_promise->_M_storage->_M_set(std::move(*_M_arg));
        .                       return std::move(_M_promise->_M_storage);
        .                     }
        .                     promise<_Res>*    _M_promise;
        .                     _Res*             _M_arg;
        .                   };
        .           
        .                 // set void
        .                 template<typename _Res>
-- line 530 ----------------------------------------
-- line 579 ----------------------------------------
        .           	{
        .           	  return _Setter<_Res, void>{ __prom };
        .           	}
        .           
        .                 template<typename _Tp>
        .                   static void
        .                   _S_check(const shared_ptr<_Tp>& __p)
        .                   {
1,032,193 ( 0.00%)            if (!static_cast<bool>(__p))
        .                       __throw_future_error((int)future_errc::no_state);
        .                   }
        .           
        .               private:
        .                 // The function invoked with std::call_once(_M_once, ...).
        .                 void
  387,273 ( 0.00%)        _M_do_set(function<_Ptr_type()>* __f, bool* __did_set)
        .                 {
        .                   _Ptr_type __res = (*__f)();
        .                   // Notify the caller that we did try to set; if we do not throw an
        .                   // exception, the caller will be aware that it did set (e.g., see
        .                   // _M_set_result).
  129,091 ( 0.00%)  	*__did_set = true;
        .                   _M_result.swap(__res); // nothrow
  516,364 ( 0.00%)        }
        .           
        .                 // Wait for completion of async function.
  129,091 ( 0.00%)        virtual void _M_complete_async() { }
        .           
        .                 // Return true if state corresponds to a deferred function.
        .                 virtual bool _M_is_deferred_future() const { return false; }
        .           
        .                 struct _Make_ready final : __at_thread_exit_elt
        .                 {
        .           	weak_ptr<_State_baseV2> _M_shared_state;
        .           	static void _S_run(void*);
-- line 613 ----------------------------------------
-- line 1101 ----------------------------------------
        .                 friend _State;
        .           
        .                 shared_ptr<_State>                        _M_future;
        .                 _Ptr_type                                 _M_storage;
        .           
        .               public:
        .                 promise()
        .                 : _M_future(std::make_shared<_State>()),
1,160,214 ( 0.00%)  	_M_storage(new _Res_type())
2,445,794 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (41,330x)
        .                 { }
        .           
        .                 promise(promise&& __rhs) noexcept
        .                 : _M_future(std::move(__rhs._M_future)),
        .           	_M_storage(std::move(__rhs._M_storage))
        .                 { }
        .           
        .                 template<typename _Allocator>
-- line 1117 ----------------------------------------
-- line 1125 ----------------------------------------
        .                   : _M_future(std::move(__rhs._M_future)),
        .           	  _M_storage(std::move(__rhs._M_storage))
        .                   { }
        .           
        .                 promise(const promise&) = delete;
        .           
        .                 ~promise()
        .                 {
  516,364 ( 0.00%)          if (static_cast<bool>(_M_future) && !_M_future.unique())
        .                     _M_future->_M_break_promise(std::move(_M_storage));
        .                 }
        .           
        .                 // Assignment
        .                 promise&
        .                 operator=(promise&& __rhs) noexcept
        .                 {
        .                   promise(std::move(__rhs)).swap(*this);
-- line 1141 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/functional_hash.h
--------------------------------------------------------------------------------
Ir                  

-- line 155 ----------------------------------------
         .           
         .             /// Explicit specialization for long.
         .             _Cxx_hashtable_define_trivial_hash(long)
         .           
         .             /// Explicit specialization for long long.
         .             _Cxx_hashtable_define_trivial_hash(long long)
         .           
         .             /// Explicit specialization for unsigned short.
       156 ( 0.00%)    _Cxx_hashtable_define_trivial_hash(unsigned short)
         .           
         .             /// Explicit specialization for unsigned int.
12,486,763 ( 0.02%)    _Cxx_hashtable_define_trivial_hash(unsigned int)
         .           
         .             /// Explicit specialization for unsigned long.
         .             _Cxx_hashtable_define_trivial_hash(unsigned long)
         .           
         .             /// Explicit specialization for unsigned long long.
         .             _Cxx_hashtable_define_trivial_hash(unsigned long long)
         .           
         .           #ifdef __GLIBCXX_TYPE_INT_N_0
-- line 174 ----------------------------------------
-- line 198 ----------------------------------------
         .           
         .           #undef _Cxx_hashtable_define_trivial_hash
         .           
         .             struct _Hash_impl
         .             {
         .               static size_t
         .               hash(const void* __ptr, size_t __clength,
         .           	 size_t __seed = static_cast<size_t>(0xc70f6907UL))
 1,454,234 ( 0.00%)      { return _Hash_bytes(__ptr, __clength, __seed); }
20,439,280 ( 0.03%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/hash_bytes.cc:std::_Hash_bytes(void const*, unsigned long, unsigned long) (196,786x)
         .           
         .               template<typename _Tp>
         .                 static size_t
         .                 hash(const _Tp& __val)
         .                 { return hash(&__val, sizeof(__val)); }
         .           
         .               template<typename _Tp>
         .                 static size_t
-- line 214 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/any
--------------------------------------------------------------------------------
Ir                  

-- line 78 ----------------------------------------
         .              *
         .              *  @since C++17
         .              */
         .             class any
         .             {
         .               // Holds either pointer to a heap object or the contained object itself.
         .               union _Storage
         .               {
        28 ( 0.00%)        constexpr _Storage() : _M_ptr{nullptr} {}
         .           
         .                 // Prevent trivial copies of this type, buffer might hold a non-POD.
         .                 _Storage(const _Storage&) = delete;
         .                 _Storage& operator=(const _Storage&) = delete;
         .           
         .                 void* _M_ptr;
         .                 aligned_storage<sizeof(_M_ptr), alignof(void*)>::type _M_buffer;
         .               };
-- line 94 ----------------------------------------
-- line 151 ----------------------------------------
         .               // construct/destruct
         .           
         .               /// Default constructor, creates an empty object.
         .               constexpr any() noexcept : _M_manager(nullptr) { }
         .           
         .               /// Copy constructor, copies the state of @p __other
         .               any(const any& __other)
         .               {
        28 ( 0.00%)        if (!__other.has_value())
         .           	_M_manager = nullptr;
         .                 else
         .           	{
         .           	  _Arg __arg;
        14 ( 0.00%)  	  __arg._M_any = this;
        42 ( 0.00%)  	  __other._M_manager(_Op_clone, &__other, &__arg);
        88 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<signed char>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (8x)
        60 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<unsigned int>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (6x)
         .           	}
         .               }
         .           
         .               /**
         .                * @brief Move constructor, transfer the state from @p __other
         .                *
         .                * @post @c !__other.has_value() (this postcondition is a GNU extension)
         .                */
-- line 173 ----------------------------------------
-- line 184 ----------------------------------------
         .               }
         .           
         .               /// Construct with a copy of @p __value as the contained object.
         .               template <typename _Tp, typename _VTp = _Decay_if_not_any<_Tp>,
         .           	      typename _Mgr = _Manager<_VTp>,
         .           	      enable_if_t<is_copy_constructible_v<_VTp>
         .           			  && !__is_in_place_type_v<_VTp>, bool> = true>
         .                 any(_Tp&& __value)
        14 ( 0.00%)        : _M_manager(&_Mgr::_S_manage)
         .                 {
         .           	_Mgr::_S_create(_M_storage, std::forward<_Tp>(__value));
         .                 }
         .           
         .               /// Construct with an object created from @p __args as the contained object.
         .               template <typename _Tp, typename... _Args, typename _VTp = decay_t<_Tp>,
         .           	      typename _Mgr = _Manager<_VTp>,
         .           	      __any_constructible_t<_VTp, _Args&&...> = false>
-- line 200 ----------------------------------------
-- line 281 ----------------------------------------
         .           	return *any::_Manager<_VTp>::_S_access(_M_storage);
         .                 }
         .           
         .               // modifiers
         .           
         .               /// If not empty, destroy the contained object.
         .               void reset() noexcept
         .               {
        56 ( 0.00%)        if (has_value())
         .                 {
        98 ( 0.00%)  	_M_manager(_Op_destroy, this, nullptr);
        40 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<signed char>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (8x)
        30 ( 0.00%)  => /usr/include/c++/14/any:std::any::_Manager_internal<unsigned int>::_S_manage(std::any::_Op, std::any const*, std::any::_Arg*) (6x)
         .           	_M_manager = nullptr;
         .                 }
         .               }
         .           
         .               /// Exchange state with another object.
         .               void swap(any& __rhs) noexcept
         .               {
         .                 if (!has_value() && !__rhs.has_value())
-- line 299 ----------------------------------------
-- line 321 ----------------------------------------
         .           	  __arg._M_any = __empty;
         .           	  __full->_M_manager(_Op_xfer, __full, &__arg);
         .           	}
         .               }
         .           
         .               // observers
         .           
         .               /// Reports whether there is a contained object or not.
        42 ( 0.00%)      bool has_value() const noexcept { return _M_manager != nullptr; }
         .           
         .           #if __cpp_rtti
         .               /// The @c typeid of the contained object, or @c typeid(void) if empty.
         .               const type_info& type() const noexcept
         .               {
         .                 if (!has_value())
         .           	return typeid(void);
         .                 _Arg __arg;
-- line 337 ----------------------------------------
-- line 463 ----------------------------------------
         .               {
         .                 using _Up = __remove_cvref_t<_ValueType>;
         .                 static_assert(any::__is_valid_cast<_ValueType>(),
         .           	  "Template argument must be a reference or CopyConstructible type");
         .                 static_assert(is_constructible_v<_ValueType, const _Up&>,
         .           	  "Template argument must be constructible from a const value.");
         .                 auto __p = any_cast<_Up>(&__any);
         .                 if (__p)
 8,324,466 ( 0.01%)  	return static_cast<_ValueType>(*__p);
         .                 __throw_bad_any_cast();
         .               }
         .           
         .             /**
         .              * @brief Access the contained object.
         .              *
         .              * @tparam  _ValueType  A reference or CopyConstructible type.
         .              * @param   __any       The object to access.
-- line 479 ----------------------------------------
-- line 523 ----------------------------------------
         .                 // The contained value has a decayed type, so if decay_t<U> is not U,
         .                 // then it's not possible to have a contained value of type U:
         .                 if constexpr (!is_same_v<decay_t<_Up>, _Up>)
         .           	return nullptr;
         .                 // Only copy constructible types can be used for contained values:
         .                 else if constexpr (!is_copy_constructible_v<_Up>)
         .           	return nullptr;
         .                 // First try comparing function addresses, which works without RTTI
12,486,699 ( 0.02%)        else if (__any->_M_manager == &any::_Manager<_Up>::_S_manage
         .           #if __cpp_rtti
24,973,398 ( 0.04%)  	  || __any->type() == typeid(_Tp)
         .           #endif
         .           	  )
         .           	{
         .           	  return any::_Manager<_Up>::_S_access(__any->_M_storage);
         .           	}
         .                 return nullptr;
         .               }
         .             /// @endcond
-- line 541 ----------------------------------------
-- line 580 ----------------------------------------
         .           
         .             template<typename _Tp>
         .               void
         .               any::_Manager_internal<_Tp>::
         .               _S_manage(_Op __which, const any* __any, _Arg* __arg)
         .               {
         .                 // The contained object is in _M_storage._M_buffer
         .                 auto __ptr = reinterpret_cast<const _Tp*>(&__any->_M_storage._M_buffer);
       168 ( 0.00%)        switch (__which)
         .                 {
         .                 case _Op_access:
         .           	__arg->_M_obj = const_cast<_Tp*>(__ptr);
         .           	break;
         .                 case _Op_get_type_info:
         .           #if __cpp_rtti
         .           	__arg->_M_typeinfo = &typeid(_Tp);
         .           #endif
         .           	break;
         .                 case _Op_clone:
        42 ( 0.00%)  	::new(&__arg->_M_any->_M_storage._M_buffer) _Tp(*__ptr);
        36 ( 0.00%)  	__arg->_M_any->_M_manager = __any->_M_manager;
        14 ( 0.00%)  	break;
         .                 case _Op_destroy:
         .           	__ptr->~_Tp();
         .           	break;
         .                 case _Op_xfer:
         .           	::new(&__arg->_M_any->_M_storage._M_buffer) _Tp
         .           	  (std::move(*const_cast<_Tp*>(__ptr)));
         .           	__ptr->~_Tp();
         .           	__arg->_M_any->_M_manager = __any->_M_manager;
         .           	const_cast<any*>(__any)->_M_manager = nullptr;
         .           	break;
         .                 }
        28 ( 0.00%)      }
         .           
         .             template<typename _Tp>
         .               void
         .               any::_Manager_external<_Tp>::
         .               _S_manage(_Op __which, const any* __any, _Arg* __arg)
         .               {
         .                 // The contained object is *_M_storage._M_ptr
         .                 auto __ptr = static_cast<const _Tp*>(__any->_M_storage._M_ptr);
-- line 621 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/stl_deque.h
--------------------------------------------------------------------------------
Ir                   

-- line 144 ----------------------------------------
          .                 _Elt_pointer _M_last;
          .                 _Map_pointer _M_node;
          .           
          .                 _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
          .                 : _M_cur(__x), _M_first(*__y),
          .           	_M_last(*__y + _S_buffer_size()), _M_node(__y) { }
          .           
          .                 _Deque_iterator() _GLIBCXX_NOEXCEPT
         14 ( 0.00%)        : _M_cur(), _M_first(), _M_last(), _M_node() { }
          .           
          .           #if __cplusplus < 201103L
          .                 // Conversion from iterator to const_iterator.
          .                 _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
          .                 : _M_cur(__x._M_cur), _M_first(__x._M_first),
          .           	_M_last(__x._M_last), _M_node(__x._M_node) { }
          .           #else
          .                 // Conversion from iterator to const_iterator.
-- line 160 ----------------------------------------
-- line 161 ----------------------------------------
          .                 template<typename _Iter,
          .           	       typename = _Require<is_same<_Self, const_iterator>,
          .           				   is_same<_Iter, iterator>>>
          .                  _Deque_iterator(const _Iter& __x) noexcept
          .                  : _M_cur(__x._M_cur), _M_first(__x._M_first),
          .           	 _M_last(__x._M_last), _M_node(__x._M_node) { }
          .           
          .                 _Deque_iterator(const _Deque_iterator& __x) noexcept
165,843,485 ( 0.28%)         : _M_cur(__x._M_cur), _M_first(__x._M_first),
    260,505 ( 0.00%)  	 _M_last(__x._M_last), _M_node(__x._M_node) { }
          .           
          .                 _Deque_iterator& operator=(const _Deque_iterator&) = default;
          .           #endif
          .           
          .                 iterator
          .                 _M_const_cast() const _GLIBCXX_NOEXCEPT
          .                 { return iterator(_M_cur, _M_node); }
          .           
-- line 178 ----------------------------------------
-- line 204 ----------------------------------------
          .           	_Self __tmp = *this;
          .           	++*this;
          .           	return __tmp;
          .                 }
          .           
          .                 _Self&
          .                 operator--() _GLIBCXX_NOEXCEPT
          .                 {
331,682,394 ( 0.56%)  	if (_M_cur == _M_first)
          .           	  {
          .           	    _M_set_node(_M_node - 1);
          .           	    _M_cur = _M_last;
          .           	  }
 82,663,240 ( 0.14%)  	--_M_cur;
          .           	return *this;
          .                 }
          .           
          .                 _Self
          .                 operator--(int) _GLIBCXX_NOEXCEPT
          .                 {
          .           	_Self __tmp = *this;
          .           	--*this;
          .           	return __tmp;
          .                 }
          .           
          .                 _Self&
          .                 operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
          .                 {
      9,136 ( 0.00%)  	const difference_type __offset = __n + (_M_cur - _M_first);
      9,136 ( 0.00%)  	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
      6,944 ( 0.00%)  	  _M_cur += __n;
          .           	else
          .           	  {
          .           	    const difference_type __node_offset =
          .           	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
          .           			   : -difference_type((-__offset - 1)
          .           					      / _S_buffer_size()) - 1;
          .           	    _M_set_node(_M_node + __node_offset);
          .           	    _M_cur = _M_first + (__offset - __node_offset
-- line 242 ----------------------------------------
-- line 255 ----------------------------------------
          .                 { return *(*this + __n); }
          .           
          .                 /**
          .                  *  Prepares to traverse new_node.  Sets everything except
          .                  *  _M_cur, which should therefore be set by the caller
          .                  *  immediately afterwards, based on _M_first and _M_last.
          .                  */
          .                 void
          4 ( 0.00%)        _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
          .                 {
         40 ( 0.00%)  	_M_node = __new_node;
      1,508 ( 0.00%)  	_M_first = *__new_node;
      2,732 ( 0.00%)  	_M_last = _M_first + difference_type(_S_buffer_size());
          .                 }
          .           
          .                 _GLIBCXX_NODISCARD
          .                 friend bool
          .                 operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
 82,664,953 ( 0.14%)        { return __x._M_cur == __y._M_cur; }
          .           
          .                 // Note: we also provide overloads whose operands are of the same type in
          .                 // order to avoid ambiguous overload resolution when std::rel_ops
          .                 // operators are in scope (for additional details, see libstdc++/3628)
          .                 template<typename _RefR, typename _PtrR>
          .           	_GLIBCXX_NODISCARD
          .           	friend bool
          .           	operator==(const _Self& __x,
-- line 281 ----------------------------------------
-- line 365 ----------------------------------------
          .           	{ return !(__x < __y); }
          .           #endif // three-way comparison
          .           
          .                 _GLIBCXX_NODISCARD
          .                 friend difference_type
          .                 operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
          .                 {
          .           	return difference_type(_S_buffer_size())
  1,840,712 ( 0.00%)  	  * (__x._M_node - __y._M_node - bool(__x._M_node))
  1,060,332 ( 0.00%)  	  + (__x._M_cur - __x._M_first)
  1,576,080 ( 0.00%)  	  + (__y._M_last - __y._M_cur);
          .                 }
          .           
          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .                 // According to the resolution of DR179 not only the various comparison
          .                 // operators but also operator- must accept mixed iterator/const_iterator
          .                 // parameters.
          .                 template<typename _RefR, typename _PtrR>
          .           	_GLIBCXX_NODISCARD
-- line 383 ----------------------------------------
-- line 452 ----------------------------------------
          .                 get_allocator() const _GLIBCXX_NOEXCEPT
          .                 { return allocator_type(_M_get_Tp_allocator()); }
          .           
          .                 typedef _Deque_iterator<_Tp, _Tp&, _Ptr>	  iterator;
          .                 typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;
          .           
          .                 _Deque_base()
          .                 : _M_impl()
      5,143 ( 0.00%)        { _M_initialize_map(0); }
        472 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:std::_Deque_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_initialize_map(unsigned long) (1x)
          .           
          .                 _Deque_base(size_t __num_elements)
          .                 : _M_impl()
          .                 { _M_initialize_map(__num_elements); }
          .           
          .                 _Deque_base(const allocator_type& __a, size_t __num_elements)
          .                 : _M_impl(__a)
          .                 { _M_initialize_map(__num_elements); }
-- line 468 ----------------------------------------
-- line 509 ----------------------------------------
          .                 struct _Deque_impl_data
          .                 {
          .           	_Map_pointer _M_map;
          .           	size_t _M_map_size;
          .           	iterator _M_start;
          .           	iterator _M_finish;
          .           
          .           	_Deque_impl_data() _GLIBCXX_NOEXCEPT
          3 ( 0.00%)  	: _M_map(), _M_map_size(), _M_start(), _M_finish()
          .           	{ }
          .           
          .           #if __cplusplus >= 201103L
      2,284 ( 0.00%)  	_Deque_impl_data(const _Deque_impl_data&) = default;
          .           	_Deque_impl_data&
          .           	operator=(const _Deque_impl_data&) = default;
          .           
          .           	_Deque_impl_data(_Deque_impl_data&& __x) noexcept
          .           	: _Deque_impl_data(__x)
          .           	{ __x = _Deque_impl_data(); }
          .           #endif
          .           
-- line 529 ----------------------------------------
-- line 612 ----------------------------------------
          .           
          .                 _Deque_impl _M_impl;
          .               };
          .           
          .             template<typename _Tp, typename _Alloc>
          .               _Deque_base<_Tp, _Alloc>::
          .               ~_Deque_base() _GLIBCXX_NOEXCEPT
          .               {
      1,148 ( 0.00%)        if (this->_M_impl._M_map)
          .           	{
          6 ( 0.00%)  	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
          .           			   this->_M_impl._M_finish._M_node + 1);
          2 ( 0.00%)  	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
          .           	}
          .               }
          .           
          .             /**
          .              *  @brief Layout storage.
          .              *  @param  __num_elements  The count of T's for which to allocate space
          .              *                          at first.
          .              *  @return   Nothing.
          .              *
          .              *  The initial underlying memory layout is a bit complicated...
          .             */
          .             template<typename _Tp, typename _Alloc>
          .               void
      5,148 ( 0.00%)      _Deque_base<_Tp, _Alloc>::
          .               _M_initialize_map(size_t __num_elements)
          .               {
      1,716 ( 0.00%)        const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
          .           				  + 1);
          .           
        577 ( 0.00%)        this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        572 ( 0.00%)  					   size_t(__num_nodes + 2));
        577 ( 0.00%)        this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
          .           
          .                 // For "small" maps (needing less than _M_map_size nodes), allocation
          .                 // starts in the middle elements and grows outwards.  So nstart may be
          .                 // the beginning of _M_map, but for small maps it may be as far in as
          .                 // _M_map+3.
          .           
        577 ( 0.00%)        _Map_pointer __nstart = (this->_M_impl._M_map
      1,731 ( 0.00%)  			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
        572 ( 0.00%)        _Map_pointer __nfinish = __nstart + __num_nodes;
          .           
          .                 __try
          .           	{ _M_create_nodes(__nstart, __nfinish); }
          .                 __catch(...)
          .           	{
          .           	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
          .           	  this->_M_impl._M_map = _Map_pointer();
          .           	  this->_M_impl._M_map_size = 0;
          .           	  __throw_exception_again;
          .           	}
          .           
          .                 this->_M_impl._M_start._M_set_node(__nstart);
        572 ( 0.00%)        this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      5,730 ( 0.00%)        this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
          .                 this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
      1,716 ( 0.00%)  					+ __num_elements
        572 ( 0.00%)  					% __deque_buf_size(sizeof(_Tp)));
      4,576 ( 0.00%)      }
          .           
          .             template<typename _Tp, typename _Alloc>
          .               void
          .               _Deque_base<_Tp, _Alloc>::
          .               _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
          .               {
          .                 _Map_pointer __cur;
          .                 __try
          .           	{
      4,004 ( 0.00%)  	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
        577 ( 0.00%)  	    *__cur = this->_M_allocate_node();
          .           	}
          .                 __catch(...)
          .           	{
          .           	  _M_destroy_nodes(__nstart, __cur);
          .           	  __throw_exception_again;
          .           	}
          .               }
          .           
          .             template<typename _Tp, typename _Alloc>
          .               void
          .               _Deque_base<_Tp, _Alloc>::
          .               _M_destroy_nodes(_Map_pointer __nstart,
          .           		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
          .               {
      1,154 ( 0.00%)        for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
          .           	_M_deallocate_node(*__n);
          .               }
          .           
          .             /**
          .              *  @brief  A standard container using fixed-size memory allocation and
          .              *  constant-time manipulation of elements at either end.
          .              *
          .              *  @ingroup sequences
-- line 707 ----------------------------------------
-- line 1495 ----------------------------------------
          .                  *  This is a typical stack operation.  The function creates an
          .                  *  element at the front of the %deque and assigns the given
          .                  *  data to it.  Due to the nature of a %deque this operation
          .                  *  can be done in constant time.
          .                  */
          .                 void
          .                 push_front(const value_type& __x)
          .                 {
      6,852 ( 0.00%)  	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
          .           	  {
          .           	    _Alloc_traits::construct(this->_M_impl,
          .           				     this->_M_impl._M_start._M_cur - 1,
          .           				     __x);
      4,384 ( 0.00%)  	    --this->_M_impl._M_start._M_cur;
          .           	  }
          .           	else
        276 ( 0.00%)  	  _M_push_front_aux(__x);
     12,700 ( 0.00%)  => /usr/include/c++/14/bits/stl_deque.h:void std::deque<OSContPad, std::allocator<OSContPad> >::_M_push_front_aux<OSContPad const&>(OSContPad const&) (92x)
          .                 }
          .           
          .           #if __cplusplus >= 201103L
          .                 void
          .                 push_front(value_type&& __x)
          .                 { emplace_front(std::move(__x)); }
          .           
          .                 template<typename... _Args>
-- line 1519 ----------------------------------------
-- line 1532 ----------------------------------------
          .                  *  This is a typical stack operation.  The function creates an
          .                  *  element at the end of the %deque and assigns the given data
          .                  *  to it.  Due to the nature of a %deque this operation can be
          .                  *  done in constant time.
          .                  */
          .                 void
          .                 push_back(const value_type& __x)
          .                 {
  1,029,434 ( 0.00%)  	if (this->_M_impl._M_finish._M_cur
    515,288 ( 0.00%)  	    != this->_M_impl._M_finish._M_last - 1)
          .           	  {
          .           	    _Alloc_traits::construct(this->_M_impl,
          .           				     this->_M_impl._M_finish._M_cur, __x);
    515,288 ( 0.00%)  	    ++this->_M_impl._M_finish._M_cur;
          .           	  }
          .           	else
          .           	  _M_push_back_aux(__x);
          .                 }
          .           
          .           #if __cplusplus >= 201103L
          .                 void
          .                 push_back(value_type&& __x)
-- line 1553 ----------------------------------------
-- line 1592 ----------------------------------------
          .                  *
          .                  *  Note that no data is returned, and if the last element's data is
          .                  *  needed, it should be retrieved before pop_back() is called.
          .                  */
          .                 void
          .                 pop_back() _GLIBCXX_NOEXCEPT
          .                 {
          .           	__glibcxx_requires_nonempty();
      4,520 ( 0.00%)  	if (this->_M_impl._M_finish._M_cur
          .           	    != this->_M_impl._M_finish._M_first)
          .           	  {
    519,624 ( 0.00%)  	    --this->_M_impl._M_finish._M_cur;
          .           	    _Alloc_traits::destroy(_M_get_Tp_allocator(),
          .           				   this->_M_impl._M_finish._M_cur);
          .           	  }
          .           	else
          .           	  _M_pop_back_aux();
          .                 }
          .           
          .           #if __cplusplus >= 201103L
-- line 1611 ----------------------------------------
-- line 2101 ----------------------------------------
          .                 }
          .           
          .                 // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
          .                 // _M_fill_assign, operator=.
          .                 void
          .                 _M_erase_at_end(iterator __pos)
          .                 {
          .           	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
      1,142 ( 0.00%)  	_M_destroy_nodes(__pos._M_node + 1,
          .           			 this->_M_impl._M_finish._M_node + 1);
          .           	this->_M_impl._M_finish = __pos;
          .                 }
          .           
          .                 iterator
          .                 _M_erase(iterator __pos);
          .           
          .                 iterator
-- line 2117 ----------------------------------------
-- line 2170 ----------------------------------------
          .           	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
          .           	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
          .           	  _M_reallocate_map(__nodes_to_add, false);
          .                 }
          .           
          .                 void
          .                 _M_reserve_map_at_front(size_type __nodes_to_add = 1)
          .                 {
        184 ( 0.00%)  	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
          .           				       - this->_M_impl._M_map))
          .           	  _M_reallocate_map(__nodes_to_add, true);
          .                 }
          .           
          .                 void
          .                 _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
          .                 ///@}
          .           
-- line 2186 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/utils/StrHash64.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 169 ----------------------------------------
        .               return ~crc;
        .           }
        .           
        .           u64 crc64(const void* buf, unint len) {
        .               return update_crc64(buf, len, INITIAL_CRC64);
        .           }
        .           
        .           u64 CRC64(const char* t) {
   17,208 ( 0.00%)      u64 crc = INITIAL_CRC64;
        .               const u8* s = (const u8*)t;
1,884,660 ( 0.00%)      while (*s) {
4,036,214 ( 0.01%)          crc = CRC64_Table[(u8)(crc >> 56) ^ *s++] ^ (crc << 8);
        .               }
        .               return crc;
        3 ( 0.00%)  }
--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imgui_draw.cpp
--------------------------------------------------------------------------------
Ir               

-- line 169 ----------------------------------------
      .           using namespace IMGUI_STB_NAMESPACE;
      .           #endif
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] Style functions
      .           //-----------------------------------------------------------------------------
      .           
      .           void ImGui::StyleColorsDark(ImGuiStyle* dst)
      2 ( 0.00%)  {
      2 ( 0.00%)      ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
      .               ImVec4* colors = style->Colors;
      .           
     26 ( 0.00%)      colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
      .               colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
      .               colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
      .               colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
      .               colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
      .               colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
      .               colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
      .               colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
      .               colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
-- line 189 ----------------------------------------
-- line 199 ----------------------------------------
      .               colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
      .               colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
      .               colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
      .               colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
      .               colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
      .               colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
      .               colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
      .               colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
      2 ( 0.00%)      colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
      2 ( 0.00%)      colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
      6 ( 0.00%)      colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
      .               colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
      .               colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
      .               colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
      .               colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
      .               colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
      2 ( 0.00%)      colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
     21 ( 0.00%)      colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
      .               colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
      .               colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
      .               colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
      .               colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
      .               colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
      .               colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
      .               colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
      .               colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
-- line 224 ----------------------------------------
-- line 228 ----------------------------------------
      .               colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
      .               colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
      .               colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
      .               colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
      .               colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
      .               colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
      .               colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
      .               colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
      2 ( 0.00%)  }
      .           
      .           void ImGui::StyleColorsClassic(ImGuiStyle* dst)
      .           {
      .               ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
      .               ImVec4* colors = style->Colors;
      .           
      .               colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
      .               colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
-- line 244 ----------------------------------------
-- line 359 ----------------------------------------
      .               colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
      .               colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
      .           }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImDrawList
      .           //-----------------------------------------------------------------------------
      .           
      6 ( 0.00%)  ImDrawListSharedData::ImDrawListSharedData()
      .           {
      4 ( 0.00%)      memset(this, 0, sizeof(*this));
     50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
    141 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
      .               {
    427 ( 0.00%)          const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  2,101 ( 0.00%)  => ???:0x000000000007c940 (47x)
  1,198 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    143 ( 0.00%)          ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
      .               }
      .               ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
      6 ( 0.00%)  }
      .           
      .           void ImDrawListSharedData::SetCircleTessellationMaxError(float max_error)
  2,855 ( 0.00%)  {
  1,713 ( 0.00%)      if (CircleSegmentMaxError == max_error)
      .                   return;
      .           
      3 ( 0.00%)      IM_ASSERT(max_error > 0.0f);
      1 ( 0.00%)      CircleSegmentMaxError = max_error;
    253 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
      .               {
    126 ( 0.00%)          const float radius = (float)i;
  1,077 ( 0.00%)          CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  3,654 ( 0.00%)  => ???:acosf (63x)
  1,120 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      .               }
      2 ( 0.00%)      ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  2,284 ( 0.00%)  }
      .           
      .           // Initialize before use in a new frame. We always have a command ready in the buffer.
      .           // In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.
      .           void ImDrawList::_ResetForNewFrame()
 19,992 ( 0.00%)  {
      .               // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
      .               IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);
      .               IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));
      .               IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
  5,712 ( 0.00%)      if (_Splitter._Count > 1)
      .                   _Splitter.Merge(this);
      .           
      .               CmdBuffer.resize(0);
      .               IdxBuffer.resize(0);
      .               VtxBuffer.resize(0);
  8,568 ( 0.00%)      Flags = _Data->InitialFlags;
  5,712 ( 0.00%)      memset(&_CmdHeader, 0, sizeof(_CmdHeader));
  2,856 ( 0.00%)      _VtxCurrentIdx = 0;
  5,712 ( 0.00%)      _VtxWritePtr = NULL;
      .               _IdxWritePtr = NULL;
      .               _ClipRectStack.resize(0);
      .               _TextureIdStack.resize(0);
      .               _Path.resize(0);
      .               _Splitter.Clear();
      .               CmdBuffer.push_back(ImDrawCmd());
  5,712 ( 0.00%)      _FringeScale = 1.0f;
 17,136 ( 0.00%)  }
      .           
      .           void ImDrawList::_ClearFreeMemory()
      2 ( 0.00%)  {
      .               CmdBuffer.clear();
      .               IdxBuffer.clear();
      .               VtxBuffer.clear();
      1 ( 0.00%)      Flags = ImDrawListFlags_None;
      .               _VtxCurrentIdx = 0;
      2 ( 0.00%)      _VtxWritePtr = NULL;
      .               _IdxWritePtr = NULL;
      .               _ClipRectStack.clear();
      .               _TextureIdStack.clear();
      .               _Path.clear();
      2 ( 0.00%)      _Splitter.ClearFreeMemory();
     25 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::ClearFreeMemory() (1x)
      1 ( 0.00%)  }
      .           
      .           ImDrawList* ImDrawList::CloneOutput() const
      .           {
      .               ImDrawList* dst = IM_NEW(ImDrawList(_Data));
      .               dst->CmdBuffer = CmdBuffer;
      .               dst->IdxBuffer = IdxBuffer;
      .               dst->VtxBuffer = VtxBuffer;
      .               dst->Flags = Flags;
      .               return dst;
      .           }
      .           
      .           void ImDrawList::AddDrawCmd()
 17,130 ( 0.00%)  {
      .               ImDrawCmd draw_cmd;
  2,855 ( 0.00%)      draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
 11,420 ( 0.00%)      draw_cmd.TextureId = _CmdHeader.TextureId;
  8,565 ( 0.00%)      draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
      .               draw_cmd.IdxOffset = IdxBuffer.Size;
      .           
 14,275 ( 0.00%)      IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
      .               CmdBuffer.push_back(draw_cmd);
 17,130 ( 0.00%)  }
      .           
      .           // Pop trailing draw command (used before merging or presenting to user)
      .           // Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL
      .           void ImDrawList::_PopUnusedDrawCmd()
      .           {
 11,995 ( 0.00%)      while (CmdBuffer.Size > 0)
      .               {
  2,855 ( 0.00%)          ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  7,424 ( 0.00%)          if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
      .                       return;// break;
      .                   CmdBuffer.pop_back();
      .               }
    572 ( 0.00%)  }
      .           
      .           void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)
      .           {
      .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
      .               ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
      .               IM_ASSERT(curr_cmd->UserCallback == NULL);
      .               if (curr_cmd->ElemCount != 0)
      .               {
-- line 476 ----------------------------------------
-- line 503 ----------------------------------------
      .           }
      .           
      .           // Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
      .           // The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
      .           void ImDrawList::_OnChangedClipRect()
      .           {
      .               // If current command is used with different settings we need to add a new command
      .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
 51,408 ( 0.00%)      ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
 32,560 ( 0.00%)      if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
      .               {
  2,857 ( 0.00%)          AddDrawCmd();
 25,695 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddDrawCmd() (571x)
      .                   return;
      .               }
 13,708 ( 0.00%)      IM_ASSERT(curr_cmd->UserCallback == NULL);
      .           
      .               // Try to merge with previous command if it matches, else use current command
      .               ImDrawCmd* prev_cmd = curr_cmd - 1;
 26,284 ( 0.00%)      if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
      .               {
      .                   CmdBuffer.pop_back();
    572 ( 0.00%)          return;
      .               }
      .           
 12,564 ( 0.00%)      curr_cmd->ClipRect = _CmdHeader.ClipRect;
      .           }
      .           
      .           void ImDrawList::_OnChangedTextureID()
      .           {
      .               // If current command is used with different settings we need to add a new command
      .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
 17,136 ( 0.00%)      ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  8,568 ( 0.00%)      if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
      .               {
      .                   AddDrawCmd();
      .                   return;
      .               }
  5,712 ( 0.00%)      IM_ASSERT(curr_cmd->UserCallback == NULL);
      .           
      .               // Try to merge with previous command if it matches, else use current command
      .               ImDrawCmd* prev_cmd = curr_cmd - 1;
  5,712 ( 0.00%)      if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
      .               {
      .                   CmdBuffer.pop_back();
      .                   return;
      .               }
      .           
  2,856 ( 0.00%)      curr_cmd->TextureId = _CmdHeader.TextureId;
      .           }
      .           
      .           void ImDrawList::_OnChangedVtxOffset()
      .           {
      .               // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
      .               _VtxCurrentIdx = 0;
      .               IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
 34,300 ( 0.00%)      ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
      .               //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
  6,860 ( 0.00%)      if (curr_cmd->ElemCount != 0)
      .               {
      .                   AddDrawCmd();
      .                   return;
      .               }
      .               IM_ASSERT(curr_cmd->UserCallback == NULL);
      .               curr_cmd->VtxOffset = _CmdHeader.VtxOffset;
      .           }
      .           
-- line 568 ----------------------------------------
-- line 573 ----------------------------------------
      .               if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
      .                   return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
      .               else
      .                   return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
      .           }
      .           
      .           // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
      .           void ImDrawList::PushClipRect(const ImVec2& cr_min, const ImVec2& cr_max, bool intersect_with_current_clip_rect)
 34,272 ( 0.00%)  {
 17,136 ( 0.00%)      ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
 17,136 ( 0.00%)      if (intersect_with_current_clip_rect)
      .               {
 15,995 ( 0.00%)          ImVec4 current = _CmdHeader.ClipRect;
      .                   if (cr.x < current.x) cr.x = current.x;
  2,285 ( 0.00%)          if (cr.y < current.y) cr.y = current.y;
  2,285 ( 0.00%)          if (cr.z > current.z) cr.z = current.z;
 13,709 ( 0.00%)          if (cr.w > current.w) cr.w = current.w;
      .               }
  5,712 ( 0.00%)      cr.z = ImMax(cr.x, cr.z);
      .               cr.w = ImMax(cr.y, cr.w);
      .           
      .               _ClipRectStack.push_back(cr);
 11,424 ( 0.00%)      _CmdHeader.ClipRect = cr;
      .               _OnChangedClipRect();
 33,129 ( 0.00%)  }
      .           
      .           void ImDrawList::PushClipRectFullScreen()
      .           {
      .               PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
      .           }
      .           
      .           void ImDrawList::PopClipRect()
  2,856 ( 0.00%)  {
      .               _ClipRectStack.pop_back();
 19,992 ( 0.00%)      _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
      .               _OnChangedClipRect();
  5,141 ( 0.00%)  }
      .           
      .           void ImDrawList::PushTextureID(ImTextureID texture_id)
 19,992 ( 0.00%)  {
      .               _TextureIdStack.push_back(texture_id);
  2,856 ( 0.00%)      _CmdHeader.TextureId = texture_id;
      .               _OnChangedTextureID();
 17,136 ( 0.00%)  }
      .           
      .           void ImDrawList::PopTextureID()
      .           {
      .               _TextureIdStack.pop_back();
      .               _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];
      .               _OnChangedTextureID();
      .           }
      .           
      .           // Reserve space for a number of vertices and indices.
      .           // You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
      .           // submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
      .           void ImDrawList::PrimReserve(int idx_count, int vtx_count)
 68,600 ( 0.00%)  {
      .               // Large mesh support (when enabled)
      .               IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
 27,440 ( 0.00%)      if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
      .               {
      .                   // FIXME: In theory we should be testing that vtx_count <64k here.
      .                   // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
      .                   // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
  6,860 ( 0.00%)          _CmdHeader.VtxOffset = VtxBuffer.Size;
      .                   _OnChangedVtxOffset();
      .               }
      .           
      .               ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
 13,720 ( 0.00%)      draw_cmd->ElemCount += idx_count;
      .           
      .               int vtx_buffer_old_size = VtxBuffer.Size;
  6,860 ( 0.00%)      VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
 34,284 ( 0.00%)      _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
      .           
  6,860 ( 0.00%)      int idx_buffer_old_size = IdxBuffer.Size;
  6,860 ( 0.00%)      IdxBuffer.resize(idx_buffer_old_size + idx_count);
 27,422 ( 0.00%)      _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
 54,880 ( 0.00%)  }
      .           
      .           // Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
      .           void ImDrawList::PrimUnreserve(int idx_count, int vtx_count)
      .           {
      .               IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
      .           
      .               ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
      .               draw_cmd->ElemCount -= idx_count;
      .               VtxBuffer.shrink(VtxBuffer.Size - vtx_count);
      .               IdxBuffer.shrink(IdxBuffer.Size - idx_count);
      .           }
      .           
      .           // Fully unrolled with inline call to keep our debug builds decently fast.
      .           void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
      .           {
  3,432 ( 0.00%)      ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
  1,716 ( 0.00%)      ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
 20,592 ( 0.00%)      _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
  3,432 ( 0.00%)      _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
 15,444 ( 0.00%)      _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
  3,432 ( 0.00%)      _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
  6,864 ( 0.00%)      _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
  3,432 ( 0.00%)      _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
  3,432 ( 0.00%)      _VtxWritePtr += 4;
  3,432 ( 0.00%)      _VtxCurrentIdx += 4;
  3,432 ( 0.00%)      _IdxWritePtr += 6;
      .           }
      .           
      .           void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
      .           {
      .               ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
      .               ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
      .               _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
      .               _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
-- line 685 ----------------------------------------
-- line 710 ----------------------------------------
      .           // - Those macros expects l-values and need to be used as their own statement.
      .           // - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.
      .           #define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
      .           #define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
      .           #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
      .           
      .           // TODO: Thickness anti-aliased lines cap are missing their AA fringe.
      .           // We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
  7,462 ( 0.00%)  void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness)
      .           {
  4,590 ( 0.00%)      if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
  1,163 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddPolyline(ImVec2 const*, int, unsigned int, int, float) [clone .part.0] (2x)
      .                   return;
      .           
  1,722 ( 0.00%)      const bool closed = (flags & ImDrawFlags_Closed) != 0;
  1,148 ( 0.00%)      const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
  2,298 ( 0.00%)      const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
    574 ( 0.00%)      const bool thick_line = (thickness > _FringeScale);
      .           
  2,870 ( 0.00%)      if (Flags & ImDrawListFlags_AntiAliasedLines)
      .               {
      .                   // Anti-aliased stroke
      .                   const float AA_SIZE = _FringeScale;
  1,148 ( 0.00%)          const ImU32 col_trans = col & ~IM_COL32_A_MASK;
      .           
      .                   // Thicknesses <1.0 should behave like thickness 1.0
  1,148 ( 0.00%)          thickness = ImMax(thickness, 1.0f);
  1,722 ( 0.00%)          const int integer_thickness = (int)thickness;
  1,148 ( 0.00%)          const float fractional_thickness = thickness - integer_thickness;
      .           
      .                   // Do we want to draw this line using a texture?
      .                   // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
      .                   // - If AA_SIZE is not 1.0f we cannot use the texture path.
  8,036 ( 0.00%)          const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
      .           
      .                   // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
      .                   IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
      .           
  2,296 ( 0.00%)          const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
  1,722 ( 0.00%)          const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
  2,296 ( 0.00%)          PrimReserve(idx_count, vtx_count);
 31,070 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (574x)
      .           
      .                   // Temporary buffer
      .                   // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
  5,160 ( 0.00%)          _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
    579 ( 0.00%)          ImVec2* temp_normals = _Data->TempBuffer.Data;
  4,018 ( 0.00%)          ImVec2* temp_points = temp_normals + points_count;
      .           
      .                   // Calculate normals (tangents) for each line segment
 10,308 ( 0.00%)          for (int i1 = 0; i1 < count; i1++)
      .                   {
      .                       const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
 11,450 ( 0.00%)              float dx = points[i2].x - points[i1].x;
  4,580 ( 0.00%)              float dy = points[i2].y - points[i1].y;
 14,314 ( 0.00%)              IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  4,580 ( 0.00%)              temp_normals[i1].x = dy;
  2,290 ( 0.00%)              temp_normals[i1].y = -dx;
      .                   }
  1,722 ( 0.00%)          if (!closed)
      8 ( 0.00%)              temp_normals[points_count - 1] = temp_normals[points_count - 2];
      .           
      .                   // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
  1,148 ( 0.00%)          if (use_texture || !thick_line)
      .                   {
      .                       // [PATH 1] Texture-based lines (thick or non-thick)
      .                       // [PATH 2] Non texture-based lines (non-thick)
      .           
      .                       // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
      .                       // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
      .                       //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
      .                       // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
      .                       //   allow scaling geometry while preserving one-screen-pixel AA fringe).
  2,870 ( 0.00%)              const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
      .           
      .                       // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
      .                       if (!closed)
      .                       {
      4 ( 0.00%)                  temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
      4 ( 0.00%)                  temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
     12 ( 0.00%)                  temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
      6 ( 0.00%)                  temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
      .                       }
      .           
      .                       // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
      .                       // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
      .                       // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  4,022 ( 0.00%)              unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
 11,448 ( 0.00%)              for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
      .                       {
  4,580 ( 0.00%)                  const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
  4,578 ( 0.00%)                  const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
      .           
      .                           // Average normals
  8,588 ( 0.00%)                  float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  6,870 ( 0.00%)                  float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
 18,320 ( 0.00%)                  IM_FIXNORMAL2F(dm_x, dm_y);
      .                           dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
      .                           dm_y *= half_draw_size;
      .           
      .                           // Add temporary vertexes for the outer edges
  6,872 ( 0.00%)                  ImVec2* out_vtx = &temp_points[i2 * 2];
  8,588 ( 0.00%)                  out_vtx[0].x = points[i2].x + dm_x;
  6,870 ( 0.00%)                  out_vtx[0].y = points[i2].y + dm_y;
  4,580 ( 0.00%)                  out_vtx[1].x = points[i2].x - dm_x;
  4,580 ( 0.00%)                  out_vtx[1].y = points[i2].y - dm_y;
      .           
      .                           if (use_texture)
      .                           {
      .                               // Add indices for two triangles
 27,480 ( 0.00%)                      _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
 13,740 ( 0.00%)                      _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
  2,290 ( 0.00%)                      _IdxWritePtr += 6;
      .                           }
      .                           else
      .                           {
      .                               // Add indexes for four triangles
      .                               _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
      .                               _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
      .                               _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
      .                               _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
-- line 828 ----------------------------------------
-- line 831 ----------------------------------------
      .           
      .                           idx1 = idx2;
      .                       }
      .           
      .                       // Add vertexes for each point on the line
      .                       if (use_texture)
      .                       {
      .                           // If we're using textures we only need to emit the left/right edge vertices
  2,870 ( 0.00%)                  ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
      .                           /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
      .                           {
      .                               const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
      .                               tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
      .                               tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
      .                               tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
      .                               tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
      .                           }*/
      .                           ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
      .                           ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
 17,782 ( 0.00%)                  for (int i = 0; i < points_count; i++)
      .                           {
  9,168 ( 0.00%)                      _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
  9,168 ( 0.00%)                      _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
  2,292 ( 0.00%)                      _VtxWritePtr += 2;
      .                           }
      .                       }
      .                       else
      .                       {
      .                           // If we're not using a texture, we need the center vertex as well
      .                           for (int i = 0; i < points_count; i++)
      .                           {
      .                               _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
-- line 862 ----------------------------------------
-- line 877 ----------------------------------------
      .                           const int points_last = points_count - 1;
      .                           temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
      .                           temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
      .                           temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
      .                           temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
      .                           temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
      .                           temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
      .                           temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
    574 ( 0.00%)                  temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
      .                       }
      .           
      .                       // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
      .                       // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
      .                       // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
      .                       unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
      .                       for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
      .                       {
-- line 893 ----------------------------------------
-- line 931 ----------------------------------------
      .                       {
      .                           _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
      .                           _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
      .                           _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
      .                           _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
      .                           _VtxWritePtr += 4;
      .                       }
      .                   }
  4,592 ( 0.00%)          _VtxCurrentIdx += (ImDrawIdx)vtx_count;
      .               }
      .               else
      .               {
      .                   // [PATH 4] Non texture-based, Non anti-aliased lines
      .                   const int idx_count = count * 6;
      .                   const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
      .                   PrimReserve(idx_count, vtx_count);
      .           
-- line 947 ----------------------------------------
-- line 964 ----------------------------------------
      .                       _VtxWritePtr += 4;
      .           
      .                       _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
      .                       _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
      .                       _IdxWritePtr += 6;
      .                       _VtxCurrentIdx += 4;
      .                   }
      .               }
  4,592 ( 0.00%)  }
      .           
      .           // - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
      .           // - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
  7,436 ( 0.00%)  void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
      .           {
  3,432 ( 0.00%)      if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
229,210 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddConvexPolyFilled(ImVec2 const*, int, unsigned int) [clone .part.0] (572x)
      .                   return;
      .           
  2,860 ( 0.00%)      const ImVec2 uv = _Data->TexUvWhitePixel;
      .           
  1,144 ( 0.00%)      if (Flags & ImDrawListFlags_AntiAliasedFill)
      .               {
      .                   // Anti-aliased Fill
  1,144 ( 0.00%)          const float AA_SIZE = _FringeScale;
  1,716 ( 0.00%)          const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  2,288 ( 0.00%)          const int idx_count = (points_count - 2)*3 + points_count * 6;
  1,144 ( 0.00%)          const int vtx_count = (points_count * 2);
    572 ( 0.00%)          PrimReserve(idx_count, vtx_count);
 30,154 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (572x)
      .           
      .                   // Add indexes for fill
    572 ( 0.00%)          unsigned int vtx_inner_idx = _VtxCurrentIdx;
  1,144 ( 0.00%)          unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
  9,724 ( 0.00%)          for (int i = 2; i < points_count; i++)
      .                   {
  4,004 ( 0.00%)              _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
      .                       _IdxWritePtr += 3;
      .                   }
      .           
      .                   // Compute normals
  1,716 ( 0.00%)          _Data->TempBuffer.reserve_discard(points_count);
    572 ( 0.00%)          ImVec2* temp_normals = _Data->TempBuffer.Data;
 12,012 ( 0.00%)          for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
      .                   {
  1,716 ( 0.00%)              const ImVec2& p0 = points[i0];
      .                       const ImVec2& p1 = points[i1];
  5,148 ( 0.00%)              float dx = p1.x - p0.x;
  3,432 ( 0.00%)              float dy = p1.y - p0.y;
 11,440 ( 0.00%)              IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  3,432 ( 0.00%)              temp_normals[i0].x = dy;
  1,716 ( 0.00%)              temp_normals[i0].y = -dx;
      .                   }
      .           
 26,884 ( 0.00%)          for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
      .                   {
      .                       // Average normals
  3,432 ( 0.00%)              const ImVec2& n0 = temp_normals[i0];
      .                       const ImVec2& n1 = temp_normals[i1];
  5,148 ( 0.00%)              float dm_x = (n0.x + n1.x) * 0.5f;
  5,148 ( 0.00%)              float dm_y = (n0.y + n1.y) * 0.5f;
 18,304 ( 0.00%)              IM_FIXNORMAL2F(dm_x, dm_y);
  2,288 ( 0.00%)              dm_x *= AA_SIZE * 0.5f;
      .                       dm_y *= AA_SIZE * 0.5f;
      .           
      .                       // Add vertices
 13,728 ( 0.00%)              _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
 12,012 ( 0.00%)              _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
      .                       _VtxWritePtr += 2;
      .           
      .                       // Add indexes for fringes
 19,448 ( 0.00%)              _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
  5,148 ( 0.00%)              _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
      .                       _IdxWritePtr += 6;
      .                   }
  2,860 ( 0.00%)          _VtxCurrentIdx += (ImDrawIdx)vtx_count;
      .               }
      .               else
      .               {
      .                   // Non Anti-aliased Fill
      .                   const int idx_count = (points_count - 2)*3;
      .                   const int vtx_count = points_count;
      .                   PrimReserve(idx_count, vtx_count);
      .                   for (int i = 0; i < vtx_count; i++)
-- line 1044 ----------------------------------------
-- line 1048 ----------------------------------------
      .                   }
      .                   for (int i = 2; i < points_count; i++)
      .                   {
      .                       _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
      .                       _IdxWritePtr += 3;
      .                   }
      .                   _VtxCurrentIdx += (ImDrawIdx)vtx_count;
      .               }
  4,576 ( 0.00%)  }
      .           
      .           void ImDrawList::_PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step)
      .           {
      .               if (radius < 0.5f)
      .               {
      .                   _Path.push_back(center);
      .                   return;
      .               }
-- line 1064 ----------------------------------------
-- line 1361 ----------------------------------------
      .           
      .               if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
      .                   flags |= ImDrawFlags_RoundCornersAll;
      .           
      .               return flags;
      .           }
      .           
      .           void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawFlags flags)
  6,292 ( 0.00%)  {
  1,716 ( 0.00%)      if (rounding >= 0.5f)
      .               {
      .                   flags = FixRectCornerFlags(flags);
      .                   rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
      .                   rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
      .               }
  1,144 ( 0.00%)      if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
      .               {
      .                   PathLineTo(a);
      .                   PathLineTo(ImVec2(b.x, a.y));
      .                   PathLineTo(b);
      .                   PathLineTo(ImVec2(a.x, b.y));
      .               }
      .               else
      .               {
-- line 1384 ----------------------------------------
-- line 1386 ----------------------------------------
      .                   const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
      .                   const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
      .                   const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
      .                   PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
      .                   PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
      .                   PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
      .                   PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
      .               }
  4,576 ( 0.00%)  }
      .           
      .           void ImDrawList::AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness)
     18 ( 0.00%)  {
      4 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
      .                   return;
      .               PathLineTo(p1 + ImVec2(0.5f, 0.5f));
      .               PathLineTo(p2 + ImVec2(0.5f, 0.5f));
      .               PathStroke(col, 0, thickness);
     14 ( 0.00%)  }
      .           
      .           // p_min = upper-left, p_max = lower-right
      .           // Note we don't render 1 pixels sized rectangles properly.
      .           void ImDrawList::AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness)
  4,004 ( 0.00%)  {
  1,144 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
      .                   return;
  1,144 ( 0.00%)      if (Flags & ImDrawListFlags_AntiAliasedLines)
      .                   PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
      .               else
  4,004 ( 0.00%)          PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
 36,622 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PathRect(ImVec2 const&, ImVec2 const&, float, int) (572x)
      .               PathStroke(col, ImDrawFlags_Closed, thickness);
  2,860 ( 0.00%)  }
      .           
      .           void ImDrawList::AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags)
 15,444 ( 0.00%)  {
  3,432 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
      .                   return;
  5,148 ( 0.00%)      if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
      .               {
  6,864 ( 0.00%)          PrimReserve(6, 4);
 88,620 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (1,716x)
      .                   PrimRect(p_min, p_max, col);
      .               }
      .               else
      .               {
      .                   PathRect(p_min, p_max, rounding, flags);
      .                   PathFillConvex(col);
      .               }
 10,296 ( 0.00%)  }
      .           
      .           // p_min = upper-left, p_max = lower-right
      .           void ImDrawList::AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
      .           {
      .               if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
      .                   return;
      .           
      .               const ImVec2 uv = _Data->TexUvWhitePixel;
-- line 1440 ----------------------------------------
-- line 1479 ----------------------------------------
      .               PathLineTo(p1);
      .               PathLineTo(p2);
      .               PathLineTo(p3);
      .               PathStroke(col, ImDrawFlags_Closed, thickness);
      .           }
      .           
      .           void ImDrawList::AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col)
      .           {
  1,144 ( 0.00%)      if ((col & IM_COL32_A_MASK) == 0)
      .                   return;
      .           
      .               PathLineTo(p1);
      .               PathLineTo(p2);
      .               PathLineTo(p3);
      .               PathFillConvex(col);
      .           }
      .           
-- line 1495 ----------------------------------------
-- line 1612 ----------------------------------------
      .                   return;
      .           
      .               PathLineTo(p1);
      .               PathBezierQuadraticCurveTo(p2, p3, num_segments);
      .               PathStroke(col, 0, thickness);
      .           }
      .           
      .           void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
 19,990 ( 0.00%)  {
      .               if ((col & IM_COL32_A_MASK) == 0)
      .                   return;
      .           
      .               // Accept null ranges
 23,988 ( 0.00%)      if (text_begin == text_end || text_begin[0] == 0)
      .                   return;
 19,990 ( 0.00%)      if (text_end == NULL)
      .                   text_end = text_begin + strlen(text_begin);
      .           
      .               // Pull default font/size from the shared ImDrawListSharedData instance
  7,996 ( 0.00%)      if (font == NULL)
  1,716 ( 0.00%)          font = _Data->Font;
 15,992 ( 0.00%)      if (font_size == 0.0f)
  1,144 ( 0.00%)          font_size = _Data->FontSize;
      .           
 15,992 ( 0.00%)      IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
      .           
  7,998 ( 0.00%)      ImVec4 clip_rect = _CmdHeader.ClipRect;
  7,996 ( 0.00%)      if (cpu_fine_clip_rect)
      .               {
      1 ( 0.00%)          clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
      2 ( 0.00%)          clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
      .                   clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
      8 ( 0.00%)          clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
      .               }
 55,972 ( 0.00%)      font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
3,623,938 ( 0.01%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::RenderText(ImDrawList*, float, ImVec2 const&, unsigned int, ImVec4 const&, char const*, char const*, float, bool) const (3,998x)
 19,990 ( 0.00%)  }
      .           
      .           void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
      .           {
      .               AddText(NULL, 0.0f, pos, col, text_begin, text_end);
      .           }
      .           
      .           void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col)
      .           {
-- line 1655 ----------------------------------------
-- line 2022 ----------------------------------------
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImDrawListSplitter
      .           //-----------------------------------------------------------------------------
      .           // FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
      .           //-----------------------------------------------------------------------------
      .           
      .           void ImDrawListSplitter::ClearFreeMemory()
      9 ( 0.00%)  {
      3 ( 0.00%)      for (int i = 0; i < _Channels.Size; i++)
      .               {
      .                   if (i == _Current)
      .                       memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
      .                   _Channels[i]._CmdBuffer.clear();
      .                   _Channels[i]._IdxBuffer.clear();
      .               }
      2 ( 0.00%)      _Current = 0;
      .               _Count = 1;
      .               _Channels.clear();
      8 ( 0.00%)  }
      .           
      .           void ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)
  4,568 ( 0.00%)  {
      .               IM_UNUSED(draw_list);
  3,426 ( 0.00%)      IM_ASSERT(_Current == 0 && _Count <= 1 && "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.");
  1,713 ( 0.00%)      int old_channels_count = _Channels.Size;
  1,142 ( 0.00%)      if (old_channels_count < channels_count)
      .               {
      .                   _Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable
      .                   _Channels.resize(channels_count);
      .               }
    571 ( 0.00%)      _Count = channels_count;
      .           
      .               // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
      .               // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
      .               // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
  1,713 ( 0.00%)      memset(&_Channels[0], 0, sizeof(ImDrawChannel));
  5,710 ( 0.00%)      for (int i = 1; i < channels_count; i++)
      .               {
  2,284 ( 0.00%)          if (i >= old_channels_count)
      .                   {
      .                       IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
      .                   }
      .                   else
      .                   {
      .                       _Channels[i]._CmdBuffer.resize(0);
      .                       _Channels[i]._IdxBuffer.resize(0);
      .                   }
      .               }
  4,568 ( 0.00%)  }
      .           
  5,139 ( 0.00%)  void ImDrawListSplitter::Merge(ImDrawList* draw_list)
      .           {
      .               // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
  1,713 ( 0.00%)      if (_Count <= 1)
134,721 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::Merge(ImDrawList*) [clone .part.0] (571x)
      .                   return;
      .           
  1,142 ( 0.00%)      SetCurrentChannel(draw_list, 0);
 28,554 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSplitter::SetCurrentChannel(ImDrawList*, int) (571x)
      .               draw_list->_PopUnusedDrawCmd();
      .           
      .               // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
      .               int new_cmd_buffer_count = 0;
      .               int new_idx_buffer_count = 0;
      2 ( 0.00%)      ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;
    576 ( 0.00%)      int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
  6,852 ( 0.00%)      for (int i = 1; i < _Count; i++)
      .               {
      .                   ImDrawChannel& ch = _Channels[i];
  4,568 ( 0.00%)          if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
      .                       ch._CmdBuffer.pop_back();
      .           
    571 ( 0.00%)          if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)
      .                   {
      .                       // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
      .                       // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
      .                       ImDrawCmd* next_cmd = &ch._CmdBuffer[0];
      .                       if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)
      .                       {
      .                           // Merge previous channel last draw command with current channel first draw command if matching.
      .                           last_cmd->ElemCount += next_cmd->ElemCount;
      .                           idx_offset += next_cmd->ElemCount;
      .                           ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
      .                       }
      .                   }
  1,142 ( 0.00%)          if (ch._CmdBuffer.Size > 0)
      .                       last_cmd = &ch._CmdBuffer.back();
    571 ( 0.00%)          new_cmd_buffer_count += ch._CmdBuffer.Size;
  2,284 ( 0.00%)          new_idx_buffer_count += ch._IdxBuffer.Size;
      .                   for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)
      .                   {
      .                       ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;
      .                       idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;
      .                   }
      .               }
  1,142 ( 0.00%)      draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);
  1,142 ( 0.00%)      draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);
      .           
      .               // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
  4,568 ( 0.00%)      ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;
  1,142 ( 0.00%)      ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;
  5,140 ( 0.00%)      for (int i = 1; i < _Count; i++)
      .               {
      .                   ImDrawChannel& ch = _Channels[i];
  1,713 ( 0.00%)          if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
  1,713 ( 0.00%)          if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }
      .               }
    571 ( 0.00%)      draw_list->_IdxWritePtr = idx_write;
      .           
      .               // Ensure there's always a non-callback draw command trailing the command-buffer
  1,715 ( 0.00%)      if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)
  1,140 ( 0.00%)          draw_list->AddDrawCmd();
 25,650 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddDrawCmd() (570x)
      .           
      .               // If current command is used with different settings we need to add a new command
  2,850 ( 0.00%)      ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
  1,713 ( 0.00%)      if (curr_cmd->ElemCount == 0)
  2,850 ( 0.00%)          ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
      8 ( 0.00%)      else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
      .                   draw_list->AddDrawCmd();
      .           
    571 ( 0.00%)      _Count = 1;
  4,568 ( 0.00%)  }
      .           
      .           void ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)
      .           {
  8,570 ( 0.00%)      IM_ASSERT(idx >= 0 && idx < _Count);
  5,142 ( 0.00%)      if (_Current == idx)
      .                   return;
      .           
      .               // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
  5,720 ( 0.00%)      memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));
  5,720 ( 0.00%)      memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));
  1,144 ( 0.00%)      _Current = idx;
  8,008 ( 0.00%)      memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));
  5,720 ( 0.00%)      memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));
  3,432 ( 0.00%)      draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;
      .           
      .               // If current command is used with different settings we need to add a new command
  4,580 ( 0.00%)      ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
  1,146 ( 0.00%)      if (curr_cmd == NULL)
    571 ( 0.00%)          draw_list->AddDrawCmd();
 26,039 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddDrawCmd() (571x)
  1,719 ( 0.00%)      else if (curr_cmd->ElemCount == 0)
  2,860 ( 0.00%)          ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
    579 ( 0.00%)      else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
      .                   draw_list->AddDrawCmd();
      .           }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImDrawData
      .           //-----------------------------------------------------------------------------
      .           
      .           void ImDrawData::Clear()
      8 ( 0.00%)  {
      2 ( 0.00%)      Valid = false;
      4 ( 0.00%)      CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
      .               CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
      8 ( 0.00%)      DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
      2 ( 0.00%)      OwnerViewport = NULL;
      8 ( 0.00%)  }
      .           
      .           // Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list
      .           // as long at it is expected that the result will be later merged into draw_data->CmdLists[].
      .           void ImGui::AddDrawListToDrawDataEx(ImDrawData* draw_data, ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
 18,264 ( 0.00%)  {
  6,849 ( 0.00%)      if (draw_list->CmdBuffer.Size == 0)
      .                   return;
 14,835 ( 0.00%)      if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
      .                   return;
      .           
      .               // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
      .               // May trigger for you if you are using PrimXXX functions incorrectly.
  5,148 ( 0.00%)      IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
  4,004 ( 0.00%)      IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
  1,144 ( 0.00%)      if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
    572 ( 0.00%)          IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
      .           
      .               // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
      .               // If this assert triggers because you are drawing lots of stuff manually:
      .               // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
      .               //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
      .               // - If you want large meshes with more than 64K vertices, you can either:
      .               //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
      .               //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
-- line 2203 ----------------------------------------
-- line 2205 ----------------------------------------
      .               //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
      .               //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
      .               //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
      .               //       Your own engine or render API may use different parameters or function calls to specify index sizes.
      .               //       2 and 4 bytes indices are generally supported by most graphics API.
      .               // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
      .               //   the 64K limit to split your draw commands in multiple draw lists.
      .               if (sizeof(ImDrawIdx) == 2)
  1,144 ( 0.00%)          IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
      .           
      .               // Add to output list + records state in ImDrawData
      .               out_list->push_back(draw_list);
  3,432 ( 0.00%)      draw_data->CmdListsCount++;
  1,144 ( 0.00%)      draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
      .               draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
 13,698 ( 0.00%)  }
      .           
      .           void ImDrawData::AddDrawList(ImDrawList* draw_list)
      .           {
      .               IM_ASSERT(CmdLists.Size == CmdListsCount);
      .               draw_list->_PopUnusedDrawCmd();
      .               ImGui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);
      .           }
      .           
-- line 2228 ----------------------------------------
-- line 2317 ----------------------------------------
      .           }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImFontConfig
      .           //-----------------------------------------------------------------------------
      .           
      .           ImFontConfig::ImFontConfig()
      .           {
     12 ( 0.00%)      memset(this, 0, sizeof(*this));
      2 ( 0.00%)      FontDataOwnedByAtlas = true;
      2 ( 0.00%)      OversampleH = 2;
      .               OversampleV = 1;
      2 ( 0.00%)      GlyphMaxAdvanceX = FLT_MAX;
      4 ( 0.00%)      RasterizerMultiply = 1.0f;
      .               RasterizerDensity = 1.0f;
      3 ( 0.00%)      EllipsisChar = (ImWchar)-1;
      1 ( 0.00%)  }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImFontAtlas
      .           //-----------------------------------------------------------------------------
      .           
      .           // A work of art lies ahead! (. = white layer, X = black layer, others are blank)
      .           // The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
      .           // (This is used when io.MouseDrawCursor = true)
-- line 2341 ----------------------------------------
-- line 2381 ----------------------------------------
      .               { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
      .               { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
      .               { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
      .               { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
      .               { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
      .               { ImVec2(109,0),ImVec2(13,15), ImVec2( 6, 7) }, // ImGuiMouseCursor_NotAllowed
      .           };
      .           
      1 ( 0.00%)  ImFontAtlas::ImFontAtlas()
      .           {
      4 ( 0.00%)      memset(this, 0, sizeof(*this));
     85 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      1 ( 0.00%)      TexGlyphPadding = 1;
      1 ( 0.00%)      PackIdMouseCursors = PackIdLines = -1;
      2 ( 0.00%)  }
      .           
      .           ImFontAtlas::~ImFontAtlas()
      .           {
      .               IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
      .               Clear();
      .           }
      .           
      .           void    ImFontAtlas::ClearInputData()
-- line 2402 ----------------------------------------
-- line 2419 ----------------------------------------
      .               ConfigData.clear();
      .               CustomRects.clear();
      .               PackIdMouseCursors = PackIdLines = -1;
      .               // Important: we leave TexReady untouched
      .           }
      .           
      .           void    ImFontAtlas::ClearTexData()
      .           {
      6 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
     10 ( 0.00%)      if (TexPixelsAlpha8)
      .                   IM_FREE(TexPixelsAlpha8);
     10 ( 0.00%)      if (TexPixelsRGBA32)
      .                   IM_FREE(TexPixelsRGBA32);
      7 ( 0.00%)      TexPixelsAlpha8 = NULL;
      .               TexPixelsRGBA32 = NULL;
      3 ( 0.00%)      TexPixelsUseColors = false;
      .               // Important: we leave TexReady untouched
      .           }
      .           
      .           void    ImFontAtlas::ClearFonts()
      .           {
      .               IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
      .               Fonts.clear_delete();
      .               TexReady = false;
-- line 2442 ----------------------------------------
-- line 2447 ----------------------------------------
      .               ClearInputData();
      .               ClearTexData();
      .               ClearFonts();
      .           }
      .           
      .           void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
      .           {
      .               // Build atlas on demand
      3 ( 0.00%)      if (TexPixelsAlpha8 == NULL)
      .                   Build();
      .           
      1 ( 0.00%)      *out_pixels = TexPixelsAlpha8;
      .               if (out_width) *out_width = TexWidth;
      .               if (out_height) *out_height = TexHeight;
      .               if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
      .           }
      .           
      .           void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
     14 ( 0.00%)  {
      .               // Convert to RGBA32 format on demand
      .               // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
      3 ( 0.00%)      if (!TexPixelsRGBA32)
      .               {
      .                   unsigned char* pixels = NULL;
      .                   GetTexDataAsAlpha8(&pixels, NULL, NULL);
      2 ( 0.00%)          if (pixels)
      .                   {
      8 ( 0.00%)              TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
    426 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
      .                       const unsigned char* src = pixels;
      .                       unsigned int* dst = TexPixelsRGBA32;
 16,413 ( 0.00%)              for (int n = TexWidth * TexHeight; n > 0; n--)
196,617 ( 0.00%)                  *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
      .                   }
      .               }
      .           
      1 ( 0.00%)      *out_pixels = (unsigned char*)TexPixelsRGBA32;
      4 ( 0.00%)      if (out_width) *out_width = TexWidth;
      4 ( 0.00%)      if (out_height) *out_height = TexHeight;
      2 ( 0.00%)      if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
      8 ( 0.00%)  }
      .           
      .           ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
     16 ( 0.00%)  {
      4 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
     12 ( 0.00%)      IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
      8 ( 0.00%)      IM_ASSERT(font_cfg->SizePixels > 0.0f);
      .           
      .               // Create new font
      6 ( 0.00%)      if (!font_cfg->MergeMode)
      3 ( 0.00%)          Fonts.push_back(IM_NEW(ImFont));
     69 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
      .               else
      3 ( 0.00%)          IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
      .           
      .               ConfigData.push_back(*font_cfg);
      .               ImFontConfig& new_font_cfg = ConfigData.back();
      6 ( 0.00%)      if (new_font_cfg.DstFont == NULL)
     10 ( 0.00%)          new_font_cfg.DstFont = Fonts.back();
      6 ( 0.00%)      if (!new_font_cfg.FontDataOwnedByAtlas)
      .               {
      .                   new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
      .                   new_font_cfg.FontDataOwnedByAtlas = true;
      .                   memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
      .               }
      .           
      4 ( 0.00%)      if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
      2 ( 0.00%)          new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
      .           
      .               ImFontAtlasUpdateConfigDataPointers(this);
      .           
      .               // Invalidate texture
      2 ( 0.00%)      TexReady = false;
      .               ClearTexData();
      2 ( 0.00%)      return new_font_cfg.DstFont;
     16 ( 0.00%)  }
      .           
      .           // Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
      .           static unsigned int stb_decompress_length(const unsigned char* input);
      .           static unsigned int stb_decompress(unsigned char* output, const unsigned char* input, unsigned int length);
      .           static const char*  GetDefaultCompressedFontDataTTFBase85();
655,017 ( 0.00%)  static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
      .           static void         Decode85(const unsigned char* src, unsigned char* dst)
      .           {
100,626 ( 0.00%)      while (*src)
      .               {
402,456 ( 0.00%)          unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
234,766 ( 0.00%)          dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
 33,538 ( 0.00%)          src += 5;
 33,538 ( 0.00%)          dst += 4;
      .               }
      .           }
      .           
      .           // Load embedded ProggyClean.ttf at size 13, disable oversampling
      .           ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
      6 ( 0.00%)  {
      2 ( 0.00%)      ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
      .               if (!font_cfg_template)
      .               {
      2 ( 0.00%)          font_cfg.OversampleH = font_cfg.OversampleV = 1;
      1 ( 0.00%)          font_cfg.PixelSnapH = true;
      .               }
      .               if (font_cfg.SizePixels <= 0.0f)
      3 ( 0.00%)          font_cfg.SizePixels = 13.0f * 1.0f;
      .               if (font_cfg.Name[0] == '\0')
      8 ( 0.00%)          ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
  1,750 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImFormatString(char*, unsigned long, char const*, ...) (1x)
      1 ( 0.00%)      font_cfg.EllipsisChar = (ImWchar)0x0085;
      8 ( 0.00%)      font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
      .           
      .               const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
      4 ( 0.00%)      const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
      5 ( 0.00%)      ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
334,816 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(char const*, float, ImFontConfig const*, unsigned short const*) (1x)
      .               return font;
      5 ( 0.00%)  }
      .           
      .           ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
      .           {
      .               IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
      .               size_t data_size = 0;
      .               void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
      .               if (!data)
      .               {
-- line 2566 ----------------------------------------
-- line 2576 ----------------------------------------
      .                   ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
      .               }
      .               return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
      .           }
      .           
      .           // NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
      .           ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
      .           {
      4 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
     20 ( 0.00%)      ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
      .               IM_ASSERT(font_cfg.FontData == NULL);
      4 ( 0.00%)      IM_ASSERT(font_data_size > 100 && "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
      2 ( 0.00%)      font_cfg.FontData = font_data;
      2 ( 0.00%)      font_cfg.FontDataSize = font_data_size;
     10 ( 0.00%)      font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
      4 ( 0.00%)      if (glyph_ranges)
      2 ( 0.00%)          font_cfg.GlyphRanges = glyph_ranges;
      8 ( 0.00%)      return AddFont(&font_cfg);
  1,407 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFont(ImFontConfig const*) (2x)
      .           }
      .           
      .           ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
     30 ( 0.00%)  {
      .               const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
      6 ( 0.00%)      unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
    769 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (2x)
      .               stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
      .           
     36 ( 0.00%)      ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
      4 ( 0.00%)      IM_ASSERT(font_cfg.FontData == NULL);
      2 ( 0.00%)      font_cfg.FontDataOwnedByAtlas = true;
      .               return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
     16 ( 0.00%)  }
      .           
      .           ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
     24 ( 0.00%)  {
     20 ( 0.00%)      int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
 13,180 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (2x)
      6 ( 0.00%)      void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
    896 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (2x)
      .               Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
     14 ( 0.00%)      ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
1,239,047 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddFontFromMemoryCompressedTTF(void const*, int, float, ImFontConfig const*, unsigned short const*) (2x)
      4 ( 0.00%)      IM_FREE(compressed_ttf);
    414 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (2x)
      .               return font;
     18 ( 0.00%)  }
      .           
      .           int ImFontAtlas::AddCustomRectRegular(int width, int height)
     14 ( 0.00%)  {
      6 ( 0.00%)      IM_ASSERT(width > 0 && width <= 0xFFFF);
      6 ( 0.00%)      IM_ASSERT(height > 0 && height <= 0xFFFF);
      .               ImFontAtlasCustomRect r;
      8 ( 0.00%)      r.Width = (unsigned short)width;
      .               r.Height = (unsigned short)height;
      .               CustomRects.push_back(r);
      2 ( 0.00%)      return CustomRects.Size - 1; // Return index
     12 ( 0.00%)  }
      .           
      .           int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
      .           {
      .           #ifdef IMGUI_USE_WCHAR32
      .               IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);
      .           #endif
      .               IM_ASSERT(font != NULL);
      .               IM_ASSERT(width > 0 && width <= 0xFFFF);
-- line 2635 ----------------------------------------
-- line 2671 ----------------------------------------
      .               pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
      .               out_uv_fill[0] = (pos) * TexUvScale;
      .               out_uv_fill[1] = (pos + size) * TexUvScale;
      .               return true;
      .           }
      .           
      .           bool    ImFontAtlas::Build()
      .           {
      2 ( 0.00%)      IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
      .           
      .               // Default font is none are specified
      3 ( 0.00%)      if (ConfigData.Size == 0)
      .                   AddFontDefault();
      .           
      .               // Select builder
      .               // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
      .               //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
      .               //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
      .               //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
      1 ( 0.00%)      const ImFontBuilderIO* builder_io = FontBuilderIO;
      2 ( 0.00%)      if (builder_io == NULL)
      .               {
      .           #ifdef IMGUI_ENABLE_FREETYPE
      .                   builder_io = ImGuiFreeType::GetBuilderForFreeType();
      .           #elif defined(IMGUI_ENABLE_STB_TRUETYPE)
      .                   builder_io = ImFontAtlasGetBuilderForStbTruetype();
      .           #else
      .                   IM_ASSERT(0); // Invalid Build function
      .           #endif
      .               }
      .           
      .               // Build
      2 ( 0.00%)      return builder_io->FontBuilder_Build(this);
35,367,995 ( 0.06%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildWithStbTruetype(ImFontAtlas*) (1x)
      .           }
      .           
      .           void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
      .           {
      .               for (unsigned int i = 0; i < 256; i++)
      .               {
      .                   unsigned int value = (unsigned int)(i * in_brighten_factor);
      .                   out_table[i] = value > 255 ? 255 : (value & 0xFF);
-- line 2711 ----------------------------------------
-- line 2747 ----------------------------------------
      .               ImBitVector         GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
      .           };
      .           
      .           static void UnpackBitVectorToFlatIndexList(const ImBitVector* in, ImVector<int>* out)
      .           {
      .               IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
      .               const ImU32* it_begin = in->Storage.begin();
      .               const ImU32* it_end = in->Storage.end();
  7,816 ( 0.00%)      for (const ImU32* it = it_begin; it < it_end; it++)
  5,856 ( 0.00%)          if (ImU32 entries_32 = *it)
  3,007 ( 0.00%)              for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
  1,984 ( 0.00%)                  if (entries_32 & ((ImU32)1 << bit_n))
  1,119 ( 0.00%)                      out->push_back((int)(((it - it_begin) << 5) + bit_n));
      .           }
      .           
      .           static bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
     13 ( 0.00%)  {
      4 ( 0.00%)      IM_ASSERT(atlas->ConfigData.Size > 0);
      .           
      1 ( 0.00%)      ImFontAtlasBuildInit(atlas);
    224 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildInit(ImFontAtlas*) (1x)
      .           
      .               // Clear atlas
      1 ( 0.00%)      atlas->TexID = (ImTextureID)NULL;
      1 ( 0.00%)      atlas->TexWidth = atlas->TexHeight = 0;
      2 ( 0.00%)      atlas->TexUvScale = ImVec2(0.0f, 0.0f);
      .               atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
      .               atlas->ClearTexData();
      .           
      .               // Temporary storage for building
      .               ImVector<ImFontBuildSrcData> src_tmp_array;
      .               ImVector<ImFontBuildDstData> dst_tmp_array;
      2 ( 0.00%)      src_tmp_array.resize(atlas->ConfigData.Size);
      3 ( 0.00%)      dst_tmp_array.resize(atlas->Fonts.Size);
      7 ( 0.00%)      memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
     50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      5 ( 0.00%)      memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
     12 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      .           
      .               // 1. Initialize font loading structure, check font data validity
     19 ( 0.00%)      for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
      .               {
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      .                   ImFontConfig& cfg = atlas->ConfigData[src_i];
     10 ( 0.00%)          IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
      .           
      .                   // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
      2 ( 0.00%)          src_tmp.DstIndex = -1;
      8 ( 0.00%)          for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
      4 ( 0.00%)              if (cfg.DstFont == atlas->Fonts[output_i])
      2 ( 0.00%)                  src_tmp.DstIndex = output_i;
      .                   if (src_tmp.DstIndex == -1)
      .                   {
      .                       IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
      .                       return false;
      .                   }
      .                   // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
      4 ( 0.00%)          const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
      .                   IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
      .                   if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
      .                   {
      .                       IM_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.");
      .                       return false;
      .                   }
      .           
      .                   // Measure highest codepoints
      .                   ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
      8 ( 0.00%)          src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
     20 ( 0.00%)          for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
      .                   {
      .                       // Check for valid range. This may also help detect *some* dangling pointers, because a common
      .                       // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent.
      4 ( 0.00%)              IM_ASSERT(src_range[0] <= src_range[1]);
      2 ( 0.00%)              src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
      .                   }
     10 ( 0.00%)          dst_tmp.SrcCount++;
      .                   dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
      .               }
      .           
      .               // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
      4 ( 0.00%)      int total_glyphs_count = 0;
      7 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
      .               {
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      2 ( 0.00%)          ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
      .                   src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
      8 ( 0.00%)          if (dst_tmp.GlyphsSet.Storage.empty())
      .                       dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
      .           
     36 ( 0.00%)          for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  2,911 ( 0.00%)              for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
      .                       {
  1,922 ( 0.00%)                  if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
      .                               continue;
  5,766 ( 0.00%)                  if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
172,397 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_FindGlyphIndex.isra.0 (961x)
      .                               continue;
      .           
      .                           // Add to avail set/counters
    902 ( 0.00%)                  src_tmp.GlyphsCount++;
    902 ( 0.00%)                  dst_tmp.GlyphsCount++;
      .                           src_tmp.GlyphsSet.SetBit(codepoint);
      .                           dst_tmp.GlyphsSet.SetBit(codepoint);
    902 ( 0.00%)                  total_glyphs_count++;
      .                       }
      .               }
      .           
      .               // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
      6 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
      .               {
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      2 ( 0.00%)          src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
      .                   UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
      .                   src_tmp.GlyphsSet.Clear();
      6 ( 0.00%)          IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
      .               }
     10 ( 0.00%)      for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
      .                   dst_tmp_array[dst_i].GlyphsSet.Clear();
      .               dst_tmp_array.clear();
      .           
      .               // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
      .               // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
      .               ImVector<stbrp_rect> buf_rects;
      .               ImVector<stbtt_packedchar> buf_packedchars;
      .               buf_rects.resize(total_glyphs_count);
      .               buf_packedchars.resize(total_glyphs_count);
      5 ( 0.00%)      memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
 21,665 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      6 ( 0.00%)      memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
 25,273 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      .           
      .               // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
      1 ( 0.00%)      int total_surface = 0;
      2 ( 0.00%)      int buf_rects_out_n = 0;
      .               int buf_packedchars_out_n = 0;
     17 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
      .               {
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      6 ( 0.00%)          if (src_tmp.GlyphsCount == 0)
      .                       continue;
      .           
      2 ( 0.00%)          src_tmp.Rects = &buf_rects[buf_rects_out_n];
      2 ( 0.00%)          src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
      4 ( 0.00%)          buf_rects_out_n += src_tmp.GlyphsCount;
      .                   buf_packedchars_out_n += src_tmp.GlyphsCount;
      .           
      .                   // Convert our ranges in the format stb_truetype wants
      .                   ImFontConfig& cfg = atlas->ConfigData[src_i];
      6 ( 0.00%)          src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
      2 ( 0.00%)          src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
      4 ( 0.00%)          src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
      4 ( 0.00%)          src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
      2 ( 0.00%)          src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
      4 ( 0.00%)          src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
      4 ( 0.00%)          src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
      .           
      .                   // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
     16 ( 0.00%)          const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
      2 ( 0.00%)          const int padding = atlas->TexGlyphPadding;
  4,544 ( 0.00%)          for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
      .                   {
      .                       int x0, y0, x1, y1;
  4,510 ( 0.00%)              const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
162,713 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_FindGlyphIndex.isra.0 (902x)
  1,804 ( 0.00%)              IM_ASSERT(glyph_index_in_font != 0);
 10,824 ( 0.00%)              stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
111,066 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_truetype.h:stbtt_GetGlyphBitmapBoxSubpixel.constprop.0 (902x)
  6,314 ( 0.00%)              src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
  5,412 ( 0.00%)              src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
  1,804 ( 0.00%)              total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
      .                   }
      .               }
      .           
      .               // We need a width for the skyline algorithm, any width!
      .               // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
      .               // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
      8 ( 0.00%)      const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
      2 ( 0.00%)      atlas->TexHeight = 0;
      4 ( 0.00%)      if (atlas->TexDesiredWidth > 0)
      3 ( 0.00%)          atlas->TexWidth = atlas->TexDesiredWidth;
      .               else
     14 ( 0.00%)          atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
      .           
      .               // 5. Start packing
      .               // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
      .               const int TEX_HEIGHT_MAX = 1024 * 32;
      .               stbtt_pack_context spc = {};
      1 ( 0.00%)      stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
      3 ( 0.00%)      ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
  1,213 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildPackCustomRects(ImFontAtlas*, void*) (1x)
      .           
      .               // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
     13 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
      .               {
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      6 ( 0.00%)          if (src_tmp.GlyphsCount == 0)
      .                       continue;
      .           
      6 ( 0.00%)          stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
3,058,241 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_rectpack.h:stbrp_pack_rects.isra.0 (2x)
      .           
      .                   // Extend texture height and mark missing glyphs as non-packed so we won't render them.
      .                   // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
  2,730 ( 0.00%)          for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  2,706 ( 0.00%)              if (src_tmp.Rects[glyph_i].was_packed)
  1,804 ( 0.00%)                  atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
      .               }
      .           
      .               // 7. Allocate texture
      7 ( 0.00%)      atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
     10 ( 0.00%)      atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
      6 ( 0.00%)      atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
    356 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
      8 ( 0.00%)      memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
262,161 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
      2 ( 0.00%)      spc.pixels = atlas->TexPixelsAlpha8;
      .               spc.height = atlas->TexHeight;
      .           
      .               // 8. Render/rasterize font characters into the texture
     18 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
      .               {
      2 ( 0.00%)          ImFontConfig& cfg = atlas->ConfigData[src_i];
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      8 ( 0.00%)          if (src_tmp.GlyphsCount == 0)
      .                       continue;
      .           
      2 ( 0.00%)          stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
      .           
      .                   // Apply multiply operator
     10 ( 0.00%)          if (cfg.RasterizerMultiply != 1.0f)
      .                   {
      .                       unsigned char multiply_table[256];
      .                       ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
      .                       stbrp_rect* r = &src_tmp.Rects[0];
      .                       for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
      .                           if (r->was_packed)
      .                               ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
      .                   }
      4 ( 0.00%)          src_tmp.Rects = NULL;
      .               }
      .           
      .               // End packing
      .               stbtt_PackEnd(&spc);
      .               buf_rects.clear();
      .           
      .               // 9. Setup ImFont and glyphs for runtime
     16 ( 0.00%)      for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
      .               {
      .                   // When merging fonts with MergeMode=true:
      .                   // - We can have multiple input fonts writing into a same destination font.
      .                   // - dst_font->ConfigData is != from cfg which is our source configuration.
      .                   ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
      2 ( 0.00%)          ImFontConfig& cfg = atlas->ConfigData[src_i];
      2 ( 0.00%)          ImFont* dst_font = cfg.DstFont;
      .           
      .                   const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
      .                   int unscaled_ascent, unscaled_descent, unscaled_line_gap;
      .                   stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
      .           
      4 ( 0.00%)          const float ascent = ImCeil(unscaled_ascent * font_scale);
      4 ( 0.00%)          const float descent = ImFloor(unscaled_descent * font_scale);
      .                   ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
      4 ( 0.00%)          const float font_off_x = cfg.GlyphOffset.x;
     13 ( 0.00%)          const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
      .           
      4 ( 0.00%)          const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;
      .           
  5,424 ( 0.00%)          for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
      .                   {
      .                       // Register glyph
      .                       const int codepoint = src_tmp.GlyphsList[glyph_i];
  1,804 ( 0.00%)              const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
      .                       stbtt_aligned_quad q;
      .                       float unused_x = 0.0f, unused_y = 0.0f;
      .                       stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
  1,804 ( 0.00%)              float x0 = q.x0 * inv_rasterization_scale + font_off_x;
      .                       float y0 = q.y0 * inv_rasterization_scale + font_off_y;
      .                       float x1 = q.x1 * inv_rasterization_scale + font_off_x;
      .                       float y1 = q.y1 * inv_rasterization_scale + font_off_y;
 16,236 ( 0.00%)              dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
151,052 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::AddGlyph(ImFontConfig const*, unsigned short, float, float, float, float, float, float, float, float, float) (902x)
      .                   }
      .               }
      .           
      .               // Cleanup
      .               src_tmp_array.clear_destruct();
      .           
      2 ( 0.00%)      ImFontAtlasBuildFinish(atlas);
1,340,271 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlasBuildFinish(ImFontAtlas*) (1x)
      .               return true;
     11 ( 0.00%)  }
      .           
      .           const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype()
      .           {
      .               static ImFontBuilderIO io;
      1 ( 0.00%)      io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
      2 ( 0.00%)      return &io;
      .           }
      .           
      .           #endif // IMGUI_ENABLE_STB_TRUETYPE
      .           
      .           void ImFontAtlasUpdateConfigDataPointers(ImFontAtlas* atlas)
      .           {
     18 ( 0.00%)      for (ImFontConfig& font_cfg : atlas->ConfigData)
      .               {
      3 ( 0.00%)          ImFont* font = font_cfg.DstFont;
      6 ( 0.00%)          if (!font_cfg.MergeMode)
      .                   {
      2 ( 0.00%)              font->ConfigData = &font_cfg;
      .                       font->ConfigDataCount = 0;
      .                   }
      3 ( 0.00%)          font->ConfigDataCount++;
      .               }
      .           }
      .           
      .           void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
      .           {
      4 ( 0.00%)      if (!font_config->MergeMode)
      .               {
      .                   font->ClearOutputData();
      2 ( 0.00%)          font->FontSize = font_config->SizePixels;
      2 ( 0.00%)          IM_ASSERT(font->ConfigData == font_config);
      2 ( 0.00%)          font->ContainerAtlas = atlas;
      3 ( 0.00%)          font->Ascent = ascent;
      .                   font->Descent = descent;
      .               }
      .           }
      .           
      .           void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)
      5 ( 0.00%)  {
      .               stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
      2 ( 0.00%)      IM_ASSERT(pack_context != NULL);
      .           
      .               ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
      4 ( 0.00%)      IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
      .           #ifdef __GNUC__
      .               if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
      .           #endif
      .           
      .               ImVector<stbrp_rect> pack_rects;
      .               pack_rects.resize(user_rects.Size);
      5 ( 0.00%)      memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
     12 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
     17 ( 0.00%)      for (int i = 0; i < user_rects.Size; i++)
      .               {
      4 ( 0.00%)          pack_rects[i].w = user_rects[i].Width;
      6 ( 0.00%)          pack_rects[i].h = user_rects[i].Height;
      .               }
      8 ( 0.00%)      stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
    887 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imstb_rectpack.h:stbrp_pack_rects.isra.0 (1x)
      8 ( 0.00%)      for (int i = 0; i < pack_rects.Size; i++)
      6 ( 0.00%)          if (pack_rects[i].was_packed)
      .                   {
     14 ( 0.00%)              user_rects[i].X = (unsigned short)pack_rects[i].x;
      2 ( 0.00%)              user_rects[i].Y = (unsigned short)pack_rects[i].y;
     14 ( 0.00%)              IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
      2 ( 0.00%)              atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
      .                   }
      6 ( 0.00%)  }
      .           
      .           void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value)
      .           {
      6 ( 0.00%)      IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
      6 ( 0.00%)      IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
     11 ( 0.00%)      unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
    271 ( 0.00%)      for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
    270 ( 0.00%)          for (int off_x = 0; off_x < w; off_x++)
  2,601 ( 0.00%)              out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
      .           }
      .           
      .           void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value)
      .           {
      .               IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
      .               IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
      .               unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);
      .               for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
      .                   for (int off_x = 0; off_x < w; off_x++)
      .                       out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;
      .           }
      .           
      .           static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
      .           {
      1 ( 0.00%)      ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
      2 ( 0.00%)      IM_ASSERT(r->IsPacked());
      .           
      1 ( 0.00%)      const int w = atlas->TexWidth;
      2 ( 0.00%)      if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
      .               {
      .                   // Render/copy pixels
      3 ( 0.00%)          IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
      4 ( 0.00%)          const int x_for_white = r->X;
      1 ( 0.00%)          const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
      2 ( 0.00%)          if (atlas->TexPixelsAlpha8 != NULL)
      .                   {
      .                       ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
      1 ( 0.00%)              ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
      .                   }
      .                   else
      .                   {
      .                       ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
      .                       ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
      .                   }
      .               }
      .               else
-- line 3134 ----------------------------------------
-- line 3140 ----------------------------------------
      .                   {
      .                       atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
      .                   }
      .                   else
      .                   {
      .                       atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
      .                   }
      .               }
     11 ( 0.00%)      atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
      .           }
      .           
      .           static void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas* atlas)
      .           {
      3 ( 0.00%)      if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
      .                   return;
      .           
      .               // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
      1 ( 0.00%)      ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
      3 ( 0.00%)      IM_ASSERT(r->IsPacked());
    192 ( 0.00%)      for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
      .               {
      .                   // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
      .                   unsigned int y = n;
      .                   unsigned int line_width = n;
    256 ( 0.00%)          unsigned int pad_left = (r->Width - line_width) / 2;
    128 ( 0.00%)          unsigned int pad_right = r->Width - (pad_left + line_width);
      .           
      .                   // Write each slice
    256 ( 0.00%)          IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
    192 ( 0.00%)          if (atlas->TexPixelsAlpha8 != NULL)
      .                   {
    512 ( 0.00%)              unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
    128 ( 0.00%)              for (unsigned int i = 0; i < pad_left; i++)
    512 ( 0.00%)                  *(write_ptr + i) = 0x00;
    810 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (64x)
      .           
    128 ( 0.00%)              for (unsigned int i = 0; i < line_width; i++)
  1,970 ( 0.00%)                  *(write_ptr + pad_left + i) = 0xFF;
      .           
    128 ( 0.00%)              for (unsigned int i = 0; i < pad_right; i++)
    575 ( 0.00%)                  *(write_ptr + pad_left + line_width + i) = 0x00;
    805 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (64x)
      .                   }
      .                   else
      .                   {
      .                       unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
      .                       for (unsigned int i = 0; i < pad_left; i++)
      5 ( 0.00%)                  *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
      .           
      .                       for (unsigned int i = 0; i < line_width; i++)
      .                           *(write_ptr + pad_left + i) = IM_COL32_WHITE;
      .           
      .                       for (unsigned int i = 0; i < pad_right; i++)
      .                           *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
      .                   }
      .           
      .                   // Calculate UVs for this line
    576 ( 0.00%)          ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
    320 ( 0.00%)          ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
    128 ( 0.00%)          float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
    384 ( 0.00%)          atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
      .               }
      .           }
      .           
      .           // Note: this is called / shared by both the stb_truetype and the FreeType builder
      .           void ImFontAtlasBuildInit(ImFontAtlas* atlas)
      5 ( 0.00%)  {
      .               // Round font size
      .               // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
      .               // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
      .               // - We may support it better later and remove this rounding.
     17 ( 0.00%)      for (ImFontConfig& cfg : atlas->ConfigData)
      .                  cfg.SizePixels = ImTrunc(cfg.SizePixels);
      .           
      .               // Register texture region for mouse cursors or standard white pixels
      3 ( 0.00%)      if (atlas->PackIdMouseCursors < 0)
      .               {
      2 ( 0.00%)          if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
      6 ( 0.00%)              atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
    126 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddCustomRectRegular(int, int) (1x)
      .                   else
      .                       atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
      .               }
      .           
      .               // Register texture region for thick lines
      .               // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
      3 ( 0.00%)      if (atlas->PackIdLines < 0)
      .               {
      2 ( 0.00%)          if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
      5 ( 0.00%)              atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
     40 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFontAtlas::AddCustomRectRegular(int, int) (1x)
      .               }
      3 ( 0.00%)  }
      .           
      .           // This is called/shared by both the stb_truetype and the FreeType builder.
      .           void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
     10 ( 0.00%)  {
      .               // Render into our custom data blocks
      3 ( 0.00%)      IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
      .               ImFontAtlasBuildRenderDefaultTexData(atlas);
      .               ImFontAtlasBuildRenderLinesTexData(atlas);
      .           
      .               // Register custom rectangle glyphs
     10 ( 0.00%)      for (int i = 0; i < atlas->CustomRects.Size; i++)
      .               {
      .                   const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
      6 ( 0.00%)          if (r->Font == NULL || r->GlyphID == 0)
      .                       continue;
      .           
      .                   // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
      .                   IM_ASSERT(r->Font->ContainerAtlas == atlas);
      .                   ImVec2 uv0, uv1;
      .                   atlas->CalcCustomRectUV(r, &uv0, &uv1);
      .                   r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
      .               }
      .           
      .               // Build all fonts lookup tables
      8 ( 0.00%)      for (ImFont* font : atlas->Fonts)
      2 ( 0.00%)          if (font->DirtyLookupTables)
      1 ( 0.00%)              font->BuildLookupTable();
1,328,544 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::BuildLookupTable() (1x)
      .           
      1 ( 0.00%)      atlas->TexReady = true;
      8 ( 0.00%)  }
      .           
      .           // Retrieve list of range (2 int per range, values are inclusive)
      .           const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
      .           {
      .               static const ImWchar ranges[] =
      .               {
      .                   0x0020, 0x00FF, // Basic Latin + Latin Supplement
      .                   0,
-- line 3266 ----------------------------------------
-- line 3559 ----------------------------------------
      .                   }
      .               out_ranges->push_back(0);
      .           }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImFont
      .           //-----------------------------------------------------------------------------
      .           
     10 ( 0.00%)  ImFont::ImFont()
      .           {
      .               FontSize = 0.0f;
      2 ( 0.00%)      FallbackAdvanceX = 0.0f;
      .               FallbackChar = (ImWchar)-1;
      .               EllipsisChar = (ImWchar)-1;
      2 ( 0.00%)      EllipsisWidth = EllipsisCharStep = 0.0f;
      .               EllipsisCharCount = 0;
      .               FallbackGlyph = NULL;
      .               ContainerAtlas = NULL;
      .               ConfigData = NULL;
      .               ConfigDataCount = 0;
      .               DirtyLookupTables = false;
      .               Scale = 1.0f;
      .               Ascent = Descent = 0.0f;
      2 ( 0.00%)      MetricsTotalSurface = 0;
      2 ( 0.00%)      memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
      1 ( 0.00%)  }
      .           
      .           ImFont::~ImFont()
      .           {
      .               ClearOutputData();
      .           }
      .           
      .           void    ImFont::ClearOutputData()
      .           {
      .               FontSize = 0.0f;
      1 ( 0.00%)      FallbackAdvanceX = 0.0f;
      .               Glyphs.clear();
      .               IndexAdvanceX.clear();
      .               IndexLookup.clear();
      2 ( 0.00%)      FallbackGlyph = NULL;
      .               ContainerAtlas = NULL;
      1 ( 0.00%)      DirtyLookupTables = true;
      1 ( 0.00%)      Ascent = Descent = 0.0f;
      1 ( 0.00%)      MetricsTotalSurface = 0;
      .           }
      .           
      .           static ImWchar FindFirstExistingGlyph(ImFont* font, const ImWchar* candidate_chars, int candidate_chars_count)
      .           {
      .               for (int n = 0; n < candidate_chars_count; n++)
      6 ( 0.00%)          if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
      .                       return candidate_chars[n];
      2 ( 0.00%)      return (ImWchar)-1;
      .           }
      .           
      .           void ImFont::BuildLookupTable()
      9 ( 0.00%)  {
      .               int max_codepoint = 0;
    160 ( 0.00%)      for (int i = 0; i != Glyphs.Size; i++)
     12 ( 0.00%)          max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
      .           
      .               // Build lookup table
      .               IM_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
      2 ( 0.00%)      IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
      .               IndexAdvanceX.clear();
      .               IndexLookup.clear();
      1 ( 0.00%)      DirtyLookupTables = false;
      1 ( 0.00%)      memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
      5 ( 0.00%)      GrowIndex(max_codepoint + 1);
684,978 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImFont::GrowIndex(int) (1x)
  3,614 ( 0.00%)      for (int i = 0; i < Glyphs.Size; i++)
      .               {
  1,804 ( 0.00%)          int codepoint = (int)Glyphs[i].Codepoint;
  1,804 ( 0.00%)          IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
    902 ( 0.00%)          IndexLookup[codepoint] = (ImWchar)i;
      .           
      .                   // Mark 4K page as used
    902 ( 0.00%)          const int page_n = codepoint / 4096;
  5,416 ( 0.00%)          Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
      .               }
      .           
      .               // Create a glyph to handle TAB
      .               // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
      2 ( 0.00%)      if (FindGlyph((ImWchar)' '))
      .               {
      4 ( 0.00%)          if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
      1 ( 0.00%)              Glyphs.resize(Glyphs.Size + 1);
      .                   ImFontGlyph& tab_glyph = Glyphs.back();
      4 ( 0.00%)          tab_glyph = *FindGlyph((ImWchar)' ');
      4 ( 0.00%)          tab_glyph.Codepoint = '\t';
      4 ( 0.00%)          tab_glyph.AdvanceX *= IM_TABSIZE;
      1 ( 0.00%)          IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
      6 ( 0.00%)          IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
      .               }
      .           
      .               // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
      .               SetGlyphVisible((ImWchar)' ', false);
      .               SetGlyphVisible((ImWchar)'\t', false);
      .           
      .               // Setup Fallback character
      .               const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
      .               FallbackGlyph = FindGlyphNoFallback(FallbackChar);
      .               if (FallbackGlyph == NULL)
      .               {
      1 ( 0.00%)          FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
      1 ( 0.00%)          FallbackGlyph = FindGlyphNoFallback(FallbackChar);
      2 ( 0.00%)          if (FallbackGlyph == NULL)
      .                   {
      .                       FallbackGlyph = &Glyphs.back();
      .                       FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
      .                   }
      .               }
      6 ( 0.00%)      FallbackAdvanceX = FallbackGlyph->AdvanceX;
186,531 ( 0.00%)      for (int i = 0; i < max_codepoint + 1; i++)
186,532 ( 0.00%)          if (IndexAdvanceX[i] < 0.0f)
122,548 ( 0.00%)              IndexAdvanceX[i] = FallbackAdvanceX;
      .           
      .               // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
      .               // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
      .               // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
      .               const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
      .               const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
      3 ( 0.00%)      if (EllipsisChar == (ImWchar)-1)
      .                   EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
      .               const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
      2 ( 0.00%)      if (EllipsisChar != (ImWchar)-1)
      .               {
      1 ( 0.00%)          EllipsisCharCount = 1;
      3 ( 0.00%)          EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
      .               }
      .               else if (dot_char != (ImWchar)-1)
      .               {
      .                   const ImFontGlyph* glyph = FindGlyph(dot_char);
      .                   EllipsisChar = dot_char;
      .                   EllipsisCharCount = 3;
      .                   EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
      .                   EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
      .               }
      8 ( 0.00%)  }
      .           
      .           // API is designed this way to avoid exposing the 4K page size
      .           // e.g. use with IsGlyphRangeUnused(0, 255)
      .           bool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last)
      .           {
      .               unsigned int page_begin = (c_begin / 4096);
      .               unsigned int page_last = (c_last / 4096);
      .               for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)
-- line 3703 ----------------------------------------
-- line 3704 ----------------------------------------
      .                   if ((page_n >> 3) < sizeof(Used4kPagesMap))
      .                       if (Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7)))
      .                           return false;
      .               return true;
      .           }
      .           
      .           void ImFont::SetGlyphVisible(ImWchar c, bool visible)
      .           {
      4 ( 0.00%)      if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
      2 ( 0.00%)          glyph->Visible = visible ? 1 : 0;
      .           }
      .           
      .           void ImFont::GrowIndex(int new_size)
      5 ( 0.00%)  {
      3 ( 0.00%)      IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
      3 ( 0.00%)      if (new_size <= IndexLookup.Size)
      .                   return;
      .               IndexAdvanceX.resize(new_size, -1.0f);
      .               IndexLookup.resize(new_size, (ImWchar)-1);
      6 ( 0.00%)  }
      .           
      .           // x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
      .           // Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
      .           // 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.
      .           void ImFont::AddGlyph(const ImFontConfig* cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
 12,628 ( 0.00%)  {
  1,804 ( 0.00%)      if (cfg != NULL)
      .               {
      .                   // Clamp & recenter if needed
      .                   const float advance_x_original = advance_x;
  1,508 ( 0.00%)          advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
    909 ( 0.00%)          if (advance_x != advance_x_original)
      .                   {
  4,799 ( 0.00%)              float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
    599 ( 0.00%)              x0 += char_off_x;
    599 ( 0.00%)              x1 += char_off_x;
      .                   }
      .           
      .                   // Snap to pixel
    909 ( 0.00%)          if (cfg->PixelSnapH)
  2,706 ( 0.00%)              advance_x = IM_ROUND(advance_x);
      .           
      .                   // Bake spacing
  1,501 ( 0.00%)          advance_x += cfg->GlyphExtraSpacing.x;
      .               }
      .           
  6,314 ( 0.00%)      Glyphs.resize(Glyphs.Size + 1);
      .               ImFontGlyph& glyph = Glyphs.back();
      .               glyph.Codepoint = (unsigned int)codepoint;
  7,216 ( 0.00%)      glyph.Visible = (x0 != x1) && (y0 != y1);
  5,412 ( 0.00%)      glyph.Colored = false;
      .               glyph.X0 = x0;
      .               glyph.Y0 = y0;
      .               glyph.X1 = x1;
      .               glyph.Y1 = y1;
      .               glyph.U0 = u0;
      .               glyph.V0 = v0;
      .               glyph.U1 = u1;
    902 ( 0.00%)      glyph.V1 = v1;
    902 ( 0.00%)      glyph.AdvanceX = advance_x;
      .           
      .               // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
      .               // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
  2,706 ( 0.00%)      float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
    902 ( 0.00%)      DirtyLookupTables = true;
  9,922 ( 0.00%)      MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
  7,216 ( 0.00%)  }
      .           
      .           void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
      .           {
      .               IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
      .               unsigned int index_size = (unsigned int)IndexLookup.Size;
      .           
      .               if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
      .                   return;
-- line 3778 ----------------------------------------
-- line 3781 ----------------------------------------
      .           
      .               GrowIndex(dst + 1);
      .               IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
      .               IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
      .           }
      .           
      .           const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
      .           {
130,282 ( 0.00%)      if (c >= (size_t)IndexLookup.Size)
      .                   return FallbackGlyph;
 65,144 ( 0.00%)      const ImWchar i = IndexLookup.Data[c];
 65,146 ( 0.00%)      if (i == (ImWchar)-1)
      .                   return FallbackGlyph;
 97,717 ( 0.00%)      return &Glyphs.Data[i];
      .           }
      .           
      .           const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
      .           {
     10 ( 0.00%)      if (c >= (size_t)IndexLookup.Size)
      .                   return NULL;
      6 ( 0.00%)      const ImWchar i = IndexLookup.Data[c];
      6 ( 0.00%)      if (i == (ImWchar)-1)
      .                   return NULL;
      8 ( 0.00%)      return &Glyphs.Data[i];
      .           }
      .           
      .           // Wrapping skips upcoming blanks
      .           static inline const char* CalcWordWrapNextLineStartA(const char* text, const char* text_end)
      .           {
      .               while (text < text_end && ImCharIsBlankA(*text))
      .                   text++;
  3,998 ( 0.00%)      if (*text == '\n')
      .                   text++;
      .               return text;
      .           }
      .           
      .           // Simple word-wrapping for English, not full-featured. Please submit failing cases!
      .           // This will return the next location to wrap from. If no wrapping if necessary, this will fast-forward to e.g. text_end.
      .           // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
      .           const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const
-- line 3820 ----------------------------------------
-- line 3911 ----------------------------------------
      .               // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
      .               // +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
      .               if (s == text && text < text_end)
      .                   return s + 1;
      .               return s;
      .           }
      .           
      .           ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
 51,974 ( 0.00%)  {
  7,996 ( 0.00%)      if (!text_end)
      .                   text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
      .           
      .               const float line_height = size;
 11,994 ( 0.00%)      const float scale = size / FontSize;
      .           
  7,996 ( 0.00%)      ImVec2 text_size = ImVec2(0, 0);
  3,998 ( 0.00%)      float line_width = 0.0f;
      .           
      .               const bool word_wrap_enabled = (wrap_width > 0.0f);
  3,998 ( 0.00%)      const char* word_wrap_eol = NULL;
      .           
      .               const char* s = text_begin;
 73,132 ( 0.00%)      while (s < text_end)
      .               {
138,268 ( 0.00%)          if (word_wrap_enabled)
      .                   {
      .                       // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
      .                       if (!word_wrap_eol)
      .                           word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
      .           
      .                       if (s >= word_wrap_eol)
      .                       {
      .                           if (text_size.x < line_width)
-- line 3943 ----------------------------------------
-- line 3947 ----------------------------------------
      .                           word_wrap_eol = NULL;
      .                           s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
      .                           continue;
      .                       }
      .                   }
      .           
      .                   // Decode and advance source
      .                   const char* prev_s = s;
 65,136 ( 0.00%)          unsigned int c = (unsigned int)*s;
 65,136 ( 0.00%)          if (c < 0x80)
 32,568 ( 0.00%)              s += 1;
      .                   else
      .                       s += ImTextCharFromUtf8(&c, s, text_end);
      .           
 65,136 ( 0.00%)          if (c < 32)
      .                   {
      .                       if (c == '\n')
      .                       {
      .                           text_size.x = ImMax(text_size.x, line_width);
      .                           text_size.y += line_height;
      .                           line_width = 0.0f;
      .                           continue;
      .                       }
      .                       if (c == '\r')
      .                           continue;
      .                   }
      .           
130,272 ( 0.00%)          const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
 97,704 ( 0.00%)          if (line_width + char_width >= max_width)
      .                   {
      .                       s = prev_s;
      .                       break;
      .                   }
      .           
      .                   line_width += char_width;
      .               }
      .           
      .               if (text_size.x < line_width)
      .                   text_size.x = line_width;
      .           
 15,992 ( 0.00%)      if (line_width > 0 || text_size.y == 0.0f)
 11,994 ( 0.00%)          text_size.y += line_height;
      .           
 11,994 ( 0.00%)      if (remaining)
      .                   *remaining = s;
      .           
      .               return text_size;
 31,984 ( 0.00%)  }
      .           
      .           // Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
      .           void ImFont::RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const
      .           {
      .               const ImFontGlyph* glyph = FindGlyph(c);
      .               if (!glyph || !glyph->Visible)
      .                   return;
      .               if (glyph->Colored)
-- line 4002 ----------------------------------------
-- line 4005 ----------------------------------------
      .               float x = IM_TRUNC(pos.x);
      .               float y = IM_TRUNC(pos.y);
      .               draw_list->PrimReserve(6, 4);
      .               draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
      .           }
      .           
      .           // Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
      .           void ImFont::RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
 67,966 ( 0.00%)  {
  7,996 ( 0.00%)      if (!text_end)
      .                   text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
      .           
      .               // Align to be pixel perfect
 23,988 ( 0.00%)      float x = IM_TRUNC(pos.x);
 11,994 ( 0.00%)      float y = IM_TRUNC(pos.y);
  7,996 ( 0.00%)      if (y > clip_rect.w)
      .                   return;
      .           
      .               const float start_x = x;
  7,996 ( 0.00%)      const float scale = size / FontSize;
  7,996 ( 0.00%)      const float line_height = FontSize * scale;
      .               const bool word_wrap_enabled = (wrap_width > 0.0f);
      .           
      .               // Fast-forward to first visible line
      .               const char* s = text_begin;
 15,992 ( 0.00%)      if (y + line_height < clip_rect.y)
      .                   while (y + line_height < clip_rect.y && s < text_end)
      .                   {
  7,996 ( 0.00%)              const char* line_end = (const char*)memchr(s, '\n', text_end - s);
      .                       if (word_wrap_enabled)
      .                       {
      .                           // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
      .                           // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
      .                           // However it is still better than nothing performing the fast-forward!
      .                           s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
      .                           s = CalcWordWrapNextLineStartA(s, text_end);
      .                       }
-- line 4041 ----------------------------------------
-- line 4043 ----------------------------------------
      .                       {
      .                           s = line_end ? line_end + 1 : text_end;
      .                       }
      .                       y += line_height;
      .                   }
      .           
      .               // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
      .               // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
  7,996 ( 0.00%)      if (text_end - s > 10000 && !word_wrap_enabled)
      .               {
      .                   const char* s_end = s;
      .                   float y_end = y;
      .                   while (y_end < clip_rect.w && s_end < text_end)
      .                   {
      .                       s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
      .                       s_end = s_end ? s_end + 1 : text_end;
      .                       y_end += line_height;
      .                   }
      .                   text_end = s_end;
      .               }
 15,992 ( 0.00%)      if (s == text_end)
      .                   return;
      .           
      .               // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
 15,992 ( 0.00%)      const int vtx_count_max = (int)(text_end - s) * 4;
  7,996 ( 0.00%)      const int idx_count_max = (int)(text_end - s) * 6;
 11,994 ( 0.00%)      const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
 11,994 ( 0.00%)      draw_list->PrimReserve(idx_count_max, vtx_count_max);
209,678 ( 0.00%)  => build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PrimReserve(int, int) (3,998x)
  3,998 ( 0.00%)      ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
  3,998 ( 0.00%)      ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
  3,998 ( 0.00%)      unsigned int vtx_index = draw_list->_VtxCurrentIdx;
      .           
      .               const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
  3,998 ( 0.00%)      const char* word_wrap_eol = NULL;
      .           
 93,122 ( 0.00%)      while (s < text_end)
      .               {
113,112 ( 0.00%)          if (word_wrap_enabled)
      .                   {
      .                       // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
      .                       if (!word_wrap_eol)
      .                           word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
      .           
      .                       if (s >= word_wrap_eol)
      .                       {
      .                           x = start_x;
-- line 4088 ----------------------------------------
-- line 4091 ----------------------------------------
      .                               break; // break out of main loop
      .                           word_wrap_eol = NULL;
      .                           s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
      .                           continue;
      .                       }
      .                   }
      .           
      .                   // Decode and advance source
 65,136 ( 0.00%)          unsigned int c = (unsigned int)*s;
 65,136 ( 0.00%)          if (c < 0x80)
 32,568 ( 0.00%)              s += 1;
      .                   else
      .                       s += ImTextCharFromUtf8(&c, s, text_end);
      .           
 65,136 ( 0.00%)          if (c < 32)
      .                   {
      .                       if (c == '\n')
      .                       {
      .                           x = start_x;
      .                           y += line_height;
      .                           if (y > clip_rect.w)
      .                               break; // break out of main loop
      .                           continue;
      .                       }
      .                       if (c == '\r')
      .                           continue;
      .                   }
      .           
      .                   const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
 65,136 ( 0.00%)          if (glyph == NULL)
      .                       continue;
      .           
 32,568 ( 0.00%)          float char_width = glyph->AdvanceX * scale;
 97,704 ( 0.00%)          if (glyph->Visible)
      .                   {
      .                       // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
 65,134 ( 0.00%)              float x1 = x + glyph->X0 * scale;
 65,094 ( 0.00%)              float x2 = x + glyph->X1 * scale;
 65,094 ( 0.00%)              float y1 = y + glyph->Y0 * scale;
 65,094 ( 0.00%)              float y2 = y + glyph->Y1 * scale;
195,342 ( 0.00%)              if (x1 <= clip_rect.z && x2 >= clip_rect.x)
      .                       {
      .                           // Render a character
 32,547 ( 0.00%)                  float u1 = glyph->U0;
 32,547 ( 0.00%)                  float v1 = glyph->V0;
 32,547 ( 0.00%)                  float u2 = glyph->U1;
 32,547 ( 0.00%)                  float v2 = glyph->V1;
      .           
      .                           // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
 65,094 ( 0.00%)                  if (cpu_fine_clip)
      .                           {
      .                               if (x1 < clip_rect.x)
      .                               {
      .                                   u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
      .                                   x1 = clip_rect.x;
      .                               }
      .                               if (y1 < clip_rect.y)
      .                               {
-- line 4148 ----------------------------------------
-- line 4162 ----------------------------------------
      .                               if (y1 >= y2)
      .                               {
      .                                   x += char_width;
      .                                   continue;
      .                               }
      .                           }
      .           
      .                           // Support for untinted glyphs
195,282 ( 0.00%)                  ImU32 glyph_col = glyph->Colored ? col_untinted : col;
      .           
      .                           // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
      .                           {
162,735 ( 0.00%)                      vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
162,735 ( 0.00%)                      vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
195,282 ( 0.00%)                      vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
162,735 ( 0.00%)                      vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
260,376 ( 0.00%)                      idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
 65,094 ( 0.00%)                      idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
 32,547 ( 0.00%)                      vtx_write += 4;
 32,547 ( 0.00%)                      vtx_index += 4;
 97,641 ( 0.00%)                      idx_write += 6;
      .                           }
      .                       }
      .                   }
 32,568 ( 0.00%)          x += char_width;
      .               }
      .           
      .               // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
 23,988 ( 0.00%)      draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
 19,990 ( 0.00%)      draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
 11,994 ( 0.00%)      draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
  3,998 ( 0.00%)      draw_list->_VtxWritePtr = vtx_write;
  3,998 ( 0.00%)      draw_list->_IdxWritePtr = idx_write;
  3,998 ( 0.00%)      draw_list->_VtxCurrentIdx = vtx_index;
 31,984 ( 0.00%)  }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] ImGui Internal Render Helpers
      .           //-----------------------------------------------------------------------------
      .           // Vaguely redesigned to stop accessing ImGui global state:
      .           // - RenderArrow()
      .           // - RenderBullet()
      .           // - RenderCheckMark()
-- line 4204 ----------------------------------------
-- line 4208 ----------------------------------------
      .           // - RenderRectFilledWithHole()
      .           //-----------------------------------------------------------------------------
      .           // Function in need of a redesign (legacy mess)
      .           // - RenderColorRectWithAlphaCheckerboard()
      .           //-----------------------------------------------------------------------------
      .           
      .           // Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
      .           void ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)
  4,576 ( 0.00%)  {
  1,144 ( 0.00%)      const float h = draw_list->_Data->FontSize * 1.00f;
  1,144 ( 0.00%)      float r = h * 0.40f * scale;
  1,144 ( 0.00%)      ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
      .           
      .               ImVec2 a, b, c;
  2,288 ( 0.00%)      switch (dir)
      .               {
      .               case ImGuiDir_Up:
      .               case ImGuiDir_Down:
  4,004 ( 0.00%)          if (dir == ImGuiDir_Up) r = -r;
      .                   a = ImVec2(+0.000f, +0.750f) * r;
      .                   b = ImVec2(-0.866f, -0.750f) * r;
      .                   c = ImVec2(+0.866f, -0.750f) * r;
    572 ( 0.00%)          break;
      .               case ImGuiDir_Left:
      .               case ImGuiDir_Right:
      .                   if (dir == ImGuiDir_Left) r = -r;
      .                   a = ImVec2(+0.750f, +0.000f) * r;
      .                   b = ImVec2(-0.750f, +0.866f) * r;
      .                   c = ImVec2(-0.750f, -0.866f) * r;
      .                   break;
      .               case ImGuiDir_None:
      .               case ImGuiDir_COUNT:
      .                   IM_ASSERT(0);
      .                   break;
      .               }
      .               draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
  3,432 ( 0.00%)  }
      .           
      .           void ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)
      .           {
      .               // FIXME-OPT: This should be baked in font.
      .               draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);
      .           }
      .           
      .           void ImGui::RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz)
-- line 4252 ----------------------------------------
-- line 4437 ----------------------------------------
      .           }
      .           
      .           static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
      .           static const unsigned char *stb__barrier_in_b;
      .           static unsigned char *stb__dout;
      .           static void stb__match(const unsigned char *data, unsigned int length)
      .           {
      .               // INVERSE of memmove... write each byte before copying the next...
 47,088 ( 0.00%)      IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
      .               if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
 60,020 ( 0.00%)      if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
504,083 ( 0.00%)      while (length--) *stb__dout++ = *data++;
      .           }
      .           
      .           static void stb__lit(const unsigned char *data, unsigned int length)
      .           {
 32,556 ( 0.00%)      IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
      .               if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
 24,417 ( 0.00%)      if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
111,524 ( 0.00%)      memcpy(stb__dout, data, length);
 11,479 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (663x)
 10,791 ( 0.00%)      stb__dout += length;
      .           }
      .           
      .           #define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
      .           #define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
      .           #define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
      .           
      .           static const unsigned char *stb_decompress_token(const unsigned char *i)
      .           {
 59,743 ( 0.00%)      if (*i >= 0x20) { // use fewer if's for cases that expand small
110,704 ( 0.00%)          if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
 63,078 ( 0.00%)          else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
 59,808 ( 0.00%)          else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
      .               } else { // more ifs for cases that expand large, since overhead is amortized
  6,625 ( 0.00%)          if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
  1,330 ( 0.00%)          else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  6,634 ( 0.00%)          else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
      2 ( 0.00%)          else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
      4 ( 0.00%)          else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
  7,311 ( 0.00%)          else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
      .               }
      .               return i;
      .           }
      .           
      .           static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
      .           {
      .               const unsigned long ADLER_MOD = 65521;
      .               unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
-- line 4484 ----------------------------------------
-- line 4506 ----------------------------------------
      .                   buflen -= blocklen;
      .                   blocklen = 5552;
      .               }
      .               return (unsigned int)(s2 << 16) + (unsigned int)s1;
      .           }
      .           
      .           static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
      .           {
     12 ( 0.00%)      if (stb__in4(0) != 0x57bC0000) return 0;
      6 ( 0.00%)      if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
      2 ( 0.00%)      const unsigned int olen = stb_decompress_length(i);
      2 ( 0.00%)      stb__barrier_in_b = i;
      6 ( 0.00%)      stb__barrier_out_e = output + olen;
      2 ( 0.00%)      stb__barrier_out_b = output;
      2 ( 0.00%)      i += 16;
      .           
     14 ( 0.00%)      stb__dout = output;
      .               for (;;) {
      .                   const unsigned char *old_i = i;
 19,911 ( 0.00%)          i = stb_decompress_token(i);
 39,822 ( 0.00%)          if (i == old_i) {
      8 ( 0.00%)              if (*i == 0x05 && i[1] == 0xfa) {
      4 ( 0.00%)                  IM_ASSERT(stb__dout == output + olen);
      .                           if (stb__dout != output + olen) return 0;
      .                           if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
      .                               return 0;
      .                           return olen;
      .                       } else {
      .                           IM_ASSERT(0); /* NOTREACHED */
      .                           return 0;
      .                       }
      .                   }
 59,733 ( 0.00%)          IM_ASSERT(stb__dout <= output + olen);
      .                   if (stb__dout > output + olen)
      .                       return 0;
      .               }
      .           }
      .           
      .           //-----------------------------------------------------------------------------
      .           // [SECTION] Default font data (ProggyClean.ttf)
      .           //-----------------------------------------------------------------------------
-- line 4546 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/racing/actors.c
--------------------------------------------------------------------------------
Ir                 

-- line 119 ----------------------------------------
        .                               destroy_actor((struct Actor*) compare);
        .                               return;
        .                       }
        .                   }
        .               }
        .           }
        .           
        .           // Sets introductory values for a new actor (ex. Banana).
      261 ( 0.00%)  void actor_init(struct Actor* actor, Vec3f startingPos, Vec3s startingRot, Vec3f startingVelocity, s16 actorType) {
       58 ( 0.00%)      vec3f_copy_return(actor->pos, startingPos);
      232 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_copy_return (29x)
       87 ( 0.00%)      vec3s_copy(actor->rot, startingRot);
      203 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3s_copy (29x)
       87 ( 0.00%)      vec3f_copy_return(actor->velocity, startingVelocity);
      232 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_copy_return (29x)
       29 ( 0.00%)      actor->type = actorType;
       29 ( 0.00%)      actor->flags = -0x8000;
       29 ( 0.00%)      actor->unk_04 = 0;
        .               actor->state = 0;
       29 ( 0.00%)      actor->unk_08 = 0.0f;
        .               actor->boundingBoxSize = 0.0f;
       87 ( 0.00%)      func_802AAAAC(&actor->unk30);
      986 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/collision.c:func_802AAAAC (29x)
      203 ( 0.00%)      switch (actorType) {
        .                   case ACTOR_BOX_TRUCK:
        .                       if ((s32) D_802BA260 >= 3) {
        .                           D_802BA260 = 0;
        .                       }
        .                       actor->state = (s16) D_802BA260;
        .                       D_802BA260 += 1;
        .                       break;
        .                   case ACTOR_YOSHI_EGG:
-- line 146 ----------------------------------------
-- line 154 ----------------------------------------
        .                   case ACTOR_KIWANO_FRUIT:
        .                       actor->state = 0;
        .                       actor->rot[0] = 0;
        .                       actor->rot[1] = 0;
        .                       actor->rot[2] = 0;
        .                       actor->boundingBoxSize = 2.0f;
        .                       break;
        .                   case ACTOR_FALLING_ROCK:
        3 ( 0.00%)              actor->flags |= 0x4000;
        3 ( 0.00%)              actor->boundingBoxSize = 10.0f;
        3 ( 0.00%)              break;
        .                   case ACTOR_TRAIN_ENGINE:
        2 ( 0.00%)              actor->unk_08 = 10.0f;
        2 ( 0.00%)              break;
        .                   case ACTOR_BANANA:
        .                       actor->flags = actor->flags | 0x4000 | 0x1000;
        .                       actor->boundingBoxSize = 2.0f;
        .                       break;
        .                   case ACTOR_GREEN_SHELL:
        .                       gNumSpawnedShells += 1;
        .                       actor->unk_04 = 0;
        .                       actor->boundingBoxSize = 4.0f;
-- line 175 ----------------------------------------
-- line 268 ----------------------------------------
        .                       break;
        .                   case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
        .                       actor->flags |= 0x4000;
        .                       actor->unk_04 = 0;
        .                       actor->state = 5;
        .                       actor->boundingBoxSize = 5.5f;
        .                       break;
        .                   case ACTOR_ITEM_BOX:
       11 ( 0.00%)              actor->flags |= 0x4000;
       11 ( 0.00%)              actor->unk_04 = 0;
        .                       actor->state = 0;
       11 ( 0.00%)              actor->boundingBoxSize = 5.5f;
       11 ( 0.00%)              break;
        .                   case ACTOR_PIRANHA_PLANT:
        .                       actor->flags |= 0x4000;
        .                       actor->state = 0x001E;
        .                       actor->boundingBoxSize = 5.0f;
        .                       break;
        .                   default:
        .                       break;
        .               }
      174 ( 0.00%)  }
        .           
        .           void actor_not_rendered(Camera* arg0, struct Actor* arg1) {
        .               switch (arg0 - camera1) {
        .                   case PLAYER_ONE:
        .                       arg1->flags &= ~(1 << PLAYER_ONE);
        .                       break;
        .                   case PLAYER_TWO:
        .                       arg1->flags &= ~(1 << PLAYER_TWO);
-- line 297 ----------------------------------------
-- line 317 ----------------------------------------
        .                       arg1->flags |= 1 << PLAYER_THREE;
        .                       break;
        .                   case PLAYER_FOUR:
        .                       arg1->flags |= 1 << PLAYER_FOUR;
        .                       break;
        .               }
        .           }
        .           
    1,904 ( 0.00%)  void func_80297340(Camera* arg0) {
        .               Mat4 sp38;
    1,904 ( 0.00%)      s16 temp = D_8015F8D0[2];
        .               s32 maxObjectsReached;
        .           
    1,428 ( 0.00%)      if (gGamestate == CREDITS_SEQUENCE) {
        .                   return;
        .               }
        .           
    1,428 ( 0.00%)      mtxf_translate(sp38, D_8015F8D0);
   10,472 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:mtxf_translate (476x)
        .           
    1,428 ( 0.00%)      maxObjectsReached = render_set_position(sp38, 0) == 0;
   36,652 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:render_set_position (476x)
      952 ( 0.00%)      if (maxObjectsReached) {
        .                   return;
        .               }
        .           
    2,856 ( 0.00%)      if (temp < arg0->pos[2]) {
    1,904 ( 0.00%)          if (D_800DC5BC != 0) {
        .           
    1,428 ( 0.00%)              gDPSetFogColor(gDisplayListHead++, D_801625EC, D_801625F4, D_801625F0, 0xFF);
        .                       gSPDisplayList(gDisplayListHead++, D_0D001C20);
        .                   } else {
    1,428 ( 0.00%)              gSPDisplayList(gDisplayListHead++, D_0D001B90);
  949,585 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
        .                   }
        .               } else if (D_800DC5BC != 0) {
        .           
        .                   gDPSetFogColor(gDisplayListHead++, D_801625EC, D_801625F4, D_801625F0, 0xFF);
        .                   gSPDisplayList(gDisplayListHead++, D_0D001C88);
        .               } else {
        .                   gSPDisplayList(gDisplayListHead++, D_0D001BD8);
        .               }
    1,904 ( 0.00%)  }
        .           
        .           UNUSED void func_80297524(uintptr_t addr, s32 width, s32 height) {
        .               gDPLoadTextureBlock(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(addr), G_IM_FMT_RGBA, G_IM_SIZ_16b, width, height, 0,
        .                                   G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
        .                                   G_TX_NOLOD);
        .           }
        .           
        .           void func_802976D8(Vec3s arg0) {
-- line 364 ----------------------------------------
-- line 395 ----------------------------------------
        .           void func_802977B0(Player* arg0) {
        .               arg0->tyres[FRONT_RIGHT].unk_14 |= 2;
        .               arg0->tyres[FRONT_LEFT].unk_14 |= 2;
        .               arg0->tyres[BACK_RIGHT].unk_14 |= 2;
        .               arg0->tyres[BACK_LEFT].unk_14 |= 2;
        .           }
        .           
        .           void func_802977E4(Player* arg0) {
    7,616 ( 0.00%)      arg0->tyres[FRONT_RIGHT].unk_14 &= ~2 & 0xFFFF;
    7,616 ( 0.00%)      arg0->tyres[FRONT_LEFT].unk_14 &= ~2 & 0xFFFF;
    7,616 ( 0.00%)      arg0->tyres[BACK_RIGHT].unk_14 &= ~2 & 0xFFFF;
    7,616 ( 0.00%)      arg0->tyres[BACK_LEFT].unk_14 &= ~2 & 0xFFFF;
    7,616 ( 0.00%)  }
        .           
        .           // Generate the red shell tlut by invert green the green one
        4 ( 0.00%)  void init_red_shell_texture(void) {
        9 ( 0.00%)      s16* tlut = (s16*) LOAD_ASSET(common_tlut_green_shell);
    2,420 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (1x)
       31 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (1x)
        .               s16* red_shell_texture = (s16*) &gTLUTRedShell[0];
        .               s16* green_shell_texture = (s16*) tlut;
        .               s16 color_pixel, red_color, green_color, blue_color, alpha_color;
        .               s32 i;
        .           
        7 ( 0.00%)      for (i = 0; i < 256; i++) {
       61 ( 0.00%)          color_pixel = BSWAP16(*green_shell_texture);
       16 ( 0.00%)          red_color = BSWAP16(color_pixel & 0xF800);
       73 ( 0.00%)          green_color = BSWAP16(color_pixel & 0x7C0);
        .                   blue_color = BSWAP16(color_pixel & 0x3E);
        .                   alpha_color = BSWAP16(color_pixel & 0x1);
        .           
      115 ( 0.00%)          *red_shell_texture = (red_color >> 5) | (green_color << 5) | blue_color | alpha_color; // Invert green to red
        .                   green_shell_texture++;
        .                   red_shell_texture++;
        .               }
        3 ( 0.00%)  }
        .           
        .           UNUSED void func_80297944(void) {};
        .           
        .           void func_8029794C(Vec3f pos, Vec3s rot, f32 scale) {
        .               Mat4 sp20;
        .               pos[1] += 2.0f;
        .           
        .               mtxf_pos_rotation_xyz(sp20, pos, rot);
-- line 436 ----------------------------------------
-- line 940 ----------------------------------------
        .                                                                      temp_s0->unk30.meshIndexZX);
        .                       }
        .                       func_802976EC(&temp_s0->unk30, temp_s0->rot);
        .                   }
        .                   var_s3++;
        .               }
        .           }
        .           
        8 ( 0.00%)  void spawn_all_item_boxes(struct ActorSpawnData* spawnData) {
        .               s16 temp_s1;
        .               f32 temp_f0;
        .               Vec3f startingPos;
        .               Vec3f startingVelocity;
        .               Vec3s startingRot;
        .               struct ActorSpawnData* temp_s0 = spawnData;
        .               // struct ItemBox *itemBox;
        .           
        6 ( 0.00%)      if ((gModeSelection == TIME_TRIALS) || (gPlaceItemBoxes == 0)) {
        .                   return;
        .               }
        .           
        6 ( 0.00%)      vec3f_set(startingVelocity, 0, 0, 0);
        4 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (1x)
       54 ( 0.00%)      while (temp_s0->pos[0] != END_OF_SPAWN_DATA) {
       44 ( 0.00%)          startingPos[0] = temp_s0->pos[0] * gCourseDirection;
       22 ( 0.00%)          startingPos[1] = temp_s0->pos[1];
       33 ( 0.00%)          startingPos[2] = temp_s0->pos[2];
       22 ( 0.00%)          startingRot[0] = random_u16();
      243 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_u16 (11x)
       22 ( 0.00%)          startingRot[1] = random_u16();
      258 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_u16 (11x)
       22 ( 0.00%)          startingRot[2] = random_u16();
      246 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_u16 (11x)
       66 ( 0.00%)          temp_s1 = add_actor_to_empty_slot(startingPos, startingRot, startingVelocity, ACTOR_ITEM_BOX);
    2,461 ( 0.00%)  => src/racing/actors.c:add_actor_to_empty_slot (11x)
       55 ( 0.00%)          temp_f0 = spawn_actor_on_surface(startingPos[0], startingPos[1] + 10.0f, startingPos[2]);
    5,137 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/collision.c:spawn_actor_on_surface (11x)
        .           
        .                   // Should be struct ItemBox but not enough space in the stack.
        .                   // It's either the ItemBox or the SEGMENT/OFFSET variables.
        .                   // itemBox = (struct ItemBox *) &gActorList[temp_s1];
        .           
       55 ( 0.00%)          gActorList[temp_s1].unk_08 = temp_f0;
        .                   // itemBox->resetDistance = temp_f0;
        .           
       22 ( 0.00%)          gActorList[temp_s1].velocity[0] = startingPos[1];
        .                   // itemBox->origY = startingPos[1];
        .           
       22 ( 0.00%)          gActorList[temp_s1].pos[1] = temp_f0 - 20.0f;
        .                   // itemBox->pos[1] = temp_f0 - 20.0f;
        .           
       11 ( 0.00%)          temp_s0++;
        .               }
        8 ( 0.00%)  }
        .           
        .           void init_kiwano_fruit(void) {
        .               Vec3f sp64;
        .               Vec3f sp58;
        .               Vec3s sp50;
        .               Player* phi_s1;
        .               struct Actor* actor;
        .               s16 phi_s0;
-- line 995 ----------------------------------------
-- line 1014 ----------------------------------------
        .           
        .           /**
        .            * Destroys actors via zeroing some of the member data
        .            * Key word some. When spawning a new actor,
        .            * members such as pos and rot should be set to prevent using expired data
        .            **/
        .           void destroy_all_actors(void) {
        .               s32 i;
        2 ( 0.00%)      gNumActors = 0;
       53 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
        .                   gActorList[i].flags = 0;
      125 ( 0.00%)          gActorList[i].type = 0;
        .                   gActorList[i].unk_04 = 0;
        .                   gActorList[i].state = 0;
      100 ( 0.00%)          gActorList[i].unk_08 = 0.0f;
        .                   gActorList[i].boundingBoxSize = 0.0f;
        .               }
        1 ( 0.00%)  }
        .           
        1 ( 0.00%)  void spawn_course_actors(void) {
        .               UNUSED s32 pad;
        .               Vec3f position;
        .               Vec3f velocity = { 0.0f, 0.0f, 0.0f };
        .               Vec3s rotation = { 0, 0, 0 };
        .               struct Actor* actor;
        .               struct RailroadCrossing* rrxing;
        .           
        2 ( 0.00%)      gNumPermanentActors = 0;
        2 ( 0.00%)      CourseManager_SpawnActors();
   33,989 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_SpawnActors (1x)
        .           
        .               // switch (gCurrentCourseId) {
        .               //     case COURSE_MARIO_RACEWAY:
        .               //         // spawn_foliage(d_course_mario_raceway_tree_spawns);
        .               //         // spawn_piranha_plants(d_course_mario_raceway_piranha_plant_spawns);
        .               //         // spawn_all_item_boxes(d_course_mario_raceway_item_box_spawns);
        .               //         // vec3f_set(position, 150.0f, 40.0f, -1300.0f);
        .               //         // position[0] *= gCourseDirection;
-- line 1050 ----------------------------------------
-- line 1155 ----------------------------------------
        .               //         spawn_all_item_boxes(d_course_dks_jungle_parkway_item_box_spawns);
        .               //         init_kiwano_fruit();
        .               //         func_80298D10();
        .               //         break;
        .               //     case COURSE_BIG_DONUT:
        .               //         spawn_all_item_boxes(d_course_big_donut_item_box_spawns);
        .               //         break;
        .               // }
        3 ( 0.00%)      gNumPermanentActors = gNumActors;
        2 ( 0.00%)  }
        .           
        .           /**
        .            * @brief Loads actor textures, course specific actor textures.
        .            * Calls to spawn_course_vehicles and place_course_actors
        .            *
        .            */
        1 ( 0.00%)  void init_actors_and_load_textures(void) {
        4 ( 0.00%)      set_segment_base_addr_x64(3, (void*) gNextFreeMemoryAddress);
        5 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:set_segment_base_addr_x64 (1x)
        6 ( 0.00%)      D_802BA050 = dma_textures(gTextureGreenShell0, 0x00000257U, 0x00000400U);
    2,549 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell1, 0x00000242U, 0x00000400U);
    3,059 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell2, 0x00000259U, 0x00000400U);
    2,906 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell3, 0x00000256U, 0x00000400U);
    2,954 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell4, 0x00000246U, 0x00000400U);
    2,932 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell5, 0x0000025EU, 0x00000400U);
    2,917 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell6, 0x0000025CU, 0x00000400U);
    2,994 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureGreenShell7, 0x00000254U, 0x00000400U);
    3,127 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        6 ( 0.00%)      D_802BA054 = dma_textures(gTextureBlueShell0, 0x0000022AU, 0x00000400U);
    2,842 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell1, 0x00000237U, 0x00000400U);
    2,895 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell2, 0x0000023EU, 0x00000400U);
    2,868 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell3, 0x00000243U, 0x00000400U);
    2,895 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell4, 0x00000255U, 0x00000400U);
    2,893 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell5, 0x00000259U, 0x00000400U);
    2,915 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell6, 0x00000239U, 0x00000400U);
    2,664 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureBlueShell7, 0x00000236U, 0x00000400U);
    3,058 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner1, 0x0000028EU, 0x00000800U);
    3,009 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner2, 0x000002FBU, 0x00000800U);
    3,335 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner3, 0x00000302U, 0x00000800U);
    2,735 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner4, 0x000003B4U, 0x00000800U);
    3,161 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner5, 0x0000031EU, 0x00000800U);
    3,032 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner6, 0x0000036EU, 0x00000800U);
    2,841 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner7, 0x0000029CU, 0x00000800U);
    2,790 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTextureFinishLineBanner8, 0x0000025BU, 0x00000800U);
    2,961 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTexture671A88, 0x00000400U, 0x00000800U);
    3,393 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        4 ( 0.00%)      dma_textures(gTexture6774D8, 0x00000400U, 0x00000800U);
    2,952 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
        .           
        2 ( 0.00%)      CourseManager_LoadTextures();
   29,693 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_LoadTextures (1x)
        .           
        1 ( 0.00%)      init_red_shell_texture();
    2,739 ( 0.00%)  => src/racing/actors.c:init_red_shell_texture (1x)
        1 ( 0.00%)      destroy_all_actors();
      281 ( 0.00%)  => src/racing/actors.c:destroy_all_actors (1x)
        1 ( 0.00%)      spawn_course_actors();
   33,999 ( 0.00%)  => src/racing/actors.c:spawn_course_actors (1x)
        .           
        2 ( 0.00%)      CourseManager_VehiclesSpawn();
    9,293 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_VehiclesSpawn (1x)
        .           
        .               // spawn_course_vehicles();
        1 ( 0.00%)  }
        .           
        .           void play_sound_before_despawn(struct Actor* actor) {
        .               s16 flags = actor->flags;
        .           
        .               if ((flags & 0x200) != 0) {
        .                   func_800C99E0(actor->pos, SOUND_ARG_LOAD(0x19, 0x01, 0x90, 0x53));
        .                   return;
        .               }
-- line 1217 ----------------------------------------
-- line 1359 ----------------------------------------
        .                           break;
        .                   }
        .               }
        .           
        .               return -1;
        .           }
        .           
        .           // returns actor index if any slot avaible returns -1
      232 ( 0.00%)  s16 add_actor_to_empty_slot(Vec3f pos, Vec3s rot, Vec3f velocity, s16 actorType) {
        .               s32 index;
        .           
      116 ( 0.00%)      if (gNumActors >= ACTOR_LIST_SIZE) {
        .                   return try_remove_destructable_item(pos, rot, velocity, actorType);
        .               }
      646 ( 0.00%)      for (index = 0; index < ACTOR_LIST_SIZE; index++) {
    2,991 ( 0.00%)          if (gActorList[index].flags == 0) {
       58 ( 0.00%)              gNumActors++;
      319 ( 0.00%)              actor_init(&gActorList[index], pos, rot, velocity, actorType);
    2,783 ( 0.00%)  => src/racing/actors.c:actor_init (29x)
       29 ( 0.00%)              return index;
        .                   }
        .               }
        .               return -1;
      174 ( 0.00%)  }
        .           
        .           UNUSED s16 spawn_actor_at_pos(Vec3f pos, s16 actorType) {
        .               Vec3f vel;
        .               Vec3s rot;
        .           
        .               vec3f_set(vel, 0.0f, 0.0f, 0.0f);
        .               vec3s_set(rot, 0, 0, 0);
        .               return add_actor_to_empty_slot(pos, rot, vel, actorType);
-- line 1389 ----------------------------------------
-- line 1687 ----------------------------------------
        .           
        .           bool query_collision_player_vs_actor_item(Player* arg0, struct Actor* arg1) {
        .               f32 temp_f0;
        .               f32 dist;
        .               f32 yDist;
        .               f32 zDist;
        .               f32 xDist;
        .           
  204,438 ( 0.00%)      temp_f0 = arg0->boundingBoxSize + arg1->boundingBoxSize;
  204,438 ( 0.00%)      xDist = arg1->pos[0] - arg0->pos[0];
  204,438 ( 0.00%)      if (temp_f0 < xDist) {
  102,219 ( 0.00%)          return NO_COLLISION;
        .               }
   44,997 ( 0.00%)      if (xDist < -temp_f0) {
        .                   return NO_COLLISION;
        .               }
    1,724 ( 0.00%)      yDist = arg1->pos[1] - arg0->pos[1];
    1,724 ( 0.00%)      if (temp_f0 < yDist) {
        .                   return NO_COLLISION;
        .               }
    1,588 ( 0.00%)      if (yDist < -temp_f0) {
        .                   return NO_COLLISION;
        .               }
    1,588 ( 0.00%)      zDist = arg1->pos[2] - arg0->pos[2];
    1,588 ( 0.00%)      if (temp_f0 < zDist) {
        .                   return NO_COLLISION;
        .               }
    1,402 ( 0.00%)      if (zDist < -temp_f0) {
        .                   return NO_COLLISION;
        .               }
        .               dist = (xDist * xDist) + (yDist * yDist) + (zDist * zDist);
        .               if (dist < 0.1f) {
        .                   return NO_COLLISION;
        .               }
        .               if ((temp_f0 * temp_f0) < dist) {
        .                   return NO_COLLISION;
        .               }
        .               return COLLISION;
  102,219 ( 0.00%)  }
        .           
        .           bool query_collision_actor_vs_actor(struct Actor* arg0, struct Actor* arg1) {
        .               f32 temp_f0;
        .               f32 dist;
        .               f32 dist_y;
        .               f32 dist_z;
        .               f32 dist_x;
        .           
-- line 1733 ----------------------------------------
-- line 1972 ----------------------------------------
        .                       }
        .                   } else {
        .                       destroy_destructable_actor(actor2); // automatically destroy if it's something different of a blueshell
        .                   }
        .                   play_sound_on_destructible_actor_collision(actor1, actor2);
        .               }
        .           }
        .           
  511,095 ( 0.00%)  void evaluate_collision_between_player_actor(Player* player, struct Actor* actor) {
        .               UNUSED s32 pad;
        .               s16 temp_lo;
        .               UNUSED s32 pad2[2];
        .               s16 temp_v1;
        .               Player* owner;
        .               f32 temp_f0;
        .               f32 temp_f2;
        .           
  613,314 ( 0.00%)      temp_lo = player - gPlayerOne;
1,022,190 ( 0.00%)      switch (actor->type) {
        .                   case ACTOR_YOSHI_EGG:
        .                       if (!(player->effects & BOO_EFFECT) && !(player->type & PLAYER_INVISIBLE_OR_BOMB)) {
        .                           collision_yoshi_egg(player, (struct YoshiValleyEgg*) actor);
        .                       }
        .                       break;
        .                   case ACTOR_BANANA:
        .                       if (player->effects & (BOO_EFFECT | 0x8C0)) {
        .                           break;
-- line 1998 ----------------------------------------
-- line 2108 ----------------------------------------
        .                   case ACTOR_CACTUS2_KALAMARI_DESERT:
        .                   case ACTOR_CACTUS3_KALAMARI_DESERT:
        .                   case ACTOR_BUSH_BOWSERS_CASTLE:
        .                       if (!(player->effects & BOO_EFFECT)) {
        .                           collision_tree(player, actor);
        .                       }
        .                       break;
        .                   case ACTOR_FALLING_ROCK:
  114,240 ( 0.00%)              if (!(player->effects & BOO_EFFECT) && !(player->type & PLAYER_INVISIBLE_OR_BOMB)) {
   68,544 ( 0.00%)                  if (query_collision_player_vs_actor_item(player, actor) == COLLISION) {
  188,049 ( 0.00%)  => src/racing/actors.c:query_collision_player_vs_actor_item (22,848x)
        .                               func_800C98B8(actor->pos, actor->velocity, SOUND_ACTION_EXPLOSION);
        .                               if ((gModeSelection == TIME_TRIALS) && !(player->type & PLAYER_KART_AI)) {
        .                                   D_80162DF8 = 1;
        .                               }
        .                               if (player->effects & STAR_EFFECT) {
        .                                   actor->velocity[1] = 10.0f;
        .                               } else {
        .                                   apply_hit_sound_effect(player, player - gPlayerOne);
-- line 2125 ----------------------------------------
-- line 2162 ----------------------------------------
        .                   case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
        .                       if (query_collision_player_vs_actor_item(player, actor) == COLLISION) {
        .                           actor->state = 3;
        .                           actor->flags = -0x8000;
        .                           actor->unk_04 = 0;
        .                           if (player->type & PLAYER_HUMAN) {
        .                               func_8007ABFC(player - gPlayerOne, 7);
        .                           }
  158,742 ( 0.00%)              } else if (actor->state == 0) {
       11 ( 0.00%)                  actor->state = 1;
       22 ( 0.00%)                  actor->flags = -0x8000;
        .                       }
        .                       break;
        .                   case ACTOR_ITEM_BOX:
  238,113 ( 0.00%)              if (query_collision_player_vs_actor_item(player, actor) == COLLISION) {
  684,314 ( 0.00%)  => src/racing/actors.c:query_collision_player_vs_actor_item (79,371x)
        .                           actor->state = 3;
        .                           actor->flags = -0x8000;
        .                           actor->unk_04 = 0;
        .                           if (player->type & PLAYER_HUMAN) {
        .                               func_8007ABFC(player - gPlayerOne, 0);
        .                           }
        .                       } else if (actor->state == 0) {
        .                           actor->state = 1;
        .                           actor->flags = -0x8000;
        .                       }
        .                       break;
        .                   default:
        .                       break;
        .               }
  613,314 ( 0.00%)  }
        .           
    7,616 ( 0.00%)  void evaluate_collision_for_players_and_actors(void) {
        .               struct Actor* temp_a1;
        .               s32 i, j;
        .               Player* phi_s1;
        .           
   22,848 ( 0.00%)      for (i = 0; i < NUM_PLAYERS; i++) {
        .                   phi_s1 = &gPlayers[i];
        .           
   30,464 ( 0.00%)          if (((phi_s1->type & 0x8000) != 0) && ((phi_s1->effects & 0x4000000) == 0)) {
   15,232 ( 0.00%)              func_802977E4(phi_s1);
   38,080 ( 0.00%)  => src/racing/actors.c:func_802977E4 (7,616x)
2,749,376 ( 0.00%)              for (j = 0; j < ACTOR_LIST_SIZE; j++) {
        .                           temp_a1 = &gActorList[j];
        .           
1,523,200 ( 0.00%)                  if ((phi_s1->effects & 0x4000000) == 0) {
        .                               // temp_v0 = temp_a1->unk2;
2,726,528 ( 0.00%)                      if (((temp_a1->flags & 0x8000) != 0) && ((temp_a1->flags & 0x4000) != 0)) {
  408,876 ( 0.00%)                          evaluate_collision_between_player_actor(phi_s1, temp_a1);
4,211,948 ( 0.01%)  => src/racing/actors.c:evaluate_collision_between_player_actor (102,219x)
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
    5,712 ( 0.00%)  }
        .           
        .           // It's look like to check collision between item and other different item
    6,664 ( 0.00%)  void evaluate_collision_for_destructible_actors(void) {
        .               struct Actor* actor1;
        .               struct Actor* actor2;
        .               s32 i, j;
        .               UNUSED s32 pad;
        .           
  325,584 ( 0.00%)      for (i = gNumPermanentActors; i < (ACTOR_LIST_SIZE - 1); i++) {
        .                   actor1 = &gActorList[i];
        .           
  239,904 ( 0.00%)          if ((actor1->flags & 0x8000) == 0) {
        .                       continue;
        .                   }
   26,656 ( 0.00%)          if ((actor1->flags & 0x4000) == 0) {
        .                       continue;
        .                   }
        .           
    4,760 ( 0.00%)          switch (actor1->type) {
        .                       case ACTOR_BANANA:
        .                       case ACTOR_GREEN_SHELL:
        .                       case ACTOR_RED_SHELL:
        .                       case ACTOR_BLUE_SPINY_SHELL:
        .                       case ACTOR_FAKE_ITEM_BOX:
        .           
        .                           for (j = i + 1; j < ACTOR_LIST_SIZE; j++) {
        .                               actor2 = &gActorList[j];
-- line 2242 ----------------------------------------
-- line 2283 ----------------------------------------
        .                                       evaluate_actor_collision_between_two_destructible_actors(actor1, actor2);
        .                                       break;
        .                               }
        .                           }
        .           
        .                           break;
        .                   }
        .               }
    7,616 ( 0.00%)  }
        .           
        .           void func_802A1064(struct FakeItemBox* fake_item_box) {
        .               if ((u32) (fake_item_box - (struct FakeItemBox*) gActorList) <= (u32) ACTOR_LIST_SIZE) {
        .                   if (((fake_item_box->flags & 0x8000) != 0) && (fake_item_box->type == ACTOR_FAKE_ITEM_BOX)) {
        .                       fake_item_box->state = 1;
        .                       fake_item_box->targetY = func_802ABEAC(&fake_item_box->unk30, fake_item_box->pos) + 8.66f;
        .                       fake_item_box->someTimer = 100;
        .                   }
-- line 2299 ----------------------------------------
-- line 2332 ----------------------------------------
        .           #include "actors/yoshi_egg/render.inc.c"
        .           
        .           #include "actors/mario_sign/render.inc.c"
        .           
        .           #include "actors/railroad_crossing/render.inc.c"
        .           
        .           #include "actors/palm_tree/render.inc.c"
        .           
    1,904 ( 0.00%)  void render_item_boxes(struct UnkStruct_800DC5EC* arg0) {
      476 ( 0.00%)      Camera* camera = arg0->camera;
        .               struct Actor* actor;
        .               s32 i;
      952 ( 0.00%)      D_8015F8DC = 0;
        .           
  143,752 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
        .                   actor = &gActorList[i];
        .           
   95,200 ( 0.00%)          if (actor->flags == 0) {
        .                       continue;
        .                   }
        .           
   96,628 ( 0.00%)          switch (actor->type) {
        .                       case ACTOR_FAKE_ITEM_BOX:
        .                           render_actor_fake_item_box(camera, (struct FakeItemBox*) actor);
        .                           break;
        .                       case ACTOR_ITEM_BOX:
        .                           render_actor_item_box(camera, (struct ItemBox*) actor);
        .                           break;
        .                       case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
   15,708 ( 0.00%)                  render_actor_item_box(camera, (struct ItemBox*) actor);
2,767,194 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/item_box/render.inc.c:render_actor_item_box (5,236x)
        .                           break;
        .                   }
        .               }
    1,904 ( 0.00%)  }
        .           
    3,808 ( 0.00%)  void render_course_actors(struct UnkStruct_800DC5EC* arg0) {
      476 ( 0.00%)      Camera* camera = arg0->camera;
      952 ( 0.00%)      u16 pathCounter = arg0->pathCounter;
        .               UNUSED s32 pad[12];
        .               s32 i;
        .           
        .               struct Actor* actor;
        .               UNUSED Vec3f sp4C = { 0.0f, 5.0f, 10.0f };
    2,380 ( 0.00%)      f32 sp48 = sins(camera->rot[1] - 0x8000); // unk26;
    2,380 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (476x)
    1,904 ( 0.00%)      f32 temp_f0 = coss(camera->rot[1] - 0x8000);
    2,856 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (476x)
        .           
      952 ( 0.00%)      D_801502C0[0][0] = temp_f0;
    1,428 ( 0.00%)      D_801502C0[0][2] = -sp48;
      476 ( 0.00%)      D_801502C0[2][2] = temp_f0;
        .               D_801502C0[1][0] = 0.0f;
      476 ( 0.00%)      D_801502C0[0][1] = 0.0f;
      476 ( 0.00%)      D_801502C0[2][1] = 0.0f;
        .               D_801502C0[1][2] = 0.0f;
      476 ( 0.00%)      D_801502C0[0][3] = 0.0f;
      476 ( 0.00%)      D_801502C0[1][3] = 0.0f;
      476 ( 0.00%)      D_801502C0[2][3] = 0.0f; // 2c
      476 ( 0.00%)      D_801502C0[2][0] = sp48;
      476 ( 0.00%)      D_801502C0[1][1] = 1.0f;
      476 ( 0.00%)      D_801502C0[3][3] = 1.0f; // unk3c
        .           
    1,904 ( 0.00%)      gSPClearGeometryMode(gDisplayListHead++, G_LIGHTING);
    3,332 ( 0.00%)      gSPSetLights1(gDisplayListHead++, D_800DC610[1]);
    2,856 ( 0.00%)      gSPTexture(gDisplayListHead++, 0xFFFF, 0xFFFF, 0, G_TX_RENDERTILE, G_ON);
        .           
    2,380 ( 0.00%)      CourseManager_DrawActors(D_800DC5EC->camera);
9,683,744 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_DrawActors (476x)
        .           
    1,428 ( 0.00%)      if (gModeSelection != BATTLE) {
      952 ( 0.00%)          func_80297340(camera);
1,015,273 ( 0.00%)  => src/racing/actors.c:func_80297340 (476x)
        .               }
    1,428 ( 0.00%)      D_8015F8E0 = 0;
        .           
  143,752 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
        .                   actor = &gActorList[i];
        .           
   95,200 ( 0.00%)          if (actor->flags == 0) {
        .                       continue;
        .                   }
   83,300 ( 0.00%)          switch (actor->type) {
        .                       case ACTOR_TREE_MARIO_RACEWAY:
        .                           render_actor_tree_mario_raceway(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_TREE_YOSHI_VALLEY:
        .                           render_actor_tree_yoshi_valley(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_TREE_ROYAL_RACEWAY:
        .                           render_actor_tree_royal_raceway(camera, D_801502C0, actor);
-- line 2417 ----------------------------------------
-- line 2436 ----------------------------------------
        .                           break;
        .                       case ACTOR_CACTUS2_KALAMARI_DESERT:
        .                           render_actor_tree_cactus2_kalimari_desert(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_CACTUS3_KALAMARI_DESERT:
        .                           render_actor_tree_cactus3_kalimari_desert(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_FALLING_ROCK:
    4,284 ( 0.00%)                  render_actor_falling_rock(camera, (struct FallingRock*) actor);
1,789,703 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/falling_rock/render.inc.c:render_actor_falling_rock (1,428x)
        .                           break;
        .                       case ACTOR_KIWANO_FRUIT:
        .                           render_actor_kiwano_fruit(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_BANANA:
        .                           render_actor_banana(camera, D_801502C0, (struct BananaActor*) actor);
        .                           break;
        .                       case ACTOR_GREEN_SHELL:
-- line 2452 ----------------------------------------
-- line 2457 ----------------------------------------
        .                           break;
        .                       case ACTOR_BLUE_SPINY_SHELL:
        .                           render_actor_blue_shell(camera, D_801502C0, (struct ShellActor*) actor);
        .                           break;
        .                       case ACTOR_PIRANHA_PLANT:
        .                           render_actor_piranha_plant(camera, D_801502C0, (struct PiranhaPlant*) actor);
        .                           break;
        .                       case ACTOR_TRAIN_ENGINE:
    2,856 ( 0.00%)                  render_actor_train_engine(camera, (struct TrainCar*) actor);
5,641,339 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/render.inc.c:render_actor_train_engine (952x)
        .                           break;
        .                       case ACTOR_TRAIN_TENDER:
    2,856 ( 0.00%)                  render_actor_train_tender(camera, (struct TrainCar*) actor);
2,939,649 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/render.inc.c:render_actor_train_tender (952x)
        .                           break;
        .                       case ACTOR_TRAIN_PASSENGER_CAR:
   14,280 ( 0.00%)                  render_actor_train_passenger_car(camera, (struct TrainCar*) actor);
20,506,243 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/render.inc.c:render_actor_train_passenger_car (4,760x)
        .                           break;
        .                       case ACTOR_COW:
        .                           render_actor_cow(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_UNKNOWN_0x14:
        .                           func_8029AC18(camera, D_801502C0, actor);
        .                           break;
        .                       case ACTOR_MARIO_SIGN:
-- line 2479 ----------------------------------------
-- line 2496 ----------------------------------------
        .                           break;
        .                       case ACTOR_TANKER_TRUCK:
        .                           render_actor_tanker_truck(camera, actor);
        .                           break;
        .                       case ACTOR_CAR:
        .                           render_actor_car(camera, actor);
        .                           break;
        .                       case ACTOR_RAILROAD_CROSSING:
    1,428 ( 0.00%)                  render_actor_railroad_crossing(camera, (struct RailroadCrossing*) actor);
1,313,374 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/railroad_crossing/render.inc.c:render_actor_railroad_crossing (476x)
        .                           break;
        .                       case ACTOR_YOSHI_EGG:
        .                           render_actor_yoshi_egg(camera, D_801502C0, (struct YoshiValleyEgg*) actor, pathCounter);
        .                           break;
        .                   }
        .               }
    2,380 ( 0.00%)      if (GetCourse() == GetMooMooFarm()) {
    1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (476x)
    1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetMooMooFarm (476x)
        .                   render_cows(camera, D_801502C0, actor);
    2,380 ( 0.00%)      } else if (GetCourse() == GetDkJungle()) {
    1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (476x)
    1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetDkJungle (476x)
        .                   render_palm_trees(camera, D_801502C0, actor);
        .               }
    3,808 ( 0.00%)  }
        .           
    5,712 ( 0.00%)  void update_course_actors(void) {
        .               struct Actor* actor;
        .               s32 i;
  285,600 ( 0.00%)      for (i = 0; i < ACTOR_LIST_SIZE; i++) {
        .           
        .                   actor = &gActorList[i];
  190,400 ( 0.00%)          if (actor->flags == 0) {
        .                       continue;
        .                   }
        .           
  166,600 ( 0.00%)          switch (actor->type) {
        .                       case ACTOR_FALLING_ROCK:
    5,712 ( 0.00%)                  update_actor_falling_rocks((struct FallingRock*) actor);
  419,564 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/falling_rock/update.inc.c:update_actor_falling_rocks (2,856x)
    2,856 ( 0.00%)                  break;
        .                       case ACTOR_GREEN_SHELL:
        .                           update_actor_green_shell((struct ShellActor*) actor);
        .                           break;
        .                       case ACTOR_RED_SHELL:
        .                           update_actor_red_blue_shell((struct ShellActor*) actor);
        .                           break;
        .                       case ACTOR_BLUE_SPINY_SHELL:
        .                           update_actor_red_blue_shell((struct ShellActor*) actor);
-- line 2539 ----------------------------------------
-- line 2543 ----------------------------------------
        .                           break;
        .                       case ACTOR_BANANA:
        .                           update_actor_banana((struct BananaActor*) actor);
        .                           break;
        .                       case ACTOR_PADDLE_BOAT:
        .                           update_actor_paddle_boat((struct PaddleWheelBoat*) actor);
        .                           break;
        .                       case ACTOR_TRAIN_ENGINE:
    3,808 ( 0.00%)                  update_actor_train_engine((struct TrainCar*) actor);
   11,706 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/update.inc.c:update_actor_train_engine (1,904x)
    1,904 ( 0.00%)                  break;
        .                       case ACTOR_TRAIN_TENDER:
    3,808 ( 0.00%)                  update_actor_train_tender((struct TrainCar*) actor);
    3,808 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/update.inc.c:update_actor_train_tender (1,904x)
    1,904 ( 0.00%)                  break;
        .                       case ACTOR_TRAIN_PASSENGER_CAR:
   19,040 ( 0.00%)                  update_actor_train_passenger_car((struct TrainCar*) actor);
   19,040 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/train/update.inc.c:update_actor_train_passenger_car (9,520x)
    9,520 ( 0.00%)                  break;
        .                       case ACTOR_ITEM_BOX:
   20,944 ( 0.00%)                  update_actor_item_box((struct ItemBox*) actor);
   98,686 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/item_box/update.inc.c:update_actor_item_box (10,472x)
   10,472 ( 0.00%)                  break;
        .                       case ACTOR_HOT_AIR_BALLOON_ITEM_BOX:
        .                           update_actor_item_box_hot_air_balloon((struct ItemBox*) actor);
        .                           break;
        .                       case ACTOR_FAKE_ITEM_BOX:
        .                           update_actor_fake_item_box((struct FakeItemBox*) actor);
        .                           break;
        .                       case ACTOR_PIRANHA_PLANT:
        .                           update_actor_piranha_plant((struct PiranhaPlant*) actor);
-- line 2569 ----------------------------------------
-- line 2579 ----------------------------------------
        .                           break;
        .                       case ACTOR_MARIO_SIGN:
        .                           update_actor_mario_sign(actor);
        .                           break;
        .                       case ACTOR_WARIO_SIGN:
        .                           update_actor_wario_sign(actor);
        .                           break;
        .                       case ACTOR_RAILROAD_CROSSING:
    1,904 ( 0.00%)                  update_actor_railroad_crossing((struct RailroadCrossing*) actor);
   16,016 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/actors/railroad_crossing/update.inc.c:update_actor_railroad_crossing (952x)
      952 ( 0.00%)                  break;
        .                       case ACTOR_TREE_MARIO_RACEWAY:
        .                       case ACTOR_TREE_YOSHI_VALLEY:
        .                       case ACTOR_TREE_ROYAL_RACEWAY:
        .                       case ACTOR_TREE_MOO_MOO_FARM:
        .                       case ACTOR_PALM_TREE:
        .                       case ACTOR_UNKNOWN_0x1A: // A plant?
        .                       case ACTOR_UNKNOWN_0x1B:
        .                       case ACTOR_TREE_BOWSERS_CASTLE:
-- line 2596 ----------------------------------------
-- line 2601 ----------------------------------------
        .                       case ACTOR_BUSH_BOWSERS_CASTLE:
        .                           update_actor_static_plant(actor);
        .                           break;
        .                       case ACTOR_YOSHI_EGG:
        .                           update_actor_yoshi_egg((struct YoshiValleyEgg*) actor);
        .                           break;
        .                   }
        .               }
      952 ( 0.00%)      evaluate_collision_for_destructible_actors();
  611,184 ( 0.00%)  => src/racing/actors.c:evaluate_collision_for_destructible_actors (952x)
      952 ( 0.00%)      check_player_use_item();
  121,856 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/actors_extended.c:check_player_use_item (952x)
    2,856 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/ext/atomicity.h
--------------------------------------------------------------------------------
Ir                 

-- line 44 ----------------------------------------
        .           
        .             __attribute__((__always_inline__))
        .             inline bool
        .             __is_single_threaded() _GLIBCXX_NOTHROW
        .             {
        .           #ifndef __GTHREADS
        .               return true;
        .           #elif __has_include(<sys/single_threaded.h>)
  342,666 ( 0.00%)      return ::__libc_single_threaded;
        .           #else
        .               return !__gthread_active_p();
        .           #endif
        .             }
        .           
        .             // Functions for portable atomic access.
        .             // To abstract locking primitives across all thread policies, use:
        .             // __exchange_and_add_dispatch
        .             // __atomic_add_dispatch
        .           #ifdef _GLIBCXX_ATOMIC_BUILTINS
        .             inline _Atomic_word
        .             __attribute__((__always_inline__))
        .             __exchange_and_add(volatile _Atomic_word* __mem, int __val)
5,015,785 ( 0.01%)    { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
        .           
        .             inline void
        .             __attribute__((__always_inline__))
        .             __atomic_add(volatile _Atomic_word* __mem, int __val)
2,763,549 ( 0.00%)    { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
        .           #else
        .             _Atomic_word
        .             __exchange_and_add(volatile _Atomic_word*, int) _GLIBCXX_NOTHROW;
        .           
        .             void
        .             __atomic_add(volatile _Atomic_word*, int) _GLIBCXX_NOTHROW;
        .           #endif
        .           
        .             inline _Atomic_word
        .             __attribute__((__always_inline__))
        .             __exchange_and_add_single(_Atomic_word* __mem, int __val)
        .             {
  124,676 ( 0.00%)      _Atomic_word __result = *__mem;
        2 ( 0.00%)      *__mem += __val;
        .               return __result;
        .             }
        .           
        .             inline void
        .             __attribute__((__always_inline__))
        .             __atomic_add_single(_Atomic_word* __mem, int __val)
        6 ( 0.00%)    { *__mem += __val; }
        .           
        .             inline _Atomic_word
        .             __attribute__ ((__always_inline__))
        .             __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
        .             {
4,945,453 ( 0.01%)      if (__is_single_threaded())
        .                 return __exchange_and_add_single(__mem, __val);
        .               else
2,402,213 ( 0.00%)        return __exchange_and_add(__mem, __val);
        .             }
        .           
        .             inline void
        .             __attribute__ ((__always_inline__))
        .             __atomic_add_dispatch(_Atomic_word* __mem, int __val)
        .             {
4,313,262 ( 0.01%)      if (__is_single_threaded())
        .                 __atomic_add_single(__mem, __val);
        .               else
        .                 __atomic_add(__mem, __val);
        .             }
        .           
        .           _GLIBCXX_END_NAMESPACE_VERSION
        .           } // namespace
        .           
-- line 116 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/gfx_cc.h
--------------------------------------------------------------------------------
Ir                 

-- line 61 ----------------------------------------
        .           #define SHADER_OPT(opt) ((uint64_t)(1 << static_cast<int>(ShaderOpts::opt)))
        .           #endif
        .           
        .           struct ColorCombinerKey {
        .               uint64_t combine_mode;
        .               uint64_t options;
        .           
        .           #ifdef __cplusplus
5,230,360 ( 0.01%)      auto operator<=>(const ColorCombinerKey&) const = default;
        .           #endif
        .           };
        .           
        .           #define SHADER_MAX_TEXTURES 6
        .           #define SHADER_FIRST_TEXTURE 0
        .           #define SHADER_FIRST_MASK_TEXTURE 2
        .           #define SHADER_FIRST_REPLACEMENT_TEXTURE 4
        .           
-- line 77 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/port/GBIMiddleware.cpp
--------------------------------------------------------------------------------
Ir               

-- line 2 ----------------------------------------
      .           
      .           #include "Engine.h"
      .           #include "DisplayList.h"
      .           #include "resource/type/ResourceType.h"
      .           #include "resource/type/Array.h"
      .           
      .           extern "C" int GameEngine_OTRSigCheck(const char* data);
      .           
847,272 ( 0.00%)  extern "C" void gSPDisplayList(Gfx* pkt, Gfx* dl) {
      .               char* imgData = (char*) dl;
      .           
423,636 ( 0.00%)      if (GameEngine_OTRSigCheck(imgData) == 1) {
3,459,544 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (105,909x)
836,796 ( 0.00%)          auto resource = Ship::Context::GetInstance()->GetResourceManager()->LoadResource(imgData);
113,113,122 ( 0.19%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>) (69,733x)
1,464,393 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetInstance() (69,733x)
697,330 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:Ship::Context::GetResourceManager() (69,733x)
      .                   auto res = std::static_pointer_cast<LUS::DisplayList>(resource);
      .                   dl = &res->Instructions[0];
      .               }
      .           
211,818 ( 0.00%)      __gSPDisplayList(pkt, dl);
741,363 ( 0.00%)  }
      .           
249,921 ( 0.00%)  extern "C" void gSPVertex(Gfx* pkt, uintptr_t v, int n, int v0) {
      .           
111,076 ( 0.00%)      if (GameEngine_OTRSigCheck((char*) v) == 1) {
967,113 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (27,769x)
 16,372 ( 0.00%)          v = (uintptr_t) ResourceGetDataByName((char*) v);
8,019,441 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (4,093x)
      .               }
      .           
360,997 ( 0.00%)      __gSPVertex(pkt, v, n, v0);
166,614 ( 0.00%)  }
      .           
      .           extern "C" void gSPInvalidateTexCache(Gfx* pkt, uintptr_t texAddr) {
      .               auto data = reinterpret_cast<char*>(texAddr);
      .           
      .               if (texAddr != 0 && GameEngine_OTRSigCheck(data)) {
      .                   const auto res = Ship::Context::GetInstance()->GetResourceManager()->LoadResource(data);
      .                   const auto type = static_cast<LUS::ResourceType>(res->GetInitData()->Type);
      .           
-- line 37 ----------------------------------------
-- line 40 ----------------------------------------
      .                   } else if (res->GetInitData()->Type == static_cast<uint32_t>(MK64::ResourceType::MK_Array)) {
      .                       texAddr = reinterpret_cast<uintptr_t>(std::static_pointer_cast<MK64::Array>(res)->Vertices.data());
      .                   } else {
      .                       texAddr = reinterpret_cast<uintptr_t>(res->GetRawPointer());
      .                   }
      .               }
      .           
      .               __gSPInvalidateTexCache(pkt, texAddr);
      1 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/graphic/Fast3D/debug/GfxDebugger.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 20 ----------------------------------------
         .           void GfxDebugger::SetBreakPoint(const std::vector<const F3DGfx*>& bp) {
         .               mBreakPoint = bp;
         .           }
         .           
         .           void GfxDebugger::RequestDebugging() {
         .               mIsDebuggingRequested = true;
         .           }
         .           bool GfxDebugger::IsDebugging() const {
82,663,810 ( 0.14%)      return mIsDebugging;
82,663,810 ( 0.14%)  }
         .           bool GfxDebugger::IsDebuggingRequested() const {
       571 ( 0.00%)      return mIsDebuggingRequested;
       571 ( 0.00%)  }
         .           
         .           void GfxDebugger::DebugDisplayList(F3DGfx* cmds) {
         .               mDlist = cmds;
         .               mIsDebuggingRequested = false;
         .               mIsDebugging = true;
         .               mBreakPoint = { cmds };
         .           }
         .           
-- line 40 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/racing/collision.c
--------------------------------------------------------------------------------
Ir                 

-- line 19 ----------------------------------------
        .           void nullify_displaylist(uintptr_t addr) {
        .               Gfx* macro;
        .           
        .               macro = (Gfx*) addr;
        .               macro->words.w0 = (G_ENDDL << 24);
        .               macro->words.w1 = 0;
        .           }
        .           
       80 ( 0.00%)  void func_802AAAAC(Collision* collision) {
        .               collision->meshIndexYX = 5000;
       40 ( 0.00%)      collision->meshIndexZY = 5000;
        .               collision->meshIndexZX = 5000;
       80 ( 0.00%)      collision->unk30 = 0;
        .               collision->unk32 = 0;
        .               collision->unk34 = 0;
       40 ( 0.00%)      collision->surfaceDistance[0] = 0;
        .               collision->surfaceDistance[1] = 0;
        .               collision->surfaceDistance[2] = 0;
      200 ( 0.00%)      vec3f_set(collision->unk48, 0.0f, 0.0f, 1.0f);
      160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (40x)
      200 ( 0.00%)      vec3f_set(collision->unk54, 1.0f, 0.0f, 0.0f);
      160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (40x)
      200 ( 0.00%)      vec3f_set(collision->orientationVector, 0.0f, 1.0f, 0.0f);
      160 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:vec3f_set (40x)
       40 ( 0.00%)  }
        .           
    7,076 ( 0.00%)  f32 func_802AAB4C(Player* player) {
        .               f32 playerX;
        .               f32 playerZ;
        .               s32 temp_v1;
        .           
    3,538 ( 0.00%)      playerX = player->pos[0];
    3,538 ( 0.00%)      playerZ = player->pos[2];
    8,845 ( 0.00%)      if (GetCourse() == GetBowsersCastle()) {
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,769x)
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBowsersCastle (1,769x)
        .                   if (playerX > 1859.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerX < 1549.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ > -1102.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ < -1402.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   return 20.0f;
    8,845 ( 0.00%)      } else if (GetCourse() == GetKoopaTroopaBeach()) {
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,769x)
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetKoopaTroopaBeach (1,769x)
        .                   if (playerX > 239.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerX < 67.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ > 2405.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   if (playerZ < 2233.0f) {
        .                       return D_8015F8E4;
        .                   }
        .                   return 0.8f;
    8,845 ( 0.00%)      } else if (GetCourse() == GetSherbetLand()) {
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,769x)
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetSherbetLand (1,769x)
        .                   if ((get_surface_type(player->collision.meshIndexZX) & 0xFF) == SNOW) {
        .                       return (f32) (gCourseMinY - 0xA);
        .                   }
        .                   return D_8015F8E4;
   10,614 ( 0.00%)      } else if (GetCourse() == GetDkJungle()) {
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1,769x)
    5,307 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetDkJungle (1,769x)
        .                   temp_v1 = get_track_section_id(player->collision.meshIndexZX) & 0xFF;
        .                   if (temp_v1 == 0xFF) {
        .                       if ((get_surface_type(player->collision.meshIndexZX) & 0xFF) == CAVE) {
        .                           return -475.0f;
        .                       }
        .                       if (playerX > -478.0f) {
        .                           return -33.9f;
        .                       }
-- line 90 ----------------------------------------
-- line 102 ----------------------------------------
        .                       }
        .                       return -33.9f;
        .                   }
        .                   if (temp_v1 >= 0x14) {
        .                       return -475.0f;
        .                   }
        .                   return -33.9f;
        .               } else {
    3,538 ( 0.00%)          return D_8015F8E4;
        .               }
    7,076 ( 0.00%)  }
        .           
   16,122 ( 0.00%)  s32 check_collision_zx(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ, u16 index) {
   48,366 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED f32 pad;
        .               f32 x3;
        .               UNUSED f32 pad2;
        .               f32 z3;
        .               UNUSED f32 pad3[4];
        .               f32 x2;
        .               f32 z2;
        .               f32 x1;
        .               f32 z1;
        .               f32 distanceToSurface;
        .               f32 crossProductZX_1;
        .               f32 crossProductZX_2;
        .               f32 crossProductZX_3;
        .               s32 b = true;
        .           
   32,244 ( 0.00%)      if (triangle->normalY < -0.9f) {
   15,544 ( 0.00%)          return 0;
        .               }
   40,305 ( 0.00%)      if (triangle->minX > posX) {
        .                   return 0;
        .               }
   31,632 ( 0.00%)      if (triangle->minZ > posZ) {
        .                   return 0;
        .               }
   25,648 ( 0.00%)      if (triangle->maxX < posX) {
        .                   return 0;
        .               }
   19,492 ( 0.00%)      if (triangle->maxZ < posZ) {
        .                   return 0;
        .               }
   24,345 ( 0.00%)      if ((triangle->minY - boundingBoxSize * 3.0f) > posY) {
        .                   return 0;
        .               }
        .           
   14,607 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
    9,738 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
        .           
   14,607 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
    9,738 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
        .           
   14,607 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
    9,738 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
        .           
   29,214 ( 0.00%)      crossProductZX_1 = (z1 - posZ) * (x2 - posX) - (x1 - posX) * (z2 - posZ);
        .           
   19,476 ( 0.00%)      if (!crossProductZX_1) {
        .           
   19,476 ( 0.00%)          crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
        .           
        .                   crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .           
        .                   if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
        .                       b = false;
        .                   }
        .               } else {
        .           
        .                   crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
        .           
   19,476 ( 0.00%)          if (!crossProductZX_2) {
        .                       crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .           
        .                       if ((crossProductZX_1 * crossProductZX_3) < 0.0f) {
        .                           b = false;
        .                       }
        .                   } else {
   19,476 ( 0.00%)              if ((crossProductZX_1 * crossProductZX_2) < 0.0f) {
        .                           b = false;
        .                       } else {
    6,502 ( 0.00%)                  crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
    9,753 ( 0.00%)                  if (crossProductZX_3 != 0) {
   13,894 ( 0.00%)                      if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
        .                                   b = false;
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
        .               if (!b) {
        .                   return 0;
        .               }
    2,361 ( 0.00%)      distanceToSurface =
   16,527 ( 0.00%)          ((triangle->normalX * posX) + (triangle->normalY * posY) + (triangle->normalZ * posZ) + triangle->distance) -
        .                   boundingBoxSize;
    7,083 ( 0.00%)      if (distanceToSurface > 0.0f) {
    6,216 ( 0.00%)          if (collision->surfaceDistance[2] > distanceToSurface) {
    1,036 ( 0.00%)              collision->unk34 = 1;
    1,036 ( 0.00%)              collision->meshIndexZX = index;
    1,036 ( 0.00%)              collision->surfaceDistance[2] = distanceToSurface;
    1,036 ( 0.00%)              collision->orientationVector[0] = triangle->normalX;
        .                       collision->orientationVector[1] = triangle->normalY;
    1,036 ( 0.00%)              collision->orientationVector[2] = triangle->normalZ;
        .                   }
        .                   return 0;
        .               }
        .           
      578 ( 0.00%)      if (distanceToSurface > -16.0f) {
      289 ( 0.00%)          collision->unk34 = 1;
      289 ( 0.00%)          collision->meshIndexZX = index;
      289 ( 0.00%)          collision->surfaceDistance[2] = distanceToSurface;
      289 ( 0.00%)          collision->orientationVector[0] = triangle->normalX;
        .                   collision->orientationVector[1] = triangle->normalY;
      289 ( 0.00%)          collision->orientationVector[2] = triangle->normalZ;
      289 ( 0.00%)          return 1;
        .               }
        .               return 0;
      289 ( 0.00%)  }
        .           
    2,256 ( 0.00%)  s32 check_collision_yx(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ, u16 index) {
    7,896 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED f32 pad[6];
        .               f32 x3;
        .               f32 y3;
        .               UNUSED f32 pad2[1];
        .           
        .               UNUSED f32 pad3[5];
        .               f32 x2;
        .               f32 y2;
-- line 232 ----------------------------------------
-- line 233 ----------------------------------------
        .               f32 x1;
        .               f32 y1;
        .               f32 distanceToSurface;
        .               f32 crossProductYX_1;
        .               f32 crossProductYX_2;
        .               f32 crossProductYX_3;
        .               s32 b = true;
        .           
    4,512 ( 0.00%)      if (triangle->minX > posX) {
    2,256 ( 0.00%)          return 0;
        .               }
      884 ( 0.00%)      if (triangle->maxX < posX) {
        .                   return 0;
        .               }
      884 ( 0.00%)      if (triangle->maxY < posY) {
        .                   return 0;
        .               }
        4 ( 0.00%)      if (triangle->minY > posY) {
        .                   return 0;
        .               }
        .           
        6 ( 0.00%)      if ((triangle->minZ - boundingBoxSize * 3.0f) > posZ) {
        .                   return 0;
        .               }
        5 ( 0.00%)      if ((triangle->maxZ + boundingBoxSize * 3.0f) < posZ) {
        .                   return 0;
        .               }
        .           
        .               x1 = triangle->vtx1->v.ob[0];
        .               y1 = triangle->vtx1->v.ob[1];
        .           
        .               x2 = triangle->vtx2->v.ob[0];
        .               y2 = triangle->vtx2->v.ob[1];
-- line 265 ----------------------------------------
-- line 323 ----------------------------------------
        .                   collision->unk48[0] = triangle->normalX;
        .                   collision->unk48[1] = triangle->normalY;
        .                   collision->unk48[2] = triangle->normalZ;
        .                   return 1;
        .               }
        .               return 0;
        .           }
        .           
    2,256 ( 0.00%)  s32 check_collision_zy(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ, u16 index) {
    7,896 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               s32 b = true;
        .               UNUSED f32 pad[7];
        .               f32 y3;
        .               f32 z3;
        .               UNUSED f32 pad2[5];
        .               f32 y2;
        .               f32 z2;
        .               f32 y1;
        .               f32 z1;
        .               f32 distanceToSurface;
        .               f32 crossProductYZ_1;
        .               f32 crossProductYZ_2;
        .               f32 crossProductYZ_3;
    4,512 ( 0.00%)      if (triangle->minZ > posZ) {
    2,256 ( 0.00%)          return 0;
        .               }
    4,512 ( 0.00%)      if (triangle->maxZ < posZ) {
        .                   return 0;
        .               }
        .               if (triangle->maxY < posY) {
        .                   return 0;
        .               }
        .               if (triangle->minY > posY) {
        .                   return 0;
        .               }
-- line 357 ----------------------------------------
-- line 432 ----------------------------------------
        .                   collision->unk54[0] = triangle->normalX;
        .                   collision->unk54[1] = triangle->normalY;
        .                   collision->unk54[2] = triangle->normalZ;
        .                   return 1;
        .               }
        .               return 0;
        .           }
        .           
       88 ( 0.00%)  s32 check_horizontally_colliding_with_triangle(f32 posX, f32 posZ, u16 index) {
      616 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED f32 pad;
        .               f32 x3;
        .               UNUSED f32 pad2;
        .               f32 z3;
        .               f32 x2;
        .               UNUSED f32 pad3;
        .               f32 z2;
        .               f32 x1;
        .               f32 z1;
        .               UNUSED f32 pad4[4];
        .               f32 crossProductZX_1;
        .               f32 crossProductZX_3;
        .               f32 crossProductZX_2;
       42 ( 0.00%)      s32 b = true;
        .           
      264 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
      176 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
        .           
      264 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
      176 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
        .           
      264 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
      176 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
        .           
      528 ( 0.00%)      crossProductZX_1 = (z1 - posZ) * (x2 - posX) - (x1 - posX) * (z2 - posZ);
        .           
      352 ( 0.00%)      if (!crossProductZX_1) {
        .           
      352 ( 0.00%)          crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
        .           
        .                   crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .           
        .                   if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
       88 ( 0.00%)              b = false;
        .                   }
        .               } else {
        .                   crossProductZX_2 = (z2 - posZ) * (x3 - posX) - (x2 - posX) * (z3 - posZ);
      352 ( 0.00%)          if (!crossProductZX_2) {
        .                       crossProductZX_3 = (z3 - posZ) * (x1 - posX) - (x3 - posX) * (z1 - posZ);
        .                       if (crossProductZX_1 * crossProductZX_3 < 0.0f) {
        .                           b = false;
        .                       }
        .                   } else {
      352 ( 0.00%)              if ((crossProductZX_1 * crossProductZX_2) < 0.0f) {
        .                           b = false;
        .                       } else {
       84 ( 0.00%)                  crossProductZX_3 = ((z3 - posZ) * (x1 - posX)) - ((x3 - posX) * (z1 - posZ));
      126 ( 0.00%)                  if (crossProductZX_3 != 0) {
      210 ( 0.00%)                      if ((crossProductZX_2 * crossProductZX_3) < 0.0f) {
        .                                   b = false;
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
        .               return b;
       88 ( 0.00%)  }
        .           
        .           s8 get_surface_type(u16 index) {
    3,035 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   18,210 ( 0.00%)      return triangle->surfaceType;
    3,035 ( 0.00%)  }
        .           
        .           s16 get_track_section_id(u16 index) {
    8,694 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   52,164 ( 0.00%)      return triangle->flags & 0xFF;
    8,694 ( 0.00%)  }
        .           
        .           s16 func_802ABD7C(u16 index) {
    2,447 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   17,129 ( 0.00%)      return triangle->flags & 0x1000;
    2,447 ( 0.00%)  }
        .           
        .           s16 func_802ABDB8(u16 index) {
    3,538 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   24,766 ( 0.00%)      return triangle->flags & 0x400;
    3,538 ( 0.00%)  }
        .           
        .           s16 func_802ABDF4(u16 index) {
    1,812 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   12,684 ( 0.00%)      return triangle->flags & 0x800;
    1,812 ( 0.00%)  }
        .           
        .           f32 calculate_surface_height(f32 x, f32 y, f32 z, u16 index) {
   91,878 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
   76,565 ( 0.00%)      if (triangle->normalY == 0.0f) {
        .                   return y;
        .               }
   76,565 ( 0.00%)      return ((triangle->normalX * x) + (triangle->normalZ * z) + triangle->distance) / -triangle->normalY;
   30,626 ( 0.00%)  }
        .           
        .           f32 func_802ABEAC(Collision* collision, Vec3f pos) {
        .               if (collision->unk34 == 1) {
        .                   return calculate_surface_height(pos[0], pos[1], pos[2], collision->meshIndexZX);
        .               }
        .               if (collision->unk30 == 1) {
        .                   return calculate_surface_height(pos[0], pos[1], pos[2], collision->meshIndexYX);
        .               }
-- line 539 ----------------------------------------
-- line 597 ----------------------------------------
        .               if (collision->surfaceDistance[1] < 0.0f) {
        .                   process_shell_collision(collision->unk54, collision->surfaceDistance[1], velocity, 2.0f);
        .               }
        .           }
        .           
        .           /**
        .            * Adjusts the position of pos2 based on pos1 but in the orthogonal direction to pos2.
        .            */
       72 ( 0.00%)  void adjust_pos_orthogonally(Vec3f pos1, f32 boundingBoxSize, Vec3f pos2, UNUSED f32 unk) {
        .               f32 x1;
        .               f32 y1;
        .               f32 z1;
        .               f32 x2;
        .               f32 y2;
        .               f32 z2;
        .               f32 dotProduct;
        .               f32 orthoX;
        .               f32 orthoY;
        .               f32 orthoZ;
        .           
       72 ( 0.00%)      x2 = pos2[0];
        .               y2 = pos2[1];
       72 ( 0.00%)      z2 = pos2[2];
      216 ( 0.00%)      x1 = -pos1[0];
        .               y1 = -pos1[1];
      144 ( 0.00%)      z1 = -pos1[2];
        .           
      432 ( 0.00%)      dotProduct = (x1 * x2) + (y1 * y2) + (z1 * z2);
        .           
      576 ( 0.00%)      orthoX = x2 - (dotProduct * x1);
        .               orthoY = y2 - (dotProduct * y1);
      144 ( 0.00%)      orthoZ = z2 - (dotProduct * z1);
        .           
      216 ( 0.00%)      if (boundingBoxSize < -3.5) {
       72 ( 0.00%)          pos2[0] = orthoX - (dotProduct * x1 * 0.5f);
        .                   pos2[1] = orthoY - (dotProduct * y1 * 0.5f);
       72 ( 0.00%)          pos2[2] = orthoZ - (dotProduct * z1 * 0.5f);
        .               } else {
        .                   pos2[0] = orthoX;
        .                   pos2[1] = orthoY;
        .                   pos2[2] = orthoZ;
        .               }
       72 ( 0.00%)  }
        .           
        .           UNUSED s32 detect_tyre_collision(KartTyre* tyre) {
        .               Collision collision;
        .               UNUSED s32 pad[12];
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               f32 tyreX;
        .               f32 tyreY;
-- line 647 ----------------------------------------
-- line 750 ----------------------------------------
        .               tyre->surfaceType = 0;
        .               //! @bug
        .               // Another function that has a return value but doesn't have an explicit return statement in one of its codepaths.
        .               // The return value at this point will be whatever was last returned by func_802AAE4C/func_802AB6C4/func_802AB288
        .               // depending on which (if any) if statements were entered on the loop's last cycle
        .           }
        .           
        .           s32 is_colliding_with_drivable_surface(Collision* collision, f32 boundingBoxSize, f32 newX, f32 newY, f32 newZ,
   16,212 ( 0.00%)                                         u16 index, f32 oldX, f32 oldY, f32 oldZ) {
   37,828 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               UNUSED s32 pad;
        .               f32 x4;
        .               UNUSED f32 y4;
        .               f32 z4;
        .               f32 x3;
        .               UNUSED f32 y3;
        .               f32 z3;
        .               f32 x2;
-- line 767 ----------------------------------------
-- line 770 ----------------------------------------
        .               f32 surfaceDistance;
        .               f32 temp;
        .               UNUSED s32 pad2[2];
        .               f32 area;
        .               f32 area2;
        .               f32 area3;
        .               s32 b = 1;
        .           
   21,616 ( 0.00%)      if (triangle->minX > newX) {
       34 ( 0.00%)          return 0;
        .               }
   21,616 ( 0.00%)      if (triangle->minZ > newZ) {
        .                   return 0;
        .               }
   21,568 ( 0.00%)      if (triangle->maxX < newX) {
        .                   return 0;
        .               }
   21,568 ( 0.00%)      if (triangle->maxZ < newZ) {
        .                   return 0;
        .               }
   26,950 ( 0.00%)      if ((triangle->minY - boundingBoxSize * 3.0f) > newY) {
        .                   return 0;
        .               }
        .           
   16,170 ( 0.00%)      x2 = (f32) triangle->vtx1->v.ob[0];
   10,780 ( 0.00%)      z2 = (f32) triangle->vtx1->v.ob[2];
        .           
   16,170 ( 0.00%)      x3 = (f32) triangle->vtx2->v.ob[0];
   10,780 ( 0.00%)      z3 = (f32) triangle->vtx2->v.ob[2];
        .           
   16,170 ( 0.00%)      x4 = (f32) triangle->vtx3->v.ob[0];
   10,780 ( 0.00%)      z4 = (f32) triangle->vtx3->v.ob[2];
        .           
   32,340 ( 0.00%)      area = (z2 - newZ) * (x3 - newX) - (x2 - newX) * (z3 - newZ);
        .           
   21,560 ( 0.00%)      if (area == 0) {
   21,560 ( 0.00%)          area2 = (z3 - newZ) * (x4 - newX) - (x3 - newX) * (z4 - newZ);
        .                   area3 = (z4 - newZ) * (x2 - newX) - (x4 - newX) * (z2 - newZ);
        .                   if (area2 * area3 < 0.0f) {
        .                       b = 0;
        .                   }
        .               } else {
        .           
        .                   area2 = (z3 - newZ) * (x4 - newX) - (x3 - newX) * (z4 - newZ);
        .           
   21,560 ( 0.00%)          if (area2 == 0) {
        .           
        .                       area3 = (z4 - newZ) * (x2 - newX) - (x4 - newX) * (z2 - newZ);
        .           
        .                       if (area * area3 < 0.0f) {
        .                           b = 0;
        .                       }
        .                   } else {
   21,560 ( 0.00%)              if ((area * area2) < 0.0f) {
        .                           b = 0;
        .                       } else {
   10,780 ( 0.00%)                  area3 = (z4 - newZ) * (x2 - newX) - (x4 - newX) * (z2 - newZ);
   16,170 ( 0.00%)                  if (area3 != 0) {
   21,563 ( 0.00%)                      if (area2 * area3 < 0.0f) {
        .                                   b = 0;
        .                               }
        .                           }
        .                       }
        .                   }
        .               }
        .               if (b == 0) {
        .                   return 0;
        .               }
        .           
    5,387 ( 0.00%)      surfaceDistance =
   43,096 ( 0.00%)          (triangle->normalX * newX) + (triangle->normalY * newY) + (triangle->normalZ * newZ) + triangle->distance;
        .           
   10,774 ( 0.00%)      if (surfaceDistance > boundingBoxSize) {
        .                   if (collision->surfaceDistance[2] > surfaceDistance) {
        .                       collision->unk34 = 1;
        .                       collision->meshIndexZX = index;
        .                       collision->surfaceDistance[2] = surfaceDistance - boundingBoxSize;
        .                       collision->orientationVector[0] = triangle->normalX;
        .                       collision->orientationVector[1] = triangle->normalY;
        .                       collision->orientationVector[2] = triangle->normalZ;
        .                   }
        .                   return 0;
        .               }
        .           
   21,548 ( 0.00%)      temp = (triangle->normalX * oldX) + (triangle->normalY * oldY) + (triangle->normalZ * oldZ) + triangle->distance;
        .           
   16,161 ( 0.00%)      if (temp < 0.0f) {
        .                   return 0;
        .               }
        .           
    5,387 ( 0.00%)      collision->unk34 = 1;
    5,387 ( 0.00%)      collision->meshIndexZX = index;
   10,774 ( 0.00%)      collision->surfaceDistance[2] = surfaceDistance - boundingBoxSize;
    5,387 ( 0.00%)      collision->orientationVector[0] = triangle->normalX;
        .               collision->orientationVector[1] = triangle->normalY;
    5,387 ( 0.00%)      collision->orientationVector[2] = triangle->normalZ;
    5,387 ( 0.00%)      return 1;
    5,387 ( 0.00%)  }
        .           
        .           /**
        .            * Wall collision
        .            */
        .           s32 is_colliding_with_wall2(Collision* arg, f32 boundingBoxSize, f32 x1, f32 y1, f32 z1, u16 surfaceIndex, f32 posX,
        .                                       f32 posY, f32 posZ) {
        .               if (CVarGetInteger("gNoWallColision", 0)) {
        .                   return NO_COLLISION;
-- line 875 ----------------------------------------
-- line 1233 ----------------------------------------
        .               arg->surfaceDistance[1] = distanceToSurface - boundingBoxSize;
        .               arg->unk54[0] = triangle->normalX;
        .               arg->unk54[1] = triangle->normalY;
        .               arg->unk54[2] = triangle->normalZ;
        .               return COLLISION;
        .           }
        .           
        .           u16 actor_terrain_collision(Collision* collision, f32 boundingBoxSize, f32 newX, f32 newY, f32 newZ, f32 oldX, f32 oldY,
   30,350 ( 0.00%)                              f32 oldZ) {
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               u16 numTriangles;
        .               u16 collisionIndex;
        .               s16 gridIndex;
        .           
        .               u16 sectionIndex;
        .           
        .               u16 flags = 0;
        .               s32 sectionX;
        .               s32 sectionZ;
        .               u16 i;
        .           
    3,035 ( 0.00%)      collision->unk30 = 0;
        .               collision->unk32 = 0;
    3,035 ( 0.00%)      collision->unk34 = 0;
    6,070 ( 0.00%)      collision->surfaceDistance[0] = 1000.0f;
        .               collision->surfaceDistance[1] = 1000.0f;
    3,035 ( 0.00%)      collision->surfaceDistance[2] = 1000.0f;
        .           
        .               // Check if an intersection test has already been performed.
   15,175 ( 0.00%)      if ((s32) collision->meshIndexZX < (s32) gCollisionMeshCount) {
   33,297 ( 0.00%)          if (is_colliding_with_drivable_surface(collision, boundingBoxSize, newX, newY, newZ, collision->meshIndexZX,
  311,048 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (3,027x)
        .                                                          oldX, oldY, oldZ) == COLLISION) {
        .                       flags |= FACING_Y_AXIS;
        .                   }
        .               }
        .           
   30,294 ( 0.00%)      if ((s32) collision->meshIndexYX < (s32) gCollisionMeshCount) {
        .                   if (is_colliding_with_wall2(collision, boundingBoxSize, newX, newY, newZ, collision->meshIndexYX, oldX, oldY,
        .                                               oldZ) == COLLISION) {
        .                       flags |= FACING_Z_AXIS;
        .                   }
        .               }
        .           
    9,105 ( 0.00%)      if ((s32) collision->meshIndexZY < (s32) gCollisionMeshCount) {
        .                   if (is_colliding_with_wall1(collision, boundingBoxSize, newX, newY, newZ, collision->meshIndexZY, oldX, oldY,
        .                                               oldZ) == COLLISION) {
        .                       flags |= FACING_X_AXIS;
        .                   }
        .               }
        .           
        .               if (flags == (FACING_Y_AXIS | FACING_Z_AXIS | FACING_X_AXIS)) {
        .                   return flags;
        .               }
        .           
   12,140 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
    9,105 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
    9,105 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
    9,105 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
   21,245 ( 0.00%)      sectionIndexX = (newX - gCourseMinX) / sectionX;
   21,245 ( 0.00%)      sectionIndexZ = (newZ - gCourseMinZ) / sectionZ;
        .               if (sectionIndexX < 0) {
        .                   return 0;
        .               }
        .               if (sectionIndexZ < 0) {
        .                   return 0;
        .               }
        .               if (sectionIndexX >= GRID_SIZE) {
        .                   return 0;
        .               }
   12,140 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 0;
        .               }
        .           
    9,105 ( 0.00%)      gridIndex = (sectionIndexX + sectionIndexZ * GRID_SIZE);
    9,105 ( 0.00%)      numTriangles = gCollisionGrid[gridIndex].numTriangles;
        .           
    6,070 ( 0.00%)      if (numTriangles == 0) {
        .                   return flags;
        .               }
        .           
    2,275 ( 0.00%)      sectionIndex = gCollisionGrid[gridIndex].triangle;
        .           
   25,311 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
    9,138 ( 0.00%)          if (flags == (FACING_Y_AXIS | FACING_Z_AXIS | FACING_X_AXIS)) {
        .                       return flags;
        .                   }
        .           
   46,072 ( 0.00%)          collisionIndex = gCollisionIndices[sectionIndex];
        .           
   80,626 ( 0.00%)          if ((gCollisionMesh[collisionIndex].flags & FACING_Y_AXIS)) {
   23,036 ( 0.00%)              if ((flags & FACING_Y_AXIS) == 0) {
       48 ( 0.00%)                  if (collisionIndex != collision->meshIndexZX) {
      359 ( 0.00%)                      if (is_colliding_with_drivable_surface(collision, boundingBoxSize, newX, newY, newZ, collisionIndex,
    2,013 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (21x)
        .                                                                      oldX, oldY, oldZ) == COLLISION) {
       38 ( 0.00%)                          flags |= FACING_Y_AXIS;
        .                               }
        .                           }
        .                       }
        .                   } else if ((gCollisionMesh[collisionIndex].flags & FACING_X_AXIS) != 0) {
        .                       if ((flags & FACING_X_AXIS) == 0) {
        .                           if (collisionIndex != collision->meshIndexZY) {
        .                               if (is_colliding_with_wall1(collision, boundingBoxSize, newX, newY, newZ, collisionIndex, oldX,
        .                                                           oldY, oldZ) == COLLISION) {
-- line 1340 ----------------------------------------
-- line 1345 ----------------------------------------
        .                   } else if ((flags & FACING_Z_AXIS) == 0) {
        .                       if (collisionIndex != collision->meshIndexYX) {
        .                           if (is_colliding_with_wall2(collision, boundingBoxSize, newX, newY, newZ, collisionIndex, oldX, oldY,
        .                                                       oldZ) == COLLISION) {
        .                               flags |= FACING_Z_AXIS;
        .                           }
        .                       }
        .                   }
   11,518 ( 0.00%)          sectionIndex++;
        .               }
        .               return flags;
   27,315 ( 0.00%)  }
        .           
   41,340 ( 0.00%)  u16 check_bounding_collision(Collision* collision, f32 boundingBoxSize, f32 posX, f32 posY, f32 posZ) {
        .               u16 numTriangles;
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               u16 meshIndex;
        .               s32 sectionX;
        .               s32 sectionZ;
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               s16 gridIndex;
        .               u16 i;
        .           
        .               u16 sectionIndex;
        .               u16 flags;
        .           
    4,134 ( 0.00%)      collision->unk30 = 0;
        .               collision->unk32 = 0;
    4,134 ( 0.00%)      collision->unk34 = 0;
    8,268 ( 0.00%)      collision->surfaceDistance[0] = 1000.0f;
        .               collision->surfaceDistance[1] = 1000.0f;
    4,134 ( 0.00%)      collision->surfaceDistance[2] = 1000.0f;
        .               flags = 0;
   20,670 ( 0.00%)      if (collision->meshIndexZX < gCollisionMeshCount) {
   11,592 ( 0.00%)          if (check_collision_zx(collision, boundingBoxSize, posX, posY, posZ, collision->meshIndexZX) == 1) {
  134,050 ( 0.00%)  => src/racing/collision.c:check_collision_zx (1,449x)
        .                       flags |= FACING_Y_AXIS;
        .                   }
        .               }
   18,198 ( 0.00%)      if (collision->meshIndexYX < gCollisionMeshCount) {
    7,896 ( 0.00%)          if (check_collision_yx(collision, boundingBoxSize, posX, posY, posZ, collision->meshIndexYX) == 1) {
   18,703 ( 0.00%)  => src/racing/collision.c:check_collision_yx (1,128x)
    7,896 ( 0.00%)              flags |= FACING_Z_AXIS;
        .                   }
        .               }
   13,530 ( 0.00%)      if (collision->meshIndexZY < gCollisionMeshCount) {
   12,408 ( 0.00%)          if (check_collision_zy(collision, boundingBoxSize, posX, posY, posZ, collision->meshIndexZY) == 1) {
   21,432 ( 0.00%)  => src/racing/collision.c:check_collision_zy (1,128x)
        .                       flags |= FACING_X_AXIS;
        .                   }
        .               }
        .               if (flags == (FACING_Y_AXIS | FACING_Z_AXIS | FACING_X_AXIS)) {
        .                   return flags;
        .               }
        .           
   16,536 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
   12,402 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
   12,402 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
   12,402 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
   28,938 ( 0.00%)      sectionIndexX = (posX - gCourseMinX) / sectionX;
   28,938 ( 0.00%)      sectionIndexZ = (posZ - gCourseMinZ) / sectionZ;
        .           
        .               if (sectionIndexX < 0) {
        .                   return 0;
        .               }
        .               if (sectionIndexZ < 0) {
        .                   return 0;
        .               }
        .               if (sectionIndexX >= GRID_SIZE) {
        .                   return 0;
        .               }
   16,536 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 0;
        .               }
        .           
   12,402 ( 0.00%)      gridIndex = sectionIndexX + sectionIndexZ * GRID_SIZE;
   12,402 ( 0.00%)      numTriangles = gCollisionGrid[gridIndex].numTriangles;
    8,268 ( 0.00%)      if (numTriangles == 0) {
        .                   return flags;
        .               }
    1,325 ( 0.00%)      sectionIndex = gCollisionGrid[gridIndex].triangle;
        .           
   19,453 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
    4,035 ( 0.00%)          if (flags == (FACING_X_AXIS | FACING_Y_AXIS | FACING_Z_AXIS)) {
        .                       return flags;
        .                   }
   36,256 ( 0.00%)          meshIndex = gCollisionIndices[sectionIndex];
   63,448 ( 0.00%)          if (gCollisionMesh[meshIndex].flags & FACING_Y_AXIS) {
   18,128 ( 0.00%)              if (!(flags & FACING_Y_AXIS)) {
   15,326 ( 0.00%)                  if (meshIndex != collision->meshIndexZX) {
   79,314 ( 0.00%)                      if (check_collision_zx(collision, boundingBoxSize, posX, posY, posZ, meshIndex) == 1) {
  369,918 ( 0.00%)  => src/racing/collision.c:check_collision_zx (6,612x)
       60 ( 0.00%)                          flags |= FACING_Y_AXIS;
        .                               }
        .                           }
        .                       }
        .                   } else if (gCollisionMesh[meshIndex].flags & FACING_X_AXIS) {
        .                       if (!(flags & FACING_X_AXIS)) {
        .                           if (meshIndex != collision->meshIndexZY) {
        .                               if (check_collision_zy(collision, boundingBoxSize, posX, posY, posZ, meshIndex) == 1) {
        .                                   flags |= FACING_X_AXIS;
-- line 1445 ----------------------------------------
-- line 1450 ----------------------------------------
        .                       if (!(flags & FACING_Z_AXIS)) {
        .                           if (meshIndex != collision->meshIndexYX) {
        .                               if (check_collision_yx(collision, boundingBoxSize, posX, posY, posZ, meshIndex) == 1) {
        .                                   flags |= FACING_Z_AXIS;
        .                               }
        .                           }
        .                       }
        .                   }
    9,064 ( 0.00%)          sectionIndex++;
        .               }
        .               return flags;
   37,206 ( 0.00%)  }
        .           
        .           extern u8 D_8014F1110;
        .           
        .           /**
        .            * If unable to spawn actor on the surface set to -3000.0f or
        .            * if outside the collision grid, spawn in the air (3000.0f).
        .            */
      200 ( 0.00%)  f32 spawn_actor_on_surface(f32 posX, f32 posY, f32 posZ) {
        .               f32 height;
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               s16 gridSection;
        .           
        .               u16 index;
        .               u16 numTriangles;
        .               u16 sectionIndex;
       51 ( 0.00%)      f32 phi_f20 = -3000.0f;
        .               u16 i;
        .           
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               s32 sectionX;
        .               s32 sectionZ;
        .           
       60 ( 0.00%)      courseLengthX = (gCourseMaxX - gCourseMinX);
       60 ( 0.00%)      courseLengthZ = (gCourseMaxZ - gCourseMinZ);
       60 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
       60 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
      140 ( 0.00%)      sectionIndexX = (s16) ((posX - gCourseMinX) / sectionX);
      140 ( 0.00%)      sectionIndexZ = (s16) ((posZ - gCourseMinZ) / sectionZ);
       60 ( 0.00%)      gridSection = sectionIndexX + (sectionIndexZ * GRID_SIZE);
       60 ( 0.00%)      numTriangles = gCollisionGrid[gridSection].numTriangles;
        .           
        .               if (sectionIndexX < 0) {
        3 ( 0.00%)          return 3000.0f;
        .               }
        .               if (sectionIndexZ < 0) {
        .                   return 3000.0f;
        .               }
        .               if (sectionIndexX >= GRID_SIZE) {
        .                   return 3000.0f;
        .               }
       20 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 3000.0f;
        .               }
       80 ( 0.00%)      if (numTriangles == 0) {
        .                   return 3000.0f;
        .               }
        .           
       17 ( 0.00%)      sectionIndex = gCollisionGrid[gridSection].triangle;
        .           
      304 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
        .           
      450 ( 0.00%)          index = gCollisionIndices[sectionIndex];
        .           
    1,158 ( 0.00%)          if ((gCollisionMesh[index].flags & FACING_Y_AXIS) &&
      704 ( 0.00%)              (check_horizontally_colliding_with_triangle(posX, posZ, index) == 1)) {
    4,598 ( 0.00%)  => src/racing/collision.c:check_horizontally_colliding_with_triangle (88x)
      238 ( 0.00%)              height = calculate_surface_height(posX, posY, posZ, index);
      612 ( 0.00%)  => src/racing/collision.c:calculate_surface_height (34x)
      272 ( 0.00%)              if ((height <= posY) && (phi_f20 < height)) {
        .                           phi_f20 = height;
        .                       }
        .                   }
        .                   sectionIndex++;
        .               }
        .               return phi_f20;
      180 ( 0.00%)  }
        .           
        .           #define MAX3(a, b, c, out) \
        .               if (a >= b) {          \
        .                   if (a >= c) {      \
        .                       out = a;       \
        .                   } else             \
        .                       out = c;       \
        .                                      \
-- line 1536 ----------------------------------------
-- line 1546 ----------------------------------------
        .                   } else             \
        .                       out = c;       \
        .                                      \
        .               } else if (b <= c) {   \
        .                   out = b;           \
        .               } else                 \
        .                   out = c;
        .           
    3,822 ( 0.00%)  void add_collision_triangle(Vtx* vtx1, Vtx* vtx2, Vtx* vtx3, s8 surfaceType, u16 sectionId) {
    2,352 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[gCollisionMeshCount];
        .               s16 x2;
        .               s16 z2;
        .               u16 vtx1Flag;
        .               s16 x3;
        .               s16 x1;
        .               s16 y1;
        .               s16 z1;
        .               u16 vtx2Flag;
-- line 1563 ----------------------------------------
-- line 1588 ----------------------------------------
        .           
        .               s16 maxX;
        .               s16 maxZ;
        .               s16 minY;
        .               s16 minX;
        .               s16 maxY;
        .               s16 minZ;
        .           
      882 ( 0.00%)      triangle->vtx1 = vtx1;
        .               triangle->vtx2 = vtx2;
      294 ( 0.00%)      triangle->vtx3 = vtx3;
      882 ( 0.00%)      if ((triangle->vtx1->v.flag == 4) && (triangle->vtx2->v.flag == 4) && (triangle->vtx3->v.flag == 4)) {
        .           
        .                   return;
        .               }
        .           
      294 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
      294 ( 0.00%)      y1 = triangle->vtx1->v.ob[1];
      294 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
      294 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
      294 ( 0.00%)      y2 = triangle->vtx2->v.ob[1];
      294 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
      294 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
      294 ( 0.00%)      y3 = triangle->vtx3->v.ob[1];
      294 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
      684 ( 0.00%)      if ((x1 == x2) && (z1 == z2)) {
        .                   triangle->vtx1 = vtx1;
        .                   triangle->vtx3 = vtx2;
       36 ( 0.00%)          triangle->vtx2 = vtx3;
        .                   x1 = triangle->vtx1->v.ob[0];
        .                   y1 = triangle->vtx1->v.ob[1];
        .                   z1 = triangle->vtx1->v.ob[2];
        .                   x2 = triangle->vtx3->v.ob[0];
        .                   y2 = triangle->vtx3->v.ob[1];
        .                   z2 = triangle->vtx3->v.ob[2];
        .                   x3 = triangle->vtx2->v.ob[0];
        .                   y3 = triangle->vtx2->v.ob[1];
        .                   z3 = triangle->vtx2->v.ob[2];
        .               }
    1,740 ( 0.00%)      MAX3(x1, x2, x3, maxX)
        .           
    1,764 ( 0.00%)      MAX3(z1, z2, z3, maxZ)
        .           
    1,830 ( 0.00%)      MAX3(y1, y2, y3, maxY)
        .           
    1,548 ( 0.00%)      MIN3(x1, x2, x3, minX)
        .           
    1,798 ( 0.00%)      MIN3(y1, y2, y3, minY)
        .           
      960 ( 0.00%)      MIN3(z1, z2, z3, minZ)
        .           
    5,880 ( 0.00%)      crossProductX = (((y2 - y1) * (z3 - z2)) - ((z2 - z1) * (y3 - y2)));
    1,764 ( 0.00%)      crossProductY = (((z2 - z1) * (x3 - x2)) - ((x2 - x1) * (z3 - z2)));
    1,176 ( 0.00%)      crossProductZ = (((x2 - x1) * (y3 - y2)) - ((y2 - y1) * (x3 - x2)));
        .           
        .               // length of the cross product
        .               magnitude =
    2,646 ( 0.00%)          sqrtf((crossProductX * crossProductX) + (crossProductY * crossProductY) + (crossProductZ * crossProductZ));
        .           
      882 ( 0.00%)      if (!magnitude) {
        .                   return;
        .               }
        .           
      240 ( 0.00%)      normalX = (f32) crossProductX / magnitude;
      240 ( 0.00%)      normalY = (f32) crossProductY / magnitude;
      240 ( 0.00%)      normalZ = (f32) crossProductZ / magnitude;
        .           
        .               // Distance from x to plane (cross product's normal).
    2,400 ( 0.00%)      distance = -((normalX * x1) + (normalY * y1) + (normalZ * z1));
        .           
        .               // Return if normalY is not vertical.
        .               // Could be checking if the surface is a floor
    1,200 ( 0.00%)      if (D_8015F59C) {
        .                   if (normalY < -0.9f) {
        .                       return;
        .                   } else if (normalY > 0.9f) {
        .                       return;
        .                   }
        .               }
        .           
        .               // Return if normalY is not horizontal
        .               // Could be checking if the surface is a wall
    1,440 ( 0.00%)      if (D_8015F5A0) {
        .                   if ((normalY < 0.1f) && (normalY > -0.1f)) {
        .                       return;
        .                   }
        .               }
        .           
        .               triangle->maxX = maxX;
      480 ( 0.00%)      triangle->maxZ = maxZ;
    2,640 ( 0.00%)      triangle->minX = minX;
        .               triangle->minZ = minZ;
        .               triangle->minY = minY;
      480 ( 0.00%)      triangle->maxY = maxY;
        .           
        .               // Define the minimum and maximum dimensions of the course.
      720 ( 0.00%)      if (minX < gCourseMinX) {
        2 ( 0.00%)          gCourseMinX = minX;
        .               }
      960 ( 0.00%)      if (minY < gCourseMinY) {
        .                   gCourseMinY = minY;
        .               }
      720 ( 0.00%)      if (minZ < gCourseMinZ) {
        9 ( 0.00%)          gCourseMinZ = minZ;
        .               }
      960 ( 0.00%)      if (maxX > gCourseMaxX) {
        4 ( 0.00%)          gCourseMaxX = maxX;
        .               }
      960 ( 0.00%)      if (maxY > gCourseMaxY) {
        1 ( 0.00%)          gCourseMaxY = maxY;
        .               }
      960 ( 0.00%)      if (maxZ > gCourseMaxZ) {
        4 ( 0.00%)          gCourseMaxZ = maxZ;
        .               }
        .           
      240 ( 0.00%)      triangle->normalX = normalX;
        .               triangle->normalY = normalY;
        .               triangle->normalZ = normalZ;
        .               triangle->distance = distance;
        .           
      480 ( 0.00%)      triangle->surfaceType = (u16) surfaceType;
        .           
        .               // Square the crossProduct to produce a magnitude
        .               crossProductX = crossProductX * crossProductX;
        .               crossProductY = crossProductY * crossProductY;
        .               crossProductZ = crossProductZ * crossProductZ;
        .           
      480 ( 0.00%)      D_8015F6FA = 0;
      480 ( 0.00%)      D_8015F6FC = 0;
        .           
        .               vtx1Flag = triangle->vtx1->v.flag;
      480 ( 0.00%)      vtx2Flag = triangle->vtx2->v.flag;
      480 ( 0.00%)      vtx3Flag = triangle->vtx3->v.flag;
        .           
        .               flags = sectionId;
        .           
      480 ( 0.00%)      if ((vtx1Flag == 1) && (vtx2Flag == 1) && (vtx3Flag == 1)) {
        .                   flags |= 0x400;
      480 ( 0.00%)      } else if ((vtx1Flag == 2) && (vtx2Flag == 2) && (vtx3Flag == 2)) {
        .                   flags |= 0x800;
    1,440 ( 0.00%)      } else if ((vtx1Flag == 3) && (vtx2Flag == 3) && (vtx3Flag == 3)) {
        .                   flags |= 0x1000;
      960 ( 0.00%)      } else if (D_8015F5A4 != 0) {
        .                   flags |= 0x200;
        .               }
        .           
        .               triangle->flags = flags;
        .           
        .               // Find the axis with the highest magnitude.
        .           
        .               // Y is the significant axis
      940 ( 0.00%)      if ((crossProductX <= crossProductY) && (crossProductY >= crossProductZ)) {
      700 ( 0.00%)          triangle->flags |= FACING_Y_AXIS;
        .                   // X is the significant axis
       40 ( 0.00%)      } else if ((crossProductX > crossProductY) && (crossProductX >= crossProductZ)) {
       20 ( 0.00%)          triangle->flags |= FACING_X_AXIS;
        .                   // Z is the significant axis
        .               } else {
        .                   triangle->flags |= FACING_Z_AXIS;
        .               }
      960 ( 0.00%)      gCollisionMeshCount++;
    2,352 ( 0.00%)  }
        .           
        .           /**
        .            * Triangle contains three indices that are used to get the actual vertices.
        .            */
       10 ( 0.00%)  void set_vtx_from_triangle(u32 triangle, s8 surfaceType, u16 sectionId) {
       10 ( 0.00%)      u32 vert1 = ((triangle & 0x00FF0000) >> 16) / 2;
       20 ( 0.00%)      u32 vert2 = ((triangle & 0x0000FF00) >> 8) / 2;
       20 ( 0.00%)      u32 vert3 = (triangle & 0x000000FF) / 2;
        .           
       10 ( 0.00%)      Vtx* vtx1 = vtxBuffer[vert1];
       10 ( 0.00%)      Vtx* vtx2 = vtxBuffer[vert2];
       20 ( 0.00%)      Vtx* vtx3 = vtxBuffer[vert3];
        .           
       60 ( 0.00%)      add_collision_triangle(vtx1, vtx2, vtx3, surfaceType, sectionId);
    2,206 ( 0.00%)  => src/racing/collision.c:add_collision_triangle (10x)
        .           }
        .           
    1,136 ( 0.00%)  void set_vtx_from_tri2(u32 triangle1, u32 triangle2, s8 surfaceType, u16 sectionId) {
        .               UNUSED s32 pad[2];
      142 ( 0.00%)      u32 vert1 = ((triangle1 & 0x00FF0000) >> 16) / 2;
      284 ( 0.00%)      u32 vert2 = ((triangle1 & 0x0000FF00) >> 8) / 2;
      284 ( 0.00%)      u32 vert3 = (triangle1 & 0x000000FF) / 2;
        .           
        .               // This is actually triangle 2; vert 1,2,3.
      284 ( 0.00%)      u32 vert4 = ((triangle2 & 0x00FF0000) >> 16) / 2;
      284 ( 0.00%)      u32 vert5 = ((triangle2 & 0x0000FF00) >> 8) / 2;
      142 ( 0.00%)      u32 vert6 = (triangle2 & 0x000000FF) / 2;
        .           
      142 ( 0.00%)      Vtx* vtx1 = vtxBuffer[vert1];
      142 ( 0.00%)      Vtx* vtx2 = vtxBuffer[vert2];
      142 ( 0.00%)      Vtx* vtx3 = vtxBuffer[vert3];
        .           
      426 ( 0.00%)      Vtx* vtx4 = vtxBuffer[vert4];
      284 ( 0.00%)      Vtx* vtx5 = vtxBuffer[vert5];
      284 ( 0.00%)      Vtx* vtx6 = vtxBuffer[vert6];
        .           
        .               // Triangle 1
    1,420 ( 0.00%)      add_collision_triangle(vtx1, vtx2, vtx3, surfaceType, sectionId);
   28,415 ( 0.00%)  => src/racing/collision.c:add_collision_triangle (142x)
        .               // Triangle 2
      852 ( 0.00%)      add_collision_triangle(vtx4, vtx5, vtx6, surfaceType, sectionId);
   28,637 ( 0.00%)  => src/racing/collision.c:add_collision_triangle (142x)
      710 ( 0.00%)  }
        .           
        .           void set_vtx_from_quadrangle(u32 line, s8 surfaceType, u16 sectionId) {
        .               UNUSED s32 pad[6];
        .               Vtx* vtx1;
        .               Vtx* vtx2;
        .               Vtx* vtx3;
        .               Vtx* vtx4;
        .           
-- line 1797 ----------------------------------------
-- line 1812 ----------------------------------------
        .           }
        .           
        .           /**
        .            * Generates a list of pointers to course vtx.
        .            */
        .           void set_vtx_buffer(uintptr_t addr, u32 numVertices, u32 bufferIndex) {
        .               u32 i;
        .               Vtx* vtx = (Vtx*) addr;
      920 ( 0.00%)      for (i = 0; i < numVertices; i++) {
        .                   // printf("VTX: 0x%llX",vtx);
       80 ( 0.00%)          if (vtx == 0) {
        .                       assert(false);
        .                   }
      856 ( 0.00%)          vtxBuffer[bufferIndex] = vtx;
      428 ( 0.00%)          vtx++;
      428 ( 0.00%)          bufferIndex++;
        .               }
        .           }
        .           /**
        .            * @return 1 intersecting triangle, 0 not intersecting.
        .            */
   62,200 ( 0.00%)  s32 is_line_intersecting_rectangle(s16 minX, s16 maxX, s16 minZ, s16 maxZ, s16 x1, s16 z1, s16 x2, s16 z2) {
        .               f32 xOffset;
        .               f32 projectedPoint;
        .               f32 zOffset;
        .           
   77,750 ( 0.00%)      xOffset = x2 - x1;
   62,200 ( 0.00%)      zOffset = z2 - z1;
        .               // Line is vertical
   62,200 ( 0.00%)      if (xOffset == 0.0f) {
        .                   if (x1 < minX) {
    9,656 ( 0.00%)              return 0;
        .                   }
   11,016 ( 0.00%)          if (maxX < x1) {
        .                       return 0;
        .                   }
    1,060 ( 0.00%)          if (zOffset > 0.0f) {
    1,536 ( 0.00%)              if ((z1 < minZ) && (maxZ < z2)) {
   13,176 ( 0.00%)                  return 1;
        .                       }
    1,918 ( 0.00%)          } else if ((z2 < minZ) && (maxZ < z1)) {
        .                       return 1;
        .                   }
        .               } else {
        .                   // Line is horizontal
   48,800 ( 0.00%)          if (zOffset == 0.0f) {
        .                       if (z1 < minZ) {
        .                           return 0;
        .                       }
   11,148 ( 0.00%)              if (maxZ < z1) {
        .                           return 0;
        .                       }
    1,088 ( 0.00%)              if (xOffset > 0.0f) {
    2,100 ( 0.00%)                  if ((x1 < minX) && (maxX < x2)) {
        .                               return 1;
        .                           }
    1,708 ( 0.00%)              } else if ((x2 < minX) && (maxX < x1)) {
        .                           return 1;
        .                       }
        .                   } else {
   59,570 ( 0.00%)              projectedPoint = ((xOffset / zOffset) * (minZ - z1)) + x1;
   55,384 ( 0.00%)              if ((minX <= projectedPoint) && (projectedPoint <= maxX)) {
        .                           return 1;
        .                       }
   36,920 ( 0.00%)              projectedPoint = ((xOffset / zOffset) * (maxZ - z1)) + x1;
   33,842 ( 0.00%)              if ((minX <= projectedPoint) && (projectedPoint <= maxX)) {
        .                           return 1;
        .                       }
   34,430 ( 0.00%)              projectedPoint = ((zOffset / xOffset) * (minX - x1)) + z1;
   30,246 ( 0.00%)              if ((minZ <= projectedPoint) && (projectedPoint <= maxZ)) {
        .                           return 1;
        .                       }
   25,600 ( 0.00%)              projectedPoint = ((zOffset / xOffset) * (maxX - x1)) + z1;
   26,350 ( 0.00%)              if ((minZ <= projectedPoint) && (projectedPoint <= maxZ)) {
        .                           return 1;
        .                       }
        .                   }
        .               }
        .               return 0;
   46,650 ( 0.00%)  }
        .           
   84,678 ( 0.00%)  s32 is_triangle_intersecting_bounding_box(s16 minX, s16 maxX, s16 minZ, s16 maxZ, u16 index) {
   46,188 ( 0.00%)      CollisionTriangle* triangle = &gCollisionMesh[index];
        .               s16 x1;
        .               s16 z1;
        .               s16 x2;
        .               s16 z2;
        .               s16 x3;
        .               s16 z3;
        .           
   15,396 ( 0.00%)      x1 = triangle->vtx1->v.ob[0];
    7,698 ( 0.00%)      z1 = triangle->vtx1->v.ob[2];
   15,396 ( 0.00%)      x2 = triangle->vtx2->v.ob[0];
    7,698 ( 0.00%)      z2 = triangle->vtx2->v.ob[2];
   13,268 ( 0.00%)      x3 = triangle->vtx3->v.ob[0];
    6,634 ( 0.00%)      z3 = triangle->vtx3->v.ob[2];
   30,020 ( 0.00%)      if ((x1 >= minX) && (maxX >= x1) && (z1 >= minZ) && (maxZ >= z1)) {
    3,436 ( 0.00%)          return 1;
        .               }
   30,072 ( 0.00%)      if ((x2 >= minX) && (maxX >= x2) && (z2 >= minZ) && (maxZ >= z2)) {
        .                   return 1;
        .               }
   31,160 ( 0.00%)      if ((x3 >= minX) && (maxX >= x3) && (z3 >= minZ) && (maxZ >= z3)) {
        .                   return 1;
        .               }
  137,984 ( 0.00%)      if (is_line_intersecting_rectangle(minX, maxX, minZ, maxZ, x1, z1, x2, z2) == 1) {
  296,616 ( 0.00%)  => src/racing/collision.c:is_line_intersecting_rectangle (6,272x)
        .                   return 1;
        .               }
   95,304 ( 0.00%)      if (is_line_intersecting_rectangle(minX, maxX, minZ, maxZ, x2, z2, x3, z3) == 1) {
  178,342 ( 0.00%)  => src/racing/collision.c:is_line_intersecting_rectangle (5,016x)
        .                   return 1;
        .               }
   68,192 ( 0.00%)      if (is_line_intersecting_rectangle(minX, maxX, minZ, maxZ, x3, z3, x1, z1) == 1) {
  241,590 ( 0.00%)  => src/racing/collision.c:is_line_intersecting_rectangle (4,262x)
        .                   return 1;
        .               }
        .               return 0;
   61,584 ( 0.00%)  }
        .           
        .           /**
        .            * Splits the collision mesh into 32x32 sections. This allows the game to check only
        .            * nearby geography for a collision rather than checking against the whole collision mesh.
        .            * (checking against the whole mesh for every actor would be expensive)
        .            */
        7 ( 0.00%)  void generate_collision_grid(void) {
        .               CollisionTriangle* triangle;
        .               s32 i, j, k;
        .               UNUSED s32 pad[5];
        .               s16 maxX;
        .               s16 maxZ;
        .               s16 minX;
        .               s16 minZ;
        .               s32 sectionZ;
        .               s32 sectionX;
        .               s32 courseLengthX;
        .               s32 courseLengthZ;
        .               s32 index;
        .           
        6 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
        6 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
        .               // Separate the course into 32 sections
        3 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
      106 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
        .               // Reset the collision grid
    1,536 ( 0.00%)      for (i = 0; i < 1024; i++) {
    1,024 ( 0.00%)          gCollisionGrid[i].numTriangles = 0;
        .               }
        .           
        2 ( 0.00%)      gNumCollisionTriangles = 0;
        .           
        .               // 32x32 grid
      196 ( 0.00%)      for (j = 0; j < GRID_SIZE; j++) {
    5,184 ( 0.00%)          for (k = 0; k < GRID_SIZE; k++) {
        .                       index = k + j * GRID_SIZE;
        .           
        .                       // Select a section of the course using min/max akin to drawing a bounding-box
    3,071 ( 0.00%)              minX = (gCourseMinX + (sectionX * k)) - 20;
    6,207 ( 0.00%)              minZ = (gCourseMinZ + (sectionZ * j)) - 20;
        .           
    2,048 ( 0.00%)              maxX = minX + sectionX + 40;
    2,048 ( 0.00%)              maxZ = minZ + sectionZ + 40;
        .           
1,009,211 ( 0.00%)              for (i = 0; i < gCollisionMeshCount; i++) {
  983,040 ( 0.00%)                  triangle = gCollisionMesh + i;
  491,520 ( 0.00%)                  if (triangle->maxZ < minZ) {
        .                               continue;
        .                           }
  272,768 ( 0.00%)                  if (triangle->minZ > maxZ) {
        .                               continue;
        .                           }
   74,752 ( 0.00%)                  if (triangle->maxX < minX) {
        .                               continue;
        .                           }
   47,276 ( 0.00%)                  if (triangle->minX > maxX) {
        .                               continue;
        .                           }
        .           
        .                           // Add the collision triangle to the list if it's inside the bounding-box
   71,824 ( 0.00%)                  if (is_triangle_intersecting_bounding_box(minX, maxX, minZ, maxZ, (u16) i) == 1) {
1,371,256 ( 0.00%)  => src/racing/collision.c:is_triangle_intersecting_bounding_box (7,698x)
        .                               // Point this grid section to the first triangle in the section
   18,024 ( 0.00%)                      if (gCollisionGrid[index].numTriangles == 0) {
    9,695 ( 0.00%)                          gCollisionGrid[index].triangle = gNumCollisionTriangles;
        .                               }
   13,518 ( 0.00%)                      gCollisionGrid[index].numTriangles++;
   13,518 ( 0.00%)                      gCollisionIndices[gNumCollisionTriangles] = (u16) i;
   13,518 ( 0.00%)                      gNumCollisionTriangles++;
        .                           }
        .                       }
        .                   }
        .               }
        8 ( 0.00%)  }
        .           
        .           /**
        .            * Recursive search for vtx and set surfaceTypes to -1 and sectionId's to 0xFF
        .            */
        .           void generate_collision_mesh_with_defaults(Gfx* gfx) {
        3 ( 0.00%)      generate_collision_mesh(gfx, SURFACE_DEFAULT, 0xFF);
   37,487 ( 0.00%)  => src/racing/collision.c:generate_collision_mesh (1x)
        .           }
        .           
        .           /**
        .            * Recursive search for vtx and set sectionId's to 0xFF
        .            */
        .           void generate_collision_mesh_with_default_section_id(Gfx* gfx, s8 surfaceType) {
        .               generate_collision_mesh(gfx, surfaceType, 0xFF);
        .           }
        .           
        .           extern u32 D_8015F58C;
        .           u32 numTimes = 0;
        .           
        .           /**
        .            * Generate via a recursive search and set for vertex data.
        .            */
      140 ( 0.00%)  void generate_collision_mesh(Gfx* addr, s8 surfaceType, u16 sectionId) {
        .               s32 opcode;
        .               uintptr_t lo;
        .               uintptr_t hi;
        .               s32 i;
       28 ( 0.00%)      numTimes++;
        .               // printf("Initial\n");
        .               // printf("ptr 0x%llX\n", &addr);
        .               // printf("w0 0x%llX\n", addr->words.w0);
        .               // printf("w1 0x%llX\n", addr->words.w1);
        .               // printf("----loop----\n");
        .               Gfx* gfx = (Gfx*) addr;
       28 ( 0.00%)      D_8015F6FA = 0;
       28 ( 0.00%)      D_8015F6FC = 0;
        .           
        .               // u8 *orig = segmented_gfx_to_virtual(0x07000000);
        .           
        .               // printf("\n\nORIG:\n");
        .               // for (size_t i = 0; i < 100; i++) {
        .               //     printf(" 0x%X ", orig[i]);
        .               // }
        .           
      534 ( 0.00%)      for (i = 0; i < 0x1FFF; i++) {
      274 ( 0.00%)          lo = gfx->words.w0;
      274 ( 0.00%)          hi = gfx->words.w1;
      548 ( 0.00%)          opcode = GFX_GET_OPCODE(lo);
        .           
        .                   //  printf("ptr 0x%llX\n", &addr);
        .                   //  printf("op 0x%llX\n", opcode);
        .                   //   printf("w0 0x%llX\n", lo);
        .                   //   printf("w1 0x%llX\n", hi);
        .           
      548 ( 0.00%)          if (opcode == (G_DL << 24)) {
        .                       // G_DL's hi contains an addr to another DL.
       48 ( 0.00%)              generate_collision_mesh((Gfx*) hi, surfaceType, sectionId);
   74,262 ( 0.00%)  => src/racing/collision.c:generate_collision_mesh'2 (12x)
        .           
      524 ( 0.00%)          } else if (opcode == (G_VTX << 24)) {
      144 ( 0.00%)              set_vtx_buffer((hi), (lo >> 10) & 0x3F, ((lo >> 16) & 0xFF) >> 1);
      114 ( 0.00%)  => src/racing/collision.c:set_vtx_buffer (2x)
        .           
      492 ( 0.00%)          } else if (opcode == (G_TRI1 << 24)) {
       20 ( 0.00%)              D_8015F58C += 1;
       50 ( 0.00%)              set_vtx_from_triangle(hi, surfaceType, sectionId);
    2,366 ( 0.00%)  => src/racing/collision.c:set_vtx_from_triangle (10x)
        .           
      472 ( 0.00%)          } else if (opcode == (G_TRI2 << 24)) {
      284 ( 0.00%)              D_8015F58C += 2;
        .           
      710 ( 0.00%)              set_vtx_from_tri2(lo, hi, surfaceType, sectionId);
   64,010 ( 0.00%)  => src/racing/collision.c:set_vtx_from_tri2 (142x)
        .           
      188 ( 0.00%)          } else if (opcode == (G_QUAD << 24)) {
        .                       D_8015F58C += 2;
        .                       set_vtx_from_quadrangle(hi, surfaceType, sectionId);
        .           
      188 ( 0.00%)          } else if (opcode == (int32_t) (G_ENDDL << 24)) {
        .                       break;
        .                   }
        .           
      260 ( 0.00%)          gfx++;
        .               }
       84 ( 0.00%)  }
        .           
        .           /**
        .            * Search for G_SETTILESIZE and set its args.
        .            */
        .           void find_and_set_tile_size(uintptr_t addr, s32 uls, s32 ult) {
        .               Gfx* gfx = (Gfx*) addr;
        .               u32 opcode;
        .           
-- line 2090 ----------------------------------------
-- line 2142 ----------------------------------------
        .                       // G_VTX contains an addr hi
        .                       set_vertex_colours(hi, (lo >> 10) & 0x3F, ((lo >> 16) & 0xFF) >> 1, alpha, red, green, blue);
        .                   }
        .                   gfx++;
        .               }
        .           }
        .           
        .           void subtract_scaled_vector(Vec3f pos1, f32 boundingBoxSize, Vec3f pos2) {
    7,056 ( 0.00%)      pos2[0] -= pos1[0] * boundingBoxSize;
    7,056 ( 0.00%)      pos2[1] -= pos1[1] * boundingBoxSize;
    7,056 ( 0.00%)      pos2[2] -= pos1[2] * boundingBoxSize;
    2,352 ( 0.00%)  }
        .           
   28,224 ( 0.00%)  u16 player_terrain_collision(Player* player, KartTyre* tyre, f32 tyre2X, f32 tyre2Y, f32 tyre2Z) {
        .               Collision wtf;
        .               Collision* collision = &wtf;
        .               UNUSED s32 pad;
        .               u16 i;
        .               u16 meshIndex;
        .               u16 numTriangles;
        .               u16 sectionIndex;
        .               f32 tyreX;
-- line 2163 ----------------------------------------
-- line 2172 ----------------------------------------
        .               s16 sectionIndexX;
        .               s16 sectionIndexZ;
        .               s16 gridIndex;
        .           
        .               s32 sectionX;
        .               s32 sectionZ;
        .               UNUSED s32 pad2[9];
        .           
    4,704 ( 0.00%)      collision->surfaceDistance[0] = 1000.0f;
        .               collision->surfaceDistance[1] = 1000.0f;
        .               collision->surfaceDistance[2] = 1000.0f;
    4,704 ( 0.00%)      boundingBoxSize = player->boundingBoxSize;
        .               collision->meshIndexYX = 5000;
    4,704 ( 0.00%)      collision->meshIndexZY = 5000;
        .               collision->meshIndexZX = 5000;
    4,704 ( 0.00%)      collision->unk30 = 0;
        .               collision->unk32 = 0;
        .               collision->unk34 = 0;
    2,352 ( 0.00%)      tyreX = tyre->pos[0];
    4,704 ( 0.00%)      tyreY = tyre->pos[1];
    2,352 ( 0.00%)      tyreZ = tyre->pos[2];
    7,072 ( 0.00%)      switch (tyre->surfaceFlags) {
        .                   case 0x80:
        .                       if (is_colliding_with_wall1(collision, boundingBoxSize, tyreX, tyreY, tyreZ, tyre->collisionMeshIndex,
        .                                                   tyre2X, tyre2Y, tyre2Z) == 1) {
        .                           height = calculate_surface_height(tyreX, tyreY, tyreZ, tyre->collisionMeshIndex);
        .                           if ((!(height > player->pos[1])) && !((player->pos[1] - height) > (2 * boundingBoxSize))) {
        .                               tyre->baseHeight = height;
        .                               subtract_scaled_vector(collision->unk54, collision->surfaceDistance[1], tyre->pos);
    4,704 ( 0.00%)                      return 1;
        .                           }
        .                       }
        .                       break;
        .                   case 0x40:
   44,612 ( 0.00%)              if (is_colliding_with_drivable_surface(collision, boundingBoxSize, tyreX, tyreY, tyreZ,
  241,512 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (2,348x)
        .                                                              tyre->collisionMeshIndex, tyre2X, tyre2Y, tyre2Z) == 1) {
   21,096 ( 0.00%)                  height = calculate_surface_height(tyreX, tyreY, tyreZ, tyre->collisionMeshIndex);
   42,192 ( 0.00%)  => src/racing/collision.c:calculate_surface_height (2,344x)
   32,816 ( 0.00%)                  if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
    2,344 ( 0.00%)                      tyre->baseHeight = height;
    9,376 ( 0.00%)                      subtract_scaled_vector(collision->orientationVector, collision->surfaceDistance[2], tyre->pos);
   23,440 ( 0.00%)  => src/racing/collision.c:subtract_scaled_vector (2,344x)
    2,344 ( 0.00%)                      return 1;
        .                           }
        .                       }
        .                       break;
        .                   case 0x20:
        .                       if (is_colliding_with_wall2(collision, boundingBoxSize, tyreX, tyreY, tyreZ, tyre->collisionMeshIndex,
        .                                                   tyre2X, tyre2Y, tyre2Z) == 1) {
        .                           height = calculate_surface_height(tyreX, tyreY, tyreZ, tyre->collisionMeshIndex);
        .                           if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
-- line 2220 ----------------------------------------
-- line 2225 ----------------------------------------
        .                       }
        .                       break;
        .                   case 0:
        .                       break;
        .               }
        .           
        .               // If the surface flags are not set then try setting them.
        .           
       32 ( 0.00%)      courseLengthX = (s32) gCourseMaxX - gCourseMinX;
       24 ( 0.00%)      courseLengthZ = (s32) gCourseMaxZ - gCourseMinZ;
        .           
       24 ( 0.00%)      sectionX = courseLengthX / GRID_SIZE;
       24 ( 0.00%)      sectionZ = courseLengthZ / GRID_SIZE;
        .           
       56 ( 0.00%)      sectionIndexX = (tyreX - gCourseMinX) / sectionX;
       56 ( 0.00%)      sectionIndexZ = (tyreZ - gCourseMinZ) / sectionZ;
        .           
        .               if (sectionIndexX < 0) {
        .                   return 0;
        .               }
        .               if (sectionIndexZ < 0) {
        .                   return 0;
        .               }
        .               if (sectionIndexX >= GRID_SIZE) {
        .                   return 0;
        .               }
       32 ( 0.00%)      if (sectionIndexZ >= GRID_SIZE) {
        .                   return 0;
        .               }
        .           
       24 ( 0.00%)      gridIndex = sectionIndexX + sectionIndexZ * GRID_SIZE;
       24 ( 0.00%)      numTriangles = gCollisionGrid[gridIndex].numTriangles;
        .           
       16 ( 0.00%)      if (numTriangles == 0) {
        .                   return 0;
        .               }
        .           
        8 ( 0.00%)      sectionIndex = gCollisionGrid[gridIndex].triangle;
        .           
        8 ( 0.00%)      for (i = 0; i < numTriangles; i++) {
       32 ( 0.00%)          meshIndex = gCollisionIndices[sectionIndex];
       64 ( 0.00%)          if (gCollisionMesh[meshIndex].flags & FACING_Y_AXIS) {
       16 ( 0.00%)              if (meshIndex != tyre->collisionMeshIndex) {
      136 ( 0.00%)                  if (is_colliding_with_drivable_surface(collision, boundingBoxSize, tyreX, tyreY, tyreZ, meshIndex,
      824 ( 0.00%)  => src/racing/collision.c:is_colliding_with_drivable_surface (8x)
        .                                                                  tyre2X, tyre2Y, tyre2Z) == 1) {
       48 ( 0.00%)                      height = calculate_surface_height(tyreX, tyreY, tyreZ, meshIndex);
      144 ( 0.00%)  => src/racing/collision.c:calculate_surface_height (8x)
        .           
      104 ( 0.00%)                      if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
       56 ( 0.00%)                          subtract_scaled_vector(collision->orientationVector, collision->surfaceDistance[2], tyre->pos);
       80 ( 0.00%)  => src/racing/collision.c:subtract_scaled_vector (8x)
       16 ( 0.00%)                          tyre->baseHeight = height;
       24 ( 0.00%)                          tyre->surfaceType = (u8) gCollisionMesh[meshIndex].surfaceType;
        8 ( 0.00%)                          tyre->surfaceFlags = 0x40;
        8 ( 0.00%)                          tyre->collisionMeshIndex = meshIndex;
        8 ( 0.00%)                          if (gCollisionMesh[meshIndex].flags & 0x1000) {
       40 ( 0.00%)                              tyre->unk_14 = 1;
        .                                   } else {
        .                                       tyre->unk_14 = 0;
        .                                   }
        .                                   return 1;
        .                               }
        .                           }
        .                       }
        .                   } else if (gCollisionMesh[meshIndex].flags & FACING_X_AXIS) {
-- line 2287 ----------------------------------------
-- line 2298 ----------------------------------------
        .                                       tyre->surfaceFlags = 0x80;
        .                                       tyre->collisionMeshIndex = meshIndex;
        .                                       return 1;
        .                                   }
        .                               }
        .                           }
        .                       }
        .                   } else {
       56 ( 0.00%)              if (gCollisionMesh[meshIndex].normalY != 0.0f) {
        .                           if (meshIndex != tyre->collisionMeshIndex) {
        .                               if (is_colliding_with_wall2(collision, boundingBoxSize, tyreX, tyreY, tyreZ, meshIndex, tyre2X,
        .                                                           tyre2Y, tyre2Z) == 1) {
        .                                   height = calculate_surface_height(tyreX, tyreY, tyreZ, meshIndex);
        .                                   if (!(player->pos[1] < height) && !((2 * boundingBoxSize) < (player->pos[1] - height))) {
        .                                       tyre->baseHeight = height;
        .                                       subtract_scaled_vector(collision->unk48, collision->surfaceDistance[0], tyre->pos);
        .                                       tyre->surfaceType = (u8) gCollisionMesh[meshIndex].surfaceType;
-- line 2314 ----------------------------------------
-- line 2320 ----------------------------------------
        .                           }
        .                       }
        .                   }
        .                   sectionIndex++;
        .               }
        .               tyre->baseHeight = tyreY;
        .               tyre->surfaceType = 0;
        .               return 0;
   18,816 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/stormlib-src/src/SFileListFile.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 65 ----------------------------------------
        .               bResult = FileStream_Read(pHandle->pStream, &ByteOffset, pvBuffer, cbBuffer);
        .               if(bResult)
        .                   *pdwBytesRead = cbBuffer;
        .               return bResult;
        .           }
        .           
        .           static bool LoadListFile_MPQ(TListFileHandle * pHandle, void * pvBuffer, DWORD cbBuffer, LPDWORD pdwBytesRead)
        .           {
       21 ( 0.00%)      return SFileReadFile(pHandle->hFile, pvBuffer, cbBuffer, pdwBytesRead, NULL);
5,132,517 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileReadFile.cpp:SFileReadFile (3x)
        .           }
        .           
        .           static bool FreeListFileCache(TListFileCache * pCache)
        .           {
        .               // Valid parameter check
        .               if(pCache != NULL)
        9 ( 0.00%)          STORM_FREE(pCache);
      333 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (3x)
        .               return true;
        .           }
        .           
        .           static TListFileCache * CreateListFileCache(
        .               LOAD_LISTFILE PfnLoadFile,
        .               TListFileHandle * pHandle,
        .               const char * szWildCard,
        .               DWORD dwFileSize,
        .               DWORD dwMaxSize,
        .               DWORD dwFlags)
        .           {
        .               TListFileCache * pCache = NULL;
        .               size_t cchWildCardAligned = 0;
        .               size_t cchWildCard = 0;
        3 ( 0.00%)      DWORD dwBytesRead = 0;
        .           
        .               // Get the amount of bytes that need to be allocated
        9 ( 0.00%)      if(dwFileSize == 0 || dwFileSize > dwMaxSize)
        .                   return NULL;
        .           
        .               // Append buffer for name mask, if any
        .               if(szWildCard != NULL)
        .               {
        .                   cchWildCard = strlen(szWildCard) + 1;
        .                   cchWildCardAligned = (cchWildCard + 3) & 0xFFFFFFFC;
        .               }
        .           
        .               // Allocate cache for one file block
       15 ( 0.00%)      pCache = (TListFileCache *)STORM_ALLOC(BYTE, sizeof(TListFileCache) + cchWildCardAligned + dwFileSize + 1);
      576 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (3x)
        6 ( 0.00%)      if(pCache != NULL)
        .               {
        .                   // Clear the entire structure
        9 ( 0.00%)          memset(pCache, 0, sizeof(TListFileCache) + cchWildCard);
        3 ( 0.00%)          pCache->dwFlags = dwFlags;
        .           
        .                   // Shall we copy the mask?
        .                   if(cchWildCard != 0)
        .                   {
        .                       pCache->szWildCard = (char *)(pCache + 1);
        .                       memcpy(pCache->szWildCard, szWildCard, cchWildCard);
        .                   }
        .           
        .                   // Fill-in the rest of the cache pointers
        6 ( 0.00%)          pCache->pBegin = (LPBYTE)(pCache + 1) + cchWildCardAligned;
        .           
        .                   // Load the entire listfile to the cache
        .                   PfnLoadFile(pHandle, pCache->pBegin, dwFileSize, &dwBytesRead);
        9 ( 0.00%)          if(dwBytesRead != 0)
        .                   {
        .                       // Allocate pointers
       12 ( 0.00%)              pCache->pPos = pCache->pBegin;
        3 ( 0.00%)              pCache->pEnd = pCache->pBegin + dwBytesRead;
        .                   }
        .                   else
        .                   {
        .                       FreeListFileCache(pCache);
        .                       pCache = NULL;
        .                   }
        .               }
        .           
-- line 140 ----------------------------------------
-- line 145 ----------------------------------------
        .           static TListFileCache * CreateListFileCache(
        .               HANDLE hMpq,
        .               const TCHAR * szListFile,
        .               const char * szWildCard,
        .               DWORD dwMaxSize,
        .               DWORD dwFlags)
        .           {
        .               TListFileCache * pCache = NULL;
        3 ( 0.00%)      TListFileHandle ListHandle = {NULL};
        .           
        .               // Put default value to dwMaxSize
        .               if(dwMaxSize == 0)
        .                   dwMaxSize = MAX_LISTFILE_SIZE;
        .           
        .               // Internal listfile: hMPQ must be non NULL and szListFile must be NULL.
        .               // We load the MPQ::(listfile) file
       15 ( 0.00%)      if(hMpq != NULL && szListFile == NULL)
        .               {
        .                   DWORD dwFileSize = 0;
        .           
        .                   // Open the file from the MPQ
       21 ( 0.00%)          if(SFileOpenFileEx(hMpq, LISTFILE_NAME, 0, &ListHandle.hFile))
    4,635 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenFileEx.cpp:SFileOpenFileEx (3x)
        .                   {
        .                       // Get the file size and create the listfile cache
       12 ( 0.00%)              dwFileSize = SFileGetFileSize(ListHandle.hFile, NULL);
      129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileReadFile.cpp:SFileGetFileSize (3x)
        .                       pCache = CreateListFileCache(LoadListFile_MPQ, &ListHandle, szWildCard, dwFileSize, dwMaxSize, dwFlags);
        .           
        .                       // Close the MPQ file
        9 ( 0.00%)              SFileCloseFile(ListHandle.hFile);
    1,121 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenFileEx.cpp:SFileCloseFile (3x)
        .                   }
        .           
        .                   // Return the loaded cache
        .                   return pCache;
        .               }
        .           
        .               // External listfile: hMpq must be NULL and szListFile must be non-NULL.
        .               // We load the file using TFileStream
-- line 181 ----------------------------------------
-- line 273 ----------------------------------------
        .           #endif  // _DEBUG
        .           
        .           static char * ReadListFileLine(TListFileCache * pCache, size_t * PtrLength)
        .           {
        .               LPBYTE pbLineBegin;
        .               LPBYTE pbLineEnd;
        .           
        .               // Skip newlines. Keep spaces and tabs, as they can be a legal part of the file name
  248,280 ( 0.00%)      while(pCache->pPos < pCache->pEnd && (pCache->pPos[0] == 0x0A || pCache->pPos[0] == 0x0D))
   33,102 ( 0.00%)          pCache->pPos++;
        .           
        .               // Set the line begin and end
   33,102 ( 0.00%)      if(pCache->pPos >= pCache->pEnd)
        .                   return NULL;
        .               pbLineBegin = pbLineEnd = pCache->pPos;
        .           
        .               // Find the end of the line
4,520,776 ( 0.01%)      while(pCache->pPos < pCache->pEnd && pCache->pPos[0] != 0x0A && pCache->pPos[0] != 0x0D)
1,113,643 ( 0.00%)          pCache->pPos++;
        .           
        .               // Remember the end of the line
   33,102 ( 0.00%)      pbLineEnd = pCache->pPos++;
   16,551 ( 0.00%)      pbLineEnd[0] = 0;
        .           
        .               // Give the line to the caller
        .               if(PtrLength != NULL)
        .                   PtrLength[0] = (size_t)(pbLineEnd - pbLineBegin);
        .               return (char *)pbLineBegin;
        .           }
        .           
        .           static int STORMLIB_CDECL CompareFileNodes(const void * p1, const void * p2)
-- line 303 ----------------------------------------
-- line 401 ----------------------------------------
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // Local functions (listfile nodes)
        .           
        .           // Adds a name into the list of all names. For each locale in the MPQ,
        .           // one entry will be created
        .           // If the file name is already there, does nothing.
  115,920 ( 0.00%)  static DWORD SListFileCreateNodeForAllLocales(TMPQArchive * ha, const char * szFileName)
        .           {
        .               TFileEntry * pFileEntry;
        .               TMPQHash * pFirstHash;
        .               TMPQHash * pHashEnd;
        .               TMPQHash * pHash;
        .               DWORD dwName1;
        .               DWORD dwName2;
        .           
        .               // If we have HET table, use that one
   33,120 ( 0.00%)      if(ha->pHetTable != NULL)
        .               {
        .                   pFileEntry = GetFileEntryLocale(ha, szFileName, 0);
        .                   if(pFileEntry != NULL)
        .                   {
        .                       // Allocate file name for the file entry
        .                       AllocateFileName(ha, pFileEntry, szFileName);
        .                   }
        .           
        .                   return ERROR_SUCCESS;
        .               }
        .           
        .               // If we have hash table, we use it
   33,120 ( 0.00%)      if(ha->pHashTable != NULL)
        .               {
        .                   // Get the end of the hash table and both names
        .                   pHashEnd = ha->pHashTable + ha->pHeader->dwHashTableSize;
   49,680 ( 0.00%)          dwName1 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_A);
6,765,900 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (16,560x)
   49,680 ( 0.00%)          dwName2 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_B);
6,765,900 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (16,560x)
        .           
        .                   // Some protectors set very high hash table size (0x00400000 items or more)
        .                   // in order to make this process very slow. We will ignore items
        .                   // in the hash table that would be beyond the end of the file.
        .                   // Example MPQ: MPQ_2022_v1_Sniper.scx
        .                   if(ha->dwFlags & MPQ_FLAG_HASH_TABLE_CUT)
        .                       pHashEnd = ha->pHashTable + (ha->dwRealHashTableSize / sizeof(TMPQHash));
        .           
-- line 445 ----------------------------------------
-- line 449 ----------------------------------------
        .                   //     if(pHash->dwName1 == dwName1 && pHash->dwName2 == dwName2 && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
        .                   //     {
        .                   //         // Allocate file name for the file entry
        .                   //         AllocateFileName(ha, ha->pFileTable + MPQ_BLOCK_INDEX(pHash), szFileName);
        .                   //     }
        .                   // }
        .           
        .                   // Go while we found something
   99,354 ( 0.00%)          pFirstHash = pHash = GetFirstHashEntry(ha, szFileName);
21,163,863 ( 0.04%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetFirstHashEntry(_TMPQArchive*, char const*) (16,560x)
   66,234 ( 0.00%)          while(pHash != NULL)
        .                   {
        .                      // Allocate file name for the file entry
  115,899 ( 0.00%)             AllocateFileName(ha, ha->pFileTable + MPQ_BLOCK_INDEX(pHash), szFileName);
4,949,361 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseFileTable.cpp:AllocateFileName(_TMPQArchive*, _TFileEntry*, char const*) (16,557x)
        .           
        .                      // Now find the next language version of the file
   82,785 ( 0.00%)             pHash = GetNextHashEntry(ha, pFirstHash, pHash);
  861,939 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetNextHashEntry(_TMPQArchive*, _TMPQHash*, _TMPQHash*) (16,557x)
        .                   }
        .           
        .                   return ERROR_SUCCESS;
        .               }
        .           
        .               return ERROR_CAN_NOT_COMPLETE;
   99,360 ( 0.00%)  }
        .           
        .           // Saves the whole listfile to the MPQ
        .           DWORD SListFileSaveToMpq(TMPQArchive * ha)
        .           {
        .               TMPQFile * hf = NULL;
        .               LPBYTE pbListFile;
        .               DWORD cbListFile = 0;
        .               DWORD dwErrCode = ERROR_SUCCESS;
-- line 479 ----------------------------------------
-- line 529 ----------------------------------------
        .               return dwErrCode;
        .           }
        .           
        .           static DWORD SFileAddArbitraryListFile(
        .               TMPQArchive * ha,
        .               HANDLE hMpq,
        .               const TCHAR * szListFile,
        .               DWORD dwMaxSize)
       33 ( 0.00%)  {
        .               TListFileCache * pCache = NULL;
        .           
        .               // Create the listfile cache for that file
        3 ( 0.00%)      pCache = CreateListFileCache(hMpq, szListFile, NULL, dwMaxSize, ha->dwFlags);
        3 ( 0.00%)      if(pCache != NULL)
        .               {
        .                   char * szFileName;
        .                   size_t nLength = 0;
        .           
        .                   // Get the next line
        .                   while((szFileName = ReadListFileLine(pCache, &nLength)) != NULL)
        .                   {
        .                       // Add the line to the MPQ
   33,102 ( 0.00%)              if(nLength != 0)
   49,653 ( 0.00%)                  SListFileCreateNodeForAllLocales(ha, szFileName);
41,243,479 ( 0.07%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) [clone .isra.0] (16,551x)
        .                   }
        .           
        .                   // Delete the cache
        .                   FreeListFileCache(pCache);
        .               }
        .           
        3 ( 0.00%)      return (pCache != NULL) ? ERROR_SUCCESS : ERROR_FILE_CORRUPT;
       24 ( 0.00%)  }
        .           
        .           static DWORD SFileAddArbitraryListFile(
        .               TMPQArchive * ha,
        .               const char ** listFileEntries,
        .               DWORD dwEntryCount)
        .           {
        .               if(listFileEntries != NULL && dwEntryCount > 0)
        .               {
-- line 568 ----------------------------------------
-- line 578 ----------------------------------------
        .               }
        .           
        .               return (listFileEntries != NULL && dwEntryCount > 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
        .           }
        .           
        .           static DWORD SFileAddInternalListFile(
        .               TMPQArchive * ha,
        .               HANDLE hMpq)
       27 ( 0.00%)  {
        .               TMPQHash * pFirstHash;
        .               TMPQHash * pHash;
        6 ( 0.00%)      LCID lcSaveLocale = g_lcFileLocale;
       12 ( 0.00%)      DWORD dwMaxSize = MAX_LISTFILE_SIZE;
        .               DWORD dwErrCode = ERROR_SUCCESS;
        .           
        .               // If there is hash table, we need to support multiple listfiles
        .               // with different locales (BrooDat.mpq)
        6 ( 0.00%)      if(ha->pHashTable != NULL)
        .               {
        .                   // If the archive is a malformed map, ignore too large listfiles
        6 ( 0.00%)          if(STORMLIB_TEST_FLAGS(ha->dwFlags, MPQ_FLAG_MALFORMED | MPQ_FLAG_PATCH, MPQ_FLAG_MALFORMED))
        .                       dwMaxSize = 0x40000;
        .           
       15 ( 0.00%)          pFirstHash = pHash = GetFirstHashEntry(ha, LISTFILE_NAME);
    1,329 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetFirstHashEntry(_TMPQArchive*, char const*) (3x)
       18 ( 0.00%)          while(dwErrCode == ERROR_SUCCESS && pHash != NULL)
        .                   {
        .                       // Set the prefered locale to that from list file
       15 ( 0.00%)              SFileSetLocale(SFILE_MAKE_LCID(pHash->Locale, pHash->Platform));
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenArchive.cpp:SFileSetLocale (3x)
        .           
        .                       // Add that listfile
       18 ( 0.00%)              dwErrCode = SFileAddArbitraryListFile(ha, hMpq, NULL, dwMaxSize);
52,464,332 ( 0.09%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SFileAddArbitraryListFile(_TMPQArchive*, void*, char const*, unsigned int) (3x)
        .           
        .                       // Move to the next hash
       15 ( 0.00%)              pHash = GetNextHashEntry(ha, pFirstHash, pHash);
      129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseCommon.cpp:GetNextHashEntry(_TMPQArchive*, _TMPQHash*, _TMPQHash*) (3x)
        .                   }
        .           
        .                   // Restore the original locale
        6 ( 0.00%)          SFileSetLocale(lcSaveLocale);
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SFileOpenArchive.cpp:SFileSetLocale (3x)
        .               }
        .               else
        .               {
        .                   // Add the single listfile
        .                   dwErrCode = SFileAddArbitraryListFile(ha, hMpq, NULL, dwMaxSize);
        .               }
        .           
        .               // Return the result of the operation
        .               return dwErrCode;
       27 ( 0.00%)  }
        .           
        .           static bool DoListFileSearch(TListFileCache * pCache, SFILE_FIND_DATA * lpFindFileData)
        .           {
        .               // Check for the valid search handle
        .               if(pCache != NULL)
        .               {
        .                   char * szFileName;
        .                   size_t nLength = 0;
-- line 633 ----------------------------------------
-- line 654 ----------------------------------------
        .               return false;
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // File functions
        .           
        .           // Adds a listfile into the MPQ archive.
        .           DWORD WINAPI SFileAddListFile(HANDLE hMpq, const TCHAR * szListFile)
        9 ( 0.00%)  {
        6 ( 0.00%)      TMPQArchive * ha = (TMPQArchive *)hMpq;
        .               DWORD dwErrCode = ERROR_SUCCESS;
        .           
        .               // Add the listfile for each MPQ in the patch chain
       24 ( 0.00%)      while(ha != NULL)
        .               {
        .                   if(szListFile != NULL)
        .                       dwErrCode = SFileAddArbitraryListFile(ha, NULL, szListFile, MAX_LISTFILE_SIZE);
        .                   else
       12 ( 0.00%)              dwErrCode = SFileAddInternalListFile(ha, hMpq);
52,465,979 ( 0.09%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SFileAddInternalListFile(_TMPQArchive*, void*) (3x)
        .           
        .                   // Also, add three special files to the listfile:
        .                   // (listfile) itself, (attributes) and (signature)
        9 ( 0.00%)          SListFileCreateNodeForAllLocales(ha, LISTFILE_NAME);
    2,667 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) [clone .isra.0] (3x)
        9 ( 0.00%)          SListFileCreateNodeForAllLocales(ha, SIGNATURE_NAME);
    2,361 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) [clone .isra.0] (3x)
        9 ( 0.00%)          SListFileCreateNodeForAllLocales(ha, ATTRIBUTES_NAME);
    3,608 ( 0.00%)  => build/_deps/stormlib-src/src/SFileListFile.cpp:SListFileCreateNodeForAllLocales(_TMPQArchive*, char const*) [clone .isra.0] (3x)
        .           
        .                   // Move to the next archive in the chain
        3 ( 0.00%)          ha = ha->haPatch;
        .               }
        .           
        .               return dwErrCode;
       15 ( 0.00%)  }
        .           
        .           DWORD WINAPI SFileAddListFileEntries(HANDLE hMpq, const char ** listFileEntries, DWORD dwEntryCount)
        .           {
        .               TMPQArchive * ha = (TMPQArchive *)hMpq;
        .               DWORD dwErrCode = ERROR_SUCCESS;
        .           
        .               // Add the listfile for each MPQ in the patch chain
        .               while(ha != NULL)
-- line 693 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/code_80057C60.c
--------------------------------------------------------------------------------
Ir               

-- line 405 ----------------------------------------
      .           s32 D_800E480C[] = {
      .               MAKE_RGB(0xB0, 0xB0, 0xB0), MAKE_RGB(0x80, 0x40, 0x11), MAKE_RGB(0xB0, 0x80, 0x50), MAKE_RGB(0xA0, 0x70, 0x40),
      .               MAKE_RGB(0x60, 0x30, 0x11), MAKE_RGB(0x80, 0x40, 0x10), MAKE_RGB(0x70, 0x90, 0xA0), MAKE_RGB(0xA0, 0x60, 0x30),
      .               MAKE_RGB(0xA0, 0x70, 0x10), MAKE_RGB(0x30, 0x10, 0x11), MAKE_RGB(0xB0, 0xA0, 0x80), MAKE_RGB(0x80, 0x60, 0x10),
      .           };
      .           
      .           // UI Code?
      .           void func_80057C60(void) {
  2,380 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
  1,428 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
  2,380 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&D_80183D60), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    476 ( 0.00%)  }
      .           
      .           void func_80057CE4(void) {
  9,520 ( 0.00%)      switch (D_8018D21C) {
      .                   case 0:
  2,856 ( 0.00%)              func_802A3730(D_800DC5EC);
 54,264 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/skybox_and_splitscreen.c:func_802A3730 (952x)
      .                       break;
      .                   case 1:
      .                       func_802A3730(D_800DC5EC);
      .                       break;
      .                   case 2:
      .                       func_802A3730(D_800DC5F0);
      .                       break;
      .                   case 3:
-- line 429 ----------------------------------------
-- line 443 ----------------------------------------
      .                       break;
      .                   case 11:
      .                       func_802A3730(D_800DC5F8);
      .                       break;
      .               }
      .           }
      .           
      .           void func_80057DD0(void) {
  1,904 ( 0.00%)      if (D_801657B2 != 0) {
      .                   func_8004C024(0xF, 0xB, 0x122, 0, 0xFF, 0, 0xFF);
      .                   func_8004C148(0x131, 0xB, 0xDA, 0, 0xFF, 0, 0xFF);
      .                   func_8004C024(0xF, 0xE5, 0x122, 0, 0xFF, 0, 0xFF);
      .                   func_8004C148(0xF, 0xB, 0xDA, 0, 0xFF, 0, 0xFF);
      .                   func_8004C024(0x16, 0x10, 0x114, 0xFF, 0, 0, 0xFF);
      .                   func_8004C148(0x12A, 0x10, 0xD0, 0xFF, 0, 0, 0xFF);
      .                   func_8004C024(0x16, 0xE0, 0x114, 0xFF, 0, 0, 0xFF);
      .                   func_8004C148(0x16, 0x10, 0xD0, 0xFF, 0, 0, 0xFF);
      .                   func_8004C024(0x18, 0x15, 0x110, 0, 0, 0xFF, 0xFF);
      .                   func_8004C148(0x128, 0x15, 0xC4, 0, 0, 0xFF, 0xFF);
      .                   func_8004C024(0x18, 0xDB, 0x110, 0, 0, 0xFF, 0xFF);
      .                   func_8004C148(0x18, 0x15, 0xC4, 0, 0, 0xFF, 0xFF);
      .               }
      .           }
      .           
    952 ( 0.00%)  void func_80057FC4(u32 arg0) {
      .               UNUSED Gfx* temp_v1;
      .           
  1,428 ( 0.00%)      if ((gHUDDisable != 0)) {
      .                   return;
      .               }
  2,856 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,564 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
    476 ( 0.00%)      set_matrix_hud_screen();
  5,712 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:set_matrix_hud_screen (476x)
      .           
  1,428 ( 0.00%)      if ((D_801657C8 != 0)) {
      .                   return;
      .               }
      .           
  3,332 ( 0.00%)      switch (arg0) {
      .                   case 0:
    476 ( 0.00%)              func_80051EBC();
8,828,685 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_80051EBC (476x)
      .                       break;
      .                   case 1:
      .                       func_80051EF8();
      .                       break;
      .                   case 2:
      .                       func_80051F9C();
      .                       break;
      .                   case 3:
      .                       func_80052044();
      .                       break;
      .                   case 4:
      .                       func_80052080();
      .                       break;
      .               }
    476 ( 0.00%)  }
      .           
    952 ( 0.00%)  void render_object(u32 arg0) {
      .               UNUSED Gfx* temp_v1;
      .           
  1,428 ( 0.00%)      if (gHUDDisable != 0) {
      .                   return;
      .               }
      .           
  2,856 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,843 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
      .           
  1,904 ( 0.00%)      if (D_8018D22C != 0) {
      .                   return;
      .               }
      .           
  2,856 ( 0.00%)      switch (arg0) {
      .                   case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    476 ( 0.00%)              render_object_p1();
12,446,642 ( 0.02%)  => src/code_80057C60.c:render_object_p1 (476x)
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                       render_object_p1();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
      .                       render_object_p2();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_ONE:
-- line 522 ----------------------------------------
-- line 542 ----------------------------------------
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_THREE:
      .                       render_object_p3();
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                       render_object_p4();
      .                       break;
      .               }
    476 ( 0.00%)  }
      .           
    476 ( 0.00%)  void render_object_p1(void) {
      .           
  1,904 ( 0.00%)      gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
  2,380 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[0]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
  2,380 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[0]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .           
    952 ( 0.00%)      func_8001C3C4(PLAYER_ONE);
 10,472 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80005FD0.c:func_8001C3C4 (476x)
  1,428 ( 0.00%)      if (gGamestate == ENDING) {
      .                   func_80055F48(PLAYER_ONE);
      .                   func_80056160(PLAYER_ONE);
      .                   func_8005217C(PLAYER_ONE);
      .                   func_80054BE8(PLAYER_ONE);
      .                   return;
      .               }
  1,428 ( 0.00%)      if (!gDemoMode) {
    952 ( 0.00%)          render_lakitu(PLAYER_ONE);
1,794,923 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_lakitu (476x)
      .               }
    952 ( 0.00%)      render_object_for_player(PLAYER_ONE);
10,627,919 ( 0.02%)  => src/code_80057C60.c:render_object_for_player (476x)
    476 ( 0.00%)  }
      .           
      .           void render_object_p2(void) {
      .           
      .               gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[1]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[1]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
-- line 580 ----------------------------------------
-- line 607 ----------------------------------------
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .               func_8001C3C4(PLAYER_FOUR);
      .               if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                   render_lakitu(PLAYER_FOUR);
      .               }
      .               render_object_for_player(PLAYER_FOUR);
      .           }
      .           
    952 ( 0.00%)  void render_player_snow_effect(u32 arg0) {
      .               UNUSED Gfx* temp_v1;
      .           
  1,428 ( 0.00%)      if (gHUDDisable != 0) {
      .                   return;
      .               }
      .           
  2,856 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,412 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
      .           
  1,904 ( 0.00%)      if (D_8018D22C != 0) {
      .                   return;
      .               }
  2,856 ( 0.00%)      switch (arg0) {
      .                   case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    476 ( 0.00%)              render_player_snow_effect_one();
 23,324 ( 0.00%)  => src/code_80057C60.c:render_player_snow_effect_one (476x)
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                       render_player_snow_effect_one();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
      .                       render_player_snow_effect_two();
      .                       break;
      .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_ONE:
-- line 637 ----------------------------------------
-- line 648 ----------------------------------------
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_THREE:
      .                       render_player_snow_effect_three();
      .                       break;
      .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                       render_player_snow_effect_four();
      .                       break;
      .               }
    476 ( 0.00%)  }
      .           
      .           void render_player_snow_effect_one(void) {
  1,904 ( 0.00%)      gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
  2,380 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[0]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
  2,380 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[0]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
  1,428 ( 0.00%)      if (gGamestate != ENDING) {
    952 ( 0.00%)          render_snowing_effect(PLAYER_ONE);
 14,280 ( 0.00%)  => src/code_80057C60.c:render_snowing_effect (476x)
      .               }
      .           }
      .           
      .           void render_player_snow_effect_two(void) {
      .               gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[1]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[1]),
-- line 673 ----------------------------------------
-- line 688 ----------------------------------------
      .               gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPersp[3]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      .               gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxLookAt[3]),
      .                         G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
      .               render_snowing_effect(PLAYER_FOUR);
      .           }
      .           
    952 ( 0.00%)  void render_object_for_player(s32 cameraId) {
      .           
    476 ( 0.00%)      CourseManager_RenderCourseObjects(cameraId);
  3,808 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_RenderCourseObjects (476x)
    952 ( 0.00%)      CourseManager_TrainSmokeDraw(cameraId);
8,234,658 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_TrainSmokeDraw (476x)
      .           
      .               // switch (gCurrentCourseId) {
      .               //     case COURSE_MARIO_RACEWAY:
      .               //         break;
      .               //     case COURSE_CHOCO_MOUNTAIN:
      .               //         break;
      .               //     case COURSE_BOWSER_CASTLE:
      .               //         render_object_thwomps(cameraId);
-- line 707 ----------------------------------------
-- line 778 ----------------------------------------
      .               //         break;
      .               //     case COURSE_DK_JUNGLE:
      .               //         if (gGamestate != CREDITS_SEQUENCE) {
      .               //             render_object_paddle_boat_smoke_particles(cameraId);
      .               //         }
      .               //         break;
      .               // }
      .           
    952 ( 0.00%)      render_object_smoke_particles(cameraId);
1,203,531 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_object_smoke_particles (476x)
    952 ( 0.00%)      render_object_leaf_particle(cameraId);
1,177,830 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_object_leaf_particle (476x)
      .           
  1,428 ( 0.00%)      if (D_80165730 != 0) {
      .                   func_80053E6C(cameraId);
      .               }
  1,428 ( 0.00%)      if (gModeSelection == BATTLE) {
      .                   render_object_bomb_kart(cameraId);
      .               }
    952 ( 0.00%)  }
      .           
  1,904 ( 0.00%)  void render_snowing_effect(s32 arg0) {
  2,380 ( 0.00%)      if (GetCourse() == GetFrappeSnowland()) {
  1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (476x)
  1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetFrappeSnowland (476x)
      .                   if (gGamestate != 9) {
      .                       if ((D_8015F894 == 0) && (gPlayerCountSelection1 == 1)) {
      .                           render_object_snowflakes_particles();
      .                       }
      .                   } else {
      .                       render_object_snowflakes_particles();
      .                   }
  2,380 ( 0.00%)      } else if (GetCourse() == GetSherbetLand()) {
  1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (476x)
  1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetSherbetLand (476x)
      .                   render_ice_block(arg0);
      .               }
  1,904 ( 0.00%)  }
      .           
      .           void func_80058BF4(void) {
  2,856 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,412 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
      .           }
      .           
    952 ( 0.00%)  void func_80058C20(u32 arg0) {
      .           
    952 ( 0.00%)      D_8018D21C = arg0;
  2,856 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,412 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
      .           
  1,904 ( 0.00%)      if (D_8018D22C == 0) {
  2,856 ( 0.00%)          switch (arg0) {
      .                       case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    476 ( 0.00%)                  func_80058F48();
  7,616 ( 0.00%)  => src/code_80057C60.c:func_80058F48 (476x)
      .                           break;
      .                       case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                           if (!gDemoMode) {
      .                               func_80059358();
      .                               break;
      .                           }
      .           
      .                           break;
-- line 831 ----------------------------------------
-- line 873 ----------------------------------------
      .                           break;
      .                       case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                           if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                               func_800597B8();
      .                           }
      .                           break;
      .                   }
      .               }
    476 ( 0.00%)  }
      .           
    952 ( 0.00%)  void render_hud(u32 arg0) {
      .           
    952 ( 0.00%)      D_8018D21C = arg0;
  2,856 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,371 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
  1,904 ( 0.00%)      if (D_8018D22C == 0) {
  2,856 ( 0.00%)          switch (arg0) {
      .                       case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
    476 ( 0.00%)                  func_80058F78();
8,690,132 ( 0.01%)  => src/code_80057C60.c:func_80058F78 (476x)
      .                           break;
      .                       case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
      .                           if (!gDemoMode) {
      .                               render_hud_2p_horizontal_player_two_horizontal_player_one();
      .                               break;
      .                           }
      .           
      .                           break;
-- line 898 ----------------------------------------
-- line 940 ----------------------------------------
      .                           break;
      .                       case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
      .                           if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                               render_hud_4p_multi();
      .                           }
      .                           break;
      .                   }
      .               }
    476 ( 0.00%)  }
      .           
      .           void func_80058F48(void) {
  1,428 ( 0.00%)      if (gHUDDisable == 0) {
    476 ( 0.00%)          set_matrix_hud_screen();
  5,712 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:set_matrix_hud_screen (476x)
      .               }
      .           }
      .           
    476 ( 0.00%)  void func_80058F78(void) {
  1,428 ( 0.00%)      if (gHUDDisable == 0) {
    476 ( 0.00%)          set_matrix_hud_screen();
  5,712 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:set_matrix_hud_screen (476x)
  4,310 ( 0.00%)          if ((!gDemoMode) && (gIsHUDVisible != 0) && (D_801657D8 == 0)) {
    652 ( 0.00%)              draw_item_window(PLAYER_ONE);
  3,586 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:draw_item_window (326x)
    978 ( 0.00%)              if (D_801657E4 != 2) {
    652 ( 0.00%)                  render_hud_timer(PLAYER_ONE);
4,212,462 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:render_hud_timer (326x)
    652 ( 0.00%)                  draw_simplified_lap_count(PLAYER_ONE);
4,024,724 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:draw_simplified_lap_count (326x)
    652 ( 0.00%)                  func_8004EB38(0);
431,442 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004EB38 (326x)
    978 ( 0.00%)                  if (D_801657E6 != false) {
      .                               func_8004ED40(0);
      .                           }
      .                       }
      .                   }
      .               }
    952 ( 0.00%)  }
      .           
      .           void func_80059024(void) {
      .           }
      .           
      .           void func_8005902C(void) {
      .           
  2,380 ( 0.00%)      if (D_8018D2AC != 0) {
      .                   switch (gPlayerCountSelection1) {
      .                       case 2:
      .                           func_8004EB30(PLAYER_ONE);
      .                           func_8004EB30(PLAYER_TWO);
      .                           break;
      .                       case 3:
      .                           func_8004EB30(PLAYER_ONE);
      .                           func_8004EB30(PLAYER_TWO);
-- line 986 ----------------------------------------
-- line 991 ----------------------------------------
      .                           func_8004EB30(PLAYER_TWO);
      .                           func_8004EB30(PLAYER_THREE);
      .                           func_8004EB30(PLAYER_FOUR);
      .                           break;
      .                   }
      .               }
      .           }
      .           
    217 ( 0.00%)  void func_800590D4(void) {
  1,304 ( 0.00%)      if (D_8018D2A4 != 0) {
    868 ( 0.00%)          if (gModeSelection != BATTLE) {
  1,519 ( 0.00%)              switch (gPlayerCountSelection1) {
      .                           case 1:
    434 ( 0.00%)                      if (gModeSelection != TIME_TRIALS) {
    434 ( 0.00%)                          func_8004E800(PLAYER_ONE);
1,396,739 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004E800 (217x)
      .                                   break;
      .                               }
      .                               break;
      .                           case 2:
      .                               func_8004E800(PLAYER_ONE);
    109 ( 0.00%)                      func_8004E800(PLAYER_TWO);
      .                               break;
      .                           case 3:
      .                               func_8004E998(PLAYER_ONE);
      .                               func_8004E998(PLAYER_TWO);
      .                               func_8004E998(PLAYER_THREE);
      .                               break;
      .                           case 4:
      .                               func_8004E998(PLAYER_ONE);
      .                               func_8004E998(PLAYER_TWO);
      .                               func_8004E998(PLAYER_THREE);
      .                               func_8004E998(PLAYER_FOUR);
      .                               break;
      .                       }
      .                   }
      .               }
    217 ( 0.00%)  }
      .           
    476 ( 0.00%)  void func_800591B4(void) {
      .           
  2,856 ( 0.00%)      if ((gHUDDisable == 0) && (D_800DC5B8 != 0)) {
    476 ( 0.00%)          func_80057C60();
  6,664 ( 0.00%)  => src/code_80057C60.c:func_80057C60 (476x)
  2,856 ( 0.00%)          gSPDisplayList(gDisplayListHead++, D_0D0076F8);
945,371 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
      .           
  1,904 ( 0.00%)          if (gIsHUDVisible != 0) {
    978 ( 0.00%)              if (D_801657D8 == 0) {
    978 ( 0.00%)                  if (D_801657F0 != false) {
      .                               func_800514BC();
      .                           }
  1,956 ( 0.00%)                  if ((!gDemoMode) && (D_801657E8 != false)) {
    978 ( 0.00%)                      if (D_80165800[0] != 0) {
    652 ( 0.00%)                          func_8004EE54(0);
735,580 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004EE54 (326x)
    978 ( 0.00%)                          if (gModeSelection != BATTLE) {
    652 ( 0.00%)                              func_8004F020(0);
4,035,572 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004F020 (326x)
      .                                   }
    978 ( 0.00%)                          func_8004F3E4(0);
15,582,168 ( 0.03%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004F3E4 (326x)
      .                               }
    978 ( 0.00%)                      if ((gScreenModeSelection == SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL) && (D_80165800[1] != 0)) {
      .                                   func_8004EE54(1);
      .                                   if (gModeSelection != BATTLE) {
      .                                       func_8004F020(1);
      .                                   }
      .                                   func_8004F3E4(1);
      .                               }
      .                           }
      .                       }
  3,586 ( 0.00%)              if ((D_801657E4 != 2) && (gModeSelection == GRAND_PRIX) && (D_8018D2BC != 0)) {
    434 ( 0.00%)                  func_80050320();
9,219,086 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_80050320 (217x)
      .                       }
    326 ( 0.00%)              func_800590D4();
1,401,841 ( 0.00%)  => src/code_80057C60.c:func_800590D4 (326x)
      .                   }
    476 ( 0.00%)          func_8005902C();
  2,380 ( 0.00%)  => src/code_80057C60.c:func_8005902C (476x)
    476 ( 0.00%)          func_80057DD0();
  1,904 ( 0.00%)  => src/code_80057C60.c:func_80057DD0 (476x)
    476 ( 0.00%)          func_80057CE4();
 33,320 ( 0.00%)  => src/code_80057C60.c:func_80057CE4 (476x)
      .               }
    476 ( 0.00%)  }
      .           
      .           void func_80059358(void) {
      .           }
      .           
      .           void render_hud_2p_horizontal_player_two_horizontal_player_one(void) {
      .               if (gHUDDisable == 0) {
      .                   render_hud_timer(PLAYER_ONE);
      .                   if (playerHUD[PLAYER_ONE].lapCount != 3) {
-- line 1074 ----------------------------------------
-- line 1188 ----------------------------------------
      .                   set_matrix_hud_screen();
      .                   render_hud_lap_3p_4p(PLAYER_FOUR);
      .               }
      .           }
      .           
      .           void func_80059820(s32 playerId) {
      .               hud_player* temp_v0;
      .           
  8,568 ( 0.00%)      D_8018CF1C = &gPlayerOne[playerId];
  7,140 ( 0.00%)      D_8018CF14 = &camera1[playerId];
      .               temp_v0 = &playerHUD[playerId];
 11,424 ( 0.00%)      temp_v0->posXInt = (s32) D_8018CF1C->pos[0];
      .               temp_v0->posYInt = (s32) D_8018CF1C->pos[1];
  2,856 ( 0.00%)      temp_v0->posZInt = (s32) D_8018CF1C->pos[2];
  1,428 ( 0.00%)  }
      .           
      .           void randomize_seed_from_controller(s32 arg0) {
    476 ( 0.00%)      struct Controller* controller = &gControllerOne[arg0];
      .           
  2,856 ( 0.00%)      if ((controller->button & A_BUTTON) != 0) {
     64 ( 0.00%)          gControllerRandom++;
      .               }
    952 ( 0.00%)      if ((controller->button & B_BUTTON) != 0) {
      .                   gControllerRandom++;
      .               }
    952 ( 0.00%)      if ((controller->button & R_TRIG) != 0) {
      .                   gControllerRandom++;
      .               }
    476 ( 0.00%)  }
      .           
      .           void func_8005994C(void) {
      .               D_8018D214 = true;
      .           }
      .           
      .           void func_8005995C(void) {
      .               s32 i;
      .               Player* player = gPlayerOne;
-- line 1224 ----------------------------------------
-- line 1234 ----------------------------------------
      .                           --playerHUD[i].unk_75;
      .                       }
      .                   }
      .                   ++player;
      .               }
      .               D_80165890 = 0;
      .           }
      .           
  1,904 ( 0.00%)  void func_80059A88(s32 playerId) {
    952 ( 0.00%)      func_80059820(playerId);
 20,944 ( 0.00%)  => src/code_80057C60.c:func_80059820 (952x)
  2,856 ( 0.00%)      if (!gDemoMode) {
  1,904 ( 0.00%)          update_object_lakitu(playerId);
183,487 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:update_object_lakitu (952x)
  1,904 ( 0.00%)          func_8007BB9C(playerId);
 73,304 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_8007BB9C (952x)
      .               }
    952 ( 0.00%)  }
      .           
  2,856 ( 0.00%)  void func_80059AC8(void) {
      .               s32 i;
      .           
  2,856 ( 0.00%)      if (gIsGamePaused == false) {
  1,904 ( 0.00%)          func_8008C1D8(&D_80165678);
    952 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C1D8 (952x)
  4,760 ( 0.00%)          gRaceFrameCounter++;
 23,800 ( 0.00%)          for (i = 0; i < NUM_PLAYERS; i++) {
 30,464 ( 0.00%)              D_8018CF68[i] = func_8008A890(&camera1[i]);
106,624 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80086E70.c:func_8008A890 (7,616x)
 15,232 ( 0.00%)              func_800892E0(i);
860,608 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80086E70.c:func_800892E0 (7,616x)
      .                   }
  6,664 ( 0.00%)          switch (gScreenModeSelection) {
      .                       case SCREEN_MODE_1P:
  2,856 ( 0.00%)                  if (gGamestate != 9) {
  1,904 ( 0.00%)                      func_80059A88(PLAYER_ONE);
288,207 ( 0.00%)  => src/code_80057C60.c:func_80059A88 (952x)
  2,856 ( 0.00%)                      if (gModeSelection == TIME_TRIALS) {
      .                                   func_8005995C();
      .                               }
      .                           } else {
      .                               func_80059820(PLAYER_ONE);
      .                           }
      .                           break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
      .                           func_80059A88(PLAYER_ONE);
-- line 1272 ----------------------------------------
-- line 1278 ----------------------------------------
      .                           break;
      .                       case SCREEN_MODE_3P_4P_SPLITSCREEN:
      .                           func_80059A88(PLAYER_ONE);
      .                           func_80059A88(PLAYER_TWO);
      .                           func_80059A88(PLAYER_THREE);
      .                           func_80059A88(PLAYER_FOUR);
      .                           break;
      .                   }
    952 ( 0.00%)          func_8005A71C();
 13,328 ( 0.00%)  => src/code_80057C60.c:func_8005A71C (952x)
      .               }
  2,856 ( 0.00%)  }
      .           
      .           void func_80059C50(void) {
      .               s32 someIndex;
      .               s32 playerId;
      .           
      .               func_8005A3C0();
      .               for (someIndex = 0; someIndex < NUM_PLAYERS; someIndex++) {
      .                   playerId = gGPCurrentRacePlayerIdByRank[someIndex];
-- line 1296 ----------------------------------------
-- line 1297 ----------------------------------------
      .                   // I hate this dumb pointer access here
      .                   gGPCurrentRaceCharacterIdByRank[someIndex] = (gPlayerOne + playerId)->characterId;
      .               }
      .               for (someIndex = 0; someIndex < NUM_PLAYERS; someIndex++) {
      .                   D_8018CF98[someIndex] = gGPCurrentRaceRankByPlayerId[someIndex];
      .               }
      .           }
      .           
  1,428 ( 0.00%)  void func_80059D00(void) {
      .           
    476 ( 0.00%)      func_8005A99C();
  6,161 ( 0.00%)  => src/code_80057C60.c:func_8005A99C (476x)
    476 ( 0.00%)      func_8005A3C0();
  8,346 ( 0.00%)  => src/code_80057C60.c:func_8005A3C0 (476x)
    476 ( 0.00%)      func_8005A380();
399,660 ( 0.00%)  => src/code_80057C60.c:func_8005A380 (476x)
      .           
  1,428 ( 0.00%)      if (D_801657AE == 0) {
  3,332 ( 0.00%)          switch (gScreenModeSelection) {
      .                       case SCREEN_MODE_1P:
    952 ( 0.00%)                  randomize_seed_from_controller(PLAYER_ONE);
  5,776 ( 0.00%)  => src/code_80057C60.c:randomize_seed_from_controller (476x)
  1,428 ( 0.00%)                  if (D_8018D214 == false) {
    952 ( 0.00%)                      func_80059820(PLAYER_ONE);
 10,472 ( 0.00%)  => src/code_80057C60.c:func_80059820 (476x)
    476 ( 0.00%)                      func_8005B914();
 57,546 ( 0.00%)  => src/code_80057C60.c:func_8005B914 (476x)
  1,428 ( 0.00%)                      if (!gDemoMode) {
  1,428 ( 0.00%)                          func_8007AA44(0);
 94,505 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_8007AA44 (476x)
      .                               }
    952 ( 0.00%)                      func_80078C70(0);
1,462,894 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_80078C70 (476x)
  1,428 ( 0.00%)                      if (playerHUD[PLAYER_ONE].raceCompleteBool == 0) {
  3,332 ( 0.00%)                          func_8005C360((gPlayerOneCopy->unk_094 / 18.0f) * 216.0f);
 12,007 ( 0.00%)  => src/code_80057C60.c:func_8005C360 (476x)
      .                               }
  1,428 ( 0.00%)                      func_8005D0FC(PLAYER_ONE);
 29,512 ( 0.00%)  => src/code_80057C60.c:func_8005D0FC (476x)
      .                           } else {
      .                               func_80059820(PLAYER_ONE);
      .                               func_80078C70(1);
      .                               func_80059820(PLAYER_TWO);
      .                               func_80078C70(2);
      .                           }
      .                           update_object();
      .                           break;
-- line 1333 ----------------------------------------
-- line 1343 ----------------------------------------
      .                           func_8005D1F4(0);
      .                           func_80059820(PLAYER_TWO);
      .                           func_8005D0FC(PLAYER_TWO);
      .                           if (!gDemoMode) {
      .                               func_8007AA44(1);
      .                           }
      .                           func_80078C70(2);
      .                           func_8005D1F4(1);
    476 ( 0.00%)                  update_object();
2,065,076 ( 0.00%)  => src/code_80057C60.c:update_object (476x)
      .                           break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL:
      .                           randomize_seed_from_controller(PLAYER_ONE);
      .                           randomize_seed_from_controller(PLAYER_TWO);
      .                           func_80059820(PLAYER_ONE);
      .                           func_8005D0FC(PLAYER_ONE);
      .                           if (!gDemoMode) {
      .                               func_8007AA44(0);
-- line 1359 ----------------------------------------
-- line 1398 ----------------------------------------
      .                               if ((!gDemoMode) && (gPlayerCountSelection1 == 4)) {
      .                                   func_8007AA44(3);
      .                               }
      .                               func_8005D1F4(3);
      .                           }
      .                           update_object();
      .                           break;
      .                   }
    476 ( 0.00%)          func_800744CC();
  3,640 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_800744CC (476x)
      .               }
  1,428 ( 0.00%)  }
      .           
    476 ( 0.00%)  void func_8005A070(void) {
  1,428 ( 0.00%)      func_8008C1D8(&D_80165678);
    476 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C1D8 (476x)
    952 ( 0.00%)      gMatrixHudCount = 0;
    952 ( 0.00%)      D_801655C0 = 0;
    476 ( 0.00%)      func_80041D34();
116,620 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:func_80041D34 (476x)
  1,428 ( 0.00%)      if (gIsGamePaused == false) {
    476 ( 0.00%)          func_8005C728();
 79,389 ( 0.00%)  => src/code_80057C60.c:func_8005C728 (476x)
  1,904 ( 0.00%)          if (gGamestate == ENDING) {
      .                       func_80086604();
      .                       func_80086D80();
      .                       update_cheep_cheep(1);
      .                       func_80077640();
    952 ( 0.00%)          } else if (gGamestate == CREDITS_SEQUENCE) {
      .                       func_80059820(PLAYER_ONE);
      .                       func_80078C70(0);
      .                       update_object();
      .                   } else {
    952 ( 0.00%)              func_80059D00();
4,179,395 ( 0.01%)  => src/code_80057C60.c:func_80059D00 (476x)
      .                   }
      .               }
    476 ( 0.00%)      func_8008C204();
    476 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C204 (476x)
  1,428 ( 0.00%)      func_8008C1E0(&D_80165678, (s32) &D_801655F0);
    476 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/effects.c:func_8008C1E0 (476x)
    476 ( 0.00%)  }
      .           
 26,656 ( 0.00%)  void func_8005A14C(s32 playerId) {
      .               s32 objectIndex;
      .               s32 lapCount;
      .               Player* player;
      .               UNUSED s32 stackPadding;
      .           
 15,232 ( 0.00%)      player = &gPlayerOne[playerId];
 19,040 ( 0.00%)      objectIndex = D_8018CE10[playerId].objectIndex;
  7,616 ( 0.00%)      lapCount = gLapCountByPlayerId[playerId];
  7,616 ( 0.00%)      if (player->type & PLAYER_EXISTS) {
 11,424 ( 0.00%)          if (player->effects & 0x204C0) {
 22,848 ( 0.00%)              gObjectList[objectIndex].direction_angle[2] += 0x1000;
      .                   } else {
  7,616 ( 0.00%)              if (gObjectList[objectIndex].direction_angle[2] != 0) {
      .                           gObjectList[objectIndex].direction_angle[2] += 0x1000;
      .                       }
      .                   }
 11,424 ( 0.00%)          if (player->effects & LIGHTNING_EFFECT) {
 19,040 ( 0.00%)              f32_step_towards(&gObjectList[objectIndex].sizeScaling, 0.3f, 0.02f);
      .                   } else {
 11,424 ( 0.00%)              f32_step_towards(&gObjectList[objectIndex].sizeScaling, 0.6f, 0.02f);
 27,904 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:f32_step_towards (3,808x)
      .                   }
  7,616 ( 0.00%)          if (player->effects & HIT_EFFECT) {
  7,616 ( 0.00%)              u16_step_up_towards(&gObjectList[objectIndex].direction_angle[0], 0x0C00U, 0x0100U);
      .                   } else {
 11,424 ( 0.00%)              u16_step_down_towards(&gObjectList[objectIndex].direction_angle[0], 0, 0x00000100);
 22,848 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:u16_step_down_towards (3,808x)
      .                   }
  7,616 ( 0.00%)          if (player->effects & 0x03000000) {
      .                       func_80087D24(objectIndex, 6.0f, 1.5f, 0.0f);
      .                   } else {
 19,040 ( 0.00%)              f32_step_towards(&gObjectList[objectIndex].offset[1], 0.0f, 1.0f);
 26,656 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:f32_step_towards (3,808x)
      .                   }
 19,040 ( 0.00%)          if ((player->type & PLAYER_INVISIBLE_OR_BOMB) || (player->effects & BOO_EFFECT)) {
  3,808 ( 0.00%)              gObjectList[objectIndex].primAlpha = 0x0050;
      .                   } else {
 19,040 ( 0.00%)              gObjectList[objectIndex].primAlpha = 0x00FF;
      .                   }
 15,232 ( 0.00%)          if (lapCount >= 3) {
      .                       gObjectList[objectIndex].direction_angle[2] = 0;
      .                       gObjectList[objectIndex].direction_angle[1] = 0;
      .                       gObjectList[objectIndex].direction_angle[0] = 0;
      .                       gObjectList[objectIndex].offset[2] = 0.0f;
      .                       gObjectList[objectIndex].offset[1] = 0.0f;
      .                       gObjectList[objectIndex].offset[0] = 0.0f;
      .                       gObjectList[objectIndex].sizeScaling = 0.6f;
      .                       gObjectList[objectIndex].primAlpha = 0x00FF;
      .                   }
      .               }
 30,464 ( 0.00%)  }
      .           
    476 ( 0.00%)  void func_8005A380(void) {
      .               s32 temp_s0;
 12,376 ( 0.00%)      for (temp_s0 = 0; temp_s0 < NUM_PLAYERS; ++temp_s0) {
  7,616 ( 0.00%)          func_8005A14C(temp_s0);
378,240 ( 0.00%)  => src/code_80057C60.c:func_8005A14C (3,808x)
      .               }
    952 ( 0.00%)  }
      .           
      .           void func_8005A3C0(void) {
      .               bool b = false;
  4,284 ( 0.00%)      if ((gGamestate != ENDING) && (gGamestate != CREDITS_SEQUENCE) && !D_8018D204) {
  2,282 ( 0.00%)          switch (gPlayerCountSelection1) {
      .                       case 1:
  1,304 ( 0.00%)                  if (gControllerOne->buttonPressed & R_CBUTTONS) {
      .                               if (++D_801657E4 >= 3) {
      .                                   D_801657E4 = 0;
      .                               }
      .                               if (D_801657E4 == 2) {
      .                                   D_801657E8 = false;
      .                                   D_801657E6 = false;
      .                                   D_801657F0 = true;
      .                               } else if (D_801657E4 == 1) {
-- line 1504 ----------------------------------------
-- line 1555 ----------------------------------------
      .                               b = true;
      .                           }
      .                           break;
      .                   }
      .                   if (b) {
      .                       func_8006F824(1);
      .                   }
      .               }
    476 ( 0.00%)  }
      .           
    952 ( 0.00%)  void func_8005A71C(void) {
  4,760 ( 0.00%)      if (GetCourse() == GetBowsersCastle()) {
  2,856 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (952x)
  2,856 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBowsersCastle (952x)
      .                   func_80081210();
      .               }
  1,904 ( 0.00%)  }
      .           
    476 ( 0.00%)  void update_object(void) {
      .           
    952 ( 0.00%)      CourseManager_UpdateCourseObjects();
  3,332 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_UpdateCourseObjects (476x)
    476 ( 0.00%)      CourseManager_TrainSmokeTick();
1,672,376 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_TrainSmokeTick (476x)
      .           
      .               // switch (gCurrentCourseId) {
      .               //     case COURSE_MARIO_RACEWAY:
      .               //     case COURSE_CHOCO_MOUNTAIN:
      .               //         break;
      .               //     case COURSE_BOWSER_CASTLE:
      .               //         func_80081208();
      .               //         update_flame_particle();
-- line 1582 ----------------------------------------
-- line 1636 ----------------------------------------
      .               //             update_neon();
      .               //             update_chain_chomps();
      .               //         }
      .               //         break;
      .               //     case COURSE_DK_JUNGLE:
      .               //         update_ferries_smoke_particle();
      .               //         break;
      .               // }
  1,428 ( 0.00%)      if (D_80165730 != 0) {
      .                   func_80074EE8();
      .               }
    476 ( 0.00%)      func_80076F2C();
189,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:func_80076F2C (476x)
  2,856 ( 0.00%)      if ((s16) GetCourse() != GetFrappeSnowland()) {
  1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (476x)
  1,428 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetFrappeSnowland (476x)
    476 ( 0.00%)          update_leaf();
189,448 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/update_objects.c:update_leaf (476x)
      .               }
    476 ( 0.00%)  }
      .           
  1,428 ( 0.00%)  void func_8005A99C(void) {
  1,904 ( 0.00%)      if (D_8018D170 == 0) {
    604 ( 0.00%)          if (D_8018D178 == 0) {
      4 ( 0.00%)              if (gPlayerCountSelection1 == 1) {
      1 ( 0.00%)                  func_8005AA34();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA34 (1x)
      .                       }
      4 ( 0.00%)              if (gPlayerCountSelection1 == 3) {
      .                           D_801657E8 = true;
      .                       }
      2 ( 0.00%)              gIsHUDVisible = (s32) 1;
      1 ( 0.00%)              D_8018D170 = (s32) 1;
      2 ( 0.00%)              D_8018D190 = (s32) 1;
      2 ( 0.00%)              D_8018D204 = 0;
      .                       return;
      .                   }
    300 ( 0.00%)          --D_8018D178;
      .               }
  1,904 ( 0.00%)  }
      .           
      .           void func_8005AA34(void) {
      2 ( 0.00%)      D_8018D1CC = 1;
      2 ( 0.00%)      D_8018D1A0 = 0;
      1 ( 0.00%)  }
      .           
      .           void func_8005AA4C(void) {
     28 ( 0.00%)      ++D_8018D1CC;
     28 ( 0.00%)      D_8018D1A0 = 0;
     14 ( 0.00%)  }
      .           
      .           void func_8005AA6C(s32 arg0) {
      2 ( 0.00%)      D_8018D1CC = arg0;
      2 ( 0.00%)      D_8018D1A0 = 0;
      1 ( 0.00%)  }
      .           
      .           void func_8005AA80(void) {
      4 ( 0.00%)      D_8018D1CC = 0;
      4 ( 0.00%)      D_8018D1A0 = 0;
      2 ( 0.00%)  }
      .           
      .           void func_8005AA94(s32 arg0) {
    112 ( 0.00%)      if (D_8018D1A0 == 0) {
      .                   D_8018D1D4 = arg0;
     12 ( 0.00%)          D_8018D1A0 = 1;
      .               }
      .           
    100 ( 0.00%)      --D_8018D1D4;
     28 ( 0.00%)      if (D_8018D1D4 < 0) {
      6 ( 0.00%)          D_8018D1A0 = 0;
      6 ( 0.00%)          func_8005AA4C();
     30 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (6x)
      .               }
     22 ( 0.00%)  }
      .           
      .           void func_8005AAF0(void) {
      2 ( 0.00%)      D_8018D1B4 = 1;
      2 ( 0.00%)      D_8018D1A0 = 0;
      1 ( 0.00%)      func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      .           }
      .           
      .           void func_8005AB20(void) {
      7 ( 0.00%)      if ((gModeSelection == GRAND_PRIX) && (gPlayerCountSelection1 == 1)) {
      2 ( 0.00%)          func_8005AA6C(0x14);
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA6C (1x)
      .               }
      .           }
      .           
    476 ( 0.00%)  void func_8005AB60(void) {
  3,808 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_78) {
      .                   case 0:
      .                       break;
      .                   case 1:
     20 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 0x10);
     71 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
     30 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 0x10) != 0) {
     71 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (5x)
      1 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      1 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_79 = 1;
      .                       }
      .                       break;
      .                   case 2:
     16 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x116, 4);
     49 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
     25 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xC6, 4) != 0) {
     49 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      .                       break;
      .                   case 3:
      .                       s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 4);
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      .                       break;
      .                   case 4:
      8 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x10E, 4);
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xBE, 4) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      .                       break;
      .                   case 5:
     24 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 4);
     86 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (6x)
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      .                       break;
      .                   case 6:
      8 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x10A, 2);
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xBA, 2) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      .                       break;
      .                   case 7:
      8 ( 0.00%)              s16_step_towards(&playerHUD[PLAYER_ONE].speedometerX, 0x106, 2);
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
     44 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].speedometerY, 0xB6, 2) != 0) {
    115 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (8x)
      6 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_78++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_78 = 0;
      1 ( 0.00%)              break;
      .               }
    951 ( 0.00%)      if ((playerHUD[PLAYER_ONE].unk_79 != 0) && (playerHUD[PLAYER_ONE].unk_79 == 1)) {
     96 ( 0.00%)          if (++D_801657E7 >= 0x10) {
      1 ( 0.00%)              D_801657E7 = 0;
      2 ( 0.00%)              D_8016579E = 0xDD00;
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_79 = 0U;
      .                   } else {
    105 ( 0.00%)              D_8016579E = D_800E55B0[D_801657E7] + 0xDD00;
      .                   }
      .               }
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_80) {
      .                   case 0:
      .                       break;
      .                   case 1:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].slideItemBoxY, 0x40, 8) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_80++;
      .                       }
      .                       break;
      .                   case 2:
-- line 1785 ----------------------------------------
-- line 1811 ----------------------------------------
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].slideItemBoxY, 0x40, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_80++;
      .                       }
      .                       break;
      .                   case 8:
      .                       playerHUD[PLAYER_ONE].unk_80 = 0;
      .                       break;
      .               }
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7A) {
      .                   case 0:
      .                       break;
      .                   case 1:
     10 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 0x10) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 2:
     25 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xF4, 4) != 0) {
     49 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 3:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 4:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xEC, 4) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 5:
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 6:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE8, 2) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 7:
     69 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].timerX, 0xE4, 2) != 0) {
    186 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (13x)
      7 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7A++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7A = 0;
      1 ( 0.00%)              break;
      .               }
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7D) {
      .                   case 0:
      .                       break;
      .                   case 1:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 0x10) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 2:
     25 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x43, 4) != 0) {
     57 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 3:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 4:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x4B, 4) != 0) {
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 5:
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 6:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x4F, 2) != 0) {
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 7:
     84 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapX, 0x53, 2) != 0) {
    196 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (16x)
      7 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7D++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7D = 0;
      1 ( 0.00%)              break;
      .               }
  2,856 ( 0.00%)      D_8018CFEC = (f32) (playerHUD[PLAYER_ONE].speedometerX + 0x18);
  2,380 ( 0.00%)      D_8018CFF4 = (f32) (playerHUD[PLAYER_ONE].speedometerY + 6);
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7B) {
      .                   case 0:
      .                       break;
      .                   case 1:
     10 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 0x10) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 2:
     25 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xF4, 4) != 0) {
     49 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 3:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 4:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xEC, 4) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 5:
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 6:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE8, 2) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 7:
     69 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap1CompletionTimeX, 0xE4, 2) != 0) {
    186 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (13x)
      7 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7B++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7B = 0;
      1 ( 0.00%)              break;
      .               }
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7E) {
      .                   case 0:
      .                       break;
      .                   case 1:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 0x10) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 2:
     25 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x43, 4) != 0) {
     57 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 3:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 4:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x4B, 4) != 0) {
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 5:
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 6:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x4F, 2) != 0) {
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 7:
     84 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage1X, 0x53, 2) != 0) {
    196 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (16x)
      7 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7E++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7E = 0;
      1 ( 0.00%)              break;
      .               }
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7C) {
      .                   case 0:
      .                       break;
      .                   case 1:
     10 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 0x10) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 2:
     25 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xF4, 4) != 0) {
     49 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 3:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 4:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xEC, 4) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 5:
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 6:
     13 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE8, 2) != 0) {
     25 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 7:
     69 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lap2CompletionTimeX, 0xE4, 2) != 0) {
    186 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (13x)
      7 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7C++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7C = 0;
      1 ( 0.00%)              break;
      .               }
  3,332 ( 0.00%)      switch (playerHUD[PLAYER_ONE].unk_7F) {
      .                   case 0:
      .                       break;
      .                   case 1:
     16 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 0x10) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 2:
     24 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x43, 4) != 0) {
     57 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (4x)
      .                           playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 3:
      .                       if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 4:
     12 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x4B, 4) != 0) {
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 5:
      6 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 4) != 0) {
      .                           playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 6:
     12 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x4F, 2) != 0) {
     29 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (2x)
      .                           playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 7:
     84 ( 0.00%)              if (s16_step_towards(&playerHUD[PLAYER_ONE].lapAfterImage2X, 0x53, 2) != 0) {
    196 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:s16_step_towards (16x)
      7 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_7F++;
      .                       }
      .                       break;
      .                   case 8:
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7F = 0;
      .                       break;
      .               }
    952 ( 0.00%)  }
      .           
      .           void func_8005B7A0(void) {
      .               f32 temp_f0;
      .               f32* temp_s2;
      .               f32* temp_s3;
      .               f32* temp_s4;
      .               UNUSED f32* var_s1;
      .               s32 var_s0;
-- line 2081 ----------------------------------------
-- line 2096 ----------------------------------------
      .                       }
      .                       if ((f64) temp_f0 <= -32.0) {
      .                           D_8018D050[var_s0] = -32.0f;
      .                       }
      .                   }
      .               }
      .           }
      .           
  3,808 ( 0.00%)  void func_8005B914(void) {
      .               s32 i;
      .               UNUSED s32 unk;
      .           
  4,284 ( 0.00%)      switch (D_8018D1CC) {
      .                   case 0:
      .                       break;
      .                   case 0x1:
      1 ( 0.00%)              func_8005AAF0();
     10 ( 0.00%)  => src/code_80057C60.c:func_8005AAF0 (1x)
      1 ( 0.00%)              break;
      .                   case 0x2:
      3 ( 0.00%)              if (gModeSelection == TIME_TRIALS) {
      1 ( 0.00%)                  playerHUD[PLAYER_ONE].unk_80 = 1;
      .                       }
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_78 = 1;
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7A = 1;
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7D = 1;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x3:
      4 ( 0.00%)              func_8005AA94(0);
     32 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (2x)
      2 ( 0.00%)              break;
      .                   case 0x4:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7B = 1;
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7E = 1;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x5:
      .                       func_8005AA94(0);
      .                       break;
      .                   case 0x6:
      2 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7C = 1;
      1 ( 0.00%)              playerHUD[PLAYER_ONE].unk_7F = 1;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              func_8005AA80();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA80 (1x)
      1 ( 0.00%)              break;
      .                   case 0x14:
      2 ( 0.00%)              D_8018D078[0] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x15:
     30 ( 0.00%)              func_8005AA94(4);
    168 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (15x)
      .                       break;
      .                   case 0x16:
      2 ( 0.00%)              D_8018D078[1] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x17:
      .                       func_8005AA94(4);
      .                       break;
      .                   case 0x18:
      2 ( 0.00%)              D_8018D078[2] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x19:
      .                       func_8005AA94(4);
      .                       break;
      .                   case 0x1A:
      2 ( 0.00%)              D_8018D078[3] = 16.0f;
      1 ( 0.00%)              func_8005AA4C();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA4C (1x)
      1 ( 0.00%)              break;
      .                   case 0x1B:
     22 ( 0.00%)              func_8005AA94(0xA);
    116 ( 0.00%)  => src/code_80057C60.c:func_8005AA94 (11x)
     11 ( 0.00%)              break;
      .                   case 0x1C:
      1 ( 0.00%)              func_8005AA80();
      5 ( 0.00%)  => src/code_80057C60.c:func_8005AA80 (1x)
      1 ( 0.00%)              break;
      .                   case 0x64:
      .                       func_8005AA4C();
      .                       break;
      .                   case 0x65:
      .                       func_8005AA94(0x3A);
      .                       break;
      .                   case 0x66:
      .                       D_8018D078[0] = -8.0f;
-- line 2178 ----------------------------------------
-- line 2375 ----------------------------------------
      .                       break;
      .                   case 0x9B:
      .                       func_8005AA94(0x14);
      .                       break;
      .                   case 0x9C:
      .                       func_8005AA80();
      .                       break;
      .               }
    989 ( 0.00%)      if (D_8018D1CC < 0x64) {
    476 ( 0.00%)          func_8005AB60();
 38,465 ( 0.00%)  => src/code_80057C60.c:func_8005AB60 (476x)
      .               } else if (D_8018D1CC < 0xC8) {
      .                   func_8005B7A0();
      .               }
  2,500 ( 0.00%)      if ((D_8018D1CC != 0) && (D_8018D1CC >= 0x14) && (D_8018D1CC < 0x1E)) {
    600 ( 0.00%)          for (i = 0; i < 4; i++) {
    480 ( 0.00%)              f32_step_towards(&D_8018D028[i], D_8018D0C8[i], D_8018D078[i]);
  1,104 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/math_util_2.c:f32_step_towards (120x)
    480 ( 0.00%)              if (D_8018D028[i] == D_8018D0C8[i]) {
     72 ( 0.00%)                  D_8018D078[i] = 0.0f;
      .                       }
      .                   }
      .               }
  3,808 ( 0.00%)  }
      .           
      .           void func_8005C360(f32 arg0) {
  1,428 ( 0.00%)      if (!playerHUD[PLAYER_ONE].unk_79) {
      .                   u16 v;
  1,383 ( 0.00%)          if (arg0 < 10.0) {
  1,161 ( 0.00%)              v = (u16) (128.0f * arg0) + 0xDD00;
    222 ( 0.00%)          } else if (arg0 < 20.0) {
    214 ( 0.00%)              v = (u16) ((arg0 - 10.0) * 256.0) + 0xE200;
      .                   } else {
    195 ( 0.00%)              v = (u16) ((arg0 - 20.0) * 268.8) + 0xEC00;
      .                   }
  2,305 ( 0.00%)          if (arg0 == D_8018CFE4) {
    698 ( 0.00%)              if (arg0 > 5.0f) {
    112 ( 0.00%)                  if (++D_801657E7 == 8) {
      .                               D_801657E7 = 0;
      .                           }
      .                       } else {
  1,396 ( 0.00%)                  D_801657E7 = 0;
      .                       }
      .                   }
  1,956 ( 0.00%)          D_8016579E = v + D_800E55A0[D_801657E7];
    461 ( 0.00%)          D_8018CFE4 = arg0;
      .               }
    476 ( 0.00%)  }
      .           
      .           void func_8005C64C(UNUSED s32* arg0) {
      .           }
      .           
      .           void func_8005C654(s32* arg0) {
      .               *arg0 = 0;
      .           }
      .           
      .           void func_8005C65C(s32 arg0) {
      .               D_8018D2C8[arg0] = 1;
      .           }
      .           
  1,428 ( 0.00%)  void func_8005C674(s8 index, s16* x, s16* y, s16* z) {
  2,380 ( 0.00%)      s16* src = &D_800E4730[index * 3];
    952 ( 0.00%)      *x = *src++;
    952 ( 0.00%)      *y = *src++;
    952 ( 0.00%)      *z = *src++;
    476 ( 0.00%)  }
      .           
      .           void func_8005C6B4(s8 arg0, s16* arg1, s16* arg2, s16* arg3) {
      .               switch (arg0) {
      .                   case 0:
      .                       *arg1 = 0xFF;
      .                       *arg2 = 0x40;
      .                       *arg3 = 0x40;
      .                       break;
-- line 2446 ----------------------------------------
-- line 2452 ----------------------------------------
      .                   case 2:
      .                       *arg1 = 0x40;
      .                       *arg2 = 0x40;
      .                       *arg3 = 0xFF;
      .                       break;
      .               }
      .           }
      .           
    476 ( 0.00%)  void func_8005C728(void) {
      .               s16 x;
      .               s16 y;
      .               s16 z;
      .               s32 temp_t7;
      .           
  1,904 ( 0.00%)      temp_t7 = ++D_8018D400;
  1,904 ( 0.00%)      D_8018D40C = temp_t7 & 0x3F; // temp_t7 % 64
  1,904 ( 0.00%)      D_8018D410 = temp_t7 & 0x1F; // temp_t7 % 32
  1,904 ( 0.00%)      D_80165590 = temp_t7 & 0xF;  // temp_t7 % 16
  1,904 ( 0.00%)      D_80165594 = temp_t7 & 7;    // temp_t7 % 8
  1,904 ( 0.00%)      D_80165598 = temp_t7 & 3;    // temp_t7 % 4
  1,428 ( 0.00%)      D_8016559C = temp_t7 & 1;    // temp_t7 % 2
    952 ( 0.00%)      if (D_8018D40C == 0) {
     14 ( 0.00%)          D_801655A4 += 1;
     14 ( 0.00%)          D_801655D8 ^= 1;
      .               }
    938 ( 0.00%)      if (D_8018D410 == 0) {
     28 ( 0.00%)          D_801655AC += 1;
     28 ( 0.00%)          D_801655E8 ^= 1;
      .               }
    924 ( 0.00%)      if (D_80165590 == 0) {
     58 ( 0.00%)          D_801655B4 += 1;
     58 ( 0.00%)          D_801655F8 ^= 1;
      .               }
    894 ( 0.00%)      if (D_80165594 == 0) {
    118 ( 0.00%)          D_801655BC += 1;
    118 ( 0.00%)          D_80165608 ^= 1;
      .               }
    834 ( 0.00%)      if (D_80165598 == 0) {
    238 ( 0.00%)          D_801655C4 += 1;
    238 ( 0.00%)          D_80165618 ^= 1;
      .               }
    833 ( 0.00%)      if (D_8016559C == 0) {
    476 ( 0.00%)          D_801655CC += 1;
    476 ( 0.00%)          D_80165628 ^= 1;
      .               }
  3,332 ( 0.00%)      if (--D_8018D2AC < 0) {
      .                   D_8018D2AC = 0;
      .               }
  1,904 ( 0.00%)      D_801658A8 += 1;
  1,088 ( 0.00%)      if (D_801658A8 >= 7) {
      .                   D_801658A8 = 0;
      .               }
  2,380 ( 0.00%)      func_8005C674(D_801658A8, &x, &y, &z);
  7,140 ( 0.00%)  => src/code_80057C60.c:func_8005C674 (476x)
  3,332 ( 0.00%)      D_801656C0 = x / 2;
  3,332 ( 0.00%)      D_801656D0 = y / 2;
  3,332 ( 0.00%)      D_801656E0 = z / 2;
    476 ( 0.00%)      func_8005C980();
 31,554 ( 0.00%)  => src/code_80057C60.c:func_8005C980 (476x)
    952 ( 0.00%)  }
      .           
  1,428 ( 0.00%)  void func_8005C980(void) {
      .               s32 var_v0;
      .               s32 sp0 = 0; //! @warning this variable was uninitialized in decomp. This was likely supposed to be random!
      .               s32 temp_v1;
    505 ( 0.00%)      for (var_v0 = 0; var_v0 < NUM_PLAYERS; var_v0++) {
  1,300 ( 0.00%)          temp_v1 = gGPCurrentRaceRankByPlayerId[var_v0];
    476 ( 0.00%)          if (D_80165590 == 0) {
    824 ( 0.00%)              D_8018CF98[var_v0] = temp_v1;
      .                   }
  9,346 ( 0.00%)          D_8018CF28[temp_v1] = &gPlayerOne[sp0];
      .                   if (sp0 == 0) {
      .                       D_80165794 = temp_v1;
      .                   }
      .               }
      .           
     29 ( 0.00%)      for (var_v0 = 0; var_v0 < NUM_PLAYERS; var_v0++) {
     58 ( 0.00%)          sp0 = gGPCurrentRacePlayerIdByRank[var_v0];
  1,846 ( 0.00%)          D_8018CF50[var_v0] = sp0;
      .                   if (D_80165590 == 0) {
    986 ( 0.00%)              gGPCurrentRaceCharacterIdByRank[var_v0] = (gPlayerOne + sp0)->characterId;
      .                   }
      .               }
      .           
  2,856 ( 0.00%)      if (--D_8018D314 <= 0) {
  1,428 ( 0.00%)          D_8018D314 = D_8018D3F4;
  3,808 ( 0.00%)          D_8018D3E4 = D_800E55D0[D_8018D3F8][0];
  1,428 ( 0.00%)          D_8018D3E8 = D_800E55D0[D_8018D3F8][1];
  1,428 ( 0.00%)          D_8018D3EC = D_800E55D0[D_8018D3F8][2];
  2,380 ( 0.00%)          if (++D_8018D3F8 == 6) {
      .                       D_8018D3F8 = 0;
      .                   }
      .               }
  1,428 ( 0.00%)  }
      .           
  4,760 ( 0.00%)  void func_8005CB60(s32 playerId, s32 lapCount) {
      .               s32 temp_a0_2;
      .               UNUSED s32 stackPadding;
      .               s8* huh;
      .               s8* huhthedeuce;
      .               Player* player;
      .           
    952 ( 0.00%)      player = &gPlayerOne[playerId];
      .               huh = &playerHUD[playerId].alsoLapCount;
      .               huhthedeuce = &playerHUD[playerId].lapCount;
  5,236 ( 0.00%)      if (playerHUD[playerId].lapCount < D_8018D320) {
  2,380 ( 0.00%)          playerHUD[playerId].someTimer = (u32) (s32) (gCourseTimer * 100.0f);
  1,428 ( 0.00%)          if (*huh < lapCount) {
      .                       temp_a0_2 = gTimePlayerLastTouchedFinishLine[playerId] * 100.0f;
      .                       playerHUD[playerId].timeLastTouchedFinishLine = temp_a0_2;
      .                       playerHUD[playerId].lapCompletionTimes[*huh] = temp_a0_2;
      .                       if (*huh == 0) {
      .                           playerHUD[playerId].lapDurations[*huh] = playerHUD[playerId].timeLastTouchedFinishLine;
      .                       } else {
      .                           playerHUD[playerId].lapDurations[*huh] =
      .                               playerHUD[playerId].lapCompletionTimes[*huh] - playerHUD[playerId].lapCompletionTimes[*huh - 1];
-- line 2565 ----------------------------------------
-- line 2663 ----------------------------------------
      .                               s16_step_towards(&playerHUD[playerId].slideRankX, -8, 2);
      .                           } else {
      .                               s16_step_towards(&playerHUD[playerId].slideRankX, 8, 2);
      .                           }
      .                           s16_step_towards(&playerHUD[playerId].slideRankY, -0x0010, 4);
      .                           break;
      .                   }
      .               }
  3,332 ( 0.00%)      if (playerHUD[playerId].blinkTimer == 0) {
    952 ( 0.00%)          playerHUD[playerId].someTimer1 = playerHUD[playerId].someTimer;
    952 ( 0.00%)          D_801657E3 = 0;
      .                   return;
      .               }
      .               if (D_80165594 == 0) {
      .                   playerHUD[playerId].blinkState += 1;
      .                   playerHUD[playerId].blinkState &= 1;
      .               }
      .               playerHUD[playerId].blinkTimer -= 1;
      .               if (playerHUD[playerId].blinkTimer == 0) {
      .                   playerHUD[playerId].blinkState = 0;
      .               }
  3,808 ( 0.00%)  }
      .           
      .           void func_8005D0FC(s32 playerId) {
  1,428 ( 0.00%)      if (gModeSelection != BATTLE) {
  2,380 ( 0.00%)          switch (playerId) { /* irregular */
      .                       case PLAYER_ONE:
  1,904 ( 0.00%)                  func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_ONE]);
 23,800 ( 0.00%)  => src/code_80057C60.c:func_8005CB60 (476x)
      .                           break;
      .                       case PLAYER_TWO:
      .                           func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_TWO]);
      .                           break;
      .                       case PLAYER_THREE:
      .                           func_8005CB60(playerId, gLapCountByPlayerId[PLAYER_THREE]);
      .                           break;
      .                       case PLAYER_FOUR:
-- line 2698 ----------------------------------------
-- line 2736 ----------------------------------------
      .                       }
      .                       playerHUD[arg0].unk_74 = 1;
      .                       break;
      .                   }
      .               }
      .           }
      .           
      .           // Appears to load GP Mode race staging balloons and kart shadows.
      1 ( 0.00%)  void func_8005D290(void) {
      6 ( 0.00%)      D_8018D488 = dma_textures(gTexture69C80C, 0x400, 0x400);
  2,492 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D474 = dma_textures(gTextureKartShadow, 0x1000, 0x1000);
  2,931 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D420 = dma_textures(gTexture69B03C, 0x100, 0x100);
  2,398 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D424 = dma_textures(gTexture69B140, 0x400, 0x400);
  2,675 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D478 = dma_textures(gTexture69C1E8, 0x200, 0x200);
  2,427 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D480 = dma_textures(gTexture69BA28, 0x400, 0x400);
  2,731 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D484 = dma_textures(gTexture69B960, 0x400, 0x400);
  2,488 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D48C = dma_textures(gTexture69C354, 0x400, 0x400);
  2,809 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D494 = dma_textures(gTexture69C4E4, 0x400, 0x400);
  2,763 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      3 ( 0.00%)      D_8018D490 = D_8018D48C;
      6 ( 0.00%)      D_8018D498 = dma_textures(gTexture69B378, 0x1000, 0x1000);
  3,247 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4BC = dma_textures(gTextureBalloon1, 0x800, 0x800);
  3,087 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4C0 = dma_textures(gTextureBalloon2, 0x800, 0x800);
  2,905 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D49C = dma_textures(gTexture69C9C4, 0x200, 0x200);
  2,771 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4A0 = dma_textures(gTextureBoingExclamation, 0x800, 0x800);
  3,026 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4A4 = dma_textures(gTextureOnomatopoeiaPoomp1, 0x800, 0x800);
  2,706 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4A8 = dma_textures(gTextureOnomatopoeiaPoomp2, 0x800, 0x800);
  2,733 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4AC = dma_textures(gTextureOnomatopoeiaWhrrrr1, 0x800, 0x800);
  2,712 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4B0 = dma_textures(gTextureOnomatopoeiaWhrrrr2, 0x800, 0x800);
  3,055 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4B4 = dma_textures(gTextureOnomatopoeiaCrash1, 0x800, 0x800);
  3,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4B8 = dma_textures(gTextureOnomatopoeiaCrash2, 0x800, 0x800);
  3,358 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D438 = dma_textures(gTexture69CB84, 0x800, 0x800);
  3,661 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D43C = dma_textures(gTexture69CCEC, 0x800, 0x800);
  3,328 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D440 = dma_textures(gTexture69CEB8, 0x800, 0x800);
  3,098 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D444 = dma_textures(gTexture69D148, 0x800, 0x800);
  3,224 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D448 = dma_textures(gTexture69D4E0, 0x800, 0x800);
  3,169 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D44C = dma_textures(gTexture69D8FC, 0x800, 0x800);
  3,284 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D450 = dma_textures(gTexture69DCB4, 0x800, 0x800);
  3,087 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D454 = dma_textures(gTexture69DFA0, 0x800, 0x800);
  3,194 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D458 = dma_textures(gTexture69E25C, 0x800, 0x800);
  3,025 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D45C = dma_textures(gTexture69E518, 0x800, 0x800);
  3,164 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D460 = dma_textures(gTexture69E7A8, 0x800, 0x800);
  3,030 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D464 = dma_textures(gTexture69EA18, 0x800, 0x800);
  3,296 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D468 = dma_textures(gTexture69EC54, 0x800, 0x800);
  2,949 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D46C = dma_textures(gTexture69EE38, 0x800, 0x800);
  3,018 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D470 = dma_textures(gTexture69EFE0, 0x800, 0x800);
  2,933 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4C4 = dma_textures(gTextureLightningBolt0, 0x800, 0x800);
  3,129 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      6 ( 0.00%)      D_8018D4C8 = dma_textures(gTextureLightningBolt1, 0x800, 0x800);
  3,000 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:dma_textures (1x)
      2 ( 0.00%)  }
      .           
      .           void func_8005D6C0(Player* player) {
      .               s32 temp_v0;
      .           
      .               for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
     80 ( 0.00%)          player->unk_258[temp_v0].unk_01C = 0;
      .                   player->unk_258[temp_v0].unk_01E = 0;
     80 ( 0.00%)          player->unk_258[temp_v0].unk_012 = 0;
      .               }
      .           
      .               for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
     80 ( 0.00%)          player->unk_258[30 + temp_v0].unk_01C = 0;
      .                   player->unk_258[30 + temp_v0].unk_01E = 0;
     80 ( 0.00%)          player->unk_258[30 + temp_v0].unk_012 = 0;
      .               }
      .           
      .               for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
     80 ( 0.00%)          player->unk_258[10 + temp_v0].unk_01C = 0;
      .                   player->unk_258[10 + temp_v0].unk_01E = 0;
     80 ( 0.00%)          player->unk_258[10 + temp_v0].unk_012 = 0;
      .               }
      .           
      .               for (temp_v0 = 0; temp_v0 < 10; ++temp_v0) {
     80 ( 0.00%)          player->unk_258[20 + temp_v0].unk_01C = 0;
      .                   player->unk_258[20 + temp_v0].unk_01E = 0;
     80 ( 0.00%)          player->unk_258[20 + temp_v0].unk_012 = 0;
      .               }
      8 ( 0.00%)  }
      .           
  1,837 ( 0.00%)  void func_8005D794(Player* player, UnkPlayerStruct258* arg1, f32 arg2, f32 arg3, f32 arg4, s8 surfaceType, s8 arg6) {
  1,837 ( 0.00%)      arg1->unk_000[2] = arg4;
  3,674 ( 0.00%)      arg1->unk_000[0] = arg2;
      .               arg1->unk_000[1] = arg3;
  5,511 ( 0.00%)      arg1->unk_020 = -player->rotation[1];
  7,348 ( 0.00%)      arg1->unk_014 = surfaceType;
  3,674 ( 0.00%)      arg1->unk_010 = arg6;
  1,837 ( 0.00%)  }
      .           
      .           s32 func_8005D7D8(UnkPlayerStruct258* arg0, s8 arg1, f32 arg2) {
  1,837 ( 0.00%)      arg0->unk_01C = 1;
  3,674 ( 0.00%)      arg0->unk_012 = arg1;
      .               arg0->unk_01E = 0;
  1,837 ( 0.00%)      arg0->unk_00C = arg2;
  1,837 ( 0.00%)  }
      .           
 16,437 ( 0.00%)  s32 func_8005D800(UnkPlayerStruct258* arg0, s32 arg1, s16 arg2) {
197,244 ( 0.00%)      arg0->unk_038 = (u8) (arg1 >> 16);
      .               arg0->unk_03A = (u8) (arg1 >> 8);
      .               arg0->unk_03C = (u8) arg1;
      .               arg0->unk_03E = arg2;
 16,437 ( 0.00%)  }
      .           
      .           s32 func_8005D82C(UnkPlayerStruct258* arg0, s32 arg1, s16 arg2) {
      .               s32 temp_v0;
      .               temp_v0 = random_int(0x30);
      .           
      .               arg0->unk_038 = (u8) ((u8) (arg1 >> 0x10) - temp_v0);
      .               arg0->unk_03A = (u8) ((u8) (arg1 >> 8) - temp_v0);
      .               arg0->unk_03C = (u8) ((u8) arg1 - temp_v0);
-- line 2842 ----------------------------------------
-- line 2893 ----------------------------------------
      .           }
      .           
      .           void func_8005DAD8(UnkPlayerStruct258* arg0, s16 arg1, s16 arg2, s16 arg3) {
      .               arg0->unk_038 = arg1;
      .               arg0->unk_03E = arg3;
      .               arg0->unk_040 = arg2;
      .           }
      .           
304,640 ( 0.00%)  void func_8005DAF4(Player* player, s16 arg1, s32 arg2, UNUSED s8 arg3, UNUSED s8 arg4) {
      .               UNUSED s32 stackPadding;
      .               s32 surfaceType;
      .               s32 var_t3;
      .               f32 var_f2;
      .               f32 var_f12;
      .               f32 var_f14;
      .               s32 temp_v0;
      .               static s32 test = 8;
      .           
      .               surfaceType = 0x000000FF;
 76,160 ( 0.00%)      temp_v0 = random_int(test);
1,389,665 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_int (38,080x)
 76,160 ( 0.00%)      if ((temp_v0 == 0) || (temp_v0 == 4)) {
  9,525 ( 0.00%)          var_f2 = player->tyres[BACK_LEFT].pos[0];
 19,050 ( 0.00%)          var_f12 = player->tyres[BACK_LEFT].baseHeight + 2.0f;
  9,525 ( 0.00%)          var_f14 = player->tyres[BACK_LEFT].pos[2];
      .                   var_t3 = 1;
 19,050 ( 0.00%)          surfaceType = player->tyres[BACK_LEFT].surfaceType;
      .               }
 57,110 ( 0.00%)      if ((temp_v0 == 2) || (temp_v0 == 6)) {
  9,469 ( 0.00%)          var_f2 = player->tyres[BACK_RIGHT].pos[0];
 18,938 ( 0.00%)          var_f12 = player->tyres[BACK_RIGHT].baseHeight + 2.0f;
  9,469 ( 0.00%)          var_f14 = player->tyres[BACK_RIGHT].pos[2];
  9,469 ( 0.00%)          var_t3 = 0;
 18,938 ( 0.00%)          surfaceType = player->tyres[BACK_RIGHT].surfaceType;
      .               }
 39,263 ( 0.00%)      switch (surfaceType) {
      .                   case DIRT:
      .                       if ((arg1 == 0) &&
      .                           ((player->unk_258[10 + arg2].unk_01E > 0) || (player->unk_258[10 + arg2].unk_01C == 0))) {
      .                           if (((player->unk_094 / 18.0f) * 216.0f) >= 10.0f) {
      .                               func_8005D794(player, &player->unk_258[10 + arg1], var_f2, var_f12, var_f14, (s8) surfaceType,
      .                                             (s8) var_t3);
      .                               func_8005D7D8(&player->unk_258[10 + arg1], 2, 0.46f);
      .                               if ((GetCourse() == GetChocoMountain()) || (GetCourse() == GetRoyalRaceway())) {
-- line 2935 ----------------------------------------
-- line 3115 ----------------------------------------
      .                           func_8005D7D8(&player->unk_258[10 + arg1], 2, 0.46f);
      .                           func_8005DAD8(&player->unk_258[10 + arg1], 0, 0, 0x0080);
      .                           player->unk_258[10 + arg1].unk_03A = random_int(0x0010U);
      .                       }
      .                       break;
      .                   default:
      .                       break;
      .               }
228,480 ( 0.00%)  }
      .           
      .           void func_8005EA94(Player* player, s16 arg1, s32 arg2, s8 arg3, UNUSED s8 arg4) {
      .               s32 temp_v0;
      .               s32 var_t0;
      .               s32 var_t1;
      .               f32 var_f2;
      .               f32 var_f12;
      .               f32 var_f14;
-- line 3131 ----------------------------------------
-- line 3551 ----------------------------------------
      .                   default:
      .                       break;
      .               }
      .           }
      .           #else
      .           GLOBAL_ASM("asm/non_matchings/code_80057C60/func_8005F90C.s")
      .           #endif
      .           
147,933 ( 0.00%)  void func_80060504(Player* player, s16 arg1, s32 arg2, UNUSED s8 arg3, UNUSED s8 arg4) {
      .               UNUSED s32 thing1;
      .               s16 thing2;
      .               UNUSED s32 thing3;
      .               f32 sp50;
      .               f32 sp4C;
      .               f32 sp48;
      .               f32 var_f0;
      .               s32 var_v0;
      .               s32 temp_v0;
      .               UNUSED s32 test;
      .           
 32,874 ( 0.00%)      if ((player->unk_044 & 0x20) == 0x20) {
 65,748 ( 0.00%)          var_v0 = 5;
      .               } else {
 16,437 ( 0.00%)          var_v0 = 0xE;
      .               }
 16,437 ( 0.00%)      temp_v0 = random_int(var_v0);
600,027 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:random_int (16,437x)
 65,748 ( 0.00%)      if ((temp_v0 == 1) || (temp_v0 == 2) || (temp_v0 == 3)) {
 22,973 ( 0.00%)          if ((arg1 == 0) && ((player->unk_258[arg2].unk_01E > 0) || (player->unk_258[arg2].unk_01C == 0))) {
    738 ( 0.00%)              sp4C = player->pos[1] - 2.5;
    492 ( 0.00%)              sp48 = player->pos[2];
    492 ( 0.00%)              sp50 = player->pos[0];
  1,476 ( 0.00%)              func_8005D794(player, &player->unk_258[arg1], sp50, sp4C, sp48, 0, 0);
  3,444 ( 0.00%)  => src/code_80057C60.c:func_8005D794 (246x)
  1,230 ( 0.00%)              func_8005D7D8(&player->unk_258[arg1], 1, 0.5f);
  1,230 ( 0.00%)  => src/code_80057C60.c:func_8005D7D8 (246x)
  8,358 ( 0.00%)          } else if (player->unk_258[arg2].unk_01E > 0) {
  4,773 ( 0.00%)              sp4C = player->pos[1] - 2.5;
  3,182 ( 0.00%)              sp48 = player->pos[2];
  3,182 ( 0.00%)              sp50 = player->pos[0];
 73,703 ( 0.00%)              func_8005D794(player, &player->unk_258[arg1], sp50, sp4C, sp48, 0, 0);
 22,274 ( 0.00%)  => src/code_80057C60.c:func_8005D794 (1,591x)
  7,955 ( 0.00%)              func_8005D7D8(&player->unk_258[arg1], 1, 0.5f);
  7,955 ( 0.00%)  => src/code_80057C60.c:func_8005D7D8 (1,591x)
      .                   }
      .               }
 49,311 ( 0.00%)      player->unk_258[arg1].unk_024 = 0.0f;
 32,874 ( 0.00%)      if ((player->unk_044 & 0x20) == 0x20) {
  2,392 ( 0.00%)          player->unk_258[arg1].unk_040 = 0;
 37,658 ( 0.00%)          if ((player->effects & BOOST_EFFECT) == BOOST_EFFECT) {
      .                       func_8005D800(&player->unk_258[arg1], 0x00FFFF00, 0x0080);
      .                       player->unk_258[arg1].unk_038 = 1;
      .                   } else {
 65,748 ( 0.00%)              func_8005D800(&player->unk_258[arg1], 0x00FFFFFF, 0x0070);
230,118 ( 0.00%)  => src/code_80057C60.c:func_8005D800 (16,437x)
 49,311 ( 0.00%)              player->unk_258[arg1].unk_038 = 0;
      .                   }
      .               } else {
 14,045 ( 0.00%)          player->unk_258[arg1].unk_040 = 1;
 28,090 ( 0.00%)          if ((player->effects & BOOST_EFFECT) == BOOST_EFFECT) {
      .                       func_8005D800(&player->unk_258[arg1], 0x00FFFF00, 0x0080);
      .                       player->unk_258[arg1].unk_038 = 1;
      .                   } else {
      .                       func_8005D800(&player->unk_258[arg1], 0x00FFFFFF, 0x0070);
      .                       player->unk_258[arg1].unk_038 = 0;
      .                   }
      .               }
 98,622 ( 0.00%)      thing2 = (player->unk_258[arg1].unk_020 - (player->unk_0C0 / 2));
 32,874 ( 0.00%)      if (player->unk_258[arg1].unk_040 == 0) {
 23,613 ( 0.00%)          var_f0 = -((player->unk_098 / 3000.0f) + 0.1);
      .               } else {
 56,180 ( 0.00%)          var_f0 = -((player->unk_098 / 5000.0f) + 0.1);
      .               }
279,429 ( 0.00%)      func_80062B18(&sp50, &sp4C, &sp48, 0.0f, 4.5f, (player->unk_258[arg1].unk_01E * var_f0) + -5.5, -thing2,
2,350,491 ( 0.00%)  => src/code_80057C60.c:func_80062B18 (16,437x)
 49,311 ( 0.00%)                    -player->unk_206 * 2);
 65,748 ( 0.00%)      player->unk_258[arg1].unk_000[0] = player->pos[0] + sp50;
 49,311 ( 0.00%)      sp4C = sp4C + (player->pos[1] - player->boundingBoxSize);
 49,311 ( 0.00%)      player->unk_258[arg1].unk_000[2] = player->pos[2] + sp48;
 16,437 ( 0.00%)      player->unk_258[arg1].unk_000[1] = player->unk_258[arg1].unk_024 + sp4C;
 16,437 ( 0.00%)      player->unk_258[arg1].unk_010 = 0;
115,059 ( 0.00%)  }
      .           
      .           void func_800608E0(Player* player, s16 arg1, UNUSED s32 arg2, s8 arg3, UNUSED s8 arg4) {
      .               f32 var_f0;
      .               f32 sp50;
      .               f32 sp4C;
      .               f32 sp48;
      .           
      .               var_f0 = 8.0f - (D_801652A0[arg3] - player->pos[1]);
-- line 3633 ----------------------------------------
-- line 4187 ----------------------------------------
      .           void func_80062AA8(Player* player, UNUSED s8 arg1, UNUSED s8 arg2, s8 arg3) {
      .               player->unk_258[20 + arg3].unk_01C = 1;
      .               player->unk_258[20 + arg3].unk_012 = 5;
      .               player->unk_258[20 + arg3].unk_00C = 0.1f;
      .               player->unk_258[20 + arg3].unk_01E = 0;
      .               player->unk_258[20 + arg3].unk_000[1] = (player->pos[1] + player->boundingBoxSize) - 2.5;
      .           }
      .           
524,563 ( 0.00%)  void func_80062B18(f32* arg0, f32* arg1, f32* arg2, f32 arg3, f32 arg4, f32 arg5, u16 arg6, u16 arg7) {
      .               UNUSED f32 pad;
      .               f32 sp30;
      .               f32 sp2C;
      .               f32 sp28;
      .               f32 temp_f20;
      .           
      .               //  Apply the matrix multiplication:
      .               //  Matrix is the Jacobian for cartesian to spherical coordinates?
-- line 4203 ----------------------------------------
-- line 4204 ----------------------------------------
      .               //  Get the change in r, theta, and phi for a change in x, y, z?
      .               //
      .               // | arg0 |     | cos(arg6)*cos(arg7)  cos(arg6)*sin(arg7)   -sin(arg6) |     | arg3 |
      .               // |      |     |                                                       |     |      |
      .               // | arg1 |  =  | -sin(arg7)           cos(arg7)                 0      |  X  | arg4 |
      .               // |      |     |                                                       |     |      |
      .               // | arg2 |     | sin(arg6)*cos(arg7)  sin(arg6)*sin(arg7)    cos(arg6) |     | arg5 |
      .               //
161,404 ( 0.00%)      sp28 = sins(arg7);
201,755 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (40,351x)
161,404 ( 0.00%)      sp2C = coss(arg6);
242,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (40,351x)
121,053 ( 0.00%)      sp30 = coss(arg7);
242,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (40,351x)
 80,702 ( 0.00%)      temp_f20 = coss(arg6);
242,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (40,351x)
      .               //    = arg3 * cos(arg6) * cos(arg7) + arg4 * cos(arg6) * sin(arg7) - arg5 * sin(arg6)
484,212 ( 0.00%)      *arg0 = (((arg3 * temp_f20) * sp30) + (arg4 * sp2C) * sp28) - (sins(arg6) * arg5);
201,755 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (40,351x)
      .           
121,053 ( 0.00%)      temp_f20 = sins(arg7);
201,755 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (40,351x)
      .               //    = -arg3 * sin(arg7) + arg4 * cos(arg7)
242,106 ( 0.00%)      *arg1 = (coss(arg7) * arg4) - (arg3 * temp_f20);
242,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (40,351x)
      .           
121,053 ( 0.00%)      sp28 = sins(arg7);
201,755 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (40,351x)
121,053 ( 0.00%)      sp2C = sins(arg6);
201,755 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (40,351x)
121,053 ( 0.00%)      sp30 = coss(arg7);
242,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (40,351x)
121,053 ( 0.00%)      temp_f20 = sins(arg6);
201,755 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:sins (40,351x)
      .               //    = arg3 * sin(arg6) * cos(arg7) + arg4 * sin(arg6) * sin(arg7) + arg5 * cos(arg6)
443,861 ( 0.00%)      *arg2 = (coss(arg6) * arg5) + (((arg3 * temp_f20) * sp30) + ((arg4 * sp2C) * sp28));
242,106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/math_util.c:coss (40,351x)
282,457 ( 0.00%)  }
      .           
238,073 ( 0.00%)  void func_80062C74(Player* player, s16 arg1, UNUSED s32 arg2, UNUSED s32 arg3) {
 43,286 ( 0.00%)      f32 sp48[8] = { 4.5f, 4.5f, 4.5f, 4.5f, 4.5f, 5.5f, 4.5f, 6.5f };
      .               f32 var_f6;
      .               f32 sp40;
      .               f32 sp3C;
      .               f32 sp38;
      .               s16 thing;
      .           
151,501 ( 0.00%)      player->unk_258[arg1].unk_01E += 1;
 43,286 ( 0.00%)      if (player->unk_258[arg1].unk_01E == 0x000C) {
  1,776 ( 0.00%)          player->unk_258[arg1].unk_01C = 0;
      .                   player->unk_258[arg1].unk_01E = 0;
  1,776 ( 0.00%)          player->unk_258[arg1].unk_012 = 0;
      .               }
 86,572 ( 0.00%)      player->unk_258[arg1].unk_018 = 2.0f;
 43,286 ( 0.00%)      if (player->unk_258[arg1].unk_040 == 0) {
 50,320 ( 0.00%)          player->unk_258[arg1].unk_00C = player->unk_258[arg1].unk_00C + 0.07;
 38,236 ( 0.00%)          player->unk_258[arg1].unk_024 = player->unk_258[arg1].unk_024 + 0.3;
 20,894 ( 0.00%)          if (player->unk_258[arg1].unk_01E >= 3) {
 28,580 ( 0.00%)              player->unk_258[arg1].unk_03E -= 3;
      .                   }
 21,532 ( 0.00%)          if (player->unk_258[arg1].unk_03E <= 0) {
  9,559 ( 0.00%)              player->unk_258[arg1].unk_03E = 0;
      .                   }
      .               } else {
 48,336 ( 0.00%)          player->unk_258[arg1].unk_00C = player->unk_258[arg1].unk_00C + 0.1;
 48,336 ( 0.00%)          player->unk_258[arg1].unk_024 = player->unk_258[arg1].unk_024 + 0.3;
 24,168 ( 0.00%)          if (player->unk_258[arg1].unk_01E >= 3) {
 30,204 ( 0.00%)              player->unk_258[arg1].unk_03E -= 2;
      .                   }
 24,168 ( 0.00%)          if (player->unk_258[arg1].unk_03E <= 0) {
 12,084 ( 0.00%)              player->unk_258[arg1].unk_03E = 0;
      .                   }
      .               }
129,858 ( 0.00%)      thing = player->unk_258[arg1].unk_020 - (player->unk_0C0 / 2);
      .               if (player->unk_258[arg1].unk_040 == 0) {
 47,795 ( 0.00%)          var_f6 = -((player->unk_098 / 5000.0f) + 0.1);
      .               } else {
 48,336 ( 0.00%)          var_f6 = -((player->unk_098 / 6000.0f) + 0.1);
      .               }
 64,929 ( 0.00%)      if (((player->effects & BOOST_EFFECT) == BOOST_EFFECT) && (player->unk_258[arg1].unk_01E >= 6)) {
      .                   player->unk_258[arg1].unk_00C = player->unk_258[arg1].unk_00C + 0.06;
      .               }
108,215 ( 0.00%)      player->unk_258[arg1].unk_010++;
      .               if (player->unk_258[arg1].unk_010 >= 3) {
 64,929 ( 0.00%)          player->unk_258[arg1].unk_010 = 0;
      .               }
324,645 ( 0.00%)      func_80062B18(&sp40, &sp38, &sp3C, 0.0f, sp48[player->characterId], (player->unk_258[arg1].unk_01E * var_f6) + -5.5,
3,094,949 ( 0.01%)  => src/code_80057C60.c:func_80062B18 (21,643x)
 64,929 ( 0.00%)                    -thing, -player->unk_206 * 2);
 86,572 ( 0.00%)      player->unk_258[arg1].unk_000[0] = player->pos[0] + sp40;
 64,929 ( 0.00%)      sp38 = (player->pos[1] - player->boundingBoxSize) + sp38;
 64,929 ( 0.00%)      player->unk_258[arg1].unk_000[2] = player->pos[2] + sp3C;
 21,643 ( 0.00%)      player->unk_258[arg1].unk_000[1] = player->unk_258[arg1].unk_024 + sp38;
173,144 ( 0.00%)  }
      .           
      .           void func_80062F98(Player* player, s16 arg1, s8 arg2, UNUSED s8 arg3) {
      .               f32 temp_f0;
      .           
      .               temp_f0 = player->unk_258[10 + arg1].unk_018 / 10.0f;
      .               ++player->unk_258[10 + arg1].unk_01E;
      .               player->unk_258[10 + arg1].unk_000[1] += temp_f0;
      .               if ((player->unk_0CA & 1) == 1) {
-- line 4292 ----------------------------------------
-- line 4966 ----------------------------------------
      .                       player->unk_0B6 &= ~0x0020;
      .                       player->unk_258[20 + arg3].unk_01C = 0;
      .                       player->unk_258[20 + arg3].unk_01E = 0;
      .                       player->unk_258[20 + arg3].unk_012 = 0;
      .                   }
      .               }
      .           }
      .           
 29,004 ( 0.00%)  void func_800652D4(Vec3f arg0, Vec3s arg1, f32 arg2) {
      .               Mat4 sp20;
      .           
 19,336 ( 0.00%)      mtxf_translate_rotate(sp20, arg0, arg1);
488,234 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_player.c:mtxf_translate_rotate (4,834x)
 14,502 ( 0.00%)      mtxf_scale2(sp20, arg2);
 91,846 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_player.c:mtxf_scale2 (4,834x)
 38,672 ( 0.00%)      convert_to_fixed_point_matrix(&gGfxPool->mtxEffect[gMatrixEffectCount], sp20);
178,858 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_player.c:convert_to_fixed_point_matrix (4,834x)
 48,340 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount]),
      .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
 24,170 ( 0.00%)  }
      .           
 38,672 ( 0.00%)  void func_8006538C(Player* player, s8 arg1, s16 arg2, s8 arg3) {
      .               Vec3f spB4;
      .               Vec3s spAC;
  9,668 ( 0.00%)      s32 primColors[] = { MAKE_RGB(0xFB, 0xFF, 0xFB), MAKE_RGB(0xFF, 0xFB, 0x86) };
  9,668 ( 0.00%)      s32 envColors[] = { MAKE_RGB(0x89, 0x62, 0x8F), MAKE_RGB(0xFE, 0x01, 0x09) };
      .               s16 primRed;
      .               s16 primGreen;
      .               s16 primBlue;
      .               s16 primAlpha;
      .               s16 envRed;
      .               s16 envGreen;
      .               s16 envBlue;
      .           
 29,004 ( 0.00%)      if (player->unk_258[arg2].unk_01C == 1) {
  9,668 ( 0.00%)          spB4[0] = player->unk_258[arg2].unk_000[0];
      .                   spB4[1] = player->unk_258[arg2].unk_000[1];
  9,668 ( 0.00%)          spB4[2] = player->unk_258[arg2].unk_000[2];
  4,834 ( 0.00%)          spAC[0] = 0;
 14,502 ( 0.00%)          spAC[1] = player->unk_048[arg3];
  4,834 ( 0.00%)          spAC[2] = 0;
  9,668 ( 0.00%)          if ((player->effects & STAR_EFFECT) && (((s32) gCourseTimer - D_8018D930[arg1]) < 9)) {
      .                       primRed = (primColors[1] >> 0x10) & 0xFF;
      .                       primGreen = (primColors[1] >> 0x08) & 0xFF;
      .                       primBlue = (primColors[1] >> 0x00) & 0xFF;
      .                       envRed = (envColors[1] >> 0x10) & 0xFF;
      .                       envGreen = (envColors[1] >> 0x08) & 0xFF;
      .                       envBlue = (envColors[1] >> 0x00) & 0xFF;
      .                       primAlpha = player->unk_258[arg2].unk_03E;
  9,668 ( 0.00%)              func_800652D4(spB4, spAC, ((player->unk_258[arg2].unk_00C * player->size) * 1.4));
      .                       gSPDisplayList(gDisplayListHead++, D_0D008DB8);
      .                       gDPLoadTextureBlock(gDisplayListHead++, common_texture_particle_smoke[player->unk_258[arg2].unk_010],
      .                                           G_IM_FMT_I, G_IM_SIZ_8b, 32, 32, 0, G_TX_NOMIRROR | G_TX_WRAP,
      .                                           G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
  4,834 ( 0.00%)              func_8004B72C(primRed, primGreen, primBlue, envRed, envGreen, envBlue, primAlpha);
      .                       gDPSetAlphaCompare(gDisplayListHead++, G_AC_DITHER);
      .                       gSPDisplayList(gDisplayListHead++, D_0D008E48);
      .                   } else {
 24,170 ( 0.00%)              primRed = (primColors[player->unk_258[arg2].unk_038] >> 0x10) & 0xFF;
      .                       primGreen = (primColors[player->unk_258[arg2].unk_038] >> 0x08) & 0xFF;
      .                       primBlue = (primColors[player->unk_258[arg2].unk_038] >> 0x00) & 0xFF;
 14,502 ( 0.00%)              envRed = (envColors[player->unk_258[arg2].unk_038] >> 0x10) & 0xFF;
      .                       envGreen = (envColors[player->unk_258[arg2].unk_038] >> 0x08) & 0xFF;
      .                       envBlue = (envColors[player->unk_258[arg2].unk_038] >> 0x00) & 0xFF;
      .                       primAlpha = player->unk_258[arg2].unk_03E;
 14,502 ( 0.00%)              func_800652D4(spB4, spAC, player->unk_258[arg2].unk_00C * player->size);
932,962 ( 0.00%)  => src/code_80057C60.c:func_800652D4 (4,834x)
 29,004 ( 0.00%)              gSPDisplayList(gDisplayListHead++, D_0D008DB8);
9,605,466 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (4,834x)
130,518 ( 0.00%)              gDPLoadTextureBlock(gDisplayListHead++, common_texture_particle_smoke[player->unk_258[arg2].unk_010],
      .                                           G_IM_FMT_I, G_IM_SIZ_8b, 32, 32, 0, G_TX_NOMIRROR | G_TX_WRAP,
      .                                           G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
 53,174 ( 0.00%)              func_8004B72C(primRed, primGreen, primBlue, envRed, envGreen, envBlue, primAlpha);
164,356 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004B72C (4,834x)
 33,838 ( 0.00%)              gSPDisplayList(gDisplayListHead++, D_0D008E48);
9,608,011 ( 0.02%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (4,834x)
      .                   }
  9,668 ( 0.00%)          gMatrixEffectCount += 1;
      .               }
 33,838 ( 0.00%)  }
      .           
      .           void func_800658A0(Player* player, UNUSED s8 arg1, s16 arg2, s8 arg3) {
      .               Vec3f sp54;
      .               Vec3s sp4C;
      .               s16 red;
      .               s16 green;
      .               s16 blue;
      .               s16 alpha;
-- line 5046 ----------------------------------------
-- line 6088 ----------------------------------------
      .           void func_8006B7E4(Player* player, s8 arg1) {
      .               func_8006A50C(player, 0.0f, 0.0f, arg1, (s8) 0, (s16) 0);
      .               func_8006A50C(player, 1.5f, 2.0f, arg1, (s8) 1, (s16) 0x1C70);
      .               func_8006A50C(player, -1.5f, 2.0f, arg1, (s8) 2, (s16) -0x1C70);
      .               gPlayerBalloonCount[arg1] = 2;
      .           }
      .           
      .           void func_8006B87C(UNUSED Player* player, s8 playerIndex) {
     40 ( 0.00%)      gPlayerBalloonStatus[playerIndex][0] = BALLOON_STATUS_GONE;
      .               gPlayerBalloonStatus[playerIndex][1] = BALLOON_STATUS_GONE;
      8 ( 0.00%)      gPlayerBalloonStatus[playerIndex][2] = BALLOON_STATUS_GONE;
      8 ( 0.00%)  }
      .           
      .           void func_8006B8B4(Player* player, s8 playerIndex) {
      .               if (gPlayerBalloonCount[playerIndex] >= 0) {
      .                   gPlayerBalloonStatus[playerIndex][gPlayerBalloonCount[playerIndex]] &= ~1;
      .                   gPlayerBalloonStatus[playerIndex][gPlayerBalloonCount[playerIndex]] |= 2;
      .                   gPlayerBalloonCount[playerIndex]--;
      .                   func_800C9060(playerIndex, SOUND_ARG_LOAD(0x19, 0x00, 0x90, 0x51));
      .                   if (gPlayerBalloonCount[playerIndex] < 0) {
-- line 6107 ----------------------------------------
-- line 6281 ----------------------------------------
      .               gDPLoadTextureBlock(gDisplayListHead++, common_texture_particle_spark[arg4], G_IM_FMT_I, G_IM_SIZ_8b, 32, 32, 0,
      .                                   G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
      .                                   G_TX_NOLOD);
      .               func_8004B414(red, green, blue, alpha);
      .               gSPDisplayList(gDisplayListHead++, D_0D008E48);
      .               gMatrixEffectCount += 1;
      .           }
      .           
 76,160 ( 0.00%)  void func_8006C6AC(Player* player, s16 arg1, s8 arg2, s8 arg3) {
      .               s8 arg2_copy = arg2;
      .               s32 sp28;
      .           
 38,080 ( 0.00%)      sp28 = arg1 - 1;
      .               if (sp28 < 0) {
152,320 ( 0.00%)          sp28 = 9;
      .               }
228,480 ( 0.00%)      if (player->unk_258[10 + arg1].unk_01C == 1) {
      .                   switch (player->unk_258[10 + arg1].unk_012) {
      .                       case 1:
 76,160 ( 0.00%)                  func_80063408(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       case 2:
      .                           func_800635D4(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       case 3:
      .                           func_80063BD4(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       case 4:
-- line 6308 ----------------------------------------
-- line 6316 ----------------------------------------
      .                           break;
      .                       case 11:
      .                           func_80062F98(player, arg1, arg2_copy, arg3);
      .                           break;
      .                       default:
      .                           break;
      .                   }
      .               } else {
 76,160 ( 0.00%)          if (player->unk_0DE & 1) {
      .                       func_80060BCC(player, arg1, sp28, arg2_copy, arg3);
114,240 ( 0.00%)          } else if (!(player->effects & 8) && !(player->effects & 2)) {
 76,160 ( 0.00%)              if (((player->effects & 0x10) == 0x10) && ((player->type & PLAYER_HUMAN) == PLAYER_HUMAN)) {
      .                           func_8005DA30(player, arg1, sp28, arg2_copy, arg3);
304,640 ( 0.00%)              } else if (((f64) (D_801652A0[arg2_copy] - player->tyres[BACK_RIGHT].baseHeight) >= 3.5) ||
 38,080 ( 0.00%)                         ((f64) (D_801652A0[arg2_copy] - player->tyres[BACK_LEFT].baseHeight) >= 3.5)) {
      .                           func_8005EA94(player, arg1, sp28, arg2_copy, arg3);
 76,160 ( 0.00%)              } else if (((player->effects & 0x80) == 0x80) || ((player->effects & 0x40) == 0x40)) {
      .                           func_8005F90C(player, arg1, sp28, arg2_copy, arg3);
 76,160 ( 0.00%)              } else if (((player->effects & 0x4000) && !(player->type & PLAYER_START_SEQUENCE)) ||
152,320 ( 0.00%)                         (player->effects & 0x800) || (player->effects & 0x20) || (player->unk_044 & 0x4000)) {
      .                           func_8005ED48(player, arg1, sp28, arg2_copy, arg3);
      .                       } else {
 38,080 ( 0.00%)                  func_8005DAF4(player, arg1, sp28, arg2_copy, arg3);
2,294,911 ( 0.00%)  => src/code_80057C60.c:func_8005DAF4 (38,080x)
      .                       }
      .                   }
      .               }
      .           }
      .           
 28,560 ( 0.00%)  void func_8006C9B8(Player* player, s16 arg1, s8 arg2, s8 arg3) {
      .               UNUSED s32 stackPadding;
      .               s32 sp28;
  4,760 ( 0.00%)      sp28 = arg1 - 1;
      .               if (sp28 < 0) {
 19,040 ( 0.00%)          sp28 = 9;
      .               }
 28,560 ( 0.00%)      if (player->unk_258[30 + arg1].unk_01C == 1) {
      .                   switch (player->unk_258[30 + arg1].unk_012) {
      .                       case 1:
      .                           func_800644E8(player, arg1, arg2, arg3);
      .                           break;
      .           
      .                       case 2:
      .                           func_800649F4(player, arg1, arg2, arg3);
      .                           break;
-- line 6359 ----------------------------------------
-- line 6385 ----------------------------------------
      .                       case 9:
      .                           func_80064664(player, arg1, arg2, arg3);
      .                           break;
      .           
      .                       default:
      .                           break;
      .                   }
      .               } else {
 14,280 ( 0.00%)          if (player->unk_044 & 0x1000) {
      .                       func_80061430(player, arg1, sp28, arg2, arg3);
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 28,560 ( 0.00%)          if (((((player->unk_0CA & 0x1000) == 0x1000) || ((player->unk_0E0 < 2) && (player->effects & 0x01000000))) ||
 19,040 ( 0.00%)               ((player->unk_0E0 < 2) && (player->effects & HIT_BY_ITEM_EFFECT))) ||
      .                       (player->effects & 0x400)) {
      .                       func_8006199C(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
  9,520 ( 0.00%)          if ((player->unk_0CA & 0x2000) == 0x2000) {
      .                       func_80061A34(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
  9,520 ( 0.00%)          if ((player->effects & STAR_EFFECT) && ((((s32) gCourseTimer) - D_8018D930[arg2]) < 9)) {
      .                       func_800615AC(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
 14,280 ( 0.00%)          if ((player->unk_046 & 8) == 8) {
      .                       func_800612F8(player, arg1, sp28, arg2, arg3);
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
  9,520 ( 0.00%)          if (((player->unk_046 & 0x20) == 0x20) && (((player->unk_094 / 18.0f) * 216.0f) >= 20.0f)) {
      .                       func_80061D4C(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
  9,520 ( 0.00%)          if ((player->effects & BOOST_EFFECT) && (player->type & PLAYER_HUMAN)) {
      .                       func_800621BC(player, arg1, sp28, arg2, arg3);
      .                       return;
      .                   }
  9,520 ( 0.00%)          if (((player->effects & 0x200000) || (player->effects & BOOST_RAMP_ASPHALT_EFFECT)) &&
      .                       ((player->type & PLAYER_HUMAN) == PLAYER_HUMAN)) {
      .                       func_80061EF4(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                       player->unk_044 &= ~0x0100;
      .                       return;
      .                   }
  9,520 ( 0.00%)          if ((player->unk_044 & 0x100) == 0x100) {
      .                       func_800624D8(player, arg1, sp28, arg2, arg3);
      .                       player->unk_046 &= ~0x0008;
      .                   }
      .               }
 19,040 ( 0.00%)  }
      .           
 38,080 ( 0.00%)  void func_8006CEC0(Player* arg0, s16 arg1, s8 arg2, s8 arg3) {
      .               UNUSED u16 temp_v0_3;
 38,080 ( 0.00%)      s32 sp20 = arg1;
      .               if (--sp20 < 0) {
152,320 ( 0.00%)          sp20 = 9;
      .               }
190,400 ( 0.00%)      if (arg0->unk_258[arg1].unk_01C == 1) {
151,501 ( 0.00%)          switch (arg0->unk_258[arg1].unk_012) {
      .                       case 1:
 64,929 ( 0.00%)                  func_80062C74(arg0, arg1, arg2, arg3);
5,325,775 ( 0.01%)  => src/code_80057C60.c:func_80062C74 (21,643x)
      .                           break;
      .                       case 3:
      .                           func_80064184(arg0, arg1, arg2, arg3);
      .                           break;
      .                       case 5:
      .                           func_800630C0(arg0, arg1, arg2, arg3);
      .                           break;
      .                       case 6:
      .                           func_800631A8(arg0, arg1, arg2, arg3);
      .                           break;
      .                       case 7:
      .                           func_80063268(arg0, arg1, arg2, arg3);
      .                           break;
      .                   }
      .               } else {
 32,874 ( 0.00%)          if ((arg0->unk_044 & 0x200) && (arg0->type & 0x4000)) {
      .                       func_80061224(arg0, arg1, sp20, arg2, arg3);
      .                       return;
 49,311 ( 0.00%)          } else if (((arg0->effects & 0x40000000) == 0x40000000) && (arg0->unk_0B0 < 0x32)) {
      .                       func_80061094(arg0, arg1, sp20, arg2, arg3);
      .                       return;
 32,874 ( 0.00%)          } else if ((arg0->type & 0x4000) == 0x4000) {
  8,199 ( 0.00%)              if ((arg0->unk_0DE & 8) == 8) {
      .                           func_80060F50(arg0, arg1, sp20, arg2, arg3);
      .                           return;
  5,466 ( 0.00%)              } else if ((arg0->unk_0DE & 2) || (arg0->unk_0DE & 1)) {
      .                           func_80060B14(arg0, arg1, sp20, arg2, arg3);
      .                           return;
      .                       }
      .                   }
 65,748 ( 0.00%)          switch (gActiveScreenMode) {
      .                       case SCREEN_MODE_1P:
 32,874 ( 0.00%)                  if (((arg0->effects & 0x04000000) != 0x04000000) && ((arg0->effects & 0x400) != 0x400) &&
      .                               ((arg0->effects & 0x01000000) != 0x01000000)) {
      .                               if (((arg0->unk_0CA & 2) != 2) && ((arg0->unk_0CA & 0x10) != 0x10) && !(arg0->unk_0CA & 0x100)) {
      .                                   func_80060504(arg0, arg1, sp20, arg2, arg3);
      .                               }
      .                           }
      .                           break;
      .                       default:
      .                           break;
      .                       case SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL:
      .                       case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
      .                       case SCREEN_MODE_3P_4P_SPLITSCREEN:
      .                           if (((arg0->type & 0x4000) != 0) && ((arg0->effects & 0x04000000) != 0x04000000) &&
      .                               ((arg0->effects & 0x400) != 0x400) && ((arg0->effects & 0x01000000) != 0x01000000)) {
 32,874 ( 0.00%)                      if (((arg0->unk_0CA & 2) != 2) && ((arg0->unk_0CA & 0x10) != 0x10) && !(arg0->unk_0CA & 0x100)) {
 65,748 ( 0.00%)                          func_80060504(arg0, arg1, sp20, arg2, arg3);
4,821,031 ( 0.01%)  => src/code_80057C60.c:func_80060504 (16,437x)
      .                               }
      .                           }
      .                           break;
      .                   }
      .               }
      .           }
      .           
  2,856 ( 0.00%)  void func_8006D194(Player* player, s8 arg1, s8 arg2) {
    952 ( 0.00%)      if (player->unk_258[0x14].unk_01C == 1) {
      .                   switch (player->unk_258[0x14].unk_012) {
      .                       case 2:
      .                           func_80064DEC(player, arg1, arg2, 0);
      .                           break;
      .                       case 3:
      .                           func_800650FC(player, arg1, arg2, 0);
      .                           break;
      .                       case 4:
-- line 6521 ----------------------------------------
-- line 6524 ----------------------------------------
      .                       case 5:
      .                           func_80064F88(player, arg1, arg2, 0);
      .                           break;
      .                       case 6:
      .                           func_80065030(player, arg1, arg2, 0);
      .                           break;
      .                   }
      .               } else {
  1,428 ( 0.00%)          if ((player->unk_0B6 & 0x40) == 0x40) {
      .                       func_800628C0(player, arg1, arg2, 0);
      .                   }
    952 ( 0.00%)          if ((player->unk_0B6 & 0x800) == 0x800) {
      .                       func_80062968(player, arg1, arg2, 0);
      .                   }
    952 ( 0.00%)          if ((player->unk_0B6 & 0x1000) == 0x1000) {
      .                       func_80062914(player, arg1, arg2, 0);
      .                   }
    952 ( 0.00%)          if ((player->unk_0B6 & 0x80) == 0x80) {
      .                       func_80062A18(player, arg1, arg2, 0);
      .                   }
    952 ( 0.00%)          if ((player->unk_0B6 & 0x100) == 0x100) {
      .                       func_800629BC(player, arg1, arg2, 0);
      .                   }
      .               }
    952 ( 0.00%)      if (player->unk_258[0x15].unk_01C == 1) {
      .                   if (player->unk_258[0x15].unk_012 == 5) {
      .                       func_800651F4(player, arg1, arg2, 1);
      .                   }
    952 ( 0.00%)      } else if ((player->unk_0B6 & 0x20) == 0x20) {
      .                   func_80062AA8(player, arg1, arg2, 1);
      .               }
  1,904 ( 0.00%)  }
      .           
 34,272 ( 0.00%)  void func_8006D474(Player* player, s8 playerId, s8 screenId) {
      .               s16 var_s2;
 39,141 ( 0.00%)      if ((player->unk_002 & (8 << (screenId * 4))) == (8 << (screenId * 4))) {
 42,440 ( 0.00%)          for (var_s2 = 0; var_s2 < 10; var_s2++) {
 55,372 ( 0.00%)              switch (player->unk_258[var_s2].unk_012) {
      .                           case 1:
  9,795 ( 0.00%)                      if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                                   if (screenId == playerId) {
  6,276 ( 0.00%)                              func_8006538C(player, playerId, var_s2, screenId);
      .                                   }
      .                               } else {
 25,993 ( 0.00%)                          func_8006538C(player, playerId, var_s2, screenId);
20,808,697 ( 0.04%)  => src/code_80057C60.c:func_8006538C (4,834x)
      .                               }
      .                               break;
      .                           case 6:
      .                               if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                                   if (screenId == playerId) {
      .                                       func_80066BAC(player, playerId, var_s2, screenId);
      .                                   }
      .                               } else if (screenId == playerId) {
      .                                   func_80066BAC(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
      .                       }
 67,997 ( 0.00%)              switch (player->unk_258[var_s2 + 30].unk_012) {
      .                           case 1:
      .                           case 9:
      .                               if (gActiveScreenMode == SCREEN_MODE_1P) {
      .                                   func_800691B8(player, playerId, var_s2, screenId);
      .                               } else if (screenId == playerId) {
      .                                   func_800691B8(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
-- line 6589 ----------------------------------------
-- line 6632 ----------------------------------------
      .                           case 8:
      .                               if (gActiveScreenMode == SCREEN_MODE_1P) {
      .                                   func_80067604(player, playerId, var_s2, screenId);
      .                               } else if (screenId == playerId) {
      .                                   func_80067604(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
      .                       }
 74,580 ( 0.00%)              switch (player->unk_258[var_s2 + 10].unk_012) {
      .                           case 1:
      .                               if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                                   if (screenId == playerId) {
      .                                       func_80065AB0(player, playerId, var_s2, screenId);
      .                                   }
      .                               } else {
      .                                   func_80065AB0(player, playerId, var_s2, screenId);
      .                               }
-- line 6648 ----------------------------------------
-- line 6675 ----------------------------------------
      .                                   }
      .                               } else if (screenId == playerId) {
      .                                   func_8006A01C(player, playerId, var_s2, screenId);
      .                               }
      .                               break;
      .                       }
      .                   }
      .               }
 11,424 ( 0.00%)      if ((gModeSelection == BATTLE) && (player->unk_002 & (2 << (screenId * 4)))) {
      .                   func_8006BA94(player, playerId, screenId);
      .               }
 33,647 ( 0.00%)  }
      .           
 11,424 ( 0.00%)  void func_8006DC54(Player* player, s8 arg1, s8 arg2) {
      .               s16 i;
      .               s32 bitwiseMask;
      .           
 15,232 ( 0.00%)      bitwiseMask = 8 << (arg2 * 4);
 11,424 ( 0.00%)      if (bitwiseMask == (player->unk_002 & bitwiseMask)) {
      .                   for (i = 0; i < 10; i++) {
 23,342 ( 0.00%)              if (player->unk_258[i].unk_012 == 7) {
      .                           func_800658A0(player, arg1, i, arg2);
      .                       }
      .                   }
      .               }
 15,232 ( 0.00%)  }
      .           
 11,424 ( 0.00%)  void func_8006DD3C(Player* arg0, s8 arg1, s8 arg2) {
      .               s16 temp_s0;
      .               s32 temp_v0;
      .           
 15,232 ( 0.00%)      temp_v0 = 8 << (arg2 * 4);
 11,424 ( 0.00%)      if (temp_v0 == (arg0->unk_002 & temp_v0)) {
      .                   for (temp_s0 = 0; temp_s0 < 10; ++temp_s0) {
 13,793 ( 0.00%)              temp_v0 = arg0->unk_258[temp_s0].unk_012;
 21,220 ( 0.00%)              if (temp_v0 != 3) {
 21,220 ( 0.00%)                  if (temp_v0 == 5) {
      .                               func_8006A280(arg0, arg1, temp_s0, arg2);
      .                           }
      .                       } else if (gActiveScreenMode == SCREEN_MODE_3P_4P_SPLITSCREEN) {
      .                           if (arg2 == arg1) {
      .                               func_80066998(arg0, arg1, temp_s0, arg2);
      .                           }
      .                       } else {
      .                           func_80066998(arg0, arg1, temp_s0, arg2);
      .                       }
      .                   }
      .           
    728 ( 0.00%)          if (((arg0->type & 0x4000) == 0x4000) && (arg2 == arg1)) {
  2,548 ( 0.00%)              switch (arg0->unk_258[20].unk_012) {
      .                           case 2:
      .                               func_80068310(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                           case 3:
      .                               func_80067964(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                           case 4:
      .                               func_80068724(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
-- line 6732 ----------------------------------------
-- line 6733 ----------------------------------------
      .                               break;
      .                           case 5:
      .                               func_80068AA4(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                           case 6:
      .                               func_80068DA0(arg0, arg1, arg0->unk_258[20].unk_00C, arg2, 0);
      .                               break;
      .                       }
    728 ( 0.00%)              if (arg0->unk_258[21].unk_012 == 5) {
      .                           func_80067D3C(arg0, arg2, D_8018D480, 1, 1.6f, 0xFFFFFF);
      .                           func_8006801C(arg0, arg2, D_8018D484, 1, 1.6f, 0xFF);
      .                       }
      .                   }
      .               }
 16,293 ( 0.00%)  }
      .           
    476 ( 0.00%)  void func_8006E058(void) {
  3,332 ( 0.00%)      switch (gActiveScreenMode) {
      .                   case SCREEN_MODE_1P:
  2,380 ( 0.00%)              switch (gModeSelection) {
      .                           case GRAND_PRIX:
  2,380 ( 0.00%)                      func_8006E420(gPlayerOne, 0, 0);
2,270,261 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerTwo, 1, 0);
1,947,354 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerThree, 2, 0);
1,972,995 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerFour, 3, 0);
1,955,016 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerFive, 4, 0);
1,964,137 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerSix, 5, 0);
1,948,409 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerSeven, 6, 0);
1,962,541 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
  2,380 ( 0.00%)                      func_8006E420(gPlayerEight, 7, 0);
1,944,590 ( 0.00%)  => src/code_80057C60.c:func_8006E420 (476x)
      .           
      .                               break;
      .                           case TIME_TRIALS:
      .                               func_8006E420(gPlayerOne, 0, 0);
      .           
      .                               if ((gPlayerTwo->type & 0x100) == 0x100) {
      .                                   func_8006E420(gPlayerTwo, 1, 0);
      .                               }
-- line 6769 ----------------------------------------
-- line 6789 ----------------------------------------
      .                               }
      .           
      .                               break;
      .                       }
      .           
      .                       break;
      .                   case SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL:
      .                   case SCREEN_MODE_2P_SPLITSCREEN_VERTICAL:
    952 ( 0.00%)              switch (gModeSelection) {
      .                           case GRAND_PRIX:
      .                               func_8006E420(gPlayerOne, 0, 0);
      .                               func_8006E420(gPlayerTwo, 1, 0);
      .                               func_8006E420(gPlayerThree, 2, 0);
      .                               func_8006E420(gPlayerFour, 3, 0);
      .                               func_8006E420(gPlayerFive, 4, 0);
      .                               func_8006E420(gPlayerSix, 5, 0);
      .                               func_8006E420(gPlayerSeven, 6, 0);
-- line 6805 ----------------------------------------
-- line 6832 ----------------------------------------
      .           
      .                           if (gPlayerCountSelection1 == 4) {
      .                               func_8006E420(gPlayerFour, 3, 0);
      .                           }
      .                       }
      .           
      .                       break;
      .               }
    476 ( 0.00%)  }
      .           
 30,464 ( 0.00%)  void func_8006E420(Player* player, s8 arg1, s8 arg2) {
      .               s16 temp_s0;
      .           
 11,424 ( 0.00%)      if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
  7,616 ( 0.00%)          if ((player->type & PLAYER_HUMAN) == PLAYER_HUMAN) {
  9,520 ( 0.00%)              func_8006D194(player, arg1, arg2);
 12,852 ( 0.00%)  => src/code_80057C60.c:func_8006D194 (476x)
      .                   }
      .           
114,240 ( 0.00%)          for (temp_s0 = 0; temp_s0 < 10; ++temp_s0) {
190,400 ( 0.00%)              func_8006CEC0(player, temp_s0, arg1, arg2);
11,108,084 ( 0.02%)  => src/code_80057C60.c:func_8006CEC0 (38,080x)
176,120 ( 0.00%)              if (((player->type & PLAYER_HUMAN) == PLAYER_HUMAN) || (gGamestate == ENDING)) {
 28,560 ( 0.00%)                  func_8006C9B8(player, temp_s0, arg1, arg2);
233,240 ( 0.00%)  => src/code_80057C60.c:func_8006C9B8 (4,760x)
      .                       }
190,400 ( 0.00%)              func_8006C6AC(player, temp_s0, arg1, arg2);
3,818,111 ( 0.01%)  => src/code_80057C60.c:func_8006C6AC (38,080x)
      .                   }
      .           
 11,424 ( 0.00%)          if (gModeSelection == BATTLE) {
      .                       func_8006B9CC(player, arg1);
      .                   }
      .               }
 22,848 ( 0.00%)  }
      .           
 11,424 ( 0.00%)  void render_kart_particle_on_screen_one(Player* player, s8 playerId, s8 screenId) {
  7,616 ( 0.00%)      if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
 11,424 ( 0.00%)          if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (playerId == screenId) {
  7,616 ( 0.00%)                  func_8006D474(player, playerId, screenId);
      .                       }
      .                   } else {
 22,848 ( 0.00%)              func_8006D474(player, playerId, screenId);
21,209,634 ( 0.04%)  => src/code_80057C60.c:func_8006D474 (3,808x)
      .                   }
 11,424 ( 0.00%)          func_8006DC54(player, playerId, screenId);
 76,654 ( 0.00%)  => src/code_80057C60.c:func_8006DC54 (3,808x)
      .               }
 11,424 ( 0.00%)  }
      .           
      .           void render_kart_particle_on_screen_two(Player* player, s8 arg1, s8 arg2) {
      .               if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
      .                   if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (arg1 == arg2) {
      .                           func_8006D474(player, arg1, arg2);
      .                       }
      .                   } else {
-- line 6883 ----------------------------------------
-- line 6909 ----------------------------------------
      .                   } else {
      .                       func_8006D474(player, arg1, arg2);
      .                   }
      .                   func_8006DC54(player, arg1, arg2);
      .               }
      .           }
      .           
      .           void func_8006E7CC(Player* player, s8 arg1, s8 arg2) {
  7,616 ( 0.00%)      if ((player->type & PLAYER_EXISTS) == PLAYER_EXISTS) {
 11,424 ( 0.00%)          if ((player->effects & BOO_EFFECT) == BOO_EFFECT) {
      .                       if (arg1 == arg2) {
 11,424 ( 0.00%)                  func_8006DD3C(player, arg1, arg2);
114,610 ( 0.00%)  => src/code_80057C60.c:func_8006DD3C (3,808x)
      .                       }
      .                   } else {
      .                       func_8006DD3C(player, arg1, arg2);
      .                   }
      .               }
      .           }
      .           
      .           void func_8006E848(Player* player, s8 arg1, s8 arg2) {
-- line 6928 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/fmt/core.h
--------------------------------------------------------------------------------
Ir               

-- line 416 ----------------------------------------
      .            private:
      .             const Char* data_;
      .             size_t size_;
      .           
      .            public:
      .             using value_type = Char;
      .             using iterator = const Char*;
      .           
  5,935 ( 0.00%)    constexpr basic_string_view() noexcept : data_(nullptr), size_(0) {}
      .           
      .             /** Constructs a string reference object from a C string and a size. */
      .             constexpr basic_string_view(const Char* s, size_t count) noexcept
      .                 : data_(s), size_(count) {}
      .           
      .             /**
      .               \rst
      .               Constructs a string reference object from a C string computing
      .               the size with ``std::char_traits<Char>::length``.
      .               \endrst
      .              */
      .             FMT_CONSTEXPR_CHAR_TRAITS
      .             FMT_INLINE
      .             basic_string_view(const Char* s)
    108 ( 0.00%)        : data_(s),
     54 ( 0.00%)          size_(detail::const_check(std::is_same<Char, char>::value &&
      .                                             !detail::is_constant_evaluated(true))
      .                             ? std::strlen(reinterpret_cast<const char*>(s))
      .                             : std::char_traits<Char>::length(s)) {}
      .           
      .             /** Constructs a string reference from a ``std::basic_string`` object. */
      .             template <typename Traits, typename Alloc>
      .             FMT_CONSTEXPR basic_string_view(
      .                 const std::basic_string<Char, Traits, Alloc>& s) noexcept
  4,609 ( 0.00%)        : data_(s.data()), size_(s.size()) {}
      .           
      .             template <typename S, FMT_ENABLE_IF(std::is_same<
      .                                                 S, detail::std_string_view<Char>>::value)>
      .             FMT_CONSTEXPR basic_string_view(S s) noexcept
      .                 : data_(s.data()), size_(s.size()) {}
      .           
      .             /** Returns a pointer to the string data. */
     14 ( 0.00%)    constexpr auto data() const noexcept -> const Char* { return data_; }
      .           
      .             /** Returns the string size. */
  5,944 ( 0.00%)    constexpr auto size() const noexcept -> size_t { return size_; }
      .           
      .             constexpr auto begin() const noexcept -> iterator { return data_; }
  9,880 ( 0.00%)    constexpr auto end() const noexcept -> iterator { return data_ + size_; }
      .           
      .             constexpr auto operator[](size_t pos) const noexcept -> const Char& {
      .               return data_[pos];
      .             }
      .           
      .             FMT_CONSTEXPR void remove_prefix(size_t n) noexcept {
      .               data_ += n;
      .               size_ -= n;
-- line 471 ----------------------------------------
-- line 788 ----------------------------------------
      .               using base::container;
      .             };
      .             return *accessor(it).container;
      .           }
      .           
      .           template <typename Char, typename InputIt, typename OutputIt>
      .           FMT_CONSTEXPR auto copy_str(InputIt begin, InputIt end, OutputIt out)
      .               -> OutputIt {
802,122 ( 0.00%)    while (begin != end) *out++ = static_cast<Char>(*begin++);
      .             return out;
      .           }
      .           
      .           template <typename Char, typename T, typename U,
      .                     FMT_ENABLE_IF(
      .                         std::is_same<remove_const_t<T>, U>::value&& is_char<U>::value)>
      .           FMT_CONSTEXPR auto copy_str(T* begin, T* end, U* out) -> U* {
      .             if (is_constant_evaluated()) return copy_str<Char, T*, U*>(begin, end, out);
      .             auto size = to_unsigned(end - begin);
  7,908 ( 0.00%)    if (size > 0) memcpy(out, begin, size * sizeof(U));
      .             return out + size;
      .           }
      .           
      .           /**
      .             \rst
      .             A contiguous memory buffer with an optional growing ability. It is an internal
      .             class and shouldn't be used directly, only via `~fmt::basic_memory_buffer`.
      .             \endrst
-- line 814 ----------------------------------------
-- line 820 ----------------------------------------
      .             size_t capacity_;
      .           
      .            protected:
      .             // Don't initialize ptr_ since it is not accessed to save a few cycles.
      .             FMT_MSC_WARNING(suppress : 26495)
      .             FMT_CONSTEXPR buffer(size_t sz) noexcept : size_(sz), capacity_(sz) {}
      .           
      .             FMT_CONSTEXPR20 buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) noexcept
 31,905 ( 0.00%)        : ptr_(p), size_(sz), capacity_(cap) {}
      .           
      .             FMT_CONSTEXPR20 ~buffer() = default;
      .             buffer(buffer&&) = default;
      .           
      .             /** Sets the buffer data and capacity. */
      .             FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  7,238 ( 0.00%)      ptr_ = buf_data;
  5,262 ( 0.00%)      capacity_ = buf_capacity;
      .             }
      .           
      .             /** Increases the buffer capacity to hold at least *capacity* elements. */
      .             // DEPRECATED!
      .             virtual FMT_CONSTEXPR20 void grow(size_t capacity) = 0;
      .           
      .            public:
      .             using value_type = T;
-- line 844 ----------------------------------------
-- line 849 ----------------------------------------
      .           
      .             FMT_INLINE auto begin() noexcept -> T* { return ptr_; }
      .             FMT_INLINE auto end() noexcept -> T* { return ptr_ + size_; }
      .           
      .             FMT_INLINE auto begin() const noexcept -> const T* { return ptr_; }
      .             FMT_INLINE auto end() const noexcept -> const T* { return ptr_ + size_; }
      .           
      .             /** Returns the size of this buffer. */
 13,800 ( 0.00%)    constexpr auto size() const noexcept -> size_t { return size_; }
      .           
      .             /** Returns the capacity of this buffer. */
  3,954 ( 0.00%)    constexpr auto capacity() const noexcept -> size_t { return capacity_; }
      .           
      .             /** Returns a pointer to the buffer data (not null-terminated). */
155,734 ( 0.00%)    FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
  1,976 ( 0.00%)    FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
      .           
      .             /** Clears this buffer. */
  5,919 ( 0.00%)    void clear() { size_ = 0; }
      .           
      .             // Tries resizing the buffer to contain *count* elements. If T is a POD type
      .             // the new elements may not be initialized.
      .             FMT_CONSTEXPR20 void try_resize(size_t count) {
      .               try_reserve(count);
 11,862 ( 0.00%)      size_ = count <= capacity_ ? count : capacity_;
      .             }
      .           
      .             // Tries increasing the buffer capacity to *new_capacity*. It can increase the
      .             // capacity by a smaller amount than requested but guarantees there is space
      .             // for at least one additional element either by increasing the capacity or by
      .             // flushing the buffer if it is full.
      .             FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
777,122 ( 0.00%)      if (new_capacity > capacity_) grow(new_capacity);
      .             }
      .           
608,608 ( 0.00%)    FMT_CONSTEXPR20 void push_back(const T& value) {
505,798 ( 0.00%)      try_reserve(size_ + 1);
758,697 ( 0.00%)      ptr_[size_++] = value;
442,624 ( 0.00%)    }
      .           
      .             /** Appends data to the end of the buffer. */
      .             template <typename U> void append(const U* begin, const U* end);
      .           
      .             template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
      .               return ptr_[index];
      .             }
      .             template <typename Idx>
-- line 895 ----------------------------------------
-- line 930 ----------------------------------------
      .            protected:
      .             FMT_CONSTEXPR20 void grow(size_t) override {
      .               if (this->size() == buffer_size) flush();
      .             }
      .           
      .             void flush() {
      .               auto size = this->size();
      .               this->clear();
  5,919 ( 0.00%)      out_ = copy_str<T>(data_, data_ + this->limit(size), out_);
      .             }
      .           
      .            public:
      .             explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
 15,784 ( 0.00%)        : Traits(n), buffer<T>(data_, 0, buffer_size), out_(out) {}
      .             iterator_buffer(iterator_buffer&& other)
      .                 : Traits(other), buffer<T>(data_, 0, buffer_size), out_(other.out_) {}
  3,946 ( 0.00%)    ~iterator_buffer() { flush(); }
      .           
      .             auto out() -> OutputIt {
      .               flush();
      .               return out_;
      .             }
      .             auto count() const -> size_t { return Traits::count() + this->size(); }
      .           };
      .           
-- line 954 ----------------------------------------
-- line 1179 ----------------------------------------
      .           };
      .           
      .           template <typename T, typename Char, size_t NUM_ARGS>
      .           struct arg_data<T, Char, NUM_ARGS, 0> {
      .             // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
      .             T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];
      .           
      .             template <typename... U>
  3,936 ( 0.00%)    FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
      .             FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
      .             FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
      .               return nullptr;
      .             }
      .           };
      .           
      .           template <typename Char>
      .           inline void init_named_args(named_arg_info<Char>*, int, int) {}
-- line 1195 ----------------------------------------
-- line 1919 ----------------------------------------
      .             FMT_CONSTEXPR auto type(int index) const -> detail::type {
      .               int shift = index * detail::packed_arg_bits;
      .               unsigned int mask = (1 << detail::packed_arg_bits) - 1;
      .               return static_cast<detail::type>((desc_ >> shift) & mask);
      .             }
      .           
      .             constexpr FMT_INLINE basic_format_args(unsigned long long desc,
      .                                                    const detail::value<Context>* values)
  5,255 ( 0.00%)        : desc_(desc), values_(values) {}
      .             constexpr basic_format_args(unsigned long long desc, const format_arg* args)
      .                 : desc_(desc), args_(args) {}
      .           
      .            public:
      .             constexpr basic_format_args() : desc_(0), args_(nullptr) {}
      .           
      .             /**
      .              \rst
-- line 1935 ----------------------------------------
-- line 2834 ----------------------------------------
      .           FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
      .               -> std::string {
      .             return vformat(fmt, fmt::make_format_args(args...));
      .           }
      .           
      .           /** Formats a string and writes the output to ``out``. */
      .           template <typename OutputIt,
      .                     FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
 15,784 ( 0.00%)  auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {
      .             auto&& buf = detail::get_buffer<char>(out);
  5,923 ( 0.00%)    detail::vformat_to(buf, fmt, args, {});
1,282,108 ( 0.00%)  => /usr/src/debug/fmt-10.2.1-5.fc40.x86_64/include/fmt/format.h:void fmt::v10::detail::vformat_to<char>(fmt::v10::detail::buffer<char>&, fmt::v10::basic_string_view<char>, fmt::v10::detail::vformat_args<char>::type, fmt::v10::detail::locale_ref) (1,973x)
  1,867 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      .             return detail::get_iterator(buf, out);
 17,757 ( 0.00%)  }
      .           
      .           /**
      .            \rst
      .            Formats ``args`` according to specifications in ``fmt``, writes the result to
      .            the output iterator ``out`` and returns the iterator past the end of the output
      .            range. `format_to` does not append a terminating null character.
      .           
      .            **Example**::
-- line 2854 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libultraship/src/resource/ResourceManager.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 6 ----------------------------------------
        .           #include <thread>
        .           #include "utils/StringHelper.h"
        .           #include "utils/glob.h"
        .           #include "public/bridge/consolevariablebridge.h"
        .           #include "Context.h"
        .           
        .           namespace Ship {
        .           
        1 ( 0.00%)  ResourceManager::ResourceManager() {
        1 ( 0.00%)  }
        .           
        .           void ResourceManager::Init(const std::vector<std::string>& otrFiles, const std::unordered_set<uint32_t>& validHashes,
       11 ( 0.00%)                             int32_t reservedThreadCount) {
        .               mResourceLoader = std::make_shared<ResourceLoader>();
        .               mArchiveManager = std::make_shared<ArchiveManager>();
        5 ( 0.00%)      GetArchiveManager()->Init(otrFiles, validHashes);
108,728,567 ( 0.18%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::Init(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::unordered_set<unsigned int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<unsigned int> > const&) (1x)
        .           
        .               // the extra `- 1` is because we reserve an extra thread for spdlog
        8 ( 0.00%)      size_t threadCount = std::max(1, (int32_t)(std::thread::hardware_concurrency() - reservedThreadCount - 1));
    1,318 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      520 ( 0.00%)  => /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/c++11/../../../../../libstdc++-v3/src/c++11/thread.cc:std::thread::hardware_concurrency() (1x)
        .               mThreadPool = std::make_shared<BS::thread_pool>(threadCount);
        .           
        .               if (!DidLoadSuccessfully()) {
        .                   // Nothing ever unpauses the thread pool since nothing will ever try to load the archive again.
        .                   mThreadPool->pause();
        .               }
        8 ( 0.00%)  }
        .           
        .           ResourceManager::~ResourceManager() {
        .               SPDLOG_INFO("destruct ResourceManager");
        .           }
        .           
        .           bool ResourceManager::DidLoadSuccessfully() {
        8 ( 0.00%)      return mArchiveManager != nullptr && mArchiveManager->IsArchiveLoaded();
        4 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::IsArchiveLoaded() (1x)
        .           }
        .           
        .           std::shared_ptr<File> ResourceManager::LoadFileProcess(const std::string& filePath,
    6,540 ( 0.00%)                                                         std::shared_ptr<ResourceInitData> initData) {
    3,270 ( 0.00%)      auto file = mArchiveManager->LoadFile(filePath, initData);
36,591,536 ( 0.06%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/archive/ArchiveManager.cpp:Ship::ArchiveManager::LoadFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::shared_ptr<Ship::ResourceInitData>) (654x)
    1,308 ( 0.00%)      if (file != nullptr) {
    2,616 ( 0.00%)          SPDLOG_TRACE("Loaded File {} on ResourceManager", file->InitData->Path);
   18,312 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::default_logger_raw() (654x)
        .               } else {
        .                   SPDLOG_TRACE("Could not load File {} in ResourceManager", filePath);
        .               }
        .               return file;
    5,886 ( 0.00%)  }
        .           
        .           std::shared_ptr<IResource> ResourceManager::LoadResourceProcess(const std::string& filePath, bool loadExact,
1,613,365 ( 0.00%)                                                                  std::shared_ptr<ResourceInitData> initData) {
        .               // Check for and remove the OTR signature
  248,210 ( 0.00%)      if (OtrSignatureCheck(filePath.c_str())) {
        .                   const auto newFilePath = filePath.substr(7);
  513,009 ( 0.00%)          return LoadResourceProcess(newFilePath, false, initData);
32,516,160 ( 0.06%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, std::shared_ptr<Ship::ResourceInitData>)'2 (57,001x)
        .               }
        .           
        .               // Attempt to load the alternate version of the asset, if we fail then we continue trying to load the standard
        .               // asset.
  335,520 ( 0.00%)      if (!loadExact && mAltAssetsEnabled && !filePath.starts_with(IResource::gAltAssetPrefix)) {
        .                   const auto altPath = IResource::gAltAssetPrefix + filePath;
        .                   auto altResource = LoadResourceProcess(altPath, loadExact, initData);
        .           
        .                   if (altResource != nullptr) {
        .                       return altResource;
        .                   }
        .               }
        .           
        .               // While waiting in the queue, another thread could have loaded the resource.
        .               // In a last attempt to avoid doing work that will be discarded, let's check if the cached version exists.
  335,520 ( 0.00%)      auto cacheLine = CheckCache(filePath, loadExact);
3,294,538 ( 0.01%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (10,103x)
  536,832 ( 0.00%)      auto cachedResource = GetCachedResource(cacheLine);
  353,049 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >) (10,103x)
  134,208 ( 0.00%)      if (cachedResource != nullptr) {
        .                   return cachedResource;
        .               }
        .           
        .               // Check for resource load errors which can indicate an alternate asset.
        .               // If we are attempting to load an alternate asset, we can return null
    2,616 ( 0.00%)      if (!loadExact && mAltAssetsEnabled && filePath.starts_with(IResource::gAltAssetPrefix)) {
        .                   if (std::holds_alternative<ResourceLoadError>(cacheLine)) {
        .                       try {
        .                           // If we have attempted to cache an alternate asset, but failed, we return nullptr and rely on the
        .                           // calling function to return a regular asset. If we have NOT attempted load already, attempt the load.
        .                           auto loadError = std::get<ResourceLoadError>(cacheLine);
        .                           if (loadError != ResourceLoadError::NotCached) {
        .                               return nullptr;
        .                           }
        .                       } catch (std::bad_variant_access const& e) {
        .                           // Ignore the exception. This should never happen. The last check should've returned the resource.
        .                       }
        .                   }
        .               }
        .           
        .               // Get the file from the OTR
    4,578 ( 0.00%)      auto file = LoadFileProcess(filePath, initData);
31,626,800 ( 0.05%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadFileProcess(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::shared_ptr<Ship::ResourceInitData>) (561x)
    1,308 ( 0.00%)      if (file == nullptr) {
        .                   SPDLOG_TRACE("Failed to load resource file at path {}", filePath);
        .               }
        .           
        .               // Transform the raw data into a resource
    1,962 ( 0.00%)      auto resource = GetResourceLoader()->LoadResource(file);
6,093,150 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/ResourceLoader.cpp:Ship::ResourceLoader::LoadResource(std::shared_ptr<Ship::File>) (561x)
        .           
        .               // Another thread could have loaded the resource while we were processing, so we want to check before setting to
        .               // the cache.
    3,270 ( 0.00%)      cachedResource = GetCachedResource(filePath, true);
  146,750 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (561x)
        .               {
        .                   const std::lock_guard<std::mutex> lock(mMutex);
        .           
    1,308 ( 0.00%)          if (cachedResource != nullptr) {
        .                       // If another thread has already loaded this resource, discard the work we already did and return from
        .                       // cache.
        .                       resource = cachedResource;
        .                   }
        .           
        .                   // Set the cache to the loaded resource
    1,308 ( 0.00%)          if (resource != nullptr) {
        .                       mResourceCache[filePath] = resource;
        .                   } else {
        .                       mResourceCache[filePath] = ResourceLoadError::NotFound;
        .                   }
        .               }
        .           
    1,308 ( 0.00%)      if (resource != nullptr) {
    1,962 ( 0.00%)          SPDLOG_TRACE("Loaded Resource {} on ResourceManager", filePath);
   15,708 ( 0.00%)  => /usr/src/debug/spdlog-1.12.0-4.fc40.x86_64/include/spdlog/spdlog-inl.h:spdlog::default_logger_raw() (561x)
        .               } else {
        .                   SPDLOG_TRACE("Resource load FAILED {} on ResourceManager", filePath);
        .               }
        .           
        .               return resource;
1,116,945 ( 0.00%)  }
        .           
        .           std::shared_future<std::shared_ptr<IResource>>
        .           ResourceManager::LoadResourceAsync(const std::string& filePath, bool loadExact, BS::priority_t priority,
3,252,780 ( 0.01%)                                     std::shared_ptr<ResourceInitData> initData) {
        .               // Check for and remove the OTR signature
  433,704 ( 0.00%)      if (OtrSignatureCheck(filePath.c_str())) {
        .                   auto newFilePath = filePath.substr(7);
  702,088 ( 0.00%)          return LoadResourceAsync(newFilePath, loadExact, priority);
90,030,878 ( 0.15%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>)'2 (87,761x)
        .               }
        .           
        .               // Check the cache before queueing the job.
        .               auto cacheCheck = GetCachedResource(filePath, loadExact);
  258,182 ( 0.00%)      if (cacheCheck) {
        .                   auto promise = std::make_shared<std::promise<std::shared_ptr<IResource>>>();
        .                   promise->set_value(cacheCheck);
        .                   return promise->get_future().share();
        .               }
        .           
        .               const auto newFilePath = std::string(filePath);
        .           
        .               return mThreadPool->submit_task(
        .                   std::bind(&ResourceManager::LoadResourceProcess, this, newFilePath, loadExact, initData), priority);
1,951,668 ( 0.00%)  }
        .           
        .           std::shared_ptr<IResource> ResourceManager::LoadResource(const std::string& filePath, bool loadExact,
1,290,910 ( 0.00%)                                                           std::shared_ptr<ResourceInitData> initData) {
1,032,728 ( 0.00%)      auto resource = LoadResourceAsync(filePath, loadExact, BS::pr::highest, initData).get();
156,434,199 ( 0.27%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::LoadResourceAsync(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool, short, std::shared_ptr<Ship::ResourceInitData>) (129,091x)
  258,182 ( 0.00%)      if (resource == nullptr) {
        .                   SPDLOG_ERROR("Failed to load resource file at path {}", filePath);
        .               }
        .               return resource;
1,161,819 ( 0.00%)  }
        .           
        .           std::variant<ResourceManager::ResourceLoadError, std::shared_ptr<IResource>>
1,968,490 ( 0.00%)  ResourceManager::CheckCache(const std::string& filePath, bool loadExact) {
  786,088 ( 0.00%)      if (!loadExact && mAltAssetsEnabled && !filePath.starts_with(IResource::gAltAssetPrefix)) {
        .                   const auto altPath = IResource::gAltAssetPrefix + filePath;
        .                   auto altCacheResult = CheckCache(altPath, loadExact);
        .           
        .                   // If the type held at this cache index is a resource, then we return it.
        .                   // Else we attempt to load standard definition assets.
        .                   if (std::holds_alternative<std::shared_ptr<IResource>>(altCacheResult)) {
        .                       return altCacheResult;
        .                   }
        .               }
        .           
        .               const std::lock_guard<std::mutex> lock(mMutex);
        .           
        .               auto resourceCacheFind = mResourceCache.find(filePath);
  585,018 ( 0.00%)      if (resourceCacheFind == mResourceCache.end()) {
        .                   return ResourceLoadError::NotCached;
        .               }
        .           
  195,006 ( 0.00%)      return resourceCacheFind->second;
1,771,641 ( 0.00%)  }
        .           
    4,578 ( 0.00%)  std::shared_ptr<IResource> ResourceManager::GetCachedResource(const std::string& filePath, bool loadExact) {
        .               // Gets the cached resource based on filePath.
1,292,872 ( 0.00%)      return GetCachedResource(CheckCache(filePath, loadExact));
12,315,080 ( 0.02%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::CheckCache(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) (41,330x)
1,484,707 ( 0.00%)  => libultraship/src/resource/ResourceManager.cpp:Ship::ResourceManager::GetCachedResource(std::variant<Ship::ResourceManager::ResourceLoadError, std::shared_ptr<Ship::IResource> >) (41,330x)
    5,232 ( 0.00%)  }
        .           
        .           std::shared_ptr<IResource>
1,177,170 ( 0.00%)  ResourceManager::GetCachedResource(std::variant<ResourceLoadError, std::shared_ptr<IResource>> cacheLine) {
        .               // Gets the cached resource based on a cache line std::variant from the cache map.
  393,698 ( 0.00%)      if (std::holds_alternative<std::shared_ptr<IResource>>(cacheLine)) {
        .                   try {
        .                       auto resource = std::get<std::shared_ptr<IResource>>(cacheLine);
        .           
  390,012 ( 0.00%)              if (resource.use_count() <= 0) {
        .                           return nullptr;
        .                       }
        .           
  780,024 ( 0.00%)              if (resource->IsDirty()) {
  390,012 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/resource/Resource.cpp:Ship::IResource::IsDirty() (195,006x)
        .                           return nullptr;
        .                       }
        .           
        .                       return resource;
        .                   } catch (std::bad_variant_access const& e) {
        .                       // Ignore the exception
        .                   }
        .               }
        .           
        .               return nullptr;
1,373,365 ( 0.00%)  }
        .           
        .           std::shared_ptr<std::vector<std::shared_future<std::shared_ptr<IResource>>>>
        .           ResourceManager::LoadDirectoryAsync(const std::string& searchMask, BS::priority_t priority) {
        .               auto loadedList = std::make_shared<std::vector<std::shared_future<std::shared_ptr<IResource>>>>();
        .               auto fileList = GetArchiveManager()->ListFiles(searchMask);
        .               loadedList->reserve(fileList->size());
        .           
        .               for (size_t i = 0; i < fileList->size(); i++) {
-- line 224 ----------------------------------------
-- line 260 ----------------------------------------
        .           void ResourceManager::UnloadDirectory(const std::string& searchMask) {
        .               auto list = GetArchiveManager()->ListFiles(searchMask);
        .           
        .               for (const auto& key : *list.get()) {
        .                   UnloadResource(key);
        .               }
        .           }
        .           
  344,126 ( 0.00%)  std::shared_ptr<ArchiveManager> ResourceManager::GetArchiveManager() {
        .               return mArchiveManager;
  172,063 ( 0.00%)  }
        .           
        6 ( 0.00%)  std::shared_ptr<ResourceLoader> ResourceManager::GetResourceLoader() {
        .               return mResourceLoader;
        3 ( 0.00%)  }
        .           
        .           size_t ResourceManager::UnloadResource(const std::string& filePath) {
        .               // Store a shared pointer here so that erase doesn't destruct the resource.
        .               // The resource will attempt to load other resources on the destructor, and this will fail because we already hold
        .               // the mutex.
        .               std::variant<ResourceLoadError, std::shared_ptr<IResource>> value = nullptr;
        .               size_t ret = 0;
        .               {
-- line 282 ----------------------------------------
-- line 283 ----------------------------------------
        .                   const std::lock_guard<std::mutex> lock(mMutex);
        .                   value = mResourceCache[filePath];
        .                   ret = mResourceCache.erase(filePath);
        .               }
        .           
        .               return ret;
        .           }
        .           
  179,456 ( 0.00%)  bool ResourceManager::OtrSignatureCheck(const char* fileName) {
        .               static const char* sOtrSignature = "__OTR__";
2,243,153 ( 0.00%)      return strncmp(fileName, sOtrSignature, strlen(sOtrSignature)) == 0;
1,578,879 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (67,104x)
  179,456 ( 0.00%)  }
        .           
        .           bool ResourceManager::IsAltAssetsEnabled() {
        .               return mAltAssetsEnabled;
        .           }
        .           
        .           void ResourceManager::SetAltAssetsEnabled(bool isEnabled) {
        .               mAltAssetsEnabled = isEnabled;
        .           }
        .           
        1 ( 0.00%)  } // namespace Ship

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/stormlib-src/src/SBaseCommon.cpp
--------------------------------------------------------------------------------
Ir                  

-- line 212 ----------------------------------------
         .           
         .           #define STORM_BUFFER_SIZE       0x500
         .           #define HASH_INDEX_MASK(ha) (ha->pHeader->dwHashTableSize ? (ha->pHeader->dwHashTableSize - 1) : 0)
         .           
         .           static DWORD StormBuffer[STORM_BUFFER_SIZE];    // Buffer for the decryption engine
         .           static bool  bMpqCryptographyInitialized = false;
         .           
         .           void InitializeMpqCryptography()
         4 ( 0.00%)  {
         1 ( 0.00%)      DWORD dwSeed = 0x00100001;
         .               DWORD index1 = 0;
         .               DWORD index2 = 0;
         .               int   i;
         .           
         .               // Initialize the decryption buffer.
         .               // Do nothing if already done.
         6 ( 0.00%)      if(bMpqCryptographyInitialized == false)
         .               {
       768 ( 0.00%)          for(index1 = 0; index1 < 0x100; index1++)
         .                   {
         .                       for(index2 = index1, i = 0; i < 5; i++, index2 += 0x100)
         .                       {
         .                           DWORD temp1, temp2;
         .           
    16,640 ( 0.00%)                  dwSeed = (dwSeed * 125 + 3) % 0x2AAAAB;
     1,280 ( 0.00%)                  temp1  = (dwSeed & 0xFFFF) << 0x10;
         .           
    16,640 ( 0.00%)                  dwSeed = (dwSeed * 125 + 3) % 0x2AAAAB;
     1,280 ( 0.00%)                  temp2  = (dwSeed & 0xFFFF);
         .           
     2,560 ( 0.00%)                  StormBuffer[index2] = (temp1 | temp2);
         .                       }
         .                   }
         .           
         .                   // Also register both MD5 and SHA1 hash algorithms
         2 ( 0.00%)          register_hash(&md5_desc);
       843 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/libtomcrypt/src/misc/crypt_register_hash.c:register_hash (1x)
         2 ( 0.00%)          register_hash(&sha1_desc);
       849 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/libtomcrypt/src/misc/crypt_register_hash.c:register_hash (1x)
         .           
         .                   // Use LibTomMath as support math library for LibTomCrypt
        27 ( 0.00%)          ltc_mp = ltm_desc;
         .           
         .                   // Don't do that again
         1 ( 0.00%)          bMpqCryptographyInitialized = true;
         .               }
         4 ( 0.00%)  }
         .           
         .           //
         .           // Note: Implementation of this function in WorldEdit.exe and storm.dll
         .           // incorrectly treats the character as signed, which leads to the
         .           // a buffer underflow if the character in the file name >= 0x80:
         .           // The following steps happen when *pbKey == 0xBF and dwHashType == 0x0000
         .           // (calculating hash index)
         .           //
-- line 264 ----------------------------------------
-- line 289 ----------------------------------------
         .               }
         .           
         .               return dwSeed1;
         .           }
         .           
         .           DWORD HashStringSlash(const char * szFileName, DWORD dwHashType)
         .           {
         .               LPBYTE pbKey   = (BYTE *)szFileName;
   520,776 ( 0.00%)      DWORD  dwSeed1 = 0x7FED7FED;
    86,796 ( 0.00%)      DWORD  dwSeed2 = 0xEEEEEEEE;
         .               DWORD  ch;
         .           
 9,113,511 ( 0.02%)      while(*pbKey != 0)
         .               {
         .                   // Convert the input character to uppercase
         .                   // DON'T convert slash (0x2F) to backslash (0x5C)
 5,844,218 ( 0.01%)          ch = AsciiToUpperTable_Slash[*pbKey++];
         .           
11,688,436 ( 0.02%)          dwSeed1 = StormBuffer[dwHashType + ch] ^ (dwSeed1 + dwSeed2);
 8,766,327 ( 0.01%)          dwSeed2 = ch + dwSeed1 + dwSeed2 + (dwSeed2 << 5) + 3;
         .               }
         .           
         .               return dwSeed1;
         .           }
         .           
         .           DWORD HashStringLower(const char * szFileName, DWORD dwHashType)
         .           {
         .               LPBYTE pbKey   = (BYTE *)szFileName;
-- line 316 ----------------------------------------
-- line 490 ----------------------------------------
         .                      ((DWORD)pbDataPointer[2] << 0x10) |
         .                      ((DWORD)pbDataPointer[3] << 0x18);
         .           }
         .           
         .           void DecryptMpqBlock(void * pvDataBlock, DWORD dwLength, DWORD dwKey1)
         .           {
         .               LPDWORD DataPointer = (LPDWORD)pvDataBlock;
         .               DWORD dwValue32;
        18 ( 0.00%)      DWORD dwKey2 = 0xEEEEEEEE;
         .           
         .               // Round to DWORDs
         .               dwLength >>= 2;
         .           
         .               // We need different approach on non-aligned buffers
         .               if(STORMLIB_DWORD_ALIGNED(DataPointer))
         .               {
 1,378,362 ( 0.00%)          for(DWORD i = 0; i < dwLength; i++)
         .                   {
         .                       // Modify the second key
   918,888 ( 0.00%)              dwKey2 += StormBuffer[MPQ_HASH_KEY2_MIX + (dwKey1 & 0xFF)];
         .           
         .                       // We can use 32-bit approach, when the buffer is aligned
 1,378,332 ( 0.00%)              DataPointer[i] = dwValue32 = DataPointer[i] ^ (dwKey1 + dwKey2);
         .           
 3,675,552 ( 0.01%)              dwKey1 = ((~dwKey1 << 0x15) + 0x11111111) | (dwKey1 >> 0x0B);
 1,837,776 ( 0.00%)              dwKey2 = dwValue32 + dwKey2 + (dwKey2 << 5) + 3;
         .                   }
         .               }
         .               else
         .               {
         .                   for(DWORD i = 0; i < dwLength; i++)
         .                   {
         .                       // Modify the second key
         .                       dwKey2 += StormBuffer[MPQ_HASH_KEY2_MIX + (dwKey1 & 0xFF)];
-- line 523 ----------------------------------------
-- line 705 ----------------------------------------
         .           
         .           //-----------------------------------------------------------------------------
         .           // Handle validation functions
         .           
         .           TMPQArchive * IsValidMpqHandle(HANDLE hMpq)
         .           {
         .               TMPQArchive * ha = (TMPQArchive *)hMpq;
         .           
    23,175 ( 0.00%)      return (ha != NULL && ha->pHeader != NULL && ha->pHeader->dwID == g_dwMpqSignature) ? ha : NULL;
         .           }
         .           
         .           TMPQFile * IsValidFileHandle(HANDLE hFile)
         .           {
         .               TMPQFile * hf = (TMPQFile *)hFile;
         .           
         .               // Must not be NULL
     7,980 ( 0.00%)      if(hf != NULL && hf->dwMagic == ID_MPQ_FILE)
         .               {
         .                   // Local file handle?
     5,985 ( 0.00%)          if(hf->pStream != NULL)
     7,980 ( 0.00%)              return hf;
         .           
         .                   // Also verify the MPQ handle within the file handle
     1,995 ( 0.00%)          if(IsValidMpqHandle(hf->ha))
         .                       return hf;
         .               }
         .           
     1,995 ( 0.00%)      return NULL;
         .           }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Hash table and block table manipulation
         .           
         .           // Attempts to search a free hash entry, or an entry whose names and locale matches
         .           TMPQHash * FindFreeHashEntry(TMPQArchive * ha, DWORD dwStartIndex, DWORD dwName1, DWORD dwName2, LCID lcFileLocale)
         .           {
-- line 740 ----------------------------------------
-- line 780 ----------------------------------------
         .           
         .               // If we found a deleted entry, return that one preferentially
         .               return (pDeletedEntry != NULL) ? pDeletedEntry : pFreeEntry;
         .           }
         .           
         .           // Retrieves the first hash entry for the given file.
         .           // Every locale version of a file has its own hash entry
         .           TMPQHash * GetFirstHashEntry(TMPQArchive * ha, const char * szFileName)
   125,244 ( 0.00%)  {
    71,568 ( 0.00%)      DWORD dwHashIndexMask = HASH_INDEX_MASK(ha);
    71,568 ( 0.00%)      DWORD dwStartIndex = ha->pfnHashString(szFileName, MPQ_HASH_TABLE_INDEX);
 7,496,088 ( 0.01%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (17,892x)
    71,568 ( 0.00%)      DWORD dwName1 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_A);
 7,496,088 ( 0.01%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (17,892x)
    71,568 ( 0.00%)      DWORD dwName2 = ha->pfnHashString(szFileName, MPQ_HASH_NAME_B);
 7,496,088 ( 0.01%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:HashStringSlash(char const*, unsigned int) (17,892x)
         .               DWORD dwIndex;
         .           
         .               // Set the initial index
    71,568 ( 0.00%)      dwStartIndex = dwIndex = (dwStartIndex & dwHashIndexMask);
         .           
         .               // Search the hash table
         .               for(;;)
         .               {
   101,511 ( 0.00%)          TMPQHash * pHash = ha->pHashTable + dwIndex;
         .           
         .                   // If the entry matches, we found it.
   187,005 ( 0.00%)          if(pHash->dwName1 == dwName1 && pHash->dwName2 == dwName2 && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
         .                       return pHash;
         .           
         .                   // If that hash entry is a free entry, it means we haven't found the file
    21,284 ( 0.00%)          if(pHash->dwBlockIndex == HASH_ENTRY_FREE)
       661 ( 0.00%)              return NULL;
         .           
         .                   // Move to the next hash entry. Stop searching
         .                   // if we got reached the original hash entry
    19,962 ( 0.00%)          dwIndex = (dwIndex + 1) & dwHashIndexMask;
    19,962 ( 0.00%)          if(dwIndex == dwStartIndex)
         .                       return NULL;
         .               }
   107,352 ( 0.00%)  }
         .           
         .           TMPQHash * GetNextHashEntry(TMPQArchive * ha, TMPQHash * pFirstHash, TMPQHash * pHash)
    17,231 ( 0.00%)  {
    68,924 ( 0.00%)      DWORD dwHashIndexMask = HASH_INDEX_MASK(ha);
    51,693 ( 0.00%)      DWORD dwStartIndex = (DWORD)(pFirstHash - ha->pHashTable);
    17,231 ( 0.00%)      DWORD dwName1 = pHash->dwName1;
    17,231 ( 0.00%)      DWORD dwName2 = pHash->dwName2;
    51,693 ( 0.00%)      DWORD dwIndex = (DWORD)(pHash - ha->pHashTable);
         .           
         .               // Now go for any next entry that follows the pHash,
         .               // until either free hash entry was found, or the start entry was reached
         .               for(;;)
         .               {
         .                   // Move to the next hash entry. Stop searching
         .                   // if we got reached the original hash entry
   106,378 ( 0.00%)          dwIndex = (dwIndex + 1) & dwHashIndexMask;
   106,378 ( 0.00%)          if(dwIndex == dwStartIndex)
    17,231 ( 0.00%)              return NULL;
   159,567 ( 0.00%)          pHash = ha->pHashTable + dwIndex;
         .           
         .                   // If the entry matches, we found it.
   159,567 ( 0.00%)          if(pHash->dwName1 == dwName1 && pHash->dwName2 == dwName2 && MPQ_BLOCK_INDEX(pHash) < ha->dwFileTableSize)
         .                       return pHash;
         .           
         .                   // If that hash entry is a free entry, it means we haven't found the file
   106,378 ( 0.00%)          if(pHash->dwBlockIndex == HASH_ENTRY_FREE)
         .                       return NULL;
         .               }
    17,231 ( 0.00%)  }
         .           
         .           // Allocates an entry in the hash table
         .           TMPQHash * AllocateHashEntry(
         .               TMPQArchive * ha,
         .               TFileEntry * pFileEntry,
         .               LCID lcFileLocale)
         .           {
         .               TMPQHash * pHash;
-- line 854 ----------------------------------------
-- line 917 ----------------------------------------
         .               // Give the free space position to the caller
         .               return FreeSpacePos;
         .           }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Common functions - MPQ File
         .           
         .           TMPQFile * CreateFileHandle(TMPQArchive * ha, TFileEntry * pFileEntry)
     3,325 ( 0.00%)  {
         .               TMPQFile * hf;
         .           
         .               // Allocate space for TMPQFile
     3,325 ( 0.00%)      hf = STORM_ALLOC(TMPQFile, 1);
   213,547 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:calloc (665x)
     1,330 ( 0.00%)      if(hf != NULL)
         .               {
         .                   // Fill the file structure
         .                   memset(hf, 0, sizeof(TMPQFile));
       665 ( 0.00%)          hf->dwMagic = ID_MPQ_FILE;
         .                   hf->pStream = NULL;
       665 ( 0.00%)          hf->ha = ha;
         .           
         .                   // If the called entered a file entry, we also copy informations from the file entry
     2,660 ( 0.00%)          if(ha != NULL && pFileEntry != NULL)
         .                   {
         .                       // Set the raw position and MPQ position
     3,990 ( 0.00%)              hf->RawFilePos = FileOffsetFromMpqOffset(ha, pFileEntry->ByteOffset);
     3,990 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseFileTable.cpp:FileOffsetFromMpqOffset(_TMPQArchive*, unsigned long long) (665x)
         .                       hf->MpqFilePos = pFileEntry->ByteOffset;
         .           
         .                       // Set the data size
     1,330 ( 0.00%)              hf->dwDataSize = pFileEntry->dwFileSize;
       665 ( 0.00%)              hf->pFileEntry = pFileEntry;
         .                   }
         .               }
         .           
         .               return hf;
     3,325 ( 0.00%)  }
         .           
         .           TMPQFile * CreateWritableHandle(TMPQArchive * ha, DWORD dwFileSize)
         .           {
         .               ULONGLONG FreeMpqSpace;
         .               ULONGLONG TempPos;
         .               TMPQFile * hf;
         .           
         .               // We need to find the position in the MPQ where we save the file data
-- line 960 ----------------------------------------
-- line 993 ----------------------------------------
         .           void * LoadMpqTable(
         .               TMPQArchive * ha,
         .               ULONGLONG ByteOffset,
         .               LPBYTE pbTableHash,
         .               DWORD dwCompressedSize,
         .               DWORD dwTableSize,
         .               DWORD dwKey,
         .               DWORD * PtrRealTableSize)
       126 ( 0.00%)  {
         9 ( 0.00%)      ULONGLONG FileSize = 0;
        18 ( 0.00%)      LPBYTE pbCompressed = NULL;
         .               LPBYTE pbMpqTable;
         .               LPBYTE pbToRead;
         9 ( 0.00%)      DWORD dwBytesToRead = dwCompressedSize;
         .               DWORD dwErrCode = ERROR_SUCCESS;
         .           
         .               // Allocate the MPQ table
        27 ( 0.00%)      pbMpqTable = pbToRead = STORM_ALLOC(BYTE, dwTableSize);
     2,109 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (9x)
        18 ( 0.00%)      if(pbMpqTable != NULL)
         .               {
         .                   // Check if the MPQ table is encrypted
        18 ( 0.00%)          if(dwCompressedSize < dwTableSize)
         .                   {
         .                       // Allocate temporary buffer for holding compressed data
         6 ( 0.00%)              pbCompressed = pbToRead = STORM_ALLOC(BYTE, dwCompressedSize);
       204 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (1x)
         2 ( 0.00%)              if(pbCompressed == NULL)
         .                       {
         .                           STORM_FREE(pbMpqTable);
         .                           return NULL;
         .                       }
         .                   }
         .           
         .                   // Get the file offset from which we will read the table
         .                   // Note: According to Storm.dll from Warcraft III (version 2002),
         .                   // if the hash table position is 0xFFFFFFFF, no SetFilePointer call is done
         .                   // and the table is loaded from the current file offset
        36 ( 0.00%)          if(ByteOffset == SFILE_INVALID_POS)
         .                       FileStream_GetPos(ha->pStream, &ByteOffset);
         .           
         .                   // On archives v 1.0, hash table and block table can go beyond EOF.
         .                   // Storm.dll reads as much as possible, then fills the missing part with zeros.
         .                   // Abused by Spazzler map protector which sets hash table size to 0x00100000
         .                   // Abused by NP_Protect in MPQs v4 as well
        27 ( 0.00%)          if(ha->pHeader->wFormatVersion == MPQ_FORMAT_VERSION_1)
         .                   {
         .                       // Cut the table size
         .                       FileStream_GetSize(ha->pStream, &FileSize);
         .                       if((ByteOffset + dwBytesToRead) > FileSize)
         .                       {
         .                           // Fill the extra data with zeros
         .                           dwBytesToRead = (DWORD)(FileSize - ByteOffset);
         .                           memset(pbMpqTable + dwBytesToRead, 0, (dwTableSize - dwBytesToRead));
         .                       }
         .                   }
         .           
         .                   // Give the caller information that the table was cut
        18 ( 0.00%)          if(PtrRealTableSize != NULL)
         .                   {
        12 ( 0.00%)              PtrRealTableSize[0] = dwBytesToRead;
         .                   }
         .           
         .                   // If everything succeeded, read the raw table from the MPQ
        63 ( 0.00%)          if(FileStream_Read(ha->pStream, &ByteOffset, pbToRead, dwBytesToRead))
       963 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/FileStream.cpp:FileStream_Read (9x)
         .                   {
         .                       // Verify the MD5 of the table, if present
         .                       if(!VerifyDataBlockHash(pbToRead, dwBytesToRead, pbTableHash))
         .                       {
         .                           dwErrCode = ERROR_FILE_CORRUPT;
         .                       }
         .                   }
         .                   else
         .                   {
         .                       dwErrCode = GetLastError();
         .                   }
         .           
         .                   if(dwErrCode == ERROR_SUCCESS)
         .                   {
         .                       // First of all, decrypt the table
        18 ( 0.00%)              if(dwKey != 0)
         .                       {
         .                           BSWAP_ARRAY32_UNSIGNED(pbToRead, dwCompressedSize);
         .                           DecryptMpqBlock(pbToRead, dwCompressedSize, dwKey);
         .                           BSWAP_ARRAY32_UNSIGNED(pbToRead, dwCompressedSize);
         .                       }
         .           
         .                       // If the table is compressed, decompress it
        18 ( 0.00%)              if(dwCompressedSize < dwTableSize)
         .                       {
         1 ( 0.00%)                  int cbOutBuffer = (int)dwTableSize;
         .                           int cbInBuffer = (int)dwCompressedSize;
         .           
         7 ( 0.00%)                  if(!SCompDecompress2(pbMpqTable, &cbOutBuffer, pbCompressed, cbInBuffer))
    18,832 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SCompression.cpp:SCompDecompress2 (1x)
         .                               dwErrCode = GetLastError();
         .                       }
         .           
         .                       // Make sure that the table is properly byte-swapped
         .                       BSWAP_ARRAY32_UNSIGNED(pbMpqTable, dwTableSize);
         .                   }
         .           
         .                   // If read failed, free the table and return
         .                   if(dwErrCode != ERROR_SUCCESS)
         .                   {
         .                       STORM_FREE(pbMpqTable);
         .                       pbMpqTable = NULL;
         .                   }
         .           
         .                   // Free the compression buffer, if any
        27 ( 0.00%)          if(pbCompressed != NULL)
         3 ( 0.00%)              STORM_FREE(pbCompressed);
        85 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (1x)
         .               }
         .           
         .               // Return the MPQ table
         .               return pbMpqTable;
        81 ( 0.00%)  }
         .           
         .           unsigned char * AllocateMd5Buffer(
         .               DWORD dwRawDataSize,
         .               DWORD dwChunkSize,
         .               LPDWORD pcbMd5Size)
         .           {
         .               unsigned char * md5_array;
         .               DWORD cbMd5Size;
-- line 1114 ----------------------------------------
-- line 1126 ----------------------------------------
         .               // Give the size of the MD5 array
         .               if(pcbMd5Size != NULL)
         .                   *pcbMd5Size = cbMd5Size;
         .               return md5_array;
         .           }
         .           
         .           // Allocates sector buffer and sector offset table
         .           DWORD AllocateSectorBuffer(TMPQFile * hf)
       665 ( 0.00%)  {
       665 ( 0.00%)      TMPQArchive * ha = hf->ha;
         .           
         .               // Caller of AllocateSectorBuffer must ensure these
     1,330 ( 0.00%)      assert(hf->pbFileSector == NULL);
     2,660 ( 0.00%)      assert(hf->pFileEntry != NULL);
     1,330 ( 0.00%)      assert(hf->ha != NULL);
         .           
         .               // Don't allocate anything if the file has zero size
     3,990 ( 0.00%)      if(hf->pFileEntry->dwFileSize == 0 || hf->dwDataSize == 0)
       665 ( 0.00%)          return ERROR_SUCCESS;
         .           
         .               // Determine the file sector size and allocate buffer for it
     2,654 ( 0.00%)      hf->dwSectorSize = (hf->pFileEntry->dwFlags & MPQ_FILE_SINGLE_UNIT) ? hf->dwDataSize : ha->dwSectorSize;
     1,995 ( 0.00%)      hf->pbFileSector = STORM_ALLOC(BYTE, hf->dwSectorSize);
   169,482 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (665x)
       665 ( 0.00%)      hf->dwSectorOffs = SFILE_INVALID_POS;
         .           
         .               // Return result
     1,330 ( 0.00%)      return (hf->pbFileSector != NULL) ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
     1,330 ( 0.00%)  }
         .           
         .           // Allocates sector offset table
         .           DWORD AllocatePatchInfo(TMPQFile * hf, bool bLoadFromFile)
         .           {
         .               TMPQArchive * ha = hf->ha;
         .               DWORD dwLength = sizeof(TPatchInfo);
         .           
         .               // The following conditions must be true
-- line 1161 ----------------------------------------
-- line 1213 ----------------------------------------
         .               // Save the final length to the patch header
         .               hf->pPatchInfo->dwLength = dwLength;
         .               hf->pPatchInfo->dwFlags  = 0x80000000;
         .               return ERROR_SUCCESS;
         .           }
         .           
         .           // Allocates sector offset table
         .           DWORD AllocateSectorOffsets(TMPQFile * hf, bool bLoadFromFile)
     4,613 ( 0.00%)  {
       659 ( 0.00%)      TMPQArchive * ha = hf->ha;
       659 ( 0.00%)      TFileEntry * pFileEntry = hf->pFileEntry;
         .               DWORD dwSectorOffsLen;
         .               bool bSectorOffsetTableCorrupt = false;
         .           
         .               // Caller of AllocateSectorOffsets must ensure these
     1,318 ( 0.00%)      assert(hf->SectorOffsets == NULL);
     1,318 ( 0.00%)      assert(hf->pFileEntry != NULL);
     2,636 ( 0.00%)      assert(hf->dwDataSize != 0);
     1,318 ( 0.00%)      assert(hf->ha != NULL);
         .           
         .               // If the file is stored as single unit, just set number of sectors to 1
     1,318 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_SINGLE_UNIT)
         .               {
         .                   hf->dwSectorCount = 1;
       659 ( 0.00%)          return ERROR_SUCCESS;
         .               }
         .           
         .               // Calculate the number of data sectors
         .               // Note that this doesn't work if the file size is zero
     3,295 ( 0.00%)      hf->dwSectorCount = ((hf->dwDataSize - 1) / hf->dwSectorSize) + 1;
         .           
         .               // Calculate the number of file sectors
       659 ( 0.00%)      dwSectorOffsLen = (hf->dwSectorCount + 1) * sizeof(DWORD);
         .           
         .               // If MPQ_FILE_SECTOR_CRC flag is set, there will either be extra DWORD
         .               // or an array of MD5's. Either way, we read at least 4 bytes more
         .               // in order to save additional read from the file.
       659 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_SECTOR_CRC)
     1,977 ( 0.00%)          dwSectorOffsLen += sizeof(DWORD);
         .           
         .               // Only allocate and load the table if the file is compressed
     1,318 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_COMPRESS_MASK)
         .               {
         .                   __LoadSectorOffsets:
         .           
         .                   // Allocate the sector offset table
     4,613 ( 0.00%)          hf->SectorOffsets = STORM_ALLOC(DWORD, (dwSectorOffsLen / sizeof(DWORD)));
    35,084 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (659x)
     1,318 ( 0.00%)          if(hf->SectorOffsets == NULL)
         .                       return ERROR_NOT_ENOUGH_MEMORY;
         .           
         .                   // Only read from the file if we are supposed to do so
     1,318 ( 0.00%)          if(bLoadFromFile)
         .                   {
     1,318 ( 0.00%)              ULONGLONG RawFilePos = hf->RawFilePos;
         .           
         .                       // Append the length of the patch info, if any
     1,977 ( 0.00%)              if(hf->pPatchInfo != NULL)
         .                       {
         .                           if((RawFilePos + hf->pPatchInfo->dwLength) < RawFilePos)
         .                               return ERROR_FILE_CORRUPT;
         .                           RawFilePos += hf->pPatchInfo->dwLength;
         .                       }
         .           
         .                       // Load the sector offsets from the file
     5,272 ( 0.00%)              if(!FileStream_Read(ha->pStream, &RawFilePos, hf->SectorOffsets, dwSectorOffsLen))
    71,349 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/FileStream.cpp:FileStream_Read (659x)
         .                       {
         .                           // Free the sector offsets
       659 ( 0.00%)                  STORM_FREE(hf->SectorOffsets);
         .                           hf->SectorOffsets = NULL;
         .                           return GetLastError();
         .                       }
         .           
         .                       // Swap the sector positions
         .                       BSWAP_ARRAY32_UNSIGNED(hf->SectorOffsets, dwSectorOffsLen);
         .           
         .                       // Decrypt loaded sector positions if necessary
     1,318 ( 0.00%)              if(pFileEntry->dwFlags & MPQ_FILE_ENCRYPTED)
         .                       {
         .                           // If we don't know the file key, try to find it.
         .                           if(hf->dwFileKey == 0)
         .                           {
         .                               hf->dwFileKey = DetectFileKeyBySectorSize(hf->SectorOffsets, ha->dwSectorSize, dwSectorOffsLen);
         .                               if(hf->dwFileKey == 0)
         .                               {
         .                                   STORM_FREE(hf->SectorOffsets);
-- line 1297 ----------------------------------------
-- line 1306 ----------------------------------------
         .           
         .                       //
         .                       // Validate the sector offset table
         .                       //
         .                       // Note: Some MPQ protectors put the actual file data before the sector offset table.
         .                       // In this case, the sector offsets are negative (> 0x80000000).
         .                       //
         .           
     5,777 ( 0.00%)              for(DWORD i = 0; i < hf->dwSectorCount; i++)
         .                       {
     2,482 ( 0.00%)                  DWORD dwSectorOffset1 = hf->SectorOffsets[i+1];
     1,241 ( 0.00%)                  DWORD dwSectorOffset0 = hf->SectorOffsets[i];
         .           
         .                           // Every following sector offset must be bigger than the previous one
     2,482 ( 0.00%)                  if(dwSectorOffset1 < dwSectorOffset0)
         .                           {
         .                               bSectorOffsetTableCorrupt = true;
         .                               break;
         .                           }
         .           
         .                           // The sector size must not be bigger than compressed file size
         .                           // Edit: Yes, but apparently, in original Storm.dll, the compressed
         .                           // size is not checked anywhere. However, we need to do this check
         .                           // in order to sector offset table malformed by MPQ protectors
     4,964 ( 0.00%)                  if((dwSectorOffset1 - dwSectorOffset0) > ha->dwSectorSize)
         .                           {
         .                               bSectorOffsetTableCorrupt = true;
         .                               break;
         .                           }
         .                       }
         .           
         .                       // If data corruption detected, free the sector offset table
         .                       if(bSectorOffsetTableCorrupt)
-- line 1338 ----------------------------------------
-- line 1347 ----------------------------------------
         .                       // They are mostly empty on WoW release MPQs, but on MPQs from PTR,
         .                       // they contain random non-zero data. Their meaning is unknown.
         .                       //
         .                       // These extra values are, however, included in the dwCmpSize in the file
         .                       // table. We cannot ignore them, because compacting archive would fail
         .                       //
         .           
         .                       // Clear the lower 2 bits in order to make sure that the value is aligned to 4 bytes
     3,295 ( 0.00%)              if((hf->SectorOffsets[0] & 0xFFFFFFFC) > dwSectorOffsLen)
         .                       {
         .                           // MPQ protectors put some ridiculous values there. We must limit the extra bytes
         .                           if(hf->SectorOffsets[0] > (dwSectorOffsLen + 0x400))
         .                               return ERROR_FILE_CORRUPT;
         .           
         .                           // Free the old sector offset table
         .                           dwSectorOffsLen = hf->SectorOffsets[0];
         .                           STORM_FREE(hf->SectorOffsets);
-- line 1363 ----------------------------------------
-- line 1367 ----------------------------------------
         .                   else
         .                   {
         .                       memset(hf->SectorOffsets, 0, dwSectorOffsLen);
         .                       hf->SectorOffsets[0] = dwSectorOffsLen;
         .                   }
         .               }
         .           
         .               return ERROR_SUCCESS;
     5,272 ( 0.00%)  }
         .           
         .           DWORD AllocateSectorChecksums(TMPQFile * hf, bool bLoadFromFile)
        15 ( 0.00%)  {
         3 ( 0.00%)      TMPQArchive * ha = hf->ha;
         3 ( 0.00%)      TFileEntry * pFileEntry = hf->pFileEntry;
         .               ULONGLONG RawFilePos;
         .               DWORD dwCompressedSize = 0;
         .               DWORD dwExpectedSize;
         .               DWORD dwCrcOffset;                      // Offset of the CRC table, relative to file offset in the MPQ
         .               DWORD dwCrcSize;
         .           
         .               // Caller of AllocateSectorChecksums must ensure these
         6 ( 0.00%)      assert(hf->SectorChksums == NULL);
        12 ( 0.00%)      assert(hf->SectorOffsets != NULL);
         6 ( 0.00%)      assert(hf->pFileEntry != NULL);
         6 ( 0.00%)      assert(hf->ha != NULL);
         .           
         .               // Single unit files don't have sector checksums
         9 ( 0.00%)      if(pFileEntry->dwFlags & MPQ_FILE_SINGLE_UNIT)
         3 ( 0.00%)          return ERROR_SUCCESS;
         .           
         .               // Caller must ensure that we are only called when we have sector checksums
         6 ( 0.00%)      assert(pFileEntry->dwFlags & MPQ_FILE_SECTOR_CRC);
         .           
         .               //
         .               // Older MPQs store an array of CRC32's after
         .               // the raw file data in the MPQ.
         .               //
         .               // In newer MPQs, the (since Cataclysm BETA) the (attributes) file
         .               // contains additional 32-bit values beyond the sector table.
         .               // Their number depends on size of the (attributes), but their
         .               // meaning is unknown. They are usually zeroed in retail game files,
         .               // but contain some sort of checksum in BETA MPQs
         .               //
         .           
         .               // Does the size of the file table match with the CRC32-based checksums?
         6 ( 0.00%)      dwExpectedSize = (hf->dwSectorCount + 2) * sizeof(DWORD);
        15 ( 0.00%)      if(hf->SectorOffsets[0] != 0 && hf->SectorOffsets[0] == dwExpectedSize)
         .               {
         .                   // If we are not loading from the MPQ file, we just allocate the sector table
         .                   // In that case, do not check any sizes
         6 ( 0.00%)          if(bLoadFromFile == false)
         .                   {
         6 ( 0.00%)              hf->SectorChksums = STORM_ALLOC(DWORD, hf->dwSectorCount);
         .                       if(hf->SectorChksums == NULL)
         .                           return ERROR_NOT_ENOUGH_MEMORY;
         .           
         .                       // Fill the checksum table with zeros
         .                       memset(hf->SectorChksums, 0, hf->dwSectorCount * sizeof(DWORD));
         .                       return ERROR_SUCCESS;
         .                   }
         .                   else
         .                   {
         .                       // Is there valid size of the sector checksums?
        15 ( 0.00%)              if(hf->SectorOffsets[hf->dwSectorCount + 1] >= hf->SectorOffsets[hf->dwSectorCount])
         6 ( 0.00%)                  dwCompressedSize = hf->SectorOffsets[hf->dwSectorCount + 1] - hf->SectorOffsets[hf->dwSectorCount];
         .           
         .                       // Ignore cases when the length is too small or too big.
        12 ( 0.00%)              if(dwCompressedSize < sizeof(DWORD) || dwCompressedSize > hf->dwSectorSize)
         .                           return ERROR_SUCCESS;
         .           
         .                       // Calculate offset of the CRC table
         .                       dwCrcSize = hf->dwSectorCount * sizeof(DWORD);
         .                       dwCrcOffset = hf->SectorOffsets[hf->dwSectorCount];
         9 ( 0.00%)              RawFilePos = CalculateRawSectorOffset(hf, dwCrcOffset);
        48 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/stormlib-src/src/SBaseFileTable.cpp:CalculateRawSectorOffset(_TMPQFile*, unsigned int) (3x)
         .           
         .                       // Now read the table from the MPQ
        27 ( 0.00%)              hf->SectorChksums = (DWORD *)LoadMpqTable(ha, RawFilePos, NULL, dwCompressedSize, dwCrcSize, 0, NULL);
    20,005 ( 0.00%)  => build/_deps/stormlib-src/src/SBaseCommon.cpp:LoadMpqTable(_TMPQArchive*, unsigned long long, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int*) (3x)
        12 ( 0.00%)              if(hf->SectorChksums == NULL)
         .                           return ERROR_NOT_ENOUGH_MEMORY;
         .                   }
         .               }
         .           
         .               // If the size doesn't match, we ignore sector checksums
         .           //  assert(false);
         .               return ERROR_SUCCESS;
        18 ( 0.00%)  }
         .           
         .           DWORD WritePatchInfo(TMPQFile * hf)
         .           {
         .               TMPQArchive * ha = hf->ha;
         .               TPatchInfo * pPatchInfo = hf->pPatchInfo;
         .           
         .               // The caller must make sure that this function is only called
         .               // when the following is true.
-- line 1460 ----------------------------------------
-- line 1667 ----------------------------------------
         .               // Free buffers and exit
         .               STORM_FREE(pbFileChunk);
         .               STORM_FREE(md5_array);
         .               return dwErrCode;
         .           }
         .           
         .           // Frees the structure for MPQ file
         .           void FreeFileHandle(TMPQFile *& hf)
     1,330 ( 0.00%)  {
     1,995 ( 0.00%)      if(hf != NULL)
         .               {
         .                   // If we have patch file attached to this one, free it first
     1,330 ( 0.00%)          if(hf->hfPatch != NULL)
         .                       FreeFileHandle(hf->hfPatch);
         .           
         .                   // Then free all buffers allocated in the file structure
     1,995 ( 0.00%)          if(hf->pbFileData != NULL)
         .                       STORM_FREE(hf->pbFileData);
     1,995 ( 0.00%)          if(hf->pPatchInfo != NULL)
         .                       STORM_FREE(hf->pPatchInfo);
     1,995 ( 0.00%)          if(hf->SectorOffsets != NULL)
     1,977 ( 0.00%)              STORM_FREE(hf->SectorOffsets);
    57,989 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (659x)
     2,654 ( 0.00%)          if(hf->SectorChksums != NULL)
         9 ( 0.00%)              STORM_FREE(hf->SectorChksums);
       255 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (3x)
     1,998 ( 0.00%)          if(hf->hctx != NULL)
         .                       STORM_FREE(hf->hctx);
     1,995 ( 0.00%)          if(hf->pbFileSector != NULL)
     1,995 ( 0.00%)              STORM_FREE(hf->pbFileSector);
   137,047 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (665x)
     2,660 ( 0.00%)          if(hf->pStream != NULL)
         .                       FileStream_Close(hf->pStream);
     1,330 ( 0.00%)          STORM_FREE(hf);
   113,408 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (665x)
       665 ( 0.00%)          hf = NULL;
         .               }
     1,330 ( 0.00%)  }
         .           
         .           // Frees the MPQ archive
         .           void FreeArchiveHandle(TMPQArchive *& ha)
         .           {
         .               if(ha != NULL)
         .               {
         .                   // First of all, free the patch archive, if any
         .                   if(ha->haPatch != NULL)
-- line 1708 ----------------------------------------
-- line 1751 ----------------------------------------
         .                   }
         .               }
         .           
         .               return false;
         .           }
         .           
         .           // Verifies if the file name is a pseudo-name
         .           bool IsPseudoFileName(const char * szFileName, DWORD * pdwFileIndex)
    53,631 ( 0.00%)  {
         .               DWORD dwFileIndex = 0;
         .           
    37,074 ( 0.00%)      if(szFileName != NULL)
         .               {
         .                   // Must be "File########.ext"
     9,240 ( 0.00%)          if(!_strnicmp(szFileName, "File", 4))
    63,556 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncasecmp_avx2 (1,320x)
         .                   {
         .                       // Check 8 digits
         .                       for(int i = 4; i < 4+8; i++)
         .                       {
         .                           if(szFileName[i] < '0' || szFileName[i] > '9')
    17,877 ( 0.00%)                      return false;
         .                           dwFileIndex = (dwFileIndex * 10) + (szFileName[i] - '0');
         .                       }
         .           
         .                       // An extension must follow
         .                       if(szFileName[12] == '.')
         .                       {
         .                           if(pdwFileIndex != NULL)
         .                               *pdwFileIndex = dwFileIndex;
         .                           return true;
         .                       }
         .                   }
         .               }
         .           
         .               // Not a pseudo-name
         .               return false;
    89,385 ( 0.00%)  }
         .           
         .           //-----------------------------------------------------------------------------
         .           // Functions calculating and verifying the MD5 signature
         .           
         .           bool IsValidMD5(LPBYTE pbMd5)
         .           {
         .               LPDWORD Md5 = (LPDWORD)pbMd5;
         .           
        57 ( 0.00%)      return ((Md5 != NULL) && (Md5[0] | Md5[1] | Md5[2] | Md5[3])) ? true : false;
         .           }
         .           
         .           bool IsValidSignature(LPBYTE pbSignature)
         .           {
         .               LPDWORD Signature = (LPDWORD)pbSignature;
         .               DWORD SigValid = 0;
         .           
         .               for(int i = 0; i < MPQ_WEAK_SIGNATURE_SIZE / sizeof(DWORD); i++)
-- line 1804 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/14/bits/shared_ptr_base.h
--------------------------------------------------------------------------------
Ir                  

-- line 121 ----------------------------------------
         .                 enum { _S_need_barriers = 1 };
         .               };
         .           
         .             template<_Lock_policy _Lp = __default_lock_policy>
         .               class _Sp_counted_base
         .               : public _Mutex_base<_Lp>
         .               {
         .               public:
   129,212 ( 0.00%)        _Sp_counted_base() noexcept
   400,235 ( 0.00%)        : _M_use_count(1), _M_weak_count(1) { }
         .           
         .                 virtual
         .                 ~_Sp_counted_base() noexcept
         .                 { }
         .           
         .                 // Called when _M_use_count drops to zero, to release the resources
         .                 // managed by *this.
         .                 virtual void
-- line 138 ----------------------------------------
-- line 144 ----------------------------------------
         .                 { delete this; }
         .           
         .                 virtual void*
         .                 _M_get_deleter(const std::type_info&) noexcept = 0;
         .           
         .                 // Increment the use count (used when the count is greater than zero).
         .                 void
         .                 _M_add_ref_copy()
   387,365 ( 0.00%)        { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
         .           
         .                 // Increment the use count if it is non-zero, throw otherwise.
         .                 void
         .                 _M_add_ref_lock()
         .                 {
         .           	if (!_M_add_ref_lock_nothrow())
         .           	  __throw_bad_weak_ptr();
         .                 }
-- line 160 ----------------------------------------
-- line 167 ----------------------------------------
         .                 void
         .                 _M_release() noexcept;
         .           
         .                 // Called by _M_release() when the use count reaches zero.
         .                 void
         .                 _M_release_last_use() noexcept
         .                 {
         .           	_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
         2 ( 0.00%)  	_M_dispose();
    92,341 ( 0.00%)  => /usr/include/c++/14/ext/aligned_buffer.h:std::_Sp_counted_ptr_inplace<spdlog::details::thread_pool, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
         .           	// There must be a memory barrier between dispose() and destroy()
         .           	// to ensure that the effects of dispose() are observed in the
         .           	// thread that runs destroy().
         .           	// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
         .           	if (_Mutex_base<_Lp>::_S_need_barriers)
         .           	  {
         .           	    __atomic_thread_fence (__ATOMIC_ACQ_REL);
         .           	  }
         .           
         .           	// Be race-detector-friendly.  For more info see bits/c++config.
         .           	_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
         2 ( 0.00%)  	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
         .           						   -1) == 1)
         .           	  {
         .           	    _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
         .           	    _M_destroy();
         .           	  }
         .                 }
         .           
         .                 // As above, but 'noinline' to reduce code size on the cold path.
         .                 __attribute__((__noinline__))
         .                 void
         6 ( 0.00%)        _M_release_last_use_cold() noexcept
         3 ( 0.00%)        { _M_release_last_use(); }
         .           
         .                 // Increment the weak count.
         .                 void
         .                 _M_weak_add_ref() noexcept
         .                 { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
         .           
         .                 // Decrement the weak count.
         .                 void
         .                 _M_weak_release() noexcept
         .                 {
         .                   // Be race-detector-friendly. For more info see bits/c++config.
         .                   _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
         2 ( 0.00%)  	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
         .           	  {
         .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
         .           	    if (_Mutex_base<_Lp>::_S_need_barriers)
         .           	      {
         .           	        // See _M_release(),
         .           	        // destroy() must observe results of dispose()
         .           		__atomic_thread_fence (__ATOMIC_ACQ_REL);
         .           	      }
-- line 220 ----------------------------------------
-- line 222 ----------------------------------------
         .           	  }
         .                 }
         .           
         .                 long
         .                 _M_get_use_count() const noexcept
         .                 {
         .                   // No memory barrier is used here so there is no synchronization
         .                   // with other threads.
 1,966,145 ( 0.00%)          return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
         .                 }
         .           
         .               private:
         .                 _Sp_counted_base(_Sp_counted_base const&) = delete;
         .                 _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;
         .           
         .                 _Atomic_word  _M_use_count;     // #shared
         .                 _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)
-- line 238 ----------------------------------------
-- line 267 ----------------------------------------
         .               inline bool
         .               _Sp_counted_base<_S_atomic>::
         .               _M_add_ref_lock_nothrow() noexcept
         .               {
         .                 // Perform lock-free add-if-not-zero operation.
         .                 _Atomic_word __count = _M_get_use_count();
         .                 do
         .           	{
 1,096,016 ( 0.00%)  	  if (__count == 0)
         .           	    return false;
         .           	  // Replace the current counter value with the old value + 1, as
         .           	  // long as it's not changed meanwhile.
         .           	}
 1,644,024 ( 0.00%)        while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
         .           					  true, __ATOMIC_ACQ_REL,
         .           					  __ATOMIC_RELAXED));
         .                 return true;
         .               }
         .           
         .             template<>
         .               inline void
         .               _Sp_counted_base<_S_single>::_M_add_ref_copy()
-- line 288 ----------------------------------------
-- line 310 ----------------------------------------
         .           	{
         .           	  _M_release_last_use();
         .           	}
         .               }
         .           
         .             template<>
         .               inline void
         .               _Sp_counted_base<_S_atomic>::_M_release() noexcept
     6,591 ( 0.00%)      {
         .                 _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
         .           #if ! _GLIBCXX_TSAN
         .                 constexpr bool __lock_free
         .           	= __atomic_always_lock_free(sizeof(long long), 0)
         .           	&& __atomic_always_lock_free(sizeof(_Atomic_word), 0);
         .                 constexpr bool __double_word
         .           	= sizeof(long long) == 2 * sizeof(_Atomic_word);
         .                 // The ref-count members follow the vptr, so are aligned to
         .                 // alignof(void*).
         .                 constexpr bool __aligned = __alignof(long long) <= alignof(void*);
         .                 if _GLIBCXX17_CONSTEXPR (__lock_free && __double_word && __aligned)
         .           	{
         .           	  constexpr int __wordbits = __CHAR_BIT__ * sizeof(_Atomic_word);
         .           	  constexpr int __shiftbits = __double_word ? __wordbits : 0;
         .           	  constexpr long long __unique_ref = 1LL + (1LL << __shiftbits);
 2,348,830 ( 0.00%)  	  auto __both_counts = reinterpret_cast<long long*>(&_M_use_count);
         .           
         .           	  _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
11,195,838 ( 0.02%)  	  if (__atomic_load_n(__both_counts, __ATOMIC_ACQUIRE) == __unique_ref)
         .           	    {
         .           	      // Both counts are 1, so there are no weak references and
         .           	      // we are releasing the last strong reference. No other
         .           	      // threads can observe the effects of this _M_release()
         .           	      // call (e.g. calling use_count()) without a data race.
   393,792 ( 0.00%)  	      _M_weak_count = _M_use_count = 0;
         .           	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
         .           	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
   665,256 ( 0.00%)  	      _M_dispose();
         1 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_ptr_inplace<TrainCrossing, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() (1x)
   797,608 ( 0.00%)  	      _M_destroy();
       126 ( 0.00%)  => /usr/include/c++/14/bits/new_allocator.h:std::_Sp_counted_ptr_inplace<TrainCrossing, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_destroy() (1x)
   262,582 ( 0.00%)  	      return;
         .           	    }
 5,467,158 ( 0.01%)  	  if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
         .           	    [[__unlikely__]]
         .           	    {
         2 ( 0.00%)  	      _M_release_last_use_cold();
    92,360 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release_last_use_cold() (1x)
     3,583 ( 0.00%)  	      return;
         .           	    }
         .           	}
         .                 else
         .           #endif
         .                 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
         .           	{
         .           	  _M_release_last_use();
         .           	}
     2,633 ( 0.00%)      }
         .           
         .             template<>
         .               inline void
         .               _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
         .               { ++_M_weak_count; }
         .           
         .             template<>
         .               inline void
-- line 371 ----------------------------------------
-- line 595 ----------------------------------------
         .                 };
         .           
         .               public:
         .                 using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
         .           
         .                 // Alloc parameter is not a reference so doesn't alias anything in __args
         .                 template<typename... _Args>
         .           	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
   266,443 ( 0.00%)  	: _M_impl(__a)
         .           	{
         .           	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           	  // 2070.  allocate_shared should use allocator_traits<A>::construct
         .           	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
         .           	      std::forward<_Args>(__args)...); // might throw
         4 ( 0.00%)  	}
         .           
         .                 ~_Sp_counted_ptr_inplace() noexcept { }
         .           
         .                 virtual void
 1,036,676 ( 0.00%)        _M_dispose() noexcept
         .                 {
         .           	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
 1,038,588 ( 0.00%)        }
         .           
         .                 // Override because the allocator needs to know the dynamic type
         .                 virtual void
         2 ( 0.00%)        _M_destroy() noexcept
         .                 {
         .           	__allocator_type __a(_M_impl._M_alloc());
         .           	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
         .           	this->~_Sp_counted_ptr_inplace();
         .                 }
         .           
         .               private:
         .                 friend class __shared_count<_Lp>; // To be able to call _M_ptr().
-- line 629 ----------------------------------------
-- line 645 ----------------------------------------
         .           #else
         .           	    _Sp_make_shared_tag::_S_eq(__ti)
         .           #endif
         .           	   )
         .           	  return __ptr;
         .           	return nullptr;
         .                 }
         .           
        20 ( 0.00%)        _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
         .           
         .                 _Impl _M_impl;
         .               };
         .           
         .           #ifdef __glibcxx_smart_ptr_for_overwrite // C++ >= 20 && HOSTED
         .             struct _Sp_overwrite_tag { };
         .           
         .             // Partial specialization used for make_shared_for_overwrite<non-array>().
-- line 661 ----------------------------------------
-- line 898 ----------------------------------------
         .           	struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };
         .           
         .           #if __glibcxx_shared_ptr_arrays >= 201707L // C++ >= 20 && HOSTED
         .                 template<typename _Alloc>
         .           	struct __not_alloc_shared_tag<_Sp_counted_array_base<_Alloc>> { };
         .           #endif
         .           
         .               public:
       544 ( 0.00%)        constexpr __shared_count() noexcept : _M_pi(0)
         .                 { }
         .           
         .                 template<typename _Ptr>
         .                   explicit
         .           	__shared_count(_Ptr __p) : _M_pi(0)
         .           	{
         .           	  __try
         .           	    {
-- line 914 ----------------------------------------
-- line 965 ----------------------------------------
         .           	  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
         .           	  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
         .           	  auto __guard = std::__allocate_guarded(__a2);
         .           	  _Sp_cp_type* __mem = __guard.get();
         .           	  auto __pi = ::new (__mem)
         .           	    _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
         .           	  __guard = nullptr;
         .           	  _M_pi = __pi;
   261,453 ( 0.00%)  	  __p = __pi->_M_ptr();
         .           	}
         .           
         .           #if __glibcxx_shared_ptr_arrays >= 201707L // C++ >= 20 && HOSTED
         .                 template<typename _Tp, typename _Alloc, typename _Init>
         .           	__shared_count(_Tp*& __p, const _Sp_counted_array_base<_Alloc>& __a,
         .           		       _Init __init)
         .           	{
         .           	  using _Up = remove_all_extents_t<_Tp>;
-- line 981 ----------------------------------------
-- line 1058 ----------------------------------------
         .           
         .                 // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
         .                 explicit __shared_count(const __weak_count<_Lp>& __r);
         .           
         .                 // Does not throw if __r._M_get_use_count() == 0, caller must check.
         .                 explicit
         .                 __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept;
         .           
   277,064 ( 0.00%)        ~__shared_count() noexcept
         .                 {
 8,214,214 ( 0.01%)  	if (_M_pi != nullptr)
   485,780 ( 0.00%)  	  _M_pi->_M_release();
 1,596,028 ( 0.00%)  => /usr/include/c++/14/bits/shared_ptr_base.h:std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() (114,002x)
         .                 }
         .           
   124,105 ( 0.00%)        __shared_count(const __shared_count& __r) noexcept
   708,847 ( 0.00%)        : _M_pi(__r._M_pi)
         .                 {
 3,974,868 ( 0.01%)  	if (_M_pi != nullptr)
         .           	  _M_pi->_M_add_ref_copy();
         .                 }
         .           
         .                 __shared_count&
         .                 operator=(const __shared_count& __r) noexcept
         .                 {
         .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   766,988 ( 0.00%)  	if (__tmp != _M_pi)
         .           	  {
   138,048 ( 0.00%)  	    if (__tmp != nullptr)
         .           	      __tmp->_M_add_ref_copy();
   239,980 ( 0.00%)  	    if (_M_pi != nullptr)
         .           	      _M_pi->_M_release();
    79,695 ( 0.00%)  	    _M_pi = __tmp;
         .           	  }
         .           	return *this;
         .                 }
         .           
         .                 void
         .                 _M_swap(__shared_count& __r) noexcept
         .                 {
    78,853 ( 0.00%)  	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
         2 ( 0.00%)  	__r._M_pi = _M_pi;
     1,080 ( 0.00%)  	_M_pi = __tmp;
         .                 }
         .           
         .                 long
         .                 _M_get_use_count() const noexcept
 2,019,441 ( 0.00%)        { return _M_pi ? _M_pi->_M_get_use_count() : 0; }
         .           
         .                 bool
         .                 _M_unique() const noexcept
         .                 { return this->_M_get_use_count() == 1; }
         .           
         .                 void*
         .                 _M_get_deleter(const std::type_info& __ti) const noexcept
         .                 { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }
         .           
         .                 bool
         .                 _M_less(const __shared_count& __rhs) const noexcept
         1 ( 0.00%)        { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
         .           
         .                 bool
         .                 _M_less(const __weak_count<_Lp>& __rhs) const noexcept
         .                 { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
         .           
         .                 // Friend function injected into enclosing namespace and found by ADL
         .                 friend inline bool
         .                 operator==(const __shared_count& __a, const __shared_count& __b) noexcept
-- line 1124 ----------------------------------------
-- line 1140 ----------------------------------------
         .             template<_Lock_policy _Lp>
         .               class __weak_count
         .               {
         .               public:
         .                 constexpr __weak_count() noexcept : _M_pi(nullptr)
         .                 { }
         .           
         .                 __weak_count(const __shared_count<_Lp>& __r) noexcept
         2 ( 0.00%)        : _M_pi(__r._M_pi)
         .                 {
         2 ( 0.00%)  	if (_M_pi != nullptr)
         .           	  _M_pi->_M_weak_add_ref();
         .                 }
         .           
         .                 __weak_count(const __weak_count& __r) noexcept
         .                 : _M_pi(__r._M_pi)
         .                 {
         .           	if (_M_pi != nullptr)
         .           	  _M_pi->_M_weak_add_ref();
-- line 1158 ----------------------------------------
-- line 1159 ----------------------------------------
         .                 }
         .           
         .                 __weak_count(__weak_count&& __r) noexcept
         .                 : _M_pi(__r._M_pi)
         .                 { __r._M_pi = nullptr; }
         .           
         .                 ~__weak_count() noexcept
         .                 {
         3 ( 0.00%)  	if (_M_pi != nullptr)
         .           	  _M_pi->_M_weak_release();
         .                 }
         .           
         .                 __weak_count&
         .                 operator=(const __shared_count<_Lp>& __r) noexcept
         .                 {
         .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
         .           	if (__tmp != nullptr)
         .           	  __tmp->_M_weak_add_ref();
         6 ( 0.00%)  	if (_M_pi != nullptr)
         .           	  _M_pi->_M_weak_release();
         2 ( 0.00%)  	_M_pi = __tmp;
         1 ( 0.00%)  	return *this;
         .                 }
         .           
         .                 __weak_count&
         .                 operator=(const __weak_count& __r) noexcept
         .                 {
         .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
         .           	if (__tmp != nullptr)
         .           	  __tmp->_M_weak_add_ref();
-- line 1188 ----------------------------------------
-- line 1207 ----------------------------------------
         .                 {
         .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
         .           	__r._M_pi = _M_pi;
         .           	_M_pi = __tmp;
         .                 }
         .           
         .                 long
         .                 _M_get_use_count() const noexcept
         7 ( 0.00%)        { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }
         .           
         .                 bool
         .                 _M_less(const __weak_count& __rhs) const noexcept
         .                 { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
         .           
         .                 bool
         .                 _M_less(const __shared_count<_Lp>& __rhs) const noexcept
         .                 { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
-- line 1223 ----------------------------------------
-- line 1235 ----------------------------------------
         .           
         .                 _Sp_counted_base<_Lp>*  _M_pi;
         .               };
         .           
         .             // Now that __weak_count is defined we can define this constructor:
         .             template<_Lock_policy _Lp>
         .               inline
         .               __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
     3,952 ( 0.00%)      : _M_pi(__r._M_pi)
         .               {
     3,952 ( 0.00%)        if (_M_pi == nullptr || !_M_pi->_M_add_ref_lock_nothrow())
         .           	__throw_bad_weak_ptr();
         .               }
         .           
         .             // Now that __weak_count is defined we can define this constructor:
         .             template<_Lock_policy _Lp>
         .               inline
         .               __shared_count<_Lp>::
         .               __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept
 1,088,112 ( 0.00%)      : _M_pi(__r._M_pi)
         .               {
 1,092,064 ( 0.00%)        if (_M_pi && !_M_pi->_M_add_ref_lock_nothrow())
         .           	_M_pi = nullptr;
         .               }
         .           
         .             // Helper traits for shared_ptr of array:
         .           
         .             // A pointer type Y* is said to be compatible with a pointer type T* when
         .             // either Y* is convertible to T* or Y is U[N] and T is U cv [].
         .             template<typename _Yp_ptr, typename _Tp_ptr>
-- line 1264 ----------------------------------------
-- line 1456 ----------------------------------------
         .           
         .               public:
         .           
         .           #if __cplusplus > 201402L
         .                 using weak_type = __weak_ptr<_Tp, _Lp>;
         .           #endif
         .           
         .                 constexpr __shared_ptr() noexcept
   719,298 ( 0.00%)        : _M_ptr(0), _M_refcount()
         .                 { }
         .           
         .                 template<typename _Yp, typename = _SafeConv<_Yp>>
         .           	explicit
         .           	__shared_ptr(_Yp* __p)
         .           	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
         .           	{
         .           	  static_assert( !is_void<_Yp>::value, "incomplete type" );
-- line 1472 ----------------------------------------
-- line 1502 ----------------------------------------
         .                   __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
         .           	: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
         .           	{ }
         .           
         .                 // Aliasing constructor
         .                 template<typename _Yp>
         .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
         .           		     element_type* __p) noexcept
     9,270 ( 0.00%)  	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
         .           	{ }
         .           
         .                 // Aliasing constructor
         .                 template<typename _Yp>
         .           	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r,
         .           		     element_type* __p) noexcept
         .           	: _M_ptr(__p), _M_refcount()
         .           	{
         .           	  _M_refcount._M_swap(__r._M_refcount);
         .           	  __r._M_ptr = nullptr;
         .           	}
         .           
 4,342,037 ( 0.01%)        __shared_ptr(const __shared_ptr&) noexcept = default;
   361,059 ( 0.00%)        __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
         .                 ~__shared_ptr() = default;
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
     4,678 ( 0.00%)  	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         .           	{ }
         .           
         .                 __shared_ptr(__shared_ptr&& __r) noexcept
 1,064,342 ( 0.00%)        : _M_ptr(__r._M_ptr), _M_refcount()
         .                 {
         .           	_M_refcount._M_swap(__r._M_refcount);
    15,110 ( 0.00%)  	__r._M_ptr = nullptr;
         .                 }
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
     1,894 ( 0.00%)  	: _M_ptr(__r._M_ptr), _M_refcount()
         .           	{
         .           	  _M_refcount._M_swap(__r._M_refcount);
         8 ( 0.00%)  	  __r._M_ptr = nullptr;
         .           	}
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
         .           	: _M_refcount(__r._M_refcount) // may throw
         .           	{
         .           	  // It is now safe to copy __r._M_ptr, as
         .           	  // _M_refcount(__r._M_refcount) did not throw.
     3,952 ( 0.00%)  	  _M_ptr = __r._M_ptr;
         .           	}
         .           
         .                 // If an exception is thrown this constructor has no effect.
         .                 template<typename _Yp, typename _Del,
         .           	       typename = _UniqCompatible<_Yp, _Del>>
         .           	__shared_ptr(unique_ptr<_Yp, _Del>&& __r)
         .           	: _M_ptr(__r.get()), _M_refcount()
         .           	{
-- line 1561 ----------------------------------------
-- line 1658 ----------------------------------------
         .           
         .                 template<typename _Yp, typename _Deleter, typename _Alloc>
         .           	_SafeConv<_Yp>
         .           	reset(_Yp* __p, _Deleter __d, _Alloc __a)
         .                   { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }
         .           
         .                 /// Return the stored pointer.
         .                 element_type*
       535 ( 0.00%)        get() const noexcept
   613,513 ( 0.00%)        { return _M_ptr; }
         .           
         .                 /// Return true if the stored pointer is not null.
        14 ( 0.00%)        explicit operator bool() const noexcept
   728,159 ( 0.00%)        { return _M_ptr != nullptr; }
         .           
         .                 /// Return true if use_count() == 1.
         .                 bool
         .                 unique() const noexcept
         .                 { return _M_refcount._M_unique(); }
         .           
         .                 /// If *this owns a pointer, return the number of owners, otherwise zero.
         .                 long
-- line 1679 ----------------------------------------
-- line 1705 ----------------------------------------
         .           	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
         .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
         .                 /// @}
         .           
         .               protected:
         .                 // This constructor is non-standard, it is used by allocate_shared.
         .                 template<typename _Alloc, typename... _Args>
         .           	__shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
   130,400 ( 0.00%)  	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
         .           	{ _M_enable_shared_from_this_with(_M_ptr); }
         .           
         .                 template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
         .           	       typename... _Args>
         .           	friend __shared_ptr<_Tp1, _Lp1>
         .           	__allocate_shared(const _Alloc& __a, _Args&&... __args);
         .           
         .           #if __glibcxx_shared_ptr_arrays >= 201707L // C++ >= 20 && HOSTED
-- line 1721 ----------------------------------------
-- line 1727 ----------------------------------------
         .           	{ }
         .           #endif
         .           
         .                 // This constructor is used by __weak_ptr::lock() and
         .                 // shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).
         .                 __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t) noexcept
         .                 : _M_refcount(__r._M_refcount, std::nothrow)
         .                 {
 2,182,152 ( 0.00%)  	_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
         .                 }
         .           
         .                 friend class __weak_ptr<_Tp, _Lp>;
         .           
         .               private:
         .           
         .                 template<typename _Yp>
         .           	using __esft_base_t = decltype(__enable_shared_from_this_base(
-- line 1743 ----------------------------------------
-- line 1984 ----------------------------------------
         .                 // Constraint for assignment from shared_ptr and weak_ptr:
         .                 template<typename _Yp>
         .           	using _Assignable = _Compatible<_Yp, __weak_ptr&>;
         .           
         .               public:
         .                 using element_type = typename remove_extent<_Tp>::type;
         .           
         .                 constexpr __weak_ptr() noexcept
         2 ( 0.00%)        : _M_ptr(nullptr), _M_refcount()
         .                 { }
         .           
         .                 __weak_ptr(const __weak_ptr&) noexcept = default;
         .           
         .                 ~__weak_ptr() = default;
         .           
         .                 // The "obvious" converting constructor implementation:
         .                 //
-- line 2000 ----------------------------------------
-- line 2012 ----------------------------------------
         .                 // in multithreaded programs __r._M_ptr may be invalidated at any point.
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
         .           	: _M_refcount(__r._M_refcount)
         .                   { _M_ptr = __r.lock().get(); }
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
         1 ( 0.00%)  	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         .           	{ }
         .           
         .                 __weak_ptr(__weak_ptr&& __r) noexcept
         1 ( 0.00%)        : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
         .                 { __r._M_ptr = nullptr; }
         .           
         .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           	__weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
         .           	: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
         .                   { __r._M_ptr = nullptr; }
         .           
         .                 __weak_ptr&
-- line 2032 ----------------------------------------
-- line 2040 ----------------------------------------
         .           	  _M_refcount = __r._M_refcount;
         .           	  return *this;
         .           	}
         .           
         .                 template<typename _Yp>
         .           	_Assignable<_Yp>
         .           	operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
         .           	{
         2 ( 0.00%)  	  _M_ptr = __r._M_ptr;
         .           	  _M_refcount = __r._M_refcount;
         .           	  return *this;
         .           	}
         .           
         .                 __weak_ptr&
         .                 operator=(__weak_ptr&& __r) noexcept
         .                 {
         .           	__weak_ptr(std::move(__r)).swap(*this);
-- line 2056 ----------------------------------------
-- line 2102 ----------------------------------------
         .           
         .               private:
         .                 // Used by __enable_shared_from_this.
         .                 void
         .                 _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
         .                 {
         .           	if (use_count() == 0)
         .           	  {
         1 ( 0.00%)  	    _M_ptr = __ptr;
         .           	    _M_refcount = __refcount;
         .           	  }
         .                 }
         .           
         .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
         .                 template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
         .                 friend class __enable_shared_from_this<_Tp, _Lp>;
         .                 friend class enable_shared_from_this<_Tp>;
-- line 2118 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/code_80091750.c
--------------------------------------------------------------------------------
Ir                 

-- line 1150 ----------------------------------------
        .           
        .               temp = *arg0;
        .               *arg0 = *arg1;
        .               *arg1 = temp;
        .           }
        .           
        .           extern s8 D_800E852C;
        .           
        1 ( 0.00%)  void func_80091B78(void) {
        .               s32 why = 0;
        .               s32 i;
        .           
        3 ( 0.00%)      if (D_800E852C) {
        1 ( 0.00%)          D_800E852C = why;
        2 ( 0.00%)          D_8018EDF4 = 10;
        2 ( 0.00%)          D_8018EDF5 = 5;
        2 ( 0.00%)          D_8018EDF6 = 10;
        2 ( 0.00%)          if (osEepromProbe(&gSIEventMesgQueue) != 0) {
        2 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/libultra/os_eeprom.cpp:osEepromProbe (1x)
        .                       // save data disabled for now due to array overflow
        .                       // load_save_data();
        .                   }
        3 ( 0.00%)          if (func_80091D74() != 0) {
       12 ( 0.00%)  => src/code_80091750.c:func_80091D74 (1x)
        .                       gMenuSelection = CONTROLLER_PAK_MENU;
        .                   }
        .               }
        .               if (gMenuSelection == LOGO_INTRO_MENU) {
        .                   gNextFreeMemoryAddress = gFreeMemoryResetAnchor;
        .           #ifdef TARGET_N64
        .                   set_segment_base_addr(6, decompress_segments((u8*) STARTUP_LOGO_ROM_START, (u8*) STARTUP_LOGO_ROM_END));
        .           #endif
        .               }
        4 ( 0.00%)      gNextFreeMemoryAddress = gFreeMemoryResetAnchor;
        .               // Hypothetically, this should be a ptr... But only hypothetically.
        4 ( 0.00%)      D_8018D9B0 = get_next_available_memory_addr(0x000900B0);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B4 = (u8*) get_next_available_memory_addr(0x0000CE00);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B8 = (u8*) get_next_available_memory_addr(0x00012C00);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9C0 = (struct_8018EE10_entry*) get_next_available_memory_addr(0x00001000);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        1 ( 0.00%)      func_800AF9B0();
   16,113 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_800AF9B0.c:func_800AF9B0 (1x)
        2 ( 0.00%)      D_8018EE0C = 0;
        .           
        .               for (i = 0; i < 5; i++) {
        3 ( 0.00%)          D_8018E7AC[i] = 0;
        .               }
        .           
        .               for (i = 0; i < 4; i++) {
        2 ( 0.00%)          D_8018E838[i] = 0;
        .               }
        .           
        .               D_800DC5EC->screenStartX = 160;
        .               D_800DC5EC->screenStartY = 120;
        4 ( 0.00%)      D_800DC5EC->screenWidth = SCREEN_WIDTH;
        .               D_800DC5EC->screenHeight = SCREEN_HEIGHT;
        2 ( 0.00%)      D_800E86A4 = 1;
        1 ( 0.00%)      render_menus();
  159,908 ( 0.00%)  => src/code_80091750.c:render_menus (1x)
        .           
        .               for (i = 0; i < 4; i++) {
        8 ( 0.00%)          func_800C97C4((u8) i);
      960 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/audio/external.c:func_800C97C4 (4x)
        .               }
        .           
       23 ( 0.00%)      for (i = 1; i < 8; i++) {
       14 ( 0.00%)          func_800C9D0C((u8) i);
    1,631 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/audio/external.c:func_800C9D0C (7x)
        .               }
        .           
        1 ( 0.00%)      func_800B44BC();
       16 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/menus.c:func_800B44BC (1x)
        2 ( 0.00%)      osViSetSpecialFeatures(OS_VI_DITHER_FILTER_ON);
        1 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/libultra/os_vi.cpp:osViSetSpecialFeatures (1x)
        1 ( 0.00%)  }
        .           
        .           s32 func_80091D74(void) {
        .               u8 sp67;
        .               UNUSED s32 pad[10];
        .               s32 i;
        .           
        3 ( 0.00%)      if (!gControllerBits) {
        1 ( 0.00%)          return 0;
        .               }
        3 ( 0.00%)      if ((!gControllerStatuses[0].status) & CONT_CARD_ON) {
        .                   return 0;
        .               }
        4 ( 0.00%)      if (!(gControllerOne->button & START_BUTTON)) {
        .                   return 0;
        .               }
        .               osPfsIsPlug(&gSIEventMesgQueue, &sp67);
        .               if (sp67 & 1) {
        .                   if (osPfsInit(&gSIEventMesgQueue, &gControllerPak1FileHandle, 0)) {
        .                       return 0;
        .                   }
        .               } else {
-- line 1236 ----------------------------------------
-- line 1245 ----------------------------------------
        .                   pfsError[i] = osPfsFileState(&gControllerPak1FileHandle, i, pfsState + i);
        .               }
        .           
        .               if (osPfsFreeBlocks(&gControllerPak1FileHandle, &gControllerPak1NumPagesFree)) {
        .                   return 0;
        .               }
        .               gControllerPak1NumPagesFree >>= 8;
        .               return 1;
        1 ( 0.00%)  }
        .           
        .           void func_80091EE4(void) {
        .               s32 temp_s0;
        .               s32 temp_s2;
        .               s32 tmp;
        .           
        .               gControllerPak1State = BAD;
        .               tmp = func_800B5F30();
-- line 1261 ----------------------------------------
-- line 1269 ----------------------------------------
        .                           func_800B64EC(temp_s0);
        .                           temp_s0 = 2;
        .                           D_8018EDFB = 0;
        .                       }
        .                   }
        .               }
        .           }
        .           
        1 ( 0.00%)  void func_80091FA4(void) {
        .               s32 i;
        .           
        .               //! @todo These sizes need to be sizeof() for shiftability if possible
        4 ( 0.00%)      D_8018D9B4 = (u8*) get_next_available_memory_addr(0x00002800);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B0 = (u16*) get_next_available_memory_addr(0x000124F8);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9B8 = (u8*) get_next_available_memory_addr(0x00001000);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        4 ( 0.00%)      D_8018D9BC = get_next_available_memory_addr(4);
       17 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:get_next_available_memory_addr (1x)
        .           
        .               for (i = 0; i < 5; i++) {
        3 ( 0.00%)          D_8018E7AC[i] = 0;
        .               }
        .           
        .               for (i = 0; i < 4; i++) {
        2 ( 0.00%)          D_8018E838[i] = 0;
        .               }
        .           
        1 ( 0.00%)      func_80099110();
        5 ( 0.00%)  => src/code_80091750.c:func_80099110 (1x)
        1 ( 0.00%)      func_8009A344();
       18 ( 0.00%)  => src/code_80091750.c:func_8009A344 (1x)
        1 ( 0.00%)      func_8009E620();
       85 ( 0.00%)  => src/code_80091750.c:func_8009E620 (1x)
        1 ( 0.00%)      func_80092258();
        6 ( 0.00%)  => src/code_80091750.c:func_80092258 (1x)
        5 ( 0.00%)      add_ui_element(0x00000096, 0x00000064, 0x00000024, 1);
       31 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)      add_ui_element(0x00000097, 0x00000064, 0x000000DD, 1);
       37 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)      add_ui_element(0x00000098, 0, 0, 0);
       43 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)      add_ui_element(0x000000C7, 0, 0, 0);
       49 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        3 ( 0.00%)      if (gModeSelection == TIME_TRIALS) {
        .                   add_ui_element(0x000000BE, 0, 0, 0);
        .                   add_ui_element(0x0000010E, 0, 0, 0);
        .               }
        .               if ((D_8015F890 != 0) && (gModeSelection == TIME_TRIALS)) {
        .                   add_ui_element(0x000000BD, 0, 0, 0);
        .               }
        3 ( 0.00%)      if (!(gControllerBits & 1) && (D_8018EE08 != 0)) {
        .                   add_ui_element(4, 0, 0, 2);
        .               }
        1 ( 0.00%)      func_800B5F30();
       36 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:func_800B5F30 (1x)
        1 ( 0.00%)  }
        .           
        .           void func_80092148(void) {
      952 ( 0.00%)      struct Controller* controller = gControllerFive;
        .               s32 isHeld;
        .           
      476 ( 0.00%)      isHeld = controller->button ? 1 : 0;
        .           
      952 ( 0.00%)      if (controller->buttonPressed) {
        2 ( 0.00%)          D_8018D9D9 = 1;
        .               }
    2,000 ( 0.00%)      if ((isHeld) && (D_8018D9D9)) {
        .                   D_8018D9D8 = 1;
        .                   return;
        .               }
      476 ( 0.00%)      D_8018D9D8 = 0;
      476 ( 0.00%)  }
        .           
        .           void func_800921B4(void) {
        .               D_8018D9D9 = 0;
        .           }
        .           
        .           // if selected and detect kind menu
        .           void text_rainbow_effect(s32 test, s32 target, s32 alternative_color) {
        .               if (test == target) {
-- line 1337 ----------------------------------------
-- line 1352 ----------------------------------------
        .                   set_text_color(alternative_color);
        .               }
        .           }
        .           
        .           void func_80092258(void) {
        .               s32 i;
        .           
        .               for (i = 0; i < 2; i++) {
        6 ( 0.00%)          D_8018E850[i] = i;
        4 ( 0.00%)          D_8018E858[i] = 0;
        .               }
        2 ( 0.00%)  }
        .           
   10,242 ( 0.00%)  void func_80092290(s32 arg0, s32* arg1, s32* arg2) {
        .               s32 temp_v1;
        .               s32 i;
        .               s32 idx;
        .               s32 temp_t6;
        .               s32 temp_t7;
        .               s32 temp_t8_2;
        .               s32 temp_t9;
        .               s32 temp_t0;
        .               s32 a, b, c, d;
        .               Vtx* vtx;
        .           
    3,414 ( 0.00%)      if ((arg0 < 4) || (arg0 >= 6)) {
        .                   return;
        .               }
        .           
   10,242 ( 0.00%)      idx = (((arg0 * 4) + ((gGlobalTimer % 2) * 2)) - 6);
        .           
    3,346 ( 0.00%)      *arg2 += 16;
    2,276 ( 0.00%)      if (*arg2 >= 256) {
       68 ( 0.00%)          *arg2 = 0;
      816 ( 0.00%)          *arg1 = (s32) (*arg1 + 1) % 3;
        .               }
        .           
   40,968 ( 0.00%)      for (i = 0; i < 3; i++) {
   34,140 ( 0.00%)          vtx = (Vtx*) LOAD_ASSET(D_800E84C0[i]);
6,561,798 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (3,414x)
  105,834 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (3,414x)
        .           
    6,828 ( 0.00%)          temp_v1 = (*arg1 * 2) + 2;
        .           
   30,726 ( 0.00%)          temp_t6 = (vtx + temp_v1)->v.cn[0] * (256 - *arg2);
    6,828 ( 0.00%)          temp_t9 = (vtx + temp_v1)->v.cn[1] * (256 - *arg2);
    6,828 ( 0.00%)          temp_t7 = (vtx + temp_v1)->v.cn[2] * (256 - *arg2);
   10,242 ( 0.00%)          temp_t8_2 = (vtx + temp_v1)->v.cn[3] * (256 - *arg2);
        .           
   34,140 ( 0.00%)          temp_v1 = (((*arg1 * 2) + 2) % 6) + 2;
   17,070 ( 0.00%)          a = ((vtx + temp_v1)->v.cn[0] * *arg2);
    6,828 ( 0.00%)          b = ((vtx + temp_v1)->v.cn[1] * *arg2);
    6,828 ( 0.00%)          c = ((vtx + temp_v1)->v.cn[2] * *arg2);
    6,828 ( 0.00%)          d = ((vtx + temp_v1)->v.cn[3] * *arg2);
        .           
   18,208 ( 0.00%)          (vtx + idx)->v.cn[0] = (temp_t6 + a) / 256;
   10,242 ( 0.00%)          (vtx + idx)->v.cn[1] = (temp_t9 + b) / 256;
   10,242 ( 0.00%)          (vtx + idx)->v.cn[2] = (temp_t7 + c) / 256;
   17,070 ( 0.00%)          (vtx + idx)->v.cn[3] = (temp_t8_2 + d) / 256;
        .           
    6,828 ( 0.00%)          (vtx + idx + 1)->v.cn[0] = (temp_t6 + a) / 256;
        .                   (vtx + idx + 1)->v.cn[1] = (temp_t9 + b) / 256;
        .                   (vtx + idx + 1)->v.cn[2] = (temp_t7 + c) / 256;
        .                   (vtx + idx + 1)->v.cn[3] = (temp_t8_2 + d) / 256;
        .               }
    9,104 ( 0.00%)  }
        .           
        .           void func_80092500(void) {
        .           
        .               switch (gModeSelection) {
        .                   case GRAND_PRIX:
        .                       add_ui_element(0xAA, 0, 0, 0);
        .                       break;
        .                   case TIME_TRIALS:
-- line 1423 ----------------------------------------
-- line 1570 ----------------------------------------
        .           
        .           // Originally func_80092C90
        .           // Some kind of lookup function, seems to return an index to be used
        .           // to get a character's width in pixels
        .           s32 char_to_glyph_index(char* character) {
        .               s32 var_v1;
        .               s8 temp_v0;
        .           
    4,180 ( 0.00%)      temp_v0 = *character;
        .               var_v1 = 1;
   12,540 ( 0.00%)      if ((temp_v0 >= 'a') && (temp_v0 <= 'z')) {
    7,030 ( 0.00%)          var_v1 = temp_v0 - 0x61;
    1,995 ( 0.00%)      } else if ((temp_v0 >= 'A') && (temp_v0 <= 'Z')) {
      520 ( 0.00%)          var_v1 = temp_v0 - 0x41;
    1,215 ( 0.00%)      } else if ((temp_v0 >= '0') && (temp_v0 <= '9')) {
        .                   var_v1 = temp_v0 - 0x10;
      810 ( 0.00%)      } else if (temp_v0 == ' ') {
      810 ( 0.00%)          var_v1 = -1;
        .               } else if (temp_v0 < 0) {
        .                   // Handling EUC-JUP characters
        .                   switch (temp_v0) { /* irregular */
        .                       case -92:      // 0xA4
        .                           var_v1 = func_80092E1C(character + 1);
        .                           break;
        .                       case -91: // 0xA5
        .                           var_v1 = func_80092DF8(character + 1);
-- line 1595 ----------------------------------------
-- line 1776 ----------------------------------------
        .                       break;
        .                   default: /* switch 3 */
        .                       var_v1 = 2;
        .               }
        .               return var_v1;
        .           }
        .           
        .           // Originally func_80093034
        6 ( 0.00%)  s32 get_string_width(char* buffer) {
        .               s32 glyphIndex;
        2 ( 0.00%)      s32 stringWidth = 0;
        .           
        8 ( 0.00%)      if (*buffer != 0) {
        .                   do {
       42 ( 0.00%)              glyphIndex = char_to_glyph_index(buffer);
      148 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (21x)
       42 ( 0.00%)              if (glyphIndex >= 0) {
       76 ( 0.00%)                  stringWidth += gGlyphDisplayWidth[glyphIndex];
        .                       } else if (glyphIndex == -1) {
        6 ( 0.00%)                  stringWidth += 7;
        .                       }
       38 ( 0.00%)              if (glyphIndex >= 0x30) {
        .                           buffer += 2;
        .                       } else {
       21 ( 0.00%)                  buffer += 1;
        .                       }
       42 ( 0.00%)          } while (*buffer != 0);
        .               }
        .               return stringWidth;
       10 ( 0.00%)  }
        .           
        .           void set_text_color(s32 arg0) {
      532 ( 0.00%)      gTextColor = arg0;
      266 ( 0.00%)  }
        .           
        .           UNUSED void func_800930E4(s32 arg0, s32 arg1, char* arg2) {
        .               set_text_color(TEXT_BLUE);
        .               func_80093324(arg0, arg1, arg2, 0, 1.0, 1.0);
        .           }
        .           
        .           // "tracking" is a uniform spacing between all characters in a given word
    1,935 ( 0.00%)  void print_text0(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY, s32 mode) {
      129 ( 0.00%)      s32 stringWidth = 0;
        .               s32 glyphIndex;
        .           
      774 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077A8);
  252,277 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (129x)
      258 ( 0.00%)      if (*text != 0) {
        .                   do {
    4,257 ( 0.00%)              glyphIndex = char_to_glyph_index(text);
   10,320 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (1,419x)
    2,838 ( 0.00%)              if (glyphIndex >= 0) {
    7,740 ( 0.00%)                  load_menu_img((MkTexture*) segmented_to_virtual_dupe((const void*) gGlyphTextureLUT[glyphIndex]));
   87,810 ( 0.00%)  => src/code_80091750.c:load_menu_img (1,290x)
    2,580 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,290x)
    1,290 ( 0.00%)                  gDisplayListHead =
   16,770 ( 0.00%)                      print_letter(gDisplayListHead,
7,583,492 ( 0.01%)  => src/code_80091750.c:print_letter (1,290x)
    3,870 ( 0.00%)                                   (MkTexture*) segmented_to_virtual_dupe((const void*) gGlyphTextureLUT[glyphIndex]),
    2,580 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,290x)
    1,290 ( 0.00%)                                   column + (stringWidth * scaleX), row, mode, scaleX, scaleY);
    6,450 ( 0.00%)                  stringWidth += gGlyphDisplayWidth[glyphIndex] + tracking;
      258 ( 0.00%)              } else if ((glyphIndex != -2) && (glyphIndex == -1)) {
      774 ( 0.00%)                  stringWidth += tracking + 7;
        .                       } else {
        .                           gSPDisplayList(gDisplayListHead++, D_020077D8);
        .                           return;
        .                       }
    2,580 ( 0.00%)              if (glyphIndex >= 0x30) {
        .                           text += 2;
        .                       } else {
    1,419 ( 0.00%)                  text += 1;
        .                       }
    2,838 ( 0.00%)          } while (*text != 0);
        .               }
      645 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077D8);
  253,801 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (129x)
      903 ( 0.00%)  }
        .           
        .           void func_80093324(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
      258 ( 0.00%)      print_text0(column, row, text, tracking, scaleX, scaleY, 1);
8,249,878 ( 0.01%)  => src/code_80091750.c:print_text0 (129x)
        .           }
        .           
        .           void func_80093358(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text0(column, row, text, tracking, scaleX, scaleY, 2);
        .           }
        .           
        .           // "tracking" is a uniform spacing between all characters in a given word
    1,918 ( 0.00%)  void print_text1(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY, s32 arg6) {
      137 ( 0.00%)      char* temp_string = text;
      137 ( 0.00%)      s32 stringWidth = 0;
        .               s32 glyphIndex;
        .               s32 sp60;
        .           
    3,014 ( 0.00%)      while (*temp_string != 0) {
    2,740 ( 0.00%)          glyphIndex = char_to_glyph_index(temp_string);
    9,316 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (1,370x)
    2,740 ( 0.00%)          if (glyphIndex >= 0) {
   11,097 ( 0.00%)              stringWidth += ((gGlyphDisplayWidth[glyphIndex] + tracking) * scaleX);
      274 ( 0.00%)          } else if ((glyphIndex != -2) && (glyphIndex == -1)) {
      959 ( 0.00%)              stringWidth += ((tracking + 7) * scaleX);
        .                   } else {
        .                       return;
        .                   }
    2,466 ( 0.00%)          if (glyphIndex >= 0x30) {
        .                       temp_string += 2;
        .                   } else {
    1,370 ( 0.00%)              temp_string += 1;
        .                   }
        .               }
        .           
      822 ( 0.00%)      switch (arg6) {
        .                   case 1:
        .                       // ???
        .                       do {
        .                       } while (0);
        .                   case 3:
      137 ( 0.00%)              column -= stringWidth;
        .                       break;
        .                   case 2:
        .                   case 4:
        .                       column -= stringWidth / 2;
        .                       break;
        .                   default:
        .                       break;
        .               }
        .           
      137 ( 0.00%)      if (arg6 < 3) {
      137 ( 0.00%)          sp60 = 1;
        .               } else {
        .                   sp60 = 2;
        .               }
        .           
      822 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077A8);
  268,583 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (137x)
    3,014 ( 0.00%)      while (*text != 0) {
    4,110 ( 0.00%)          glyphIndex = char_to_glyph_index(text);
    9,316 ( 0.00%)  => src/code_80091750.c:char_to_glyph_index (1,370x)
    2,740 ( 0.00%)          if (glyphIndex >= 0) {
    7,398 ( 0.00%)              load_menu_img(segmented_to_virtual_dupe(gGlyphTextureLUT[glyphIndex]));
   68,218 ( 0.00%)  => src/code_80091750.c:load_menu_img (1,233x)
    2,466 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,233x)
   20,961 ( 0.00%)              gDisplayListHead = print_letter(gDisplayListHead, segmented_to_virtual_dupe(gGlyphTextureLUT[glyphIndex]),
6,958,494 ( 0.01%)  => src/code_80091750.c:print_letter (1,233x)
    2,466 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1,233x)
        .                                                       column, row, sp60, scaleX, scaleY);
    9,864 ( 0.00%)              column = column + (s32) ((gGlyphDisplayWidth[glyphIndex] + tracking) * scaleX);
      274 ( 0.00%)          } else if ((glyphIndex != -2) && (glyphIndex == -1)) {
    1,096 ( 0.00%)              column = column + (s32) ((tracking + 7) * scaleX);
        .                   } else {
        .                       gSPDisplayList(gDisplayListHead++, D_020077D8);
        .                       return;
        .                   }
    2,466 ( 0.00%)          if (glyphIndex >= 0x30) {
        .                       text += 2;
        .                   } else {
    1,370 ( 0.00%)              text += 1;
        .                   }
        .               }
      685 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020077D8);
  270,677 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (137x)
      959 ( 0.00%)  }
        .           
        .           void func_800936B8(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
      274 ( 0.00%)      print_text1(column, row, text, tracking, scaleX, scaleY, 1);
7,673,380 ( 0.01%)  => src/code_80091750.c:print_text1 (137x)
        .           }
        .           
        .           void draw_text(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text1(column, row, text, tracking, scaleX, scaleY, 2);
        .           }
        .           
        .           void func_80093720(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text1(column, row, text, tracking, scaleX, scaleY, 3);
-- line 1932 ----------------------------------------
-- line 1978 ----------------------------------------
        .               print_text2(column, row, text, tracking, scaleX, scaleY, 1);
        .           }
        .           
        .           void text_draw(s32 column, s32 row, char* text, s32 tracking, f32 scaleX, f32 scaleY) {
        .               print_text2(column, row, text, tracking, scaleX, scaleY, 2);
        .           }
        .           
        .           void func_80093A30(s32 arg0) {
    1,904 ( 0.00%)      func_8009E2A8(D_800F0B1C[arg0]);
    2,856 ( 0.00%)  => src/code_80091750.c:func_8009E2A8 (476x)
        .           }
        .           
    1,904 ( 0.00%)  void func_80093A5C(u32 arg0) {
    1,904 ( 0.00%)      if (D_8015F788 == 0) {
      476 ( 0.00%)          func_8009C918();
   10,472 ( 0.00%)  => src/code_80091750.c:func_8009C918 (476x)
        .               }
    1,904 ( 0.00%)      switch (arg0) {
        .                   case RENDER_SCREEN_MODE_1P_PLAYER_ONE:
      952 ( 0.00%)              func_800940EC((s32) D_800F0B1C[arg0]);
29,608,734 ( 0.05%)  => src/code_80091750.c:func_800940EC (476x)
        .                       break;
        .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_ONE:
        .                   case RENDER_SCREEN_MODE_2P_HORIZONTAL_PLAYER_TWO:
        .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_ONE:
        .                   case RENDER_SCREEN_MODE_2P_VERTICAL_PLAYER_TWO:
        .                       if (D_8015F788 == 0) {
        .                           func_80093C1C((s32) D_800F0B1C[arg0]);
        .                       } else {
-- line 2003 ----------------------------------------
-- line 2010 ----------------------------------------
        .                   case RENDER_SCREEN_MODE_3P_4P_PLAYER_FOUR:
        .                       if (D_8015F788 == 3) {
        .                           func_800940EC((s32) D_800F0B1C[arg0]);
        .                       } else {
        .                           func_80093C1C((s32) D_800F0B1C[arg0]);
        .                       }
        .                       break;
        .               }
    2,856 ( 0.00%)      gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
    1,904 ( 0.00%)  }
        .           
        .           UNUSED void func_80093B70(u32 arg0) {
        .               if ((arg0 == 0) || (arg0 == 2) || (arg0 == 3) || (arg0 == 8)) {
        .                   func_8009C918();
        .               }
        .               switch (arg0) {
        .                   case 0:
        .                       func_800940EC(0);
-- line 2027 ----------------------------------------
-- line 2056 ----------------------------------------
        .           UNUSED void func_80093C88(void) {
        .               return;
        .           }
        .           
        .           UNUSED void func_80093C90(void) {
        .               return;
        .           }
        .           
    3,414 ( 0.00%)  void func_80093C98(s32 arg0) {
    3,983 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    7,966 ( 0.00%)      guOrtho(&gGfxPool->mtxEffect[gMatrixEffectCount], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
   61,452 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guOrthoF.c:guOrtho (569x)
    5,690 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount++]),
        .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    2,276 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007F18);
1,115,669 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (569x)
    2,845 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
      569 ( 0.00%)      func_800A8250();
2,899,953 ( 0.00%)  => src/code_80091750.c:func_800A8250 (569x)
    1,138 ( 0.00%)      if (arg0 == 0) {
      476 ( 0.00%)          func_800A54EC();
    1,904 ( 0.00%)  => src/code_80091750.c:func_800A54EC (476x)
      952 ( 0.00%)          func_8009CA6C(4);
  955,798 ( 0.00%)  => src/code_80091750.c:func_8009CA6C (476x)
    1,428 ( 0.00%)          D_80165754 = gMatrixEffectCount;
      476 ( 0.00%)          gMatrixEffectCount = 0;
        .               }
    3,414 ( 0.00%)  }
        .           
        .           void func_80093E20(void) {
      952 ( 0.00%)      func_80093C98(0);
4,403,563 ( 0.01%)  => src/code_80091750.c:func_80093C98 (476x)
        .           }
        .           
        .           void func_80093E40(void) {
      186 ( 0.00%)      func_80093C98(1);
  665,840 ( 0.00%)  => src/code_80091750.c:func_80093C98 (93x)
        .           }
        .           
        .           void func_80093E60(void) {
        .               s32 i;
        .           
        .               D_8018D9B4 = get_next_available_memory_addr(0x00002800);
        .               D_8018D9B0 = (u16*) get_next_available_memory_addr(0x000124F8);
        .               D_8018D9B8 = get_next_available_memory_addr(0x00001000);
-- line 2093 ----------------------------------------
-- line 2123 ----------------------------------------
        .               func_800A8230();
        .               func_80099AEC();
        .               func_80099EC4();
        .               func_8009CA2C();
        .               gSPDisplayList(gDisplayListHead++, D_02007F48);
        .               gMatrixEffectCount = 0;
        .           }
        .           
    2,856 ( 0.00%)  void func_800940EC(s32 arg0) {
    2,380 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
    2,380 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    6,664 ( 0.00%)      guOrtho(&gGfxPool->mtxEffect[gMatrixEffectCount], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
   51,408 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guOrthoF.c:guOrtho (476x)
    4,760 ( 0.00%)      gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount++]),
        .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
    1,904 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007F18);
  932,904 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
    2,856 ( 0.00%)      func_80092290(4, D_8018E850, D_8018E858);
2,919,094 ( 0.00%)  => src/code_80091750.c:func_80092290 (476x)
    1,904 ( 0.00%)      func_80092290(5, (s32*) &D_8018E850[1], (s32*) &D_8018E858[1]);
2,919,094 ( 0.00%)  => src/code_80091750.c:func_80092290 (476x)
      476 ( 0.00%)      func_80092148();
    5,334 ( 0.00%)  => src/code_80091750.c:func_80092148 (476x)
      476 ( 0.00%)      func_80099A70();
    1,428 ( 0.00%)  => src/code_80091750.c:func_80099A70 (476x)
      476 ( 0.00%)      func_80099E54();
    1,428 ( 0.00%)  => src/code_80091750.c:func_80099E54 (476x)
      476 ( 0.00%)      func_800A8230();
20,222,829 ( 0.03%)  => src/code_80091750.c:func_800A8230 (476x)
      476 ( 0.00%)      func_80099AEC();
   11,900 ( 0.00%)  => src/code_80091750.c:func_80099AEC (476x)
      476 ( 0.00%)      func_80099EC4();
    9,044 ( 0.00%)  => src/code_80091750.c:func_80099EC4 (476x)
      952 ( 0.00%)      func_8009CA6C(arg0);
1,534,659 ( 0.00%)  => src/code_80091750.c:func_8009CA6C (476x)
    2,380 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007F48);
  931,544 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (476x)
      476 ( 0.00%)      func_80057CE4();
   33,320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80057C60.c:func_80057CE4 (476x)
    2,380 ( 0.00%)  }
        .           
        .           void func_800942D0(void) {
        .               Mtx* test;
        .               f32 var_f26;
        .               s32 var_s2;
        .               s32 thing;
        .               test = &gGfxPool->mtxObject[0];
        .               gSPMatrix(gDisplayListHead++, &gGfxPool->mtxScreen, G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
-- line 2157 ----------------------------------------
-- line 2194 ----------------------------------------
        .               gSPPerspNormalize(gDisplayListHead++, perspNorm);
        .               guLookAt(&arg0->mtxLookAt[0], 0.0f, 0.0f, (f32) D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
        .               func_800942D0();
        .               gDPPipeSync(gDisplayListHead++);
        .               gDPSetTexturePersp(gDisplayListHead++, G_TP_NONE);
        .               gDPSetTextureFilter(gDisplayListHead++, G_TF_BILERP);
        .           }
        .           
      744 ( 0.00%)  void render_checkered_flag(struct GfxPool* arg0, UNUSED s32 arg1) {
        .               u16 perspNorm;
       93 ( 0.00%)      move_segment_table_to_dmem();
    4,092 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/racing/memory.c:move_segment_table_to_dmem (93x)
      930 ( 0.00%)      guPerspective(&arg0->mtxPersp[0], &perspNorm, 45.0f, 1.3333334f, 100.0f, 12800.0f, 1.0f);
   39,618 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guPerspectiveF.c:guPerspective (93x)
      744 ( 0.00%)      gSPPerspNormalize(gDisplayListHead++, perspNorm);
    1,488 ( 0.00%)      guLookAt(&arg0->mtxLookAt[1], 0.0f, 0.0f, (f32) D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
   13,578 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guLookAtF.c:guLookAt (93x)
      744 ( 0.00%)      guRotate(&arg0->mtxObject[0], D_8018EDC8, 1.0f, 0, 0);
   18,600 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guRotateF.c:guRotate (93x)
      744 ( 0.00%)      guRotate(&arg0->mtxObject[1], D_8018EDCC, 0, 1.0f, 0);
   16,926 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guRotateF.c:guRotate (93x)
      744 ( 0.00%)      guRotate(&arg0->mtxObject[2], D_8018EDD0, 0, 0, 1.0f);
   16,926 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guRotateF.c:guRotate (93x)
      651 ( 0.00%)      guScale(&arg0->mtxObject[3], D_8018EDC4, D_8018EDC4, D_8018EDC4);
    6,417 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guScaleF.c:guScale (93x)
      837 ( 0.00%)      guTranslate(&arg0->mtxObject[4], D_8018EDD4, D_8018EDD8, D_8018EDDC);
    6,138 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guTranslateF.c:guTranslate (93x)
      372 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxPersp[0], G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      279 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxLookAt[1], G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
      186 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[0], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      186 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[1], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      186 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[2], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      186 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[3], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      279 ( 0.00%)      gSPMatrix(gDisplayListHead++, &arg0->mtxObject[4], G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
      372 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007FC8);
  183,320 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (93x)
       93 ( 0.00%)      func_800B0004();
2,708,295 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_800AF9B0.c:func_800B0004 (93x)
      465 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007650);
  181,898 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (93x)
      744 ( 0.00%)  }
        .           
      372 ( 0.00%)  void func_80094A64(struct GfxPool* pool) {
      186 ( 0.00%)      gMatrixHudCount = 0;
      186 ( 0.00%)      gMatrixEffectCount = 0;
      465 ( 0.00%)      gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
      465 ( 0.00%)      gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
      744 ( 0.00%)      guOrtho(&pool->mtxScreen, 0.0f, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1, 0.0f, -100.0f, 100.0f, 1.0f);
   10,044 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guOrthoF.c:guOrtho (93x)
      372 ( 0.00%)      gSPMatrix(gDisplayListHead++, &pool->mtxScreen, G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
      372 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_02007650);
  182,749 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (93x)
       93 ( 0.00%)      render_menus();
    1,023 ( 0.00%)  => src/code_80091750.c:render_menus (93x)
      558 ( 0.00%)      func_80092290(4, D_8018E850, D_8018E858);
  570,754 ( 0.00%)  => src/code_80091750.c:func_80092290 (93x)
      372 ( 0.00%)      func_80092290(5, (s32*) &D_8018E850[1], (s32*) &D_8018E858[1]);
  569,042 ( 0.00%)  => src/code_80091750.c:func_80092290 (93x)
       93 ( 0.00%)      func_80099A70();
      279 ( 0.00%)  => src/code_80091750.c:func_80099A70 (93x)
       93 ( 0.00%)      func_8009C918();
    2,046 ( 0.00%)  => src/code_80091750.c:func_8009C918 (93x)
      372 ( 0.00%)      switch (gMenuSelection) {
        .                   case START_MENU:
       93 ( 0.00%)              func_80095574();
7,822,236 ( 0.01%)  => src/code_80091750.c:func_80095574 (93x)
       93 ( 0.00%)              func_80093E40();
  666,026 ( 0.00%)  => src/code_80091750.c:func_80093E40 (93x)
       93 ( 0.00%)              break;
        .                   case OPTIONS_MENU:
        .                   case DATA_MENU:
        .                   case COURSE_DATA_MENU:
        .                   case LOGO_INTRO_MENU:
        .                   case CONTROLLER_PAK_MENU:
        .                   case MAIN_MENU:
        .                   case CHARACTER_SELECT_MENU:
        .                   case COURSE_SELECT_MENU:
        .                       func_800A8230();
        .                       func_80099AEC();
        .                       break;
        .               }
       93 ( 0.00%)      func_8009CA2C();
1,463,688 ( 0.00%)  => src/code_80091750.c:func_8009CA2C (93x)
      186 ( 0.00%)      gCycleFlashMenu += 1;
      372 ( 0.00%)      gDPPipeSync(gDisplayListHead++);
      372 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020076B0);
  182,618 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (93x)
      279 ( 0.00%)  }
        .           
      282 ( 0.00%)  void render_menus(void) {
      376 ( 0.00%)      if (D_800E86A4 != 0) {
        1 ( 0.00%)          func_80099110();
        5 ( 0.00%)  => src/code_80091750.c:func_80099110 (1x)
        1 ( 0.00%)          func_8009A344();
       18 ( 0.00%)  => src/code_80091750.c:func_8009A344 (1x)
        1 ( 0.00%)          func_8009E620();
       85 ( 0.00%)  => src/code_80091750.c:func_8009E620 (1x)
        1 ( 0.00%)          func_8009B938();
        7 ( 0.00%)  => src/code_80091750.c:func_8009B938 (1x)
        1 ( 0.00%)          func_80092258();
        6 ( 0.00%)  => src/code_80091750.c:func_80092258 (1x)
        1 ( 0.00%)          func_800B5F30();
       36 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:func_800B5F30 (1x)
        1 ( 0.00%)          func_800B6014();
       26 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:func_800B6014 (1x)
        3 ( 0.00%)          func_800B3F74(gMenuSelection);
    1,085 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/menus.c:func_800B3F74 (1x)
        8 ( 0.00%)          switch (gMenuSelection) {
        .                       case OPTIONS_MENU:
        .                           add_ui_element(0x00000023, 0, 0, 2);
        .                           add_ui_element(0x000000F1, 0, 0, 4);
        .                           add_ui_element(0x000000F0, 0, 0, 2);
        .                           break;
        .                       case DATA_MENU:
        .                           add_ui_element(0x00000023, 0, 0, 2);
        .                           add_ui_element(0x0000008C, 0, 0, 6);
-- line 2279 ----------------------------------------
-- line 2312 ----------------------------------------
        .                           add_ui_element(0x000000D3, 0, 0, 8);
        .                           add_ui_element(0x000000D5, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D6, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D7, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D8, 0, 0, 0x0A);
        .                           add_ui_element(0x000000D9, 0, 0, 0x0A);
        .                           break;
        .                       case START_MENU:
        5 ( 0.00%)                  add_ui_element(2, 0, 0, 4);
    2,180 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)                  add_ui_element(1, 0, 0, 0);
  156,104 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        5 ( 0.00%)                  add_ui_element(0x000000FB, 0, 0, 0);
       62 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        3 ( 0.00%)                  if (gControllerBits & 1) {
        5 ( 0.00%)                      add_ui_element(3, 0, 0, 2);
      153 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        .                           } else {
        .                               add_ui_element(4, 0, 0, 2);
        .                           }
        5 ( 0.00%)                  add_ui_element(5, 0, 0, 6);
       55 ( 0.00%)  => src/code_80091750.c:add_ui_element (1x)
        2 ( 0.00%)                  gDemoMode = 0;
        2 ( 0.00%)                  D_8018EE08 = 0;
        1 ( 0.00%)                  break;
        .                       case MAIN_MENU:
        .                           add_ui_element(0x00000023, 0, 0, 2);
        .                           add_ui_element(0x0000000A, 0x0000015E, 0x00000011, 6);
        .                           add_ui_element(0x0000000E, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000D, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000C, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000B, 0x0000015E, 0x0000003E, 6);
        .                           add_ui_element(0x0000000F, 0x0000015E, 0x000000C8, 6);
-- line 2339 ----------------------------------------
-- line 2402 ----------------------------------------
        .                       case 0:
        .                       case 1:
        .                       case 2:
        .                       case 3:
        .                       case 4:
        .                       default:
        .                           break;
        .                   }
        2 ( 0.00%)          if (D_800E86A4 != 2) {
        2 ( 0.00%)              func_8009DF4C(0x00000014);
       19 ( 0.00%)  => src/code_80091750.c:func_8009DF4C (1x)
        .                   } else {
        .                       func_8009DF6C(0x00000014);
        .                   }
        1 ( 0.00%)          D_800E86A4 = 0;
        .               }
      376 ( 0.00%)  }
        .           
        .           CProperties* GetCoursePropsA(void);
        .           
      279 ( 0.00%)  void func_80095574(void) {
        .               s32 var_v0;
        .           
      279 ( 0.00%)      if ((D_8018EE0C < 3) || (D_8018E7AC[4] != 0)) {
       93 ( 0.00%)          func_800A8230();
6,507,852 ( 0.01%)  => src/code_80091750.c:func_800A8230 (93x)
        .               }
      372 ( 0.00%)      if (gDebugMenuSelection >= 2) {
       93 ( 0.00%)          load_debug_font();
  371,468 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:load_debug_font (93x)
      372 ( 0.00%)          debug_print_str2(0x00000050, 0x00000064, "debug_mode");
   76,167 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      591 ( 0.00%)          switch (gDebugMenuSelection) {
        .                       case DEBUG_MENU_DEBUG_MODE:
      208 ( 0.00%)                  debug_print_str2(0x00000046, 0x00000064, "*");
    5,616 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (52x)
       52 ( 0.00%)                  break;
        .                       case DEBUG_MENU_COURSE:
      116 ( 0.00%)                  debug_print_str2(0x00000046, 0x0000006E, "*");
    3,132 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (29x)
       29 ( 0.00%)                  break;
        .                       case DEBUG_MENU_SCREEN_MODE:
        .                           debug_print_str2(0x00000046, 0x00000078, "*");
        .                           break;
        .                       case DEBUG_MENU_PLAYER:
        .                           debug_print_str2(0x00000046, 0x00000082, "*");
        .                           break;
        .                       case DEBUG_MENU_SOUND_MODE:
        .                           debug_print_str2(0x00000046, 0x0000008C, "*");
        .                           break;
        .                       case DEBUG_MENU_GIVE_ALL_GOLD_CUP:
        .                           debug_print_str2(0x00000046, 0x00000096, "*");
        .                           break;
        .                   }
      279 ( 0.00%)          if (gEnableDebugMode) {
      372 ( 0.00%)              debug_print_str2(0x000000AA, 0x00000064, "on");
   17,391 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
        .                   } else {
        .                       debug_print_str2(0x000000AA, 0x00000064, "off");
        .                   }
      279 ( 0.00%)          if ((gCurrentCourseId >= (NUM_COURSES - 1)) || (gCurrentCourseId < 0)) {
        1 ( 0.00%)              gCurrentCourseId = 0;
        .                   }
      651 ( 0.00%)          print_str_num(0x00000050, 0x0000006E, "map_number", GetCourseIndex());
   90,172 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:print_str_num (93x)
      279 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourseIndex (93x)
        .                   // This isn't functionally equivallent, but who cares.
      372 ( 0.00%)          if (gCurrentCourseId < COURSE_TOADS_TURNPIKE) {
        .                       var_v0 = 0;
        .                   } else {
        .                       var_v0 = 8;
        .                   }
      465 ( 0.00%)          debug_print_str2(var_v0 + 0xB9, 0x0000006E, GetCoursePropsA()->DebugName);
   65,489 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      837 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCoursePropsA (93x)
      372 ( 0.00%)          debug_print_str2(0x00000050, 0x00000078, "screen_mode");
   83,514 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      651 ( 0.00%)          debug_print_str2(0x000000AA, 0x00000078, gDebugScreenModeNames[D_8018EDF1]);
   17,391 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      372 ( 0.00%)          debug_print_str2(0x00000050, 0x00000082, "player");
   46,779 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      651 ( 0.00%)          debug_print_str2(0x000000AA, 0x00000082, gDebugCharacterNames[gCharacterSelections[0]]);
   39,432 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      372 ( 0.00%)          debug_print_str2(0x00000050, 0x0000008C, "sound mode");
   70,308 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      651 ( 0.00%)          debug_print_str2(0x000000AA, 0x0000008C, gDebugSoundModeNames[gSoundMode]);
   46,779 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:debug_print_str2 (93x)
      186 ( 0.00%)          if (gDebugMenuSelection == DEBUG_MENU_GIVE_ALL_GOLD_CUP) {
        .                       debug_print_str2(0x00000050, 0x00000096, "push b to get all goldcup");
        .                   }
       93 ( 0.00%)          func_80057778();
  185,767 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_80057778 (93x)
        .               }
      465 ( 0.00%)      if (gDebugMenuSelection == DEBUG_MENU_DISABLED) {
        .                   gMenuTimingCounter += 1;
        .               } else {
        .                   gMenuTimingCounter = 3;
        .               }
        .               if (gMenuTimingCounter == DEBUG_MENU_DEBUG_MODE) {
        .                   play_sound2(SOUND_INTRO_WELCOME);
        .               }
        .               if (gMenuTimingCounter >= 0x12D) {
        .                   func_8009E230();
        .                   func_800CA0A0();
        .               }
      558 ( 0.00%)      gSPDisplayList(gDisplayListHead++, D_020076E0);
  184,310 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (93x)
      279 ( 0.00%)  }
        .           
        .           // While this matches, its a little screwy
        .           // This function seemingly needs to return a Gfx*, but doing that explicity doesn't match
        .           // Instead we depend on the fact that the result of draw_box_fill is left
        .           // in v0 which means it is returned, sort of.
        .           // Its also weird that the displayListHead argument goes entirely unused. What's up with that?
        .           Gfx* draw_flash_select_case(UNUSED Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 speed) {
        .               s32 greyscale;
-- line 2498 ----------------------------------------
-- line 2517 ----------------------------------------
        .           Gfx* draw_flash_select_case_slow(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
        .               return draw_flash_select_case(displayListHead, ulx, uly, lrx, lry, 64);
        .           }
        .           
        .           Gfx* draw_flash_select_case_fast(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
        .               return draw_flash_select_case(displayListHead, ulx, uly, lrx, lry, 4);
        .           }
        .           
   11,350 ( 0.00%)  Gfx* func_800959F8(Gfx* displayListHead, Vtx* arg1) {
        .               s32 index;
        .           
    9,080 ( 0.00%)      if ((s32) gTextColor < TEXT_BLUE_GREEN_RED_CYCLE_1) {
        .                   index = gTextColor;
        .               } else {
   18,160 ( 0.00%)          index = ((gTextColor * 2) + ((s32) gGlobalTimer % 2)) - 4;
        .               }
        .           #ifdef AVOID_UB
   24,970 ( 0.00%)      arg1 = LOAD_ASSET(arg1);
4,345,355 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (2,270x)
   70,370 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (2,270x)
   13,620 ( 0.00%)      gSPVertex(displayListHead++, arg1, 2, 0);
  149,820 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPVertex (2,270x)
   18,160 ( 0.00%)      gSPVertex(displayListHead++, &arg1[(index + 1) * 2], 2, 2);
  165,010 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPVertex (2,270x)
    6,810 ( 0.00%)      gSPDisplayList(displayListHead++, common_rectangle_display);
4,559,768 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (2,270x)
        .           #else
        .               if (arg1 == D_02007BB8) {
        .                   gSPDisplayList(displayListHead++, D_800E84CC[index]);
        .               } else if (arg1 == D_02007CD8) {
        .                   gSPDisplayList(displayListHead++, D_800E84EC[index]);
        .               } else if (arg1 == D_02007DF8) {
        .                   gSPDisplayList(displayListHead++, D_800E850C[index]);
        .               }
        .           #endif
        .           
        .               return displayListHead;
    9,080 ( 0.00%)  }
        .           
        .           #ifdef AVOID_UB
        .           #define MTX_TYPE Mtx
        .           #else
        .           typedef struct {
        .               u16 i[4][4];
        .               u16 f[4][4];
        .           } Mtx_u;
-- line 2557 ----------------------------------------
-- line 2566 ----------------------------------------
        .               s16 s[2];
        .               s32 w;
        .           } TheWhyUnion;
        .           
        .           #define MTX_TYPE Mtx2
        .           #endif
        .           
        .           // Why... Why... Why... This function is so bad it's not going in the header.
    4,540 ( 0.00%)  void func_80095AE0(MTX_TYPE* arg0, f32 arg1, f32 arg2, f32 arg3, f32 arg4) {
        .           #ifdef AVOID_UB
        .               // Use Mat4 array to set matrix values using guMtxF2L. This helps little-endian systems.
        .               Mat4 src;
    2,270 ( 0.00%)      src[0][0] = arg3;
    2,270 ( 0.00%)      src[0][1] = 0.0f;
        .               src[0][2] = 0.0f;
    2,270 ( 0.00%)      src[0][3] = 0.0f;
        .               src[1][0] = 0.0f;
    2,270 ( 0.00%)      src[1][1] = arg4;
    2,270 ( 0.00%)      src[1][2] = 0.0f;
        .               src[1][3] = 0.0f;
    2,270 ( 0.00%)      src[2][0] = 0.0f;
        .               src[2][1] = 0.0f;
    2,270 ( 0.00%)      src[2][2] = 1.0f;
        .               src[2][3] = 0.0f;
    2,270 ( 0.00%)      src[3][0] = arg1;
    2,270 ( 0.00%)      src[3][1] = arg2;
    4,540 ( 0.00%)      src[3][2] = 0.0f;
        .               src[3][3] = 1.0f;
    4,540 ( 0.00%)      guMtxF2L(src, arg0);
   74,910 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/os/guMtxF2L.c:guMtxF2L (2,270x)
        .           #else
        .               TheWhyUnion sp14;
        .               TheWhyUnion sp10;
        .               TheWhyUnion spC;
        .               TheWhyUnion sp8;
        .               s32 i;
        .           
        .               // clang-format off
-- line 2602 ----------------------------------------
-- line 2614 ----------------------------------------
        .               arg0->u.i[3][0] = spC.s[0];
        .               arg0->u.i[3][1] = sp8.s[0];
        .               arg0->u.i[3][3] = 1;
        .               arg0->u.f[0][0] = sp14.s[1];
        .               arg0->u.f[1][1] = sp10.s[1];
        .               arg0->u.f[3][0] = spC.s[1];
        .               arg0->u.f[3][1] = sp8.s[1];
        .           #endif
    4,540 ( 0.00%)  }
        .           
        .           #undef MTX_TYPE
        .           
   18,160 ( 0.00%)  Gfx* func_80095BD0(Gfx* displayListHead, u8* arg1, f32 arg2, f32 arg3, u32 arg4, u32 arg5, f32 arg6, f32 arg7) {
        .               Vtx* var_a1;
        .               Mtx* sp28;
        .           
        .               // A match is a match, but why are goto's required here?
   11,350 ( 0.00%)      if (gMatrixEffectCount >= 0x2F7) {
        .                   goto func_80095BD0_label1;
        .               }
   15,890 ( 0.00%)      sp28 = &gGfxPool->mtxEffect[gMatrixEffectCount];
    4,540 ( 0.00%)      if (gMatrixEffectCount < 0) {
        .                   rmonPrintf("effectcount < 0 !!!!!!(kawano)\n");
        .               }
        .               goto func_80095BD0_label2;
        .           func_80095BD0_label1:
        .               rmonPrintf("MAX effectcount(760) over!!!!(kawano)\n");
        .               return displayListHead;
        .           func_80095BD0_label2:
    4,540 ( 0.00%)      func_80095AE0(sp28, arg2, arg3, arg6, arg7);
  113,500 ( 0.00%)  => src/code_80091750.c:func_80095AE0 (2,270x)
   18,160 ( 0.00%)      gSPMatrix(displayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxEffect[gMatrixEffectCount]),
        .                         G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
    4,540 ( 0.00%)      gMatrixEffectCount += 1;
  102,150 ( 0.00%)      gDPLoadTextureTile_4b(displayListHead++, arg1, G_IM_FMT_I, arg4, 0, 0, 0, arg4, arg5, 0, G_TX_NOMIRROR | G_TX_WRAP,
        .                                     G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
    6,810 ( 0.00%)      switch (arg4) {
        .                   default:
        .                       var_a1 = D_02007CD8;
        .                       break;
        .                   case 16:
        .                       var_a1 = D_02007CD8;
        .                       break;
        .                   case 26:
        .                       var_a1 = D_02007BB8;
        .                       break;
        .                   case 30:
        .                       var_a1 = D_02007DF8;
        .                       break;
        .               }
        .           
    2,270 ( 0.00%)      return func_800959F8(displayListHead, var_a1);
9,401,553 ( 0.02%)  => src/code_80091750.c:func_800959F8 (2,270x)
   15,890 ( 0.00%)  }
        .           
        .           // Player select menu character border
        .           Gfx* func_80095E10(Gfx* displayListHead, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8,
    3,735 ( 0.00%)                     s32 arg9, u8* argA, u32 argB, u32 argC) {
        .               u32 var_a1_2 = arg4;
        .               u32 var_s3 = arg5;
        .               s32 sp7C;
        .               u32 var_s2;
        .               u32 var_s4;
      498 ( 0.00%)      s32 var_t0 = 1;
        .               s32 temp_lo;
      498 ( 0.00%)      s32 sp68 = 0;
      498 ( 0.00%)      s32 sp64 = 0;
        .               s32 var_v0_2;
        .           
    6,474 ( 0.00%)      while (var_t0 < argB) {
    1,992 ( 0.00%)          var_t0 *= 2;
        .               }
        .           
      996 ( 0.00%)      temp_lo = 0x400 / var_t0;
        .           
    1,494 ( 0.00%)      while ((temp_lo / 2) > argC) {
        .                   temp_lo /= 2;
        .               }
        .           
      249 ( 0.00%)      var_v0_2 = var_t0;
    4,482 ( 0.00%)      while (var_v0_2 > 1) {
    1,992 ( 0.00%)          var_v0_2 /= 2;
    1,992 ( 0.00%)          sp68 += 1;
        .               }
      249 ( 0.00%)      var_v0_2 = temp_lo;
        .           
    1,494 ( 0.00%)      while (var_v0_2 > 1) {
      498 ( 0.00%)          var_v0_2 /= 2;
      498 ( 0.00%)          sp64 += 1;
        .               }
        .           
      747 ( 0.00%)      if (arg8 < 0) {
        .                   arg4 -= arg8;
        .                   arg8 = 0;
      996 ( 0.00%)      } else if (((arg6 - arg4) + arg8) > SCREEN_WIDTH) {
    1,245 ( 0.00%)          arg6 = (arg4 - arg8) + SCREEN_WIDTH;
        .               }
        .           
      498 ( 0.00%)      if (arg9 < 0) {
        .                   arg5 -= arg9;
        .                   arg9 = 0;
      747 ( 0.00%)      } else if (((arg7 - arg5) + arg9) > SCREEN_HEIGHT) {
    1,494 ( 0.00%)          arg7 = (arg5 - arg9) + SCREEN_HEIGHT;
        .               }
        .           
        .               if (arg6 < arg4) {
        .                   return displayListHead;
        .               }
      996 ( 0.00%)      if (arg7 < arg5) {
        .                   return displayListHead;
        .               }
        .               sp7C = arg8;
   36,069 ( 0.00%)      for (var_s3 = arg5; var_s3 < arg7; var_s3 += temp_lo) {
        .           
   46,764 ( 0.00%)          if (arg7 < temp_lo + var_s3) {
       93 ( 0.00%)              var_s4 = arg7 - var_s3;
        .                       if (!var_s4) {
        .                           break;
        .                       }
        .                   } else {
        .                       var_s4 = temp_lo;
        .                   }
        .           
   93,342 ( 0.00%)          for (var_a1_2 = arg4; var_a1_2 < arg6; var_a1_2 += var_t0) {
        .           
   58,455 ( 0.00%)              if (arg6 < var_t0 + var_a1_2) {
   11,691 ( 0.00%)                  var_s2 = arg6 - var_a1_2;
        .                           if (!var_s2) {
        .                               break;
        .                           }
        .                       } else {
   35,073 ( 0.00%)                  var_s2 = var_t0;
        .                       }
  729,822 ( 0.00%)              gDPLoadTextureTile(displayListHead++, argA, arg1, G_IM_SIZ_16b, argB, 0, var_a1_2, var_s3,
        .                                          var_a1_2 + var_s2, var_s3 + var_s4, 0, G_TX_NOMIRROR | G_TX_WRAP,
        .                                          G_TX_NOMIRROR | G_TX_WRAP, sp68, sp64, G_TX_NOLOD, G_TX_NOLOD);
  374,112 ( 0.00%)              gSPTextureRectangle(displayListHead++, arg8 * 4, arg9 * 4, (arg8 + var_s2) * 4, (arg9 + var_s4) * 4, 0,
        .                                           (var_a1_2 * 32) & 0xFFFF, (var_s3 * 32) & 0xFFFF, arg2, arg3);
        .           
   23,382 ( 0.00%)              arg8 += var_t0;
        .                   }
        .           
        .                   arg8 = sp7C;
   11,691 ( 0.00%)          arg9 += temp_lo;
        .               }
        .               return displayListHead;
    1,992 ( 0.00%)  }
        .           
        .           Gfx* func_800963F0(Gfx* displayListHead, s8 arg1, s32 arg2, s32 arg3, f32 arg4, f32 arg5, s32 arg6, s32 arg7, s32 arg8,
        .                              s32 arg9, s32 argA, s32 argB, u8* argC, u32 argD, u32 argE) {
        .               u32 var_a1_2 = arg6;
        .               u32 var_s3 = arg7;
        .               s32 sp7C;
        .               u32 var_s2;
        .               u32 var_s4;
-- line 2766 ----------------------------------------
-- line 3226 ----------------------------------------
        .                   }
        .                   column = columnCopy;
        .                   row += 0x20;
        .               }
        .               return displayListHead;
        .           }
        .           
        .           // draw a box filled with a solid color
    2,304 ( 0.00%)  Gfx* draw_box_fill(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 red, s32 green, s32 blue, s32 alpha) {
        .               red &= 0xFF;
        .               green &= 0xFF;
        .               blue &= 0xFF;
        .               alpha &= 0xFF;
      512 ( 0.00%)      if (lrx < ulx) {
        .                   swap_values(&ulx, &lrx);
        .               }
      768 ( 0.00%)      if (lry < uly) {
        .                   swap_values(&uly, &lry);
        .               }
    1,536 ( 0.00%)      if ((ulx >= 0x140) || (uly >= 0xF0)) {
        .                   return displayListHead;
        .               }
      512 ( 0.00%)      if (ulx < 0) {
        .                   ulx = 0;
        .               }
      512 ( 0.00%)      if (uly < 0) {
        .                   uly = 0;
        .               }
    1,536 ( 0.00%)      if ((lrx < 0) || (lry < 0)) {
        .                   return displayListHead;
        .               }
      512 ( 0.00%)      if (lrx >= SCREEN_WIDTH) {
        .                   lrx = SCREEN_WIDTH - 1;
        .               }
      512 ( 0.00%)      if (lry >= SCREEN_HEIGHT) {
        .                   lry = SCREEN_HEIGHT - 1;
        .               }
      768 ( 0.00%)      gSPDisplayList(displayListHead++, D_02008030);
  501,146 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (256x)
    5,120 ( 0.00%)      gDPSetFillColor(displayListHead++, (GPACK_RGBA5551(red, green, (u32) blue, alpha) << 0x10 |
        .                                                   GPACK_RGBA5551(red, green, (u32) blue, alpha)));
    4,352 ( 0.00%)      gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
    1,280 ( 0.00%)      gSPDisplayList(displayListHead++, D_02008058);
  504,731 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (256x)
        .               return displayListHead;
    1,024 ( 0.00%)  }
        .           
        .           // draw a box filled with a solid color
        .           Gfx* draw_box_fill_wide(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, s32 red, s32 green, s32 blue,
        .                                   s32 alpha) {
        .               red &= 0xFF;
        .               green &= 0xFF;
        .               blue &= 0xFF;
        .               alpha &= 0xFF;
-- line 3277 ----------------------------------------
-- line 3305 ----------------------------------------
        .               gDPFillWideRectangle(displayListHead++, OTRGetDimensionFromLeftEdge(ulx), uly, OTRGetDimensionFromRightEdge(lrx),
        .                                    lry);
        .               // gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
        .               gSPDisplayList(displayListHead++, D_02008058);
        .               return displayListHead;
        .           }
        .           
        .           // draw a box with a solid outline
      288 ( 0.00%)  Gfx* draw_box(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry, u32 red, u32 green, u32 blue, u32 alpha) {
        .               red &= 0xFF;
        .               green &= 0xFF;
        .               blue &= 0xFF;
       32 ( 0.00%)      alpha &= 0xFF;
       64 ( 0.00%)      if (lrx < ulx) {
        .                   swap_values(&ulx, &lrx);
        .               }
       96 ( 0.00%)      if (lry < uly) {
        .                   swap_values(&uly, &lry);
        .               }
      192 ( 0.00%)      if ((ulx >= 0x140) || (uly >= 0xF0)) {
        .                   return displayListHead;
        .               }
       64 ( 0.00%)      if (ulx < 0) {
        .                   ulx = 0;
        .               }
       64 ( 0.00%)      if (uly < 0) {
        .                   uly = 0;
        .               }
      192 ( 0.00%)      if ((lrx < 0) || (lry < 0)) {
        .                   return displayListHead;
        .               }
       64 ( 0.00%)      if (lrx >= 0x141) {
        .                   lrx = 0x140;
        .               }
       64 ( 0.00%)      if (lry >= 0xF1) {
        .                   lry = 0xF0;
        .               }
       96 ( 0.00%)      gSPDisplayList(displayListHead++, D_02008008);
   63,540 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (32x)
      448 ( 0.00%)      gDPSetPrimColor(displayListHead++, 0, 0, red, green, blue, alpha);
        .               // gDPFillWideRectangle(displayListHead++, OTRGetRectDimensionFromLeftEdge(0), uly,
        .               // OTRGetRectDimensionFromRightEdge(SCREEN_WIDTH), lry);
      512 ( 0.00%)      gDPFillRectangle(displayListHead++, ulx, uly, lrx, lry);
      128 ( 0.00%)      gDPPipeSync(displayListHead++);
        .               return displayListHead;
      128 ( 0.00%)  }
        .           
      256 ( 0.00%)  Gfx* func_80098FC8(Gfx* displayListHead, s32 ulx, s32 uly, s32 lrx, s32 lry) {
    1,280 ( 0.00%)      return draw_box_fill(displayListHead, ulx, uly, lrx, lry, 0, 0, 0, 0xFF);
1,027,125 ( 0.00%)  => src/code_80091750.c:draw_box_fill (256x)
      512 ( 0.00%)  }
        .           
        .           void dma_copy_base_729a30(u64* arg0, size_t nbytes, void* vaddr) {
        .           #ifdef TARGET_N64
        .               OSIoMesg sp30;
        .               OSMesg sp2C;
        .           
        .               osInvalDCache(vaddr, nbytes);
        .               osPiStartDma(&sp30, OS_MESG_PRI_NORMAL, OS_READ, (uintptr_t) &_textures_0aSegmentRomStart[SEGMENT_OFFSET(arg0)],
-- line 3361 ----------------------------------------
-- line 3372 ----------------------------------------
        .               osInvalDCache(vaddr, nbytes);
        .               osPiStartDma(&sp30, OS_MESG_PRI_NORMAL, OS_READ, (uintptr_t) &_textures_0bSegmentRomStart[SEGMENT_OFFSET(arg0)],
        .                            vaddr, nbytes, &gDmaMesgQueue);
        .               osRecvMesg(&gDmaMesgQueue, &sp2C, OS_MESG_BLOCK);
        .           #endif
        .           }
        .           
        .           void func_80099110(void) {
        4 ( 0.00%)      gMenuTextureBufferIndex = 0;
        4 ( 0.00%)      gNumD_8018E118Entries = 0;
        2 ( 0.00%)  }
        .           
        .           /**
        .            * Differs from memory.c with `+ 0x8` instead of `| 0x8`
        .            *
        .            * @param addr
        .            * @return void*
        .            */
   10,344 ( 0.00%)  void* segmented_to_virtual_dupe(const void* addr) {
        .           #ifdef TARGET_N64
        .               size_t segment = (uintptr_t) addr >> 24;
        .               size_t offset = (uintptr_t) addr & 0x00FFFFFF;
        .           
        .               return (void*) ((gSegmentTable[segment] + offset) + 0x80000000);
        .           #else
        .               return addr;
        .           #endif
   10,344 ( 0.00%)  }
        .           
        .           void* segmented_to_virtual_dupe_2(const void* addr) {
        .           #ifdef TARGET_N64
        .               size_t segment = (uintptr_t) addr >> 24;
        .               size_t offset = (uintptr_t) addr & 0x00FFFFFF;
        .           
        .               return (void*) ((gSegmentTable[segment] + offset) + 0x80000000);
        .           #else
-- line 3407 ----------------------------------------
-- line 3409 ----------------------------------------
        .           #endif
        .           }
        .           
        .           #include <assets/player_selection.h>
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/NAZ12
        .           // Register allocation nonsense
   12,625 ( 0.00%)  void load_menu_img(MkTexture* arg0) {
        .               u16 var_a1_2;
        .               s32 var_v0;
        .               s32 var_a1;
        .               MkTexture* var_s1;
        .               struct_8018E118_entry* thing = &D_8018E118[0];
    2,525 ( 0.00%)      var_s1 = segmented_to_virtual_dupe(arg0);
    5,050 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (2,525x)
   15,150 ( 0.00%)      while (var_s1->textureData != NULL) {
        .                   var_a1 = 0;
   70,640 ( 0.00%)          for (var_v0 = 0; var_v0 < gNumD_8018E118Entries; var_v0++) {
   31,920 ( 0.00%)              if (var_s1->textureData == (thing + var_v0)->textureData) {
        .                           var_a1 = 1;
        .                           break;
        .                       }
        .                   }
        .           
        .                   if (var_a1 == 0) {
        .                       if (var_s1->type == 3) {
        .                           if (var_s1->size != 0) {
-- line 3435 ----------------------------------------
-- line 3442 ----------------------------------------
        .                           }
        .           // mio0decode(D_8018D9B4, &D_8018D9B0[gMenuTextureBufferIndex]);
        .           // size_t texSize = ResourceGetTexSizeByName(var_s1->textureData);
        .           // memcpy(&D_8018D9B0[gMenuTextureBufferIndex], var_s1->textureData, texSize);
        .           #ifdef TARGET_N64
        .                           dma_copy_base_729a30(var_s1->textureData, var_a1_2, D_8018D9B4);
        .                           mio0decode(D_8018D9B4, (u8*) &D_8018D9B0[gMenuTextureBufferIndex]);
        .           #else
       65 ( 0.00%)                  strcpy(&D_8018D9B0[gMenuTextureBufferIndex], var_s1->textureData);
        .           #endif
        .                       } else {
        .           #ifdef TARGET_N64
        .                           dma_copy_base_729a30(var_s1->textureData, var_s1->height * var_s1->width * 2,
        .                                                &D_8018D9B0[gMenuTextureBufferIndex]);
        .           #else
       26 ( 0.00%)                  strcpy(&D_8018D9B0[gMenuTextureBufferIndex], var_s1->textureData);
      290 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcpy-avx2.S:__strcpy_avx2 (13x)
        .           #endif
        .                       }
       78 ( 0.00%)              thing[gNumD_8018E118Entries].textureData = var_s1->textureData;
       26 ( 0.00%)              thing[gNumD_8018E118Entries].offset = gMenuTextureBufferIndex;
       52 ( 0.00%)              gMenuTextureBufferIndex += var_s1->height * var_s1->width;
       65 ( 0.00%)              gMenuTextureBufferIndex = ((gMenuTextureBufferIndex / 8) * 8) + 8;
       26 ( 0.00%)              gNumD_8018E118Entries += 1;
        .                   }
    2,525 ( 0.00%)          var_s1++;
        .               }
   15,150 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/load_menu_img.s")
        .           #endif
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/O2tkD
        .           // Register allocation nonsense
        .           void func_80099394(MkTexture* arg0) {
-- line 3476 ----------------------------------------
-- line 3566 ----------------------------------------
        .           
        .           void load_img_wrap(MkTexture* arg0) {
        .               load_menu_img2(arg0, 1);
        .           }
        .           
        .           #ifdef NON_MATCHING
        .           // Register allocation nonsense
        .           // https://decomp.me/scratch/hwAAp
        6 ( 0.00%)  void load_menu_img2(MkTexture* arg0, s32 arg1) {
        .               u16 var_a1_2;
        .               s32 var_v0;
        .               s32 var_a1;
        .               u8 var_v0_2;
        .               MkTexture* texture;
        .               struct_8018E118_entry* thing = &D_8018E118[0];
        .           
        1 ( 0.00%)      texture = segmented_to_virtual_dupe(arg0);
        2 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (1x)
        .           
        .               size_t siz = texture->width * texture->height;
        .               // for (size_t i = 0; i < siz; i++) {
        .               //     printf(" 0x%llX", texture->textureData[i]);
        .               // }
        .           
        .               // Because it's loading an mkTexture. The second element in the array is usually all zeros.
        .               // Despite this loop, it's usually only ran once.
        6 ( 0.00%)      while (texture->textureData != NULL) {
        .                   var_a1 = 0;
       15 ( 0.00%)          for (var_v0 = 0; var_v0 < gNumD_8018E118Entries; var_v0++) {
        2 ( 0.00%)              if (texture->textureData == (thing + var_v0)->textureData) {
        .                           var_a1 = 1;
        .                           break;
        .                       }
        .                   }
        .                   if ((var_a1 == 0) || (arg1 > 0)) {
        .                       if (texture->size != 0) {
        .                           var_a1_2 = texture->size;
        .                       } else {
-- line 3602 ----------------------------------------
-- line 3610 ----------------------------------------
        .                           case 1:
        .                               // dma_copy_base_729a30(texture->textureData, var_a1_2, D_8018D9B4);
        .                               break;
        .                           case 0:
        .                           case 2:
        .                               // dma_copy_base_7fa3c0(texture->textureData, var_a1_2, D_8018D9B4);
        .                               break;
        .                       }
        7 ( 0.00%)              switch (arg1) { /* switch 1; irregular */
        .                           case -1:    /* switch 1 */
        .                           case 1: {
        .                               // mio0decode(D_8018D9B4, (u8*)&D_8018D9B0[gMenuTextureBufferIndex]);
        .                               // printf("w: %d, h: %d", texture->width, texture->height);
        1 ( 0.00%)                      u8* tex = (u8*) LOAD_ASSET(texture->textureData);
        .                               memcpy(&D_8018D9B0[gMenuTextureBufferIndex], tex, texture->width * texture->height * 2);
        .                               break;
        .                           }
        .                           case 0: /* switch 1 */
        .                           case 2: /* switch 1 */
        .                               if (texture->type == 1) {
        .                                   var_v0_2 = 0x000000BE;
        .                               } else {
        .                                   var_v0_2 = 1;
        .                               }
        .                               if (1) {}
        .                               // D_8018D9B0[gMenuTextureBufferIndex] = &gTextureBackgroundBlueSky;
        .                               // tkmk00decode(D_8018D9B4, texture->textureData, (u8*)&D_8018D9B0[gMenuTextureBufferIndex],
        .                               // var_v0_2);
        7 ( 0.00%)                      u8* tex2 = (u8*) LOAD_ASSET(texture->textureData);
    2,336 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/libultraship/src/public/bridge/resourcebridge.cpp:ResourceGetDataByName (1x)
       31 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Engine.cpp:GameEngine_OTRSigCheck (1x)
       12 ( 0.00%)                      memcpy(&D_8018D9B0[gMenuTextureBufferIndex], tex2, texture->width * texture->height * 2);
  153,600 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        1 ( 0.00%)                      break;
        .                       }
        .           
        6 ( 0.00%)              thing[gNumD_8018E118Entries].textureData = texture->textureData;
        2 ( 0.00%)              thing[gNumD_8018E118Entries].offset = gMenuTextureBufferIndex;
        4 ( 0.00%)              gMenuTextureBufferIndex += texture->height * texture->width;
        5 ( 0.00%)              gMenuTextureBufferIndex = ((gMenuTextureBufferIndex / 8) * 8) + 8;
        2 ( 0.00%)              gNumD_8018E118Entries += 1;
        .                   }
        1 ( 0.00%)          texture++;
        .               }
        6 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/load_menu_img2.s")
        .           #endif
        .           
        .           void func_80099958(MkTexture* arg0, s32 arg1, s32 arg2) {
        .               u16 var_a1;
        .               UNUSED u8* thing;
        .               MkTexture* temp_v0;
-- line 3659 ----------------------------------------
-- line 3676 ----------------------------------------
        .                          temp_v0->width * temp_v0->height * 2);
        .                   temp_v0++;
        .               }
        .           }
        .           
        .           // Possibly a debug print function?
        .           void func_80099A70(void) {
        .               s32 i;
    1,138 ( 0.00%)      D_8018E060[0].texture = NULL;
        .               for (i = 0; i < D_8018E060_SIZE; i++) {}
      569 ( 0.00%)  }
        .           
        .           void func_80099A94(MkTexture* arg0, s32 arg1) {
        .               struct_8018E060_entry* var_v1;
        .           
        .               var_v1 = &D_8018E060[0];
        .               while (var_v1->texture != NULL) {
        .                   var_v1++;
        .               }
        .               var_v1->texture = segmented_to_virtual_dupe(arg0);
        .               var_v1->unk_4 = arg1;
        .           }
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/rxEoi
        .           // Something's up with the handling of `_textures_0aSegmentRomStart`, I don't know how to fix it
    3,808 ( 0.00%)  void func_80099AEC(void) {
        .               s8 var_s4;
        .               s32 size;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               s32 huh;
        .               OSIoMesg sp68;
        .               OSMesg sp64;
        .               UNUSED u8* test;
        .               s32 sp60;
        .               MkTexture* temp_s2;
        .               struct_8018E060_entry* var_s1;
        .           
    2,380 ( 0.00%)      if (gGamestate == RACING) {
        .                   sp60 = 0x00000500;
        .               } else {
        .                   sp60 = 0x00001000;
        .               }
        .           
        .               var_s4 = 0;
        .               var_s1 = &D_8018E060[0];
      952 ( 0.00%)      temp_s2 = var_s1->texture;
        .           
      952 ( 0.00%)      if (temp_s2 == NULL)
        .                   return;
        .           
        .               huh = temp_s2->size;
        .               if (huh != 0) {
        .                   size = huh;
        .               } else {
        .                   size = 0x1400;
        .               }
-- line 3733 ----------------------------------------
-- line 3797 ----------------------------------------
        .                          var_s1->texture->width * var_s1->texture->height * 2);
        .           #endif
        .                   var_s1->texture = NULL;
        .                   var_s1++;
        .                   if (var_s4 != 0)
        .                       break;
        .                   osRecvMesg(&gDmaMesgQueue, &sp64, 1);
        .               }
    3,808 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099AEC.s")
        .           #endif
        .           
        .           void func_80099E54(void) {
      952 ( 0.00%)      D_8018E0E8[0].mk64Texture = NULL;
      476 ( 0.00%)  }
        .           
        .           void func_80099E60(MkTexture* arg0, s32 arg1, s32 arg2) {
        .               struct_8018E0E8_entry* var_v1;
        .           
        .               var_v1 = D_8018E0E8;
        .               while (var_v1->mk64Texture != NULL) {
        .                   var_v1++;
        .               }
-- line 3820 ----------------------------------------
-- line 3822 ----------------------------------------
        .               var_v1->unk4 = arg1;
        .               var_v1->unk6 = arg2;
        .           }
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/rUXbD
        .           // Some fakematch nonsense, may or may not be necessary
        .           // Issue is with instruction ordering near the first `osPiStartDma` call
    3,332 ( 0.00%)  void func_80099EC4(void) {
        .               s8 var_s4;
        .               s32 var_s0;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               OSIoMesg sp68;
        .               OSMesg sp64;
        .               s32 huh;
        .               u8* test;
        .               MkTexture* temp_s2;
        .               struct_8018E0E8_entry* var_s1;
        .           
        .               var_s4 = 0;
        .               var_s1 = D_8018E0E8;
      952 ( 0.00%)      temp_s2 = var_s1->mk64Texture;
        .           
      952 ( 0.00%)      if (temp_s2 == NULL)
        .                   return;
        .           
        .               huh = temp_s2->size;
        .               if (huh != 0) {
        .                   var_s0 = huh;
        .               } else {
        .                   var_s0 = 0x1400;
        .               }
-- line 3854 ----------------------------------------
-- line 3923 ----------------------------------------
        .                          temp_s2->textureData, temp_s2->width * temp_s2->height * 2);
        .           #endif
        .                   var_s1->mk64Texture = NULL;
        .                   var_s1++;
        .                   if (var_s4 != 0)
        .                       break;
        .                   osRecvMesg(&gDmaMesgQueue, &sp64, 1);
        .               }
    3,808 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099EC4.s")
        .           #endif
        .           
        .           void func_8009A238(MkTexture* arg0, s32 arg1) {
        .               s32 var_a3;
        .               s32 temp_v1;
        .               u64* sp24;
-- line 3939 ----------------------------------------
-- line 3968 ----------------------------------------
        .                   temp_v0++;
        .                   var_a0 = temp_v0->mk64Texture;
        .               }
        .           }
        .           
        .           void func_8009A344(void) {
        .               s32 index;
        .               for (index = 0; index < D_8018DEE0_SIZE; index++) {
       34 ( 0.00%)          D_8018DEE0[index].visible = 0;
        .               }
        2 ( 0.00%)  }
        .           
        .           s32 animate_character_select_menu(MkAnimation* anim) {
        .               s32 i;
        .               struct_8018DEE0_entry* entry;
        .           
        .               anim = segmented_to_virtual_dupe_2(anim);
        .               i = 0;
        .               while (D_8018DEE0[i].visible) {
-- line 3986 ----------------------------------------
-- line 4321 ----------------------------------------
        .                   newgreen = ((temp_t9 * arg3) >> 8) << 6;
        .                   newblue = ((temp_t9 * arg4) >> 8) << 1;
        .                   *color++ = BSWAP16(newred + newgreen + newblue + alpha);
        .               }
        .               // Invalidate texture to properly apply color manipulation
        .               gSPInvalidateTexCache(gDisplayListHead++, D_8018E118[arg0].offset);
        .           }
        .           
    2,519 ( 0.00%)  u16* func_8009B8C4(u64* arg0) {
        .               UNUSED s32 pad[2];
        .               s32 offset;
        .               s32 found;
        .               s32 someIndex;
        .           
        .               found = 0;
   72,364 ( 0.00%)      for (someIndex = 0; someIndex < gNumD_8018E118Entries; someIndex++) {
   87,680 ( 0.00%)          if (arg0 == D_8018E118[someIndex].textureData) {
        .                       found = 1;
    2,519 ( 0.00%)              offset = D_8018E118[someIndex].offset;
        .                       break;
        .                   }
        .               }
        .           
        .               if (found != 0) {
   12,595 ( 0.00%)          return &D_8018D9B0[offset];
        .               }
      249 ( 0.00%)      return NULL;
        .           }
        .           
        .           // D_8018D9C0 is a little weird. In code_800AF9B0 its treated as a
        .           // struct_8018EE10_entry pointer. But here its being treated as a
        .           // Gfx pointer. It seems to be multi use.
        .           void func_8009B938(void) {
        4 ( 0.00%)      D_8018E75C = (Gfx*) D_8018D9C0;
        2 ( 0.00%)      gNumD_8018E768Entries = 0;
        1 ( 0.00%)  }
        .           
        .           void func_8009B954(MkTexture* arg0) {
        .               D_8018E768[gNumD_8018E768Entries].textures = segmented_to_virtual_dupe(arg0);
        .               D_8018E768[gNumD_8018E768Entries].displayList = D_8018E75C;
        .           }
        .           
        .           void func_8009B998(void) {
        .               gSPEndDisplayList(D_8018E75C++);
-- line 4364 ----------------------------------------
-- line 4385 ----------------------------------------
        .                   }
        .               }
        .               if (found) {
        .                   gSPDisplayList(displayListHead++, displayList);
        .                   return displayListHead;
        .               }
        .           }
        .           
    2,988 ( 0.00%)  Gfx* func_8009BA74(Gfx* arg0, MkTexture* arg1, s32 column, s32 row) {
        .               MkTexture* temp_v0;
        .               u8* temp_v0_3;
        .               s8 var_s4;
        .           
      249 ( 0.00%)      temp_v0 = segmented_to_virtual_dupe(arg1);
      498 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (249x)
    1,494 ( 0.00%)      while (temp_v0->textureData != NULL) {
        .                   var_s4 = 0;
    1,806 ( 0.00%)          switch (temp_v0->type) {
        .                       case 0:
      528 ( 0.00%)                  gSPDisplayList(arg0++, D_02007708);
  183,142 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (93x)
       93 ( 0.00%)                  break;
        .                       case 1:
        .                           gSPDisplayList(arg0++, D_02007728);
        .                           break;
        .                       case 2:
        .                           gSPDisplayList(arg0++, D_02007748);
        .                           break;
        .                       case 3:
        .                           gSPDisplayList(arg0++, D_02007768);
        .                           var_s4 = 3;
        .                           break;
        .                       case 4:
        .                           gSPDisplayList(arg0++, D_02007788);
        .                           break;
        .                       default:
      468 ( 0.00%)                  gSPDisplayList(arg0++, D_02007728);
  306,100 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (156x)
      156 ( 0.00%)                  break;
        .                   }
      747 ( 0.00%)          temp_v0_3 = (u8*) func_8009B8C4(temp_v0->textureData);
    7,230 ( 0.00%)  => src/code_80091750.c:func_8009B8C4 (249x)
      498 ( 0.00%)          if (temp_v0_3 != 0) {
      747 ( 0.00%)              if (D_8018E7AC[4] != 4) {
        .                           arg0 =
    5,229 ( 0.00%)                      func_80095E10(arg0, var_s4, 0x00000400, 0x00000400, 0, 0, temp_v0->width, temp_v0->height,
1,456,848 ( 0.00%)  => src/code_80091750.c:func_80095E10 (249x)
      498 ( 0.00%)                                    temp_v0->dX + column, temp_v0->dY + row, temp_v0_3, temp_v0->width, temp_v0->height);
        .                       } else {
        .                           arg0 = func_800987D0(arg0, 0U, 0U, temp_v0->width, temp_v0->height, temp_v0->dX + column,
        .                                                temp_v0->dY + row, temp_v0_3, temp_v0->width, temp_v0->height);
        .                       }
        .                   }
      249 ( 0.00%)          temp_v0++;
        .               }
        .               return arg0;
    2,241 ( 0.00%)  }
        .           
        .           Gfx* func_8009BC9C(Gfx* arg0, MkTexture* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
        .               MkTexture* var_s0;
        .               u8* temp_v0_3;
        .           
        .               var_s0 = segmented_to_virtual_dupe(arg1);
        .               while (var_s0->textureData != NULL) {
        .                   switch (var_s0->type) { /* irregular */
-- line 4444 ----------------------------------------
-- line 4470 ----------------------------------------
        .                               break;
        .                       }
        .                   }
        .                   var_s0++;
        .               }
        .               return arg0;
        .           }
        .           
   30,276 ( 0.00%)  Gfx* print_letter(Gfx* arg0, MkTexture* glyphTexture, f32 arg2, f32 arg3, s32 mode, f32 scaleX, f32 scaleY) {
        .               s32 var_v0;
        .               u8* temp_v0_2;
        .               f32 thing0;
        .               f32 thing1;
        .               MkTexture* var_s0;
        .           
    2,523 ( 0.00%)      var_s0 = segmented_to_virtual_dupe(glyphTexture);
    5,046 ( 0.00%)  => src/code_80091750.c:segmented_to_virtual_dupe (2,523x)
   27,753 ( 0.00%)      while (var_s0->textureData != NULL) {
        .                   var_v0 = 0;
        .           
    7,569 ( 0.00%)          thing0 = var_s0->dX + arg2;
    7,569 ( 0.00%)          if (thing0 > 320.0f) {
        .                       var_v0 = 1;
        .                   }
    7,569 ( 0.00%)          thing0 += var_s0->width * scaleX;
    5,046 ( 0.00%)          if (thing0 < 0.0f) {
   10,092 ( 0.00%)              var_v0 += 1;
        .                   }
    7,569 ( 0.00%)          thing1 = var_s0->dY + arg3;
    5,046 ( 0.00%)          if (thing1 < 0.0f) {
        .                       var_v0 += 1;
        .                   }
    7,299 ( 0.00%)          thing1 -= var_s0->height * scaleY;
    4,866 ( 0.00%)          if (thing1 > 240.0f) {
        .                       var_v0 += 1;
        .                   }
        .           
    4,806 ( 0.00%)          if (var_v0 != 0) {
        .                       var_s0++;
        .                   } else {
    4,540 ( 0.00%)              temp_v0_2 = (u8*) func_8009B8C4(var_s0->textureData);
  170,696 ( 0.00%)  => src/code_80091750.c:func_8009B8C4 (2,270x)
    9,080 ( 0.00%)              if (temp_v0_2 != 0) {
        .                           switch (mode) { /* irregular */
        .                               case 1:
    9,080 ( 0.00%)                          gSPDisplayList(arg0++, D_020077F8);
4,437,687 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (2,270x)
   38,590 ( 0.00%)                          arg0 = func_80095BD0(arg0, temp_v0_2, var_s0->dX + arg2, var_s0->dY + arg3, var_s0->width,
9,719,353 ( 0.02%)  => src/code_80091750.c:func_80095BD0 (2,270x)
        .                                                        var_s0->height, scaleX, scaleY);
        .                                   break;
        .                               case 2:
        .                                   gSPDisplayList(arg0++, D_02007818);
        .                                   arg0 = func_80095BD0(arg0, temp_v0_2, var_s0->dX + arg2, var_s0->dY + arg3, var_s0->width,
        .                                                        var_s0->height, scaleX, scaleY);
        .                                   break;
        .                           }
        .                       }
    2,270 ( 0.00%)              var_s0++;
        .                   }
        .               }
        .               return arg0;
   17,661 ( 0.00%)  }
        .           
        .           Gfx* func_8009C204(Gfx* arg0, MkTexture* arg1, s32 arg2, s32 arg3, s32 arg4) {
        .               s32 var_s2;
        .               u8* temp_t0;
        .               MkTexture* var_s1;
        .           
        .               var_s1 = segmented_to_virtual_dupe(arg1);
        .               while (var_s1->textureData != NULL) {
-- line 4536 ----------------------------------------
-- line 4662 ----------------------------------------
        .               }
        .               return arg0;
        .           }
        .           
        .           void func_8009C918(void) {
        .               s32 someIndex;
        .           
        .               for (someIndex = 0; someIndex < 4; someIndex++) {
    5,690 ( 0.00%)          D_8018E7E8[someIndex].x = D_8015F480[someIndex].screenStartX;
        .                   D_8018E7E8[someIndex].y = D_8015F480[someIndex].screenStartY;
    5,121 ( 0.00%)          D_8018E810[someIndex].x = D_8015F480[someIndex].screenWidth;
        .                   D_8018E810[someIndex].y = D_8015F480[someIndex].screenHeight;
        .               }
        .           
      569 ( 0.00%)      D_8018E7E8[4].x = 0x00A0;
        .               D_8018E7E8[4].y = 0x0078;
      569 ( 0.00%)      D_8018E810[4].x = 0x0140;
        .               D_8018E810[4].y = 0x00F0;
      569 ( 0.00%)  }
        .           
       93 ( 0.00%)  void func_8009CA2C(void) {
        .               s32 var_s0;
        .           
        .               for (var_s0 = 0; var_s0 < 5; var_s0++) {
      930 ( 0.00%)          func_8009CA6C(var_s0);
1,462,572 ( 0.00%)  => src/code_80091750.c:func_8009CA6C (465x)
        .               }
       93 ( 0.00%)  }
        .           
    2,834 ( 0.00%)  void func_8009CA6C(s32 arg0) {
        .               s32 var_a1;
        .           
   11,314 ( 0.00%)      if ((arg0 == 4) || ((find_8018D9E0_entry(0x000000AA) == NULL) && (find_8018D9E0_entry(0x000000AB) == NULL) &&
  335,808 ( 0.00%)  => src/code_80091750.c:find_8018D9E0_entry (1,696x)
    6,784 ( 0.00%)                          (find_8018D9E0_entry(0x000000B9) == NULL) && (find_8018D9E0_entry(0x000000BA) == NULL) &&
  335,808 ( 0.00%)  => src/code_80091750.c:find_8018D9E0_entry (1,696x)
    5,088 ( 0.00%)                          (find_8018D9E0_entry(0x000000AC) == NULL) && (find_8018D9E0_entry(0x000000B0) == NULL))) {
  335,808 ( 0.00%)  => src/code_80091750.c:find_8018D9E0_entry (1,696x)
      569 ( 0.00%)          var_a1 = 0;
    8,502 ( 0.00%)          gSPDisplayList(gDisplayListHead++, D_0D0076F8);
2,820,815 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/GBIMiddleware.cpp:gSPDisplayList (1,417x)
    4,240 ( 0.00%)          if ((arg0 != 4) && (gIsGamePaused != 0)) {
        .                       var_a1 = 1;
        .                   }
   12,753 ( 0.00%)          switch (D_8018E7AC[arg0]) {
        .                       case 1:
       40 ( 0.00%)                  func_8009CDDC(arg0, var_a1);
   43,187 ( 0.00%)  => src/code_80091750.c:func_8009CDDC (20x)
        .                           return;
        .                       case 2:
       24 ( 0.00%)                  func_8009D958(arg0, var_a1);
   26,653 ( 0.00%)  => src/code_80091750.c:func_8009D958 (12x)
        .                           return;
        .                       case 3:
        .                           func_8009DB8C();
        .                           return;
        .                       case 4:
        .                           func_8009DAA8();
        .                           return;
        .                       case 5:
-- line 4714 ----------------------------------------
-- line 4720 ----------------------------------------
        .                       case 8:
        .                           func_8009CDFC(arg0, var_a1);
        .                           break;
        .                       case 0:
        .                       default:
        .                           break;
        .                   }
        .               }
    2,802 ( 0.00%)  }
        .           
      180 ( 0.00%)  void func_8009CBE4(s32 arg0, s32 arg1, s32 arg2) {
        .               RGBA16* color;
        .               s16 x, y, w, h;
        .               UNUSED s32 pad[3];
        .               struct UnkStruct_800DC5EC* unk;
        .               struct UnkStruct_8018E7E8 *size, *start;
        .           
       60 ( 0.00%)      if ((gModeSelection == GRAND_PRIX) || (gModeSelection == TIME_TRIALS)) {
        .                   start = &(D_8018E7E8[arg0]);
        .                   size = &(D_8018E810[arg0]);
       60 ( 0.00%)          x = start->x;
       20 ( 0.00%)          y = start->y;
       40 ( 0.00%)          w = size->x;
       20 ( 0.00%)          h = size->y;
        .               } else if (arg0 >= 4) {
        .                   start = &(D_8018E7E8[arg0]);
        .                   size = &(D_8018E810[arg0]);
        .                   x = start->x;
        .                   y = start->y;
        .                   w = size->x;
        .                   h = size->y;
        .               } else {
        .                   unk = &D_8015F480[arg0];
        .                   x = unk->screenStartX;
        .                   y = unk->screenStartY;
        .                   w = unk->screenWidth;
        .                   h = unk->screenHeight;
        .               }
        .               color = &D_800E7AE8[arg2];
      680 ( 0.00%)      gDisplayListHead = draw_box(gDisplayListHead, x - (w / 2), y - (h / 2), (w / 2) + x, (h / 2) + y, color->red,
   41,580 ( 0.00%)  => src/code_80091750.c:draw_box (20x)
      160 ( 0.00%)                                  color->green, color->blue, 0xFF - (D_8018E7D0[arg0] * 0xFF / D_8018E7B8[arg0]));
        .           
      180 ( 0.00%)      if ((arg1 == 0) && (D_8018E7D0[arg0] += 1, (D_8018E7D0[arg0] >= D_8018E7B8[arg0]))) {
        3 ( 0.00%)          if (gGamestate == 4) {
        1 ( 0.00%)              D_8018E7AC[arg0] = 6;
        .                       return;
        .                   }
        1 ( 0.00%)          D_8018E7AC[arg0] = 0;
        2 ( 0.00%)          D_8018EE0C = 0;
        .               }
      160 ( 0.00%)  }
        .           
        .           void func_8009CDDC(s32 arg0, s32 arg1) {
       40 ( 0.00%)      func_8009CBE4(arg0, arg1, 0);
   43,147 ( 0.00%)  => src/code_80091750.c:func_8009CBE4 (20x)
        .           }
        .           
        .           void func_8009CDFC(s32 arg0, s32 arg1) {
        .               func_8009CBE4(arg0, arg1, 1);
        .           }
        .           
        .           void func_8009CE1C(void) {
        .               if ((gSoundMode != 3) && (gPlayerCountSelection1 >= 2)) {
        .                   func_800C3448(0xE0000002);
        .               }
        .           }
        .           
        5 ( 0.00%)  void func_8009CE64(s32 arg0) {
        .               s32 thing;
        .               s32 var_a1;
        .               UNUSED s32 stackPadding0;
        .               struct_8018D9E0_entry* temp_v0;
        .           
        .               var_a1 = 0;
        4 ( 0.00%)      if (gGamestate == 5) {
        .                   if (2 != gCCSelection) {
        .                       thing = gCCSelection;
        .                       if (thing != 3) {
        .                           goto func_8009CE64_label1;
        .                       }
        .                       goto func_8009CE64_label2;
        .                   }
        .               func_8009CE64_label2:
-- line 4801 ----------------------------------------
-- line 4805 ----------------------------------------
        .               func_8009CE64_label1:
        .                   if (var_a1) {
        .                       gGotoMenu = 9;
        .                       gCreditsCourseId = 8;
        .                   } else {
        .                       gGotoMenu = 1;
        .                       gMenuSelection = 0x0000000B;
        .                   }
        2 ( 0.00%)      } else if (gGamestate == 4) {
        .                   if (D_8018E7AC[arg0] == 2) {
        .                       if (arg0 != 4) {
        .                           D_8018E7AC[arg0] = 5;
        .                       } else {
        .                           var_a1 = 0;
        .                           temp_v0 = find_8018D9E0_entry(0x000000B0);
        .                           if (temp_v0 != NULL) {
        .                               switch (temp_v0->cursor) { /* switch 8; irregular */
-- line 4821 ----------------------------------------
-- line 4917 ----------------------------------------
        .                                   } else {
        .                                       D_8018E7AC[arg0] = 5;
        .                                   }
        .                               }
        .                           }
        .                       }
        .                   }
        .               } else {
        3 ( 0.00%)          D_8018E7AC[arg0] = 0;
        3 ( 0.00%)          if (gDebugMenuSelection != 0x40) {
        .                       switch (D_8018EDE0) { /* switch 3 */
        .                           case 0:           /* switch 3 */
        .                               if (gMenuSelection == 8) {
        .                                   gMenuSelection = 0x0000000A;
        .                                   D_800E86A4 = 2;
        .                               } else {
        .                                   gMenuSelection++;
        .                               }
-- line 4934 ----------------------------------------
-- line 5051 ----------------------------------------
        .                           gGamestateNext = 4;
        .                           if (gModeSelection == 1) {
        .                               D_8018EDFB = (s8) 1;
        .                           }
        .                           func_8009CE1C();
        .                       }
        .                       D_8018EE0C = 0;
        .                   } else {
        7 ( 0.00%)              switch (gDebugGotoScene) { /* switch 5; irregular */
        .                           case 1:                /* switch 5 */
        .                               gGamestateNext = (s32) 5;
        .                               break;
        .                           case 2: /* switch 5 */
        .                           case 3: /* switch 5 */
        1 ( 0.00%)                      gGamestateNext = 9;
        .                               gCreditsCourseId = 8;
        .                               break;
        .                           default: /* switch 5 */
        1 ( 0.00%)                      gGamestateNext = 4;
        3 ( 0.00%)                      if (gModeSelection == (s32) 1) {
        .                                   D_8018EDFB = 1;
        .                               }
        .                               break;
        .                       }
        1 ( 0.00%)              func_8000F124();
      130 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_80005FD0.c:func_8000F124 (1x)
        3 ( 0.00%)              if (gScreenModeSelection == 3) {
        .                           switch (gModeSelection) {
        .                               case 0:
        .                               case 1:
        .                                   gModeSelection = 2;
        .                                   break;
        .                           }
        .                       }
        .           
       17 ( 0.00%)              if (GetCourse() == GetBlockFort() || GetCourse() == GetSkyscraper() || GetCourse() == GetDoubleDeck() ||
        9 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (3x)
        3 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetSkyscraper (1x)
        3 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBlockFort (1x)
        3 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetDoubleDeck (1x)
        3 ( 0.00%)                  GetCourse() == GetBigDonut()) {
        3 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCourse (1x)
        3 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetBigDonut (1x)
        .           
        .                           gModeSelection = BATTLE;
        .                           if (gPlayerCountSelection1 == 1) {
        .                               gPlayerCount = 2;
        .                               gScreenModeSelection = SCREEN_MODE_2P_SPLITSCREEN_HORIZONTAL;
        .                               gPlayerCountSelection1 = gPlayerCount;
        .                           }
        .                       } else {
        3 ( 0.00%)                  if (gModeSelection == 3) {
        .                               gModeSelection = 0;
        .                           }
        2 ( 0.00%)                  if ((gModeSelection == 2) && (gPlayerCountSelection1 == 1)) {
        .                               gModeSelection = 0;
        .                           }
        .                       }
        .           
        6 ( 0.00%)              gCupSelection = gCupSelectionByCourseId[gCurrentCourseId];
        3 ( 0.00%)              D_800DC540 = GetCupIndex();
    1,007 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:GetCupIndex (1x)
        5 ( 0.00%)              gCourseIndexInCup = gPerCupIndexByCourseId[gCurrentCourseId];
        .           
        7 ( 0.00%)              switch (gDebugGotoScene) { /* switch 6; irregular */
        .                           case 1:                /* switch 6 */
        .                               break;
        .                           case 2: /* switch 6 */
        .                               gCCSelection = 0;
        .                               break;
        .                           case 3: /* switch 6 */
        .                               gCCSelection = 3;
        .                               break;
        .                           default: /* switch 6 */
        3 ( 0.00%)                      if (gCCSelection == 3) {
        1 ( 0.00%)                          gIsMirrorMode = 1;
        .                               } else {
        1 ( 0.00%)                          gIsMirrorMode = 0;
        .                               }
        .                               break;
        .                       }
        .                   }
        .               }
        7 ( 0.00%)  }
        .           
      120 ( 0.00%)  void func_8009D77C(s32 arg0, s32 arg1, s32 arg2) {
        .               s16 var_ra;
        .               s16 var_t3;
        .               s16 var_t4;
        .               s32 temp_t8;
        .               s32 temp_v1;
        .               s32 var_t2;
        .               s32 someMath0;
        .               s32 someMath1;
        .               RGBA16* temp_v0_2;
        .               s32 sp44;
        .               UNUSED s32 stackPadding0;
        .           
       36 ( 0.00%)      if ((gModeSelection == 0) || (gModeSelection == 1)) {
       36 ( 0.00%)          var_t3 = D_8018E7E8[arg0].x;
       12 ( 0.00%)          var_t4 = D_8018E7E8[arg0].y;
       24 ( 0.00%)          var_ra = D_8018E810[arg0].x;
       12 ( 0.00%)          sp44 = D_8018E810[arg0].y;
        .               } else if (arg0 >= 4) {
        .                   var_t3 = D_8018E7E8[arg0].x;
        .                   var_t4 = D_8018E7E8[arg0].y;
        .                   var_ra = D_8018E810[arg0].x;
        .                   sp44 = D_8018E810[arg0].y;
        .               } else {
        .                   var_t3 = D_8015F480[arg0].screenStartX;
        .                   var_t4 = D_8015F480[arg0].screenStartY;
        .                   var_ra = D_8015F480[arg0].screenWidth;
        .                   sp44 = D_8015F480[arg0].screenHeight;
        .               }
       96 ( 0.00%)      var_t2 = (D_8018E7D0[arg0] * 0xFF) / D_8018E7B8[arg0];
       36 ( 0.00%)      if (var_t2 >= 0x100) {
        .                   var_t2 = 0x000000FF;
        .               }
       60 ( 0.00%)      temp_v1 = var_ra / 2;
       48 ( 0.00%)      temp_t8 = sp44 / 2;
        .               temp_v0_2 = &D_800E7AE8[arg2];
        .               // Why does it have to written like this to match?
        .               someMath0 = temp_v1;
       12 ( 0.00%)      someMath0 += var_t3;
        .               someMath1 = temp_t8;
        .               someMath1 += var_t4;
      252 ( 0.00%)      gDisplayListHead = draw_box(gDisplayListHead, var_t3 - temp_v1, var_t4 - temp_t8, someMath0, someMath1,
   24,392 ( 0.00%)  => src/code_80091750.c:draw_box (12x)
       12 ( 0.00%)                                  temp_v0_2->red, temp_v0_2->green, temp_v0_2->blue, var_t2);
       36 ( 0.00%)      if (arg1 == 0) {
       36 ( 0.00%)          D_8018E7D0[arg0]++;
       60 ( 0.00%)          if ((D_8018E7B8[arg0] + 1) < D_8018E7D0[arg0]) {
        2 ( 0.00%)              func_8009CE64(arg0);
    1,252 ( 0.00%)  => src/code_80091750.c:func_8009CE64 (1x)
        .                   }
        .               }
       95 ( 0.00%)  }
        .           
        .           void func_8009D958(s32 arg0, s32 arg1) {
       24 ( 0.00%)      func_8009D77C(arg0, arg1, 0);
   26,629 ( 0.00%)  => src/code_80091750.c:func_8009D77C (12x)
        .           }
        .           
        .           void func_8009D978(s32 arg0, s32 arg1) {
        .               func_8009D77C(arg0, arg1, 1);
        .           }
        .           
        .           void func_8009D998(s32 arg0) {
        .               s16 var_t0;
-- line 5188 ----------------------------------------
-- line 5282 ----------------------------------------
        .               gDPPipeSync(gDisplayListHead++);
        .               var_v1 = (D_8018E7D0[4] * 255) / D_8018E7B8[4];
        .               if (var_v1 >= 0x100) {
        .                   var_v1 = 0x000000FF;
        .               }
        .               gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x00000140, 0x000000F0, 0, 0, 0, var_v1);
        .           }
        .           
        1 ( 0.00%)  void func_8009DEF8(u32 arg0, u32 arg1) {
        3 ( 0.00%)      if (arg0 == 0) {
        .                   arg0 = 1;
        .               }
        6 ( 0.00%)      if ((D_8018E7AC[4] != 1) && (D_8018E7AC[4] != 6)) {
        1 ( 0.00%)          D_8018E7AC[4] = arg1;
        .                   D_8018E7B8[4] = arg0;
        3 ( 0.00%)          if (D_8018E7B8[4] >= 0x100U) {
        .                       D_8018E7B8[4] = 0xFFU;
        .                   }
        2 ( 0.00%)          D_8018E7D0[4] = 0;
        .               }
        1 ( 0.00%)  }
        .           
        .           void func_8009DF4C(s32 arg0) {
        2 ( 0.00%)      func_8009DEF8(arg0, 1);
       17 ( 0.00%)  => src/code_80091750.c:func_8009DEF8 (1x)
        .           }
        .           
        .           void func_8009DF6C(s32 arg0) {
        .               func_8009DEF8(arg0, 8);
        .           }
        .           
        1 ( 0.00%)  void func_8009DF8C(u32 arg0, u32 arg1) {
        3 ( 0.00%)      if (arg0 == 0) {
        .                   arg0 = 1;
        .               }
        6 ( 0.00%)      if ((D_8018E7AC[4] != 2) && (D_8018E7AC[4] != 5)) {
        1 ( 0.00%)          D_8018E7AC[4] = arg1;
        .                   D_8018E7B8[4] = arg0;
        3 ( 0.00%)          if (D_8018E7B8[4] >= 0x100U) {
        .                       D_8018E7B8[4] = 0xFFU;
        .                   }
        2 ( 0.00%)          D_8018E7D0[4] = 0;
        .               }
        1 ( 0.00%)  }
        .           
        .           void func_8009DFE0(s32 arg0) {
        2 ( 0.00%)      func_8009DF8C(arg0, 2);
       17 ( 0.00%)  => src/code_80091750.c:func_8009DF8C (1x)
        .           }
        .           
        .           void func_8009E000(s32 arg0) {
        .               func_8009DF8C(arg0, 7);
        .           }
        .           
        .           void func_8009E020(s32 arg0, s32 arg1) {
        .               s32 temp;
-- line 5335 ----------------------------------------
-- line 5389 ----------------------------------------
        .                   D_8018E7B8[4] = arg0;
        .                   if (D_8018E7B8[4] >= 0x100U) {
        .                       D_8018E7B8[4] = 0x000000FFU;
        .                   }
        .                   D_8018E7D0[4] = 0;
        .               }
        .           }
        .           
        1 ( 0.00%)  void func_8009E1C0(void) {
        2 ( 0.00%)      func_8009DFE0(10);
       19 ( 0.00%)  => src/code_80091750.c:func_8009DFE0 (1x)
        2 ( 0.00%)      D_8018EDE0 = 0;
        2 ( 0.00%)  }
        .           
        .           void func_8009E1E4(void) {
        .               func_8009E000(10);
        .               D_8018EDE0 = 0;
        .           }
        .           
        .           void func_8009E208(void) {
        .               func_8009DFE0(10);
-- line 5408 ----------------------------------------
-- line 5420 ----------------------------------------
        .           }
        .           
        .           void func_8009E280(void) {
        .               func_8009DFE0(10);
        .               D_8018EDE0 = 4;
        .           }
        .           
        .           void func_8009E2A8(s32 arg0) {
    2,380 ( 0.00%)      switch (D_8018E838[arg0]) {
        .                   case 0:
        .                       break;
        .                   case 1:
        .                       func_8009E2F0(arg0);
        .                       break;
        .                   default:
        .                       D_8018E838[arg0] = 0;
        .                       break;
        .               }
      476 ( 0.00%)  }
        .           
        .           void func_8009E2F0(s32 arg0) {
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               s32 someIndex;
        .               s32 temp_t7;
        .               f32 temp_t7_2;
        .               RGBA16* temp_v0;
-- line 5446 ----------------------------------------
-- line 5480 ----------------------------------------
        .           
        .           void func_8009E5FC(s32 arg0) {
        .               D_8018E838[arg0] = 1;
        .               D_8018E840[arg0] = 0;
        .           }
        .           
        .           void func_8009E620(void) {
        .               s32 index;
      104 ( 0.00%)      for (index = 0; index < D_8018D9E0_SIZE; index++) {
       64 ( 0.00%)          D_8018D9E0[index].type = 0;
        .               }
        2 ( 0.00%)  }
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/1BHpa
        .           // Stack differences, can't figure out how to fix them
       63 ( 0.00%)  void add_ui_element(s32 type, s32 column, s32 row, s8 priority) {
        .               struct_8018D9E0_entry* var_ra;
        .               s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               UNUSED s32 stackPadding2;
        .               s32 temp_v0_6;
        .               s32 var_v0;
        .               s32 var_v1_3;
        .               s32 temp_a1;
-- line 5504 ----------------------------------------
-- line 5508 ----------------------------------------
        .           
        .               var_v0 = 0;
        .               var_ra = D_8018D9E0;
        .               // ????????
        .               // Credit to Vetri for the idea to mess around with this loop
        .               // to fix the issue near the 0xD4 case
        .               while (true) {
        .                   var_v0++;
       84 ( 0.00%)          if (var_ra->type == 0)
        .                       break;
        .           
       32 ( 0.00%)          if (var_v0 > D_8018D9E0_SIZE) {
        .                       printf("Ran out of buffer space for UI elements");
        .                       while (true) {}
        .                   }
       16 ( 0.00%)          var_ra++;
        .               }
        9 ( 0.00%)      var_ra->type = type;
        9 ( 0.00%)      var_ra->cursor = 0;
        .               var_ra->unk8 = 0;
        9 ( 0.00%)      var_ra->column = column;
        9 ( 0.00%)      var_ra->row = row;
        9 ( 0.00%)      var_ra->priority = (u8) priority;
        9 ( 0.00%)      var_ra->visible = one;
        9 ( 0.00%)      var_ra->unk1C = 0;
        .               var_ra->unk20 = 0;
       63 ( 0.00%)      switch (type) {
        .                   case 0xFA:
        .                       s8018ED94 = 0;
        .                       D_800E8530 = 0.0f;
        .                       D_800E8534 = 3.0f;
        .                       D_8018EDC0 = 0x000009C4;
        .                       D_8018EDC8 = 0;
        .                       D_8018EDCC = -270.0f;
        .                       D_8018EDD0 = 0;
-- line 5542 ----------------------------------------
-- line 5543 ----------------------------------------
        .                       D_8018EDD4 = 0;
        .                       D_8018EDD8 = 0;
        .                       D_8018EDDC = 0;
        .                       D_8018EDC4 = 3;
        .                       var_ra->unk1C = -1;
        .                       var_ra->unk20 = one;
        .                       break;
        .                   case 0xFB:
        2 ( 0.00%)              D_8018EDC0 = 0x00000708;
        2 ( 0.00%)              D_8018EDC8 = -51.0f;
        2 ( 0.00%)              D_8018EDCC = -12.0f;
        2 ( 0.00%)              D_8018EDD0 = -18.0f;
        2 ( 0.00%)              D_8018EDD4 = -270.0f;
        2 ( 0.00%)              D_8018EDD8 = 750.0f;
        2 ( 0.00%)              D_8018EDDC = 0;
        2 ( 0.00%)              D_8018EDC4 = 1.0f;
        2 ( 0.00%)              var_ra->unk1C = -1;
        .                       var_ra->unk20 = one;
        1 ( 0.00%)              break;
        .                   case 0xD2:
        .                       load_menu_img2(D_020014C8, 0);
        .                       func_8009B954(D_020014C8);
        .                       D_8018E75C = func_8009BA74(D_8018E75C, D_020014C8, var_ra->column, var_ra->row);
        .                       func_8009B998();
        .                       break;
        .                   case 0xD3:
        .                       load_menu_img2(D_02001540, 0);
-- line 5569 ----------------------------------------
-- line 5609 ----------------------------------------
        .                           load_menu_img(segmented_to_virtual_dupe(D_800E7D0C[var_v0]));
        .                       }
        .                       break;
        .                   case 0xD8:
        .                   case 0xD9:
        .                       load_menu_img(D_0200184C);
        .                       break;
        .                   case 0x1:
        5 ( 0.00%)              load_menu_img2(D_800E7D4C[has_unlocked_extra_mode()], 0);
        8 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:has_unlocked_extra_mode (1x)
        .                       break;
        .                   case 0x2:
        1 ( 0.00%)              load_mario_kart_64_logo();
    2,061 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/code_8006E9C0.c:load_mario_kart_64_logo (1x)
        2 ( 0.00%)              gMenuTextureBufferIndex += 0x10000;
        4 ( 0.00%)              load_menu_img(D_020045E8);
      185 ( 0.00%)  => src/code_80091750.c:load_menu_img (2x)
        .                       break;
        .                   case 0x3:
        2 ( 0.00%)              load_menu_img(D_02004610);
        .                       break;
        .                   case 0x23:
        .                   case 0x24:
        .                   case 0x25:
        .                       load_menu_img2(D_800E7D4C[has_unlocked_extra_mode()], 0);
        .                       load_menu_img2(D_02004B74, 0);
        .                       convert_img_to_greyscale(0, 0x00000019);
        .                       adjust_img_colour(0, SCREEN_WIDTH * SCREEN_HEIGHT, D_800E74E8[type - 0x23].red,
-- line 5633 ----------------------------------------
-- line 5850 ----------------------------------------
        .                           var_v0 = 0;
        .                       }
        .                       if (var_v0 != 0) {
        .                           var_a0 = gCharacterDefeatAnimation[temp_a1];
        .                       } else {
        .                           var_a0 = D_800E8320[temp_a1];
        .                       }
        .                       var_ra->D_8018DEE0_index = func_8009A478(segmented_to_virtual_dupe_2(var_a0), 0);
        2 ( 0.00%)              load_menu_img2(segmented_to_virtual_dupe(D_800E7D54[temp_a1]), 0);
  156,053 ( 0.00%)  => src/code_80091750.c:load_menu_img2 (1x)
        .                       break;
        .                   case 0x190:
        .                   case 0x191:
        .                   case 0x192:
        .                   case 0x193:
        .                   case 0x194:
        .                   case 0x195:
        .                   case 0x196:
-- line 5866 ----------------------------------------
-- line 5918 ----------------------------------------
        .                   case 0x1CA:
        .                   case 0x1CB:
        .                   case 0x1CC:
        .                   case 0x1CD:
        .                   case 0x1CE:
        .                   default:
        .                       break;
        .               }
       51 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/add_ui_element.s")
        .           #endif
        .           
        .           #ifdef NON_MATCHING
        .           // https://decomp.me/scratch/MatRp
        .           // Biggest diff left is in the case 0x12 though 0x19 handling. Not really sure what's going on there
        .           // There's also a diff in the handling of D_800E77A0 in case 0x4. Not sure what's going on there either
   15,932 ( 0.00%)  void func_8009F5E0(struct_8018D9E0_entry* arg0) {
        .               s32 var_a1;
        .               s32 var_v1;
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               MkTexture* sp9C;
        .               UNUSED s32 stackPadding2;
        .               s32 temp_a0;
        .               s32 temp_t2;
-- line 5943 ----------------------------------------
-- line 5949 ----------------------------------------
        .               UNUSED s32 var_a2;
        .               f32 why = 0.75f;
        .               s32 one = 1;
        .               f32 floatone = 1;
        .               UNUSED s32 stackPadding3;
        .               UNUSED s32 stackPadding4;
        .               f32 var_f0;
        .           
   52,348 ( 0.00%)      if ((s8) arg0->visible != 0) {
   13,656 ( 0.00%)          gDPPipeSync(gDisplayListHead++);
   18,208 ( 0.00%)          switch (arg0->type) { /* switch 6; irregular */
        .                       case 0xFA:        /* switch 6 */
        .                           func_80094660(gGfxPool, arg0->unk1C);
        .                           break;
        .                       case 0xFB: /* switch 6 */
      372 ( 0.00%)                  render_checkered_flag(gGfxPool, arg0->unk1C);
3,206,875 ( 0.01%)  => src/code_80091750.c:render_checkered_flag (93x)
        .                           break;
        .                       case 0xD2: /* switch 6 */
        .                           gDisplayListHead = func_8009B9D0(gDisplayListHead, D_020014C8);
        .                           break;
        .                       case 0xD3: /* switch 6 */
        .                           gDisplayListHead = func_8009B9D0(gDisplayListHead, D_02001540);
        .                           break;
        .                       case 0xD4: /* switch 6 */
-- line 5972 ----------------------------------------
-- line 5994 ----------------------------------------
        .                           func_800A0DFC();
        .                           break;
        .                       case 0xD8: /* switch 6 */
        .                       case 0xD9: /* switch 6 */
        .                           func_800A0EB8(arg0, arg0->type - 0xD8);
        .                           break;
        .                       case 0x1: /* switch 6 */
        .                           gDisplayListHead =
      651 ( 0.00%)                      func_8009BA74(gDisplayListHead, D_800E7D4C[has_unlocked_extra_mode()], arg0->column, arg0->row);
      744 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/save.c:has_unlocked_extra_mode (93x)
        .                           break;
        .                       case 0x2: /* switch 6 */
      651 ( 0.00%)                  func_8004C8D4((arg0->column + 0xA0), (arg0->row + 0x47));
  690,810 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/render_objects.c:func_8004C8D4 (93x)
      558 ( 0.00%)                  gDisplayListHead = func_8009BA74(gDisplayListHead, D_020045E8, arg0->column, arg0->row);
  241,073 ( 0.00%)  => src/code_80091750.c:func_8009BA74 (93x)
       93 ( 0.00%)                  break;
      186 ( 0.00%)              case 0x3: /* switch 6 */
      744 ( 0.00%)                  if (((gGlobalTimer / 8) % 3) != 0) {
      378 ( 0.00%)                      gDisplayListHead = func_8009BA74(gDisplayListHead, D_02004610, arg0->column, arg0->row);
  171,473 ( 0.00%)  => src/code_80091750.c:func_8009BA74 (63x)
        .                           }
        .                           break;
        .                       case 0x5: /* switch 6 */
        .                           var_t0 = (s32) ((f32) (get_string_width(gCourseNamesDup[0]) + 5) * 0.9f) / 2;
        .                           gDisplayListHead = draw_box(gDisplayListHead, 0xA0 - var_t0, 0x0000007B, var_t0 + 0xA0, 0x000000A4, 0,
        .                                                       0, 0, 0x00000096);
        .                           set_text_color(1);
        .                           draw_text(0x0000009B, 0x0000008C, gCourseNamesDup[0], 0, 0.9f, 0.9f);
-- line 6018 ----------------------------------------
-- line 6198 ----------------------------------------
        .                       case 0x5C: /* switch 6 */
        .                           func_800A8A98(arg0);
        .                           gDisplayListHead =
        .                               func_8009BA74(gDisplayListHead, segmented_to_virtual_dupe(D_800E82C4[arg0->type - 0x52]),
        .                                             arg0->column, arg0->row);
        .                           func_800A8CA4(arg0);
        .                           break;
        .                       case 0x52: /* switch 6 */
       93 ( 0.00%)                  gDisplayListHead =
      372 ( 0.00%)                      func_8009BA74(gDisplayListHead, segmented_to_virtual_dupe(D_800E82C4[arg0->type - 0x52]),
1,559,263 ( 0.00%)  => src/code_80091750.c:func_8009BA74 (93x)
        .                                             arg0->column, arg0->row);
        .                           break;
        .                       case 0x5F: /* switch 6 */
        .                       case 0x60: /* switch 6 */
        .                       case 0x61: /* switch 6 */
        .                       case 0x62: /* switch 6 */
        .                           func_800A1500(arg0);
        .                           break;
-- line 6215 ----------------------------------------
-- line 6295 ----------------------------------------
        .                       case 0x87: /* switch 6 */
        .                       case 0x88: /* switch 6 */
        .                       case 0x89: /* switch 6 */
        .                       case 0x8A: /* switch 6 */
        .                       case 0x8B: /* switch 6 */
        .                           func_800A15EC(arg0);
        .                           break;
        .                       case 0x96: /* switch 6 */
      274 ( 0.00%)                  set_text_color(4);
      411 ( 0.00%)  => src/code_80091750.c:set_text_color (137x)
    1,370 ( 0.00%)                  func_800936B8(arg0->column, arg0->row, gCupNames[D_800DC540], arg0->unk1C, arg0->unk24, 1.0f);
7,673,654 ( 0.01%)  => src/code_80091750.c:func_800936B8 (137x)
        .                           break;
        .                       case 0x97: /* switch 6 */
      258 ( 0.00%)                  set_text_color(5);
      387 ( 0.00%)  => src/code_80091750.c:set_text_color (129x)
    1,548 ( 0.00%)                  func_80093324(arg0->column, arg0->row, CourseManager_GetProps()->Name, arg0->unk1C, arg0->unk24, 1.0f);
8,250,136 ( 0.01%)  => src/code_80091750.c:func_80093324 (129x)
      516 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_GetProps (129x)
        .                           break;
        .                       case 0x98: /* switch 6 */
      258 ( 0.00%)                  func_800A2D1C(arg0);
1,033,100 ( 0.00%)  => src/code_80091750.c:func_800A2D1C (129x)
        .                           break;
        .                       case 0x5E: /* switch 6 */
        .                           gDisplayListHead = func_80096CD8(gDisplayListHead, 0x00000019, 0x00000072, 0x0000007CU, 0x0000004AU);
        .                           break;
        .                       case 0xAA: /* switch 6 */
        .                           func_800A2EB8(arg0);
        .                           break;
        .                       case 0xAB: /* switch 6 */
-- line 6319 ----------------------------------------
-- line 6347 ----------------------------------------
        .                           break;
        .                       case 0xBA: /* switch 6 */
        .                           func_800A3E60(arg0);
        .                           break;
        .                       case 0xBC: /* switch 6 */
        .                           func_800A4A24(arg0);
        .                           break;
        .                       case 0xC7: /* switch 6 */
      952 ( 0.00%)                  render_pause_menu(arg0);
    1,904 ( 0.00%)  => src/code_80091750.c:render_pause_menu (476x)
        .                           break;
        .                       case 0xBD: /* switch 6 */
        .                           func_800A5738(arg0);
        .                           break;
        .                       case 0xE6: /* switch 6 */
        .                           func_800A1924(arg0);
        .                           break;
        .                       case 0xE7: /* switch 6 */
-- line 6363 ----------------------------------------
-- line 6466 ----------------------------------------
        .                       case 0x1CB: /* switch 6 */
        .                       case 0x1CC: /* switch 6 */
        .                       case 0x1CD: /* switch 6 */
        .                       case 0x1CE: /* switch 6 */
        .                           func_800A7790(arg0);
        .                           break;
        .                   }
        .               }
   14,968 ( 0.00%)  }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009F5E0.s")
        .           #endif
        .           
        .           void func_800A08D8(u8 arg0, s32 column, s32 row) {
        .               if (arg0 >= 0x10) {
        .                   arg0 -= 0x10;
        .                   if (arg0 < 0x85) {
-- line 6482 ----------------------------------------
-- line 7186 ----------------------------------------
        .                       break;
        .               }
        .               func_800A66A8(arg0, (Unk_D_800E70A0*) &spE0);
        .           }
        .           #else
        .           GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1FB0.s")
        .           #endif
        .           
      516 ( 0.00%)  void func_800A2D1C(struct_8018D9E0_entry* arg0) {
      556 ( 0.00%)      switch (D_80164A28) {
        .                   case 1:
      981 ( 0.00%)              gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, 0x28);
  439,013 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (109x)
      654 ( 0.00%)              gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0xC7, 0x13F, 0xEF);
  437,463 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (109x)
      109 ( 0.00%)              arg0->unk1C = 0x28;
        .                       break;
        .                   case 2:
        .                       arg0->unk1C -= 2;
        .                       if (arg0->unk1C > 0) {
        .                           gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, arg0->unk1C);
        .                           gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
        .                       } else {
        1 ( 0.00%)                  arg0->type = 0;
        .                       }
        .                       break;
        .                   default:
      209 ( 0.00%)              if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
        .                           arg0->type = 0;
        .                       } else {
       60 ( 0.00%)                  arg0->unk1C -= 2;
       40 ( 0.00%)                  if (arg0->unk1C > 0) {
      152 ( 0.00%)                      gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, arg0->unk1C);
   76,356 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (19x)
      133 ( 0.00%)                      gDisplayListHead = func_80098FC8(gDisplayListHead, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
   76,341 ( 0.00%)  => src/code_80091750.c:func_80098FC8 (19x)
        .                           } else {
        .                               arg0->type = 0;
        .                           }
        .                       }
        .                       break;
        .               }
      516 ( 0.00%)  }
        .           
        .           void func_800A2EB8(struct_8018D9E0_entry* arg0) {
        .               s8 sp70[8];
        .               UNUSED s32 stackPadding0;
        .               char sp68[3];
        .               s32 temp_s0;
        .               s32 var_a0;
        .               s32 var_s2;
-- line 7232 ----------------------------------------
-- line 7754 ----------------------------------------
        .               temp_t2 = (s32) ((get_string_width(D_800E7780) + 8) * someMultiplier) / 2;
        .               gDisplayListHead = draw_box(gDisplayListHead, temp_t0 - temp_t2, (temp_t1 - thing) + 4, temp_t2 + temp_t0,
        .                                           temp_t1 + 4, 0, 0, 0, 0x00000064);
        .               set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
        .               draw_text(arg0->column - 3, arg0->row, D_800E7780, 0, 0.85f, 0.85f);
        .           }
        .           
        .           void render_pause_menu(struct_8018D9E0_entry* arg0) {
    1,428 ( 0.00%)      if (gIsGamePaused != 0) {
        .                   switch (gModeSelection) {
        .                       case TIME_TRIALS:
        .                           render_pause_menu_time_trials(arg0);
        .                           break;
        .                       case VERSUS:
        .                           render_pause_menu_versus(arg0);
        .                           break;
        .                       case GRAND_PRIX:
        .                           render_pause_grand_prix(arg0);
        .                           break;
        .                       case BATTLE:
        .                           render_pause_battle(arg0);
        .                           break;
        .                   }
        .               }
      476 ( 0.00%)  }
        .           
        .           void render_pause_menu_time_trials(struct_8018D9E0_entry* arg0) {
        .               UNUSED s32 stackPadding0;
        .               UNUSED s32 stackPadding1;
        .               UNUSED s32 stackPadding2;
        .               char sp68[3];
        .               s32 temp_a0;
        .               s32 var_s0;
-- line 7786 ----------------------------------------
-- line 7916 ----------------------------------------
        .           void func_800A54EC(void) {
        .               Unk_D_800E70A0 sp50;
        .               Unk_D_800E70A0* var_v1;
        .               struct_8018D9E0_entry* sp48;
        .               s32 whyTheSequel;
        .               s32 why;
        .               UNUSED Unk_D_800E70A0* huh;
        .           
    1,904 ( 0.00%)      if (gIsGamePaused == 0) {
        .                   return;
        .               }
        .           
        .               why = gModeSelection;
        .               sp48 = find_8018D9E0_entry(0x000000C7);
        .               if (why) {} // ?????
        .               gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(D_802B8880));
        .               guOrtho(&gGfxPool->mtxEffect[gMatrixEffectCount], 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
-- line 7932 ----------------------------------------
-- line 8579 ----------------------------------------
        .           void func_800A79F4(s32 arg0, char* arg1) {
        .               arg1[0] = 0xA3;
        .               arg1[1] = (arg0 / 0xA) - 0x50;
        .               arg1[2] = 0xA3;
        .               arg1[3] = (arg0 % 0xA) - 0x50;
        .               arg1[4] = '\0';
        .           }
        .           
    7,397 ( 0.00%)  void func_800A7A4C(s32 arg0) {
        .               s32 var_s0;
        .               s32 var_v1;
        .               s32 var_v1_2;
        .               s32 type;
        .               struct_8018D9E0_entry* var_s1;
        .               s32 one = 1;
        .           
  111,524 ( 0.00%)      for (var_v1_2 = 0; var_v1_2 < D_8018D9E0_SIZE; var_v1_2++) {
        .                   var_v1 = 0;
        .                   var_s1 = &D_8018D9E0[var_v1_2];
   36,416 ( 0.00%)          type = var_s1->type;
  181,708 ( 0.00%)          if ((type == 4) || (type == 5) || (type == 0x000000C7)) {
        .                       if (arg0 != 0) {
        .                           var_v1 = 1;
        .                       }
        .                   } else if (arg0 == 0) {
        .                       var_v1 = 1;
        .                   }
        .           
        .                   if (var_v1 == 0) {
        .                       continue;
        .                   }
        .           
   64,060 ( 0.00%)          switch (type) { /* switch 8; irregular */
        .                       case 0xFA:  /* switch 8 */
        .                           if (s8018ED94 < 0x50) {
        .                               D_800E8534 = 3.0f;
        .                           } else if (s8018ED94 < 0x5A) {
        .                               if (D_800E8530 < 1.0) {
        .                                   D_800E8530 += 0.1;
        .                               }
        .                               D_800E8534 += 0.1;
-- line 8619 ----------------------------------------
-- line 8643 ----------------------------------------
        .                           break;
        .                       case 0xD6: /* switch 8 */
        .                           func_800A9710(var_s1);
        .                           break;
        .                       case 0xD4: /* switch 8 */
        .                           func_800A97BC(var_s1);
        .                           break;
        .                       case 0x5:                     /* switch 8 */
      279 ( 0.00%)                  switch (var_s1->cursor) { /* switch 9; irregular */
        .                               case 0:               /* switch 9 */
      372 ( 0.00%)                          if (gControllerFive->button & R_TRIG) {
        .                                       var_s1->cursor = (s32) 1U;
        .                                       play_sound2(SOUND_ACTION_PING);
        .                                   } else {
      186 ( 0.00%)                              var_s1->visible = 0;
        .                                   }
        .                                   break;
        .                               case 1:  /* switch 9 */
        .                               default: /* switch 9 */
        .                                   var_s1->visible = one;
        .                                   break;
        .                           }
        .                           break;
-- line 8665 ----------------------------------------
-- line 8803 ----------------------------------------
        .                       case 0x79: /* switch 8 */
        .                       case 0x7A: /* switch 8 */
        .                       case 0x7B: /* switch 8 */
        .                       case 0x8C: /* switch 8 */
        .                           func_800ABAE8(var_s1);
        .                           break;
        .                       case 0x8D: /* switch 8 */
        .                           func_800ABB24(var_s1);
    1,138 ( 0.00%)                  break;
        .                       case 0x7C: /* switch 8 */
        .                       case 0x7D: /* switch 8 */
        .                       case 0x7E: /* switch 8 */
        .                       case 0x7F: /* switch 8 */
        .                       case 0x80: /* switch 8 */
        .                       case 0x81: /* switch 8 */
        .                       case 0x82: /* switch 8 */
        .                       case 0x83: /* switch 8 */
-- line 8819 ----------------------------------------
-- line 8823 ----------------------------------------
        .                       case 0x87: /* switch 8 */
        .                       case 0x88: /* switch 8 */
        .                       case 0x89: /* switch 8 */
        .                       case 0x8A: /* switch 8 */
        .                       case 0x8B: /* switch 8 */
        .                           func_800ABBCC(var_s1);
        .                           break;
        .                       case 0x96: /* switch 8 */
      276 ( 0.00%)                  func_800ABC38(var_s1);
    7,575 ( 0.00%)  => src/code_80091750.c:func_800ABC38 (138x)
        .                           break;
        .                       case 0x97: /* switch 8 */
      260 ( 0.00%)                  func_800ABEAC(var_s1);
    7,118 ( 0.00%)  => src/code_80091750.c:func_800ABEAC (130x)
        .                           break;
        .                       case 0x5E: /* switch 8 */
        .                           func_800AC300(var_s1);
        .                           break;
        .                       case 0xAA: /* switch 8 */
        .                           func_800AC324(var_s1);
        .                           break;
        .                       case 0xAB: /* switch 8 */
-- line 8842 ----------------------------------------
-- line 8862 ----------------------------------------
        .                           break;
        .                       case 0xBA: /* switch 8 */
        .                           func_800AD2E8(var_s1);
        .                           break;
        .                       case 0xBC: /* switch 8 */
        .                           func_800AEC54(var_s1);
        .                           break;
        .                       case 0xC7: /* switch 8 */
      952 ( 0.00%)                  func_800ADF48(var_s1);
    7,616 ( 0.00%)  => src/code_80091750.c:func_800ADF48 (476x)
      476 ( 0.00%)                  break;
        .                       case 0xBD: /* switch 8 */
        .                           func_800AE218(var_s1);
        .                           break;
        .                       case 0xE6: /* switch 8 */
        .                           func_800AEDBC(var_s1);
        .                           break;
        .                       case 0xE8: /* switch 8 */
        .                           func_800AEE90(var_s1);
-- line 8879 ----------------------------------------
-- line 8971 ----------------------------------------
        .                       case 1:
        .                       case 2:
        .                       case 3:
        .                       case 4:
        .                           break;
        .                   }
        .               }
        .           
   54,624 ( 0.00%)      for (var_s0 = 0; var_s0 < 0x10; var_s0++) {
1,784,953 ( 0.00%)          for (var_v1_2 = 0; var_v1_2 < D_8018D9E0_SIZE; var_v1_2++) {
        .                       var_v1 = 0;
        .                       var_s1 = &D_8018D9E0[var_v1_2];
        .                       if (var_s1 && var_s1) {} // ?
  582,656 ( 0.00%)              type = var_s1->type;
2,907,328 ( 0.00%)              if ((type == 4) || (type == 5) || (type == 0x000000C7)) {
        .                           if (arg0 != 0) {
        .                               var_v1 = 1;
        .                           }
        .                       } else if (arg0 == 0) {
        .                           var_v1 = 1;
        .                       }
  873,984 ( 0.00%)              if ((var_v1 != 0) && (var_s0 == (s8) var_s1->priority)) {
   36,416 ( 0.00%)                  func_8009F5E0(var_s1);
22,954,216 ( 0.04%)  => src/code_80091750.c:func_8009F5E0 (18,208x)
        .                       }
        .                   }
        .               }
    6,828 ( 0.00%)  }
        .           
        .           void func_800A8230(void) {
    1,138 ( 0.00%)      func_800A7A4C(0);
26,729,543 ( 0.05%)  => src/code_80091750.c:func_800A7A4C (569x)
        .           }
        .           
        .           void func_800A8250(void) {
    1,138 ( 0.00%)      func_800A7A4C(1);
2,898,815 ( 0.00%)  => src/code_80091750.c:func_800A7A4C (569x)
        .           }
        .           
        .           void func_800A8270(s32 arg0, struct_8018D9E0_entry* arg1) {
        .               s32 temp_t1;
        .               s32 temp_t6;
        .               s32 var_s0;
        .               s32 var_s2;
        .               s32 var_s3;
-- line 9012 ----------------------------------------
-- line 9276 ----------------------------------------
        .           }
        .           
        .           void func_800A91D8(struct_8018D9E0_entry* arg0, s32 columnTarget, s32 rowTarget) {
        .               func_800A9208(arg0, columnTarget);
        .               func_800A9278(arg0, rowTarget);
        .           }
        .           
        .           void func_800A9208(struct_8018D9E0_entry* arg0, s32 columnTarget) {
      536 ( 0.00%)      s32 step = columnTarget - arg0->column;
        .           
      536 ( 0.00%)      if (step != 0) {
       42 ( 0.00%)          if (step > 0) {
       42 ( 0.00%)              step = (step / 4) + 1;
       63 ( 0.00%)              if (step >= 0x11) {
        .                           step = 0x10;
        .                       }
        .                   } else {
       84 ( 0.00%)              step = (step / 4) - 1;
       63 ( 0.00%)              if (step < -0x10) {
        .                           step = -0x10;
        .                       }
        .                   }
        .               }
      310 ( 0.00%)      arg0->column += step;
      268 ( 0.00%)  }
        .           
        .           void func_800A9278(struct_8018D9E0_entry* arg0, s32 rowTarget) {
        .               s32 step = rowTarget - arg0->row;
        .           
        .               if (step != 0) {
        .                   if (step > 0) {
        .                       step = (step / 4) + 1;
        .                       if (step >= 0x11) {
-- line 9308 ----------------------------------------
-- line 10249 ----------------------------------------
        .           
        .               // Something VERY wrong has occurred
        .               //    while(true);
        .               // escape:
        .               //    return entry;
        .           }
        .           
        .           struct_8018D9E0_entry* find_8018D9E0_entry(s32 arg0) {
  671,616 ( 0.00%)      for (size_t i = 0; i < ARRAY_COUNT(D_8018D9E0); i++) {
  325,632 ( 0.00%)          if (D_8018D9E0[i].type == arg0) {
        .                       return &D_8018D9E0[i];
        .                   }
        .               }
        .               // No printf here as returning null seems to be normal game logic
        .               // printf("Error: find_8018D9E0_entry returned a null value when searching id 0x%X",
        .               //             arg0);
    5,088 ( 0.00%)      return NULL;
        .           
        .               //    struct_8018D9E0_entry *entry = D_8018D9E0;
        .               //    for (; !(entry > (&D_8018D9E0[D_8018D9E0_SIZE])); entry++) {
        .               //        if (entry->type == arg0) {
        .               //            goto escape;
        .               //        }
        .               //    }
        .           
        .               //    return NULL;
        .               // escape:
        .               //    return entry;
    5,088 ( 0.00%)  }
        .           
        .           s32 func_800AAF70(s32 arg0) {
        .               struct_8018D9E0_entry* temp;
        .               temp = func_800AAEB4(arg0);
        .               return temp->cursor;
        .           }
        .           
        .           void func_800AAF94(struct_8018D9E0_entry* arg0, s32 arg1) {
-- line 10285 ----------------------------------------
-- line 10633 ----------------------------------------
        .               Unk_D_800E70A0* temp_v1;
        .           
        .               temp_v0 = arg0->type - 0x7C;
        .               temp_v1 = &D_800E7430[temp_v0 / 4];
        .               arg0->column = (s32) temp_v1->column;
        .               arg0->row = temp_v1->row + ((temp_v0 % 4) * 0x32) + 0x14;
        .           }
        .           
      276 ( 0.00%)  void func_800ABC38(struct_8018D9E0_entry* arg0) {
        .               // Huh?
        .               s32 one = 1;
      138 ( 0.00%)      func_800ABCF4(arg0);
    5,742 ( 0.00%)  => src/code_80091750.c:func_800ABCF4 (138x)
      610 ( 0.00%)      switch (D_80164A28) { /* irregular */
        .                   case 1:
      109 ( 0.00%)              arg0->visible = one;
        .                       break;
        .                   case 2:
        .                       if (arg0->row >= -0x13) {
        .                           arg0->row -= 2;
        .                       } else {
        1 ( 0.00%)                  arg0->type = 0;
        .                       }
        .                       break;
        .                   default:
      280 ( 0.00%)              if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != (s32) 1U) || (D_8018EE08 != 0)) {
        .                           arg0->type = 0;
        .                       } else {
       87 ( 0.00%)                  if (arg0->row >= -0x13) {
       56 ( 0.00%)                      arg0->row -= 2;
        .                           } else {
        .                               arg0->type = 0;
        .                           }
        .                       }
        .                       break;
        .               }
      276 ( 0.00%)  }
        .           
      276 ( 0.00%)  void func_800ABCF4(struct_8018D9E0_entry* arg0) {
        .               f64 temp_f0;
        .           
      666 ( 0.00%)      switch (arg0->cursor) { /* irregular */
        .                   case 0:
        1 ( 0.00%)              arg0->column = 0;
        1 ( 0.00%)              arg0->cursor = 1;
       11 ( 0.00%)              arg0->unk20 = (get_string_width(gCupNames[D_800DC540]) / 2) + 0xA0;
      208 ( 0.00%)  => src/code_80091750.c:get_string_width (1x)
        .                       /* fallthrough */
        .                   case 1:
       28 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
      182 ( 0.00%)  => src/code_80091750.c:func_800A9208 (14x)
       68 ( 0.00%)              arg0->unk1C = (s32) (arg0->unk20 - arg0->column) / 4;
       28 ( 0.00%)              if (arg0->unk1C >= 9) {
       22 ( 0.00%)                  arg0->unk1C = 8;
        .                       }
       29 ( 0.00%)              arg0->unk24 = (f32) (((f64) arg0->unk1C * 0.05) + 1.0);
       56 ( 0.00%)              if (arg0->column >= (arg0->unk20 - 0x14)) {
        1 ( 0.00%)                  arg0->cursor = 2;
        1 ( 0.00%)                  arg0->D_8018DEE0_index = 0;
        .                       }
        .                       break;
        .                   case 2:
      274 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
      793 ( 0.00%)  => src/code_80091750.c:func_800A9208 (124x)
      620 ( 0.00%)              arg0->unk1C = (s32) (arg0->unk20 - arg0->column) / 4;
      620 ( 0.00%)              arg0->D_8018DEE0_index++;
      372 ( 0.00%)              temp_f0 = (f64) (arg0->D_8018DEE0_index - 0xA);
      496 ( 0.00%)              arg0->unk24 = (f32) ((temp_f0 * 0.0085 * temp_f0) + 0.4);
      596 ( 0.00%)              if ((arg0->D_8018DEE0_index >= 9) && ((f64) arg0->unk24 > 1.0)) {
      106 ( 0.00%)                  arg0->unk24 = 1.0f;
        .                       }
        .                       break;
        .               }
      287 ( 0.00%)  }
        .           
      260 ( 0.00%)  void func_800ABEAC(struct_8018D9E0_entry* arg0) {
        .               s32 why = 1;
      130 ( 0.00%)      func_800ABF68(arg0);
    5,493 ( 0.00%)  => src/code_80091750.c:func_800ABF68 (130x)
      562 ( 0.00%)      switch (D_80164A28) {
        .                   case 1:
      109 ( 0.00%)              arg0->visible = why;
        .                       break;
        .                   case 2:
        .                       if (arg0->row < 0x104) {
        .                           arg0->row += 2;
        .                       } else {
        1 ( 0.00%)                  arg0->type = 0;
        .                       }
        .                       break;
        .                   default:
      200 ( 0.00%)              if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != why) || (D_8018EE08 != 0)) {
        .                           arg0->type = 0;
        .                       } else {
       63 ( 0.00%)                  if (arg0->row < 0x104) {
       40 ( 0.00%)                      arg0->row += 2;
        .                           } else {
        .                               arg0->type = 0;
        .                           }
        .                       }
        .                       break;
        .               }
      260 ( 0.00%)  }
        .           
      260 ( 0.00%)  void func_800ABF68(struct_8018D9E0_entry* arg0) {
      626 ( 0.00%)      switch (arg0->cursor) {
        .                   case 0:
        1 ( 0.00%)              arg0->column = 0x140;
        1 ( 0.00%)              arg0->cursor = 1;
       11 ( 0.00%)              arg0->unk20 = 0xA0 - (get_string_width(CourseManager_GetProps()->Name) / 2);
      233 ( 0.00%)  => src/code_80091750.c:get_string_width (1x)
        4 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/src/port/Game.cpp:CourseManager_GetProps (1x)
        .                       /* fallthrough */
        .                   case 1:
       28 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
      210 ( 0.00%)  => src/code_80091750.c:func_800A9208 (14x)
       68 ( 0.00%)              arg0->unk1C = (arg0->column - arg0->unk20) / 4;
       28 ( 0.00%)              if (arg0->unk1C >= 9) {
       22 ( 0.00%)                  arg0->unk1C = 8;
        .                       }
       29 ( 0.00%)              arg0->unk24 = (arg0->unk1C * 0.05) + 1.0;
       56 ( 0.00%)              if ((arg0->unk20 + 0x14) >= arg0->column) {
        1 ( 0.00%)                  arg0->cursor = 2;
        1 ( 0.00%)                  arg0->D_8018DEE0_index = 0;
        .                       }
        .                       break;
        .                   case 2:
      258 ( 0.00%)              func_800A9208(arg0, arg0->unk20);
      759 ( 0.00%)  => src/code_80091750.c:func_800A9208 (116x)
      580 ( 0.00%)              arg0->unk1C = (arg0->column - arg0->unk20) / 4;
      580 ( 0.00%)              arg0->D_8018DEE0_index++;
      812 ( 0.00%)              arg0->unk24 = ((arg0->D_8018DEE0_index - 0xA) * 0.0085 * (arg0->D_8018DEE0_index - 0xA)) + 0.4;
      556 ( 0.00%)              if ((arg0->D_8018DEE0_index >= 9) && ((f64) arg0->unk24 > 1.0)) {
       98 ( 0.00%)                  arg0->unk24 = 1.0f;
        .                       }
        .                       break;
        .               }
      271 ( 0.00%)  }
        .           
        .           void func_800AC128(struct_8018D9E0_entry* arg0) {
        .               switch (arg0->cursor) {
        .                   case 0:
        .                       arg0->column = 0x00000140;
        .                       arg0->cursor = 1;
        .                       /* fallthrough */
        .                   case 1:
-- line 10769 ----------------------------------------
-- line 11593 ----------------------------------------
        .                       break;
        .               }
        .           }
        .           #ifdef VERSION_EU
        .           #define FUNC_800ADF48DEF 70
        .           #else
        .           #define FUNC_800ADF48DEF 60
        .           #endif
    2,856 ( 0.00%)  void func_800ADF48(struct_8018D9E0_entry* arg0) {
        .               UNUSED s32 stackPadding;
        .               struct Controller* controller;
        .           
    1,428 ( 0.00%)      if (gIsGamePaused != 0) {
        .                   switch (arg0->cursor) {
        .                       case 0:
        .                           arg0->cursor = D_800F0B50[gModeSelection];
        .                           break;
        .                       case 11:
        .                       case 12:
        .                       case 13:
        .                       case 14:
-- line 11613 ----------------------------------------
-- line 11667 ----------------------------------------
        .                                   }
        .                               }
        .                           }
        .                           break;
        .                       default:
        .                           break;
        .                   }
        .               } else {
      476 ( 0.00%)          arg0->cursor = 0;
        .               }
    2,856 ( 0.00%)  }
        .           
        .           void func_800AE218(struct_8018D9E0_entry* arg0) {
        .               struct_8018EE10_entry* thing;
        .               s32 var_v1;
        .           
        .               if (arg0->cursor != 0) {
        .                   D_800DC5B8 = 0;
        .               }
-- line 11685 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: build/_deps/imgui-src/imgui.cpp
--------------------------------------------------------------------------------
Ir                 

-- line 1196 ----------------------------------------
        .           #ifndef GImGui
        .           ImGuiContext*   GImGui = NULL;
        .           #endif
        .           
        .           // Memory Allocator functions. Use SetAllocatorFunctions() to change them.
        .           // - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
        .           // - DLL users: read comments above.
        .           #ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
    9,246 ( 0.00%)  static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
  906,358 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:malloc (4,623x)
    9,096 ( 0.00%)  static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
  625,314 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c:free (4,548x)
        .           #else
        .           static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
        .           static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
        .           #endif
        .           static ImGuiMemAllocFunc    GImAllocatorAllocFunc = MallocWrapper;
        .           static ImGuiMemFreeFunc     GImAllocatorFreeFunc = FreeWrapper;
        .           static void*                GImAllocatorUserData = NULL;
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
        .           //-----------------------------------------------------------------------------
        .           
       12 ( 0.00%)  ImGuiStyle::ImGuiStyle()
       71 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .           {
        2 ( 0.00%)      Alpha                       = 1.0f;             // Global alpha applies to everything in Dear ImGui.
        .               DisabledAlpha               = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
        .               WindowPadding               = ImVec2(8,8);      // Padding within a window
        .               WindowRounding              = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        .               WindowBorderSize            = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        .               WindowMinSize               = ImVec2(32,32);    // Minimum window size
        2 ( 0.00%)      WindowTitleAlign            = ImVec2(0.0f,0.5f);// Alignment for title bar text
        1 ( 0.00%)      WindowMenuButtonPosition    = ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
        6 ( 0.00%)      ChildRounding               = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
        .               ChildBorderSize             = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        .               PopupRounding               = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
        .               PopupBorderSize             = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        .               FramePadding                = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
        .               FrameRounding               = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
        .               FrameBorderSize             = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
        .               ItemSpacing                 = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
        .               ItemInnerSpacing            = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
-- line 1236 ----------------------------------------
-- line 1239 ----------------------------------------
        .               IndentSpacing               = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
        .               ColumnsMinSpacing           = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
        .               ScrollbarSize               = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
        .               ScrollbarRounding           = 9.0f;             // Radius of grab corners rounding for scrollbar
        .               GrabMinSize                 = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
        .               GrabRounding                = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        .               LogSliderDeadzone           = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
        .               TabRounding                 = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        2 ( 0.00%)      TabBorderSize               = 0.0f;             // Thickness of border around tabs.
        .               TabMinWidthForCloseButton   = 0.0f;             // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
        .               TabBarBorderSize            = 1.0f;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        .               TableAngledHeadersAngle     = 35.0f * (IM_PI / 180.0f); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        1 ( 0.00%)      TableAngledHeadersTextAlign = ImVec2(0.5f,0.0f);// Alignment of angled headers within the cell
        1 ( 0.00%)      ColorButtonPosition         = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
        2 ( 0.00%)      ButtonTextAlign             = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
        .               SelectableTextAlign         = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
        .               SeparatorTextBorderSize     = 3.0f;             // Thickkness of border in SeparatorText()
        .               SeparatorTextAlign          = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
        2 ( 0.00%)      SeparatorTextPadding        = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
        .               DisplayWindowPadding        = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
        2 ( 0.00%)      DisplaySafeAreaPadding      = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
        .               DockingSeparatorSize        = 2.0f;             // Thickness of resizing border between docked windows
        1 ( 0.00%)      MouseCursorScale            = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
        .               AntiAliasedLines            = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
        .               AntiAliasedLinesUseTex      = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
        .               AntiAliasedFill             = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
        2 ( 0.00%)      CurveTessellationTol        = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
        .               CircleTessellationMaxError  = 0.30f;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
        .           
        .               // Behaviors
        2 ( 0.00%)      HoverStationaryDelay        = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
        .               HoverDelayShort             = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
        1 ( 0.00%)      HoverDelayNormal            = 0.40f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
        2 ( 0.00%)      HoverFlagsForTooltipMouse   = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled;    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
        .               HoverFlagsForTooltipNav     = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
        .           
        .               // Default theme
        2 ( 0.00%)      ImGui::StyleColorsDark(this);
       65 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImGui::StyleColorsDark(ImGuiStyle*) (1x)
        2 ( 0.00%)  }
        .           
        .           // To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
        .           // Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
        .           void ImGuiStyle::ScaleAllSizes(float scale_factor)
        .           {
        .               WindowPadding = ImTrunc(WindowPadding * scale_factor);
        .               WindowRounding = ImTrunc(WindowRounding * scale_factor);
        .               WindowMinSize = ImTrunc(WindowMinSize * scale_factor);
-- line 1285 ----------------------------------------
-- line 1302 ----------------------------------------
        .               TabMinWidthForCloseButton = (TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(TabMinWidthForCloseButton * scale_factor) : FLT_MAX;
        .               SeparatorTextPadding = ImTrunc(SeparatorTextPadding * scale_factor);
        .               DockingSeparatorSize = ImTrunc(DockingSeparatorSize * scale_factor);
        .               DisplayWindowPadding = ImTrunc(DisplayWindowPadding * scale_factor);
        .               DisplaySafeAreaPadding = ImTrunc(DisplaySafeAreaPadding * scale_factor);
        .               MouseCursorScale = ImTrunc(MouseCursorScale * scale_factor);
        .           }
        .           
        2 ( 0.00%)  ImGuiIO::ImGuiIO()
        .           {
        .               // Most fields are initialized with zero
        4 ( 0.00%)      memset(this, 0, sizeof(*this));
   14,633 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .               IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
        .           
        .               // Settings
        .               ConfigFlags = ImGuiConfigFlags_None;
        .               BackendFlags = ImGuiBackendFlags_None;
        2 ( 0.00%)      DisplaySize = ImVec2(-1.0f, -1.0f);
        .               DeltaTime = 1.0f / 60.0f;
        .               IniSavingRate = 5.0f;
        4 ( 0.00%)      IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
        .               LogFilename = "imgui_log.txt";
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        .               for (int i = 0; i < ImGuiKey_COUNT; i++)
        5 ( 0.00%)          KeyMap[i] = -1;
    2,681 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .           #endif
        .               UserData = NULL;
        .           
        .               Fonts = NULL;
        1 ( 0.00%)      FontGlobalScale = 1.0f;
        .               FontDefault = NULL;
        .               FontAllowUserScaling = false;
        2 ( 0.00%)      DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
        .           
        .               // Docking options (when ImGuiConfigFlags_DockingEnable is set)
        .               ConfigDockingNoSplit = false;
        .               ConfigDockingWithShift = false;
        .               ConfigDockingAlwaysTabBar = false;
        .               ConfigDockingTransparentPayload = false;
        .           
        .               // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
        .               ConfigViewportsNoAutoMerge = false;
        .               ConfigViewportsNoTaskBarIcon = false;
        1 ( 0.00%)      ConfigViewportsNoDecoration = true;
        .               ConfigViewportsNoDefaultParent = false;
        .           
        .               // Miscellaneous options
        .               MouseDrawCursor = false;
        .           #ifdef __APPLE__
        .               ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
        .           #else
        .               ConfigMacOSXBehaviors = false;
        .           #endif
        1 ( 0.00%)      ConfigInputTrickleEventQueue = true;
        .               ConfigInputTextCursorBlink = true;
        .               ConfigInputTextEnterKeepActive = false;
        .               ConfigDragClickToInputText = false;
        1 ( 0.00%)      ConfigWindowsResizeFromEdges = true;
        .               ConfigWindowsMoveFromTitleBarOnly = false;
        2 ( 0.00%)      ConfigMemoryCompactTimer = 60.0f;
        .               ConfigDebugBeginReturnValueOnce = false;
        .               ConfigDebugBeginReturnValueLoop = false;
        .           
        .               // Inputs Behaviors
        .               MouseDoubleClickTime = 0.30f;
        .               MouseDoubleClickMaxDist = 6.0f;
        .               MouseDragThreshold = 6.0f;
        2 ( 0.00%)      KeyRepeatDelay = 0.275f;
        .               KeyRepeatRate = 0.050f;
        .           
        .               // Platform Functions
        .               // Note: Initialize() will setup default clipboard/ime handlers.
        .               BackendPlatformName = BackendRendererName = NULL;
        .               BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
        1 ( 0.00%)      PlatformLocaleDecimalPoint = '.';
        .           
        .               // Input (NB: we already have memset zero the entire structure!)
        2 ( 0.00%)      MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
        1 ( 0.00%)      MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
        .               MouseSource = ImGuiMouseSource_Mouse;
        9 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    1,165 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
        1 ( 0.00%)      AppAcceptingEvents = true;
        1 ( 0.00%)      BackendUsingLegacyKeyArrays = (ImS8)-1;
        .               BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
        2 ( 0.00%)  }
        .           
        .           // Pass in translated ASCII characters for text input.
        .           // - with glfw you can get those from the callback set in glfwSetCharCallback()
        .           // - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
        .           // FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
        .           void ImGuiIO::AddInputCharacter(unsigned int c)
        .           {
      579 ( 0.00%)      IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
      772 ( 0.00%)      if (c == 0 || !AppAcceptingEvents)
        .                   return;
        .           
        .               ImGuiInputEvent e;
      579 ( 0.00%)      e.Type = ImGuiInputEventType_Text;
        .               e.Source = ImGuiInputSource_Keyboard;
    1,158 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
        .               e.Text.Char = c;
        .               g.InputEventsQueue.push_back(e);
        .           }
        .           
        .           // UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
        .           // we should save the high surrogate.
        .           void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)
        .           {
-- line 1411 ----------------------------------------
-- line 1437 ----------------------------------------
        .                   }
        .           
        .                   InputQueueSurrogate = 0;
        .               }
        .               AddInputCharacter((unsigned)cp);
        .           }
        .           
        .           void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
    1,544 ( 0.00%)  {
      579 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
    1,158 ( 0.00%)      while (*utf8_chars != 0)
        .               {
        .                   unsigned int c = 0;
      193 ( 0.00%)          utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
        .                   AddInputCharacter(c);
        .               }
    1,544 ( 0.00%)  }
        .           
        .           // Clear all incoming events.
        .           void ImGuiIO::ClearEventsQueue()
        .           {
        .               IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
        .               g.InputEventsQueue.clear();
        .           }
        .           
        .           // Clear current keyboard/mouse/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
        .           void ImGuiIO::ClearInputKeys()
       24 ( 0.00%)  {
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
       30 ( 0.00%)      memset(KeysDown, 0, sizeof(KeysDown));
      342 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6x)
        .           #endif
      252 ( 0.00%)      for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
        .               {
    4,116 ( 0.00%)          KeysData[n].Down             = false;
    4,014 ( 0.00%)          KeysData[n].DownDuration     = -1.0f;
        .                   KeysData[n].DownDurationPrev = -1.0f;
        .               }
        6 ( 0.00%)      KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
        .               KeyMods = ImGuiMod_None;
       12 ( 0.00%)      MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
        .               for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
        .               {
       12 ( 0.00%)          MouseDown[n] = false;
       36 ( 0.00%)          MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
        .               }
        6 ( 0.00%)      MouseWheel = MouseWheelH = 0.0f;
        .               InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
       24 ( 0.00%)  }
        .           
        .           // Removed this as it is ambiguous/misleading and generally incorrect to use with the existence of a higher-level input queue.
        .           // Current frame character buffer is now also cleared by ClearInputKeys().
        .           #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        .           void ImGuiIO::ClearInputCharacters()
        .           {
        .               InputQueueCharacters.resize(0);
        .           }
        .           #endif
        .           
        .           static ImGuiInputEvent* FindLatestInputEvent(ImGuiContext* ctx, ImGuiInputEventType type, int arg = -1)
        .           {
        .               ImGuiContext& g = *ctx;
  941,869 ( 0.00%)      for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
        .               {
        .                   ImGuiInputEvent* e = &g.InputEventsQueue[n];
  448,716 ( 0.00%)          if (e->Type != type)
        .                       continue;
       10 ( 0.00%)          if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
        .                       continue;
        4 ( 0.00%)          if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
        .                       continue;
        .                   return e;
        .               }
    1,728 ( 0.00%)      return NULL;
        .           }
        .           
        .           // Queue a new key down/up event.
        .           // - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
        .           // - bool down:          Is the key down? use false to signify a key release.
        .           // - float analog_value: 0.0f..1.0f
        .           // IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
        .           // WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULLFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
        .           void ImGuiIO::AddKeyAnalogEvent(ImGuiKey key, bool down, float analog_value)
    3,980 ( 0.00%)  {
        .               //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
    2,985 ( 0.00%)      IM_ASSERT(Ctx != NULL);
    4,975 ( 0.00%)      if (key == ImGuiKey_None || !AppAcceptingEvents)
        .                   return;
        .               ImGuiContext& g = *Ctx;
      398 ( 0.00%)      IM_ASSERT(ImGui::IsNamedKeyOrModKey(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
      796 ( 0.00%)      IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
      401 ( 0.00%)      IM_ASSERT(key != ImGuiMod_Shortcut); // We could easily support the translation here but it seems saner to not accept it (TestEngine perform a translation itself)
        .           
        .               // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    3,980 ( 0.00%)      IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
    1,990 ( 0.00%)      if (BackendUsingLegacyKeyArrays == -1)
      462 ( 0.00%)          for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
      308 ( 0.00%)              IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
      995 ( 0.00%)      BackendUsingLegacyKeyArrays = 0;
        .           #endif
    1,990 ( 0.00%)      if (ImGui::IsGamepadKey(key))
        .                   BackendUsingLegacyNavInputArray = false;
        .           
        .               // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
        .               const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);
        .               const ImGuiKeyData* key_data = ImGui::GetKeyData(&g, key);
    5,707 ( 0.00%)      const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
    1,989 ( 0.00%)      const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
    7,936 ( 0.00%)      if (latest_key_down == down && latest_key_analog == analog_value)
        .                   return;
        .           
        .               // Add event
        .               ImGuiInputEvent e;
       12 ( 0.00%)      e.Type = ImGuiInputEventType_Key;
       84 ( 0.00%)      e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
       36 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
       12 ( 0.00%)      e.Key.Key = key;
       12 ( 0.00%)      e.Key.Down = down;
       12 ( 0.00%)      e.Key.AnalogValue = analog_value;
        .               g.InputEventsQueue.push_back(e);
    4,975 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddKeyEvent(ImGuiKey key, bool down)
        .           {
    1,990 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
    5,168 ( 0.00%)      AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
1,548,770 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiIO::AddKeyAnalogEvent(ImGuiKey, bool, float) (995x)
        .           }
        .           
        .           // [Optional] Call after AddKeyEvent().
        .           // Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
        .           // If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
        .           void ImGuiIO::SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index)
      199 ( 0.00%)  {
      398 ( 0.00%)      if (key == ImGuiKey_None)
        .                   return;
      398 ( 0.00%)      IM_ASSERT(ImGui::IsNamedKey(key)); // >= 512
      796 ( 0.00%)      IM_ASSERT(native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)); // >= 0 && <= 511
        .               IM_UNUSED(native_keycode);  // Yet unused
        .               IM_UNUSED(native_scancode); // Yet unused
        .           
        .               // Build native->imgui map so old user code can still call key functions with native 0..511 values.
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        .               const int legacy_key = (native_legacy_index != -1) ? native_legacy_index : native_keycode;
        .               if (!ImGui::IsLegacyKey((ImGuiKey)legacy_key))
        .                   return;
      398 ( 0.00%)      KeyMap[legacy_key] = key;
      398 ( 0.00%)      KeyMap[key] = legacy_key;
        .           #else
        .               IM_UNUSED(key);
        .               IM_UNUSED(native_legacy_index);
        .           #endif
      398 ( 0.00%)  }
        .           
        .           // Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
        .           void ImGuiIO::SetAppAcceptingEvents(bool accepting_events)
        .           {
        .               AppAcceptingEvents = accepting_events;
        .           }
        .           
        .           // Queue a mouse move event
        .           void ImGuiIO::AddMousePosEvent(float x, float y)
   22,160 ( 0.00%)  {
   16,620 ( 0.00%)      IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
   11,080 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
        .           
        .               // Apply same flooring as UpdateMouseInputs()
   27,700 ( 0.00%)      ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);
        .           
        .               // Filter duplicate
        .               const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);
   11,381 ( 0.00%)      const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
   45,055 ( 0.00%)      if (latest_pos.x == pos.x && latest_pos.y == pos.y)
        .                   return;
        .           
        .               ImGuiInputEvent e;
   10,564 ( 0.00%)      e.Type = ImGuiInputEventType_MousePos;
        .               e.Source = ImGuiInputSource_Mouse;
   21,128 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
    5,282 ( 0.00%)      e.MousePos.PosX = pos.x;
        .               e.MousePos.PosY = pos.y;
   10,564 ( 0.00%)      e.MousePos.MouseSource = g.InputEventsNextMouseSource;
        .               g.InputEventsQueue.push_back(e);
   27,700 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddMouseButtonEvent(int mouse_button, bool down)
       32 ( 0.00%)  {
       24 ( 0.00%)      IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
       24 ( 0.00%)      IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
       16 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
        .           
        .               // Filter duplicate
        .               const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);
       20 ( 0.00%)      const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
       16 ( 0.00%)      if (latest_button_down == down)
        .                   return;
        .           
        .               ImGuiInputEvent e;
       16 ( 0.00%)      e.Type = ImGuiInputEventType_MouseButton;
        .               e.Source = ImGuiInputSource_Mouse;
       32 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
        8 ( 0.00%)      e.MouseButton.Button = mouse_button;
        8 ( 0.00%)      e.MouseButton.Down = down;
       16 ( 0.00%)      e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
        .               g.InputEventsQueue.push_back(e);
       40 ( 0.00%)  }
        .           
        .           // Queue a mouse wheel event (some mouse/API may only have a Y component)
        .           void ImGuiIO::AddMouseWheelEvent(float wheel_x, float wheel_y)
        .           {
        .               IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
        .           
        .               // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
-- line 1656 ----------------------------------------
-- line 1666 ----------------------------------------
        .               e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
        .               g.InputEventsQueue.push_back(e);
        .           }
        .           
        .           // This is not a real event, the data is latched in order to be stored in actual Mouse events.
        .           // This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
        .           void ImGuiIO::AddMouseSourceEvent(ImGuiMouseSource source)
        .           {
   15,708 ( 0.00%)      IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
   10,472 ( 0.00%)      g.InputEventsNextMouseSource = source;
        .           }
        .           
        .           void ImGuiIO::AddMouseViewportEvent(ImGuiID viewport_id)
    2,284 ( 0.00%)  {
    1,713 ( 0.00%)      IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
        .               //IM_ASSERT(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport);
    1,142 ( 0.00%)      if (!AppAcceptingEvents)
        .                   return;
        .           
        .               // Filter duplicate
        .               const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseViewport);
      571 ( 0.00%)      const ImGuiID latest_viewport_id = latest_event ? latest_event->MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport;
    1,684 ( 0.00%)      if (latest_viewport_id == viewport_id)
        .                   return;
        .           
        .               ImGuiInputEvent e;
       40 ( 0.00%)      e.Type = ImGuiInputEventType_MouseViewport;
        .               e.Source = ImGuiInputSource_Mouse;
       20 ( 0.00%)      e.MouseViewport.HoveredViewportID = viewport_id;
        .               g.InputEventsQueue.push_back(e);
    2,855 ( 0.00%)  }
        .           
        .           void ImGuiIO::AddFocusEvent(bool focused)
       52 ( 0.00%)  {
       39 ( 0.00%)      IM_ASSERT(Ctx != NULL);
        .               ImGuiContext& g = *Ctx;
        .           
        .               // Filter duplicate
        .               const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);
       39 ( 0.00%)      const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
       38 ( 0.00%)      if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
        .                   return;
        .           
        .               ImGuiInputEvent e;
        6 ( 0.00%)      e.Type = ImGuiInputEventType_Focus;
       24 ( 0.00%)      e.EventId = g.InputEventsNextEventId++;
        6 ( 0.00%)      e.AppFocused.Focused = focused;
        .               g.InputEventsQueue.push_back(e);
       65 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
        .           //-----------------------------------------------------------------------------
        .           
        .           ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)
        .           {
        .               IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
-- line 1724 ----------------------------------------
-- line 1860 ----------------------------------------
        .                   return;
        .               if (count > 1)
        .                   strncpy(dst, src, count - 1);
        .               dst[count - 1] = 0;
        .           }
        .           
        .           char* ImStrdup(const char* str)
        .           {
       18 ( 0.00%)      size_t len = strlen(str);
       84 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (6x)
        6 ( 0.00%)      void* buf = IM_ALLOC(len + 1);
       24 ( 0.00%)      return (char*)memcpy(buf, (const void*)str, len + 1);
       74 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (6x)
        .           }
        .           
        .           char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
        .           {
        .               size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
        .               size_t src_size = strlen(src) + 1;
        .               if (dst_buf_size < src_size)
        .               {
-- line 1878 ----------------------------------------
-- line 1881 ----------------------------------------
        .                   if (p_dst_size)
        .                       *p_dst_size = src_size;
        .               }
        .               return (char*)memcpy(dst, (const void*)src, src_size);
        .           }
        .           
        .           const char* ImStrchrRange(const char* str, const char* str_end, char c)
        .           {
       25 ( 0.00%)      const char* p = (const char*)memchr(str, (int)c, str_end - str);
        .               return p;
        .           }
        .           
        .           int ImStrlenW(const ImWchar* str)
        .           {
        .               //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
        .               int n = 0;
        .               while (*str++) n++;
-- line 1897 ----------------------------------------
-- line 1947 ----------------------------------------
        .                   p--;
        .               if (p_start != buf)                     // Copy memory if we had leading blanks
        .                   memmove(buf, p_start, p - p_start);
        .               buf[p - p_start] = 0;                   // Zero terminate
        .           }
        .           
        .           const char* ImStrSkipBlank(const char* str)
        .           {
       20 ( 0.00%)      while (str[0] == ' ' || str[0] == '\t')
        1 ( 0.00%)          str++;
        .               return str;
        .           }
        .           
        .           // A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
        .           // Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
        .           // B) When buf==NULL vsnprintf() will return the output size.
        .           #ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        .           
-- line 1964 ----------------------------------------
-- line 1977 ----------------------------------------
        .           #endif
        .           #endif // #ifdef IMGUI_USE_STB_SPRINTF
        .           
        .           #if defined(_MSC_VER) && !defined(vsnprintf)
        .           #define vsnprintf _vsnprintf
        .           #endif
        .           
        .           int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
    5,730 ( 0.00%)  {
        .               va_list args;
    3,438 ( 0.00%)      va_start(args, fmt);
        .           #ifdef IMGUI_USE_STB_SPRINTF
        .               int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
        .           #else
    2,869 ( 0.00%)      int w = vsnprintf(buf, buf_size, fmt, args);
  425,325 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/vsnprintf.c:vsnprintf (573x)
    1,199 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           #endif
        .               va_end(args);
    1,146 ( 0.00%)      if (buf == NULL)
        .                   return w;
    2,292 ( 0.00%)      if (w == -1 || w >= (int)buf_size)
        .                   w = (int)buf_size - 1;
    1,146 ( 0.00%)      buf[w] = 0;
        .               return w;
    2,292 ( 0.00%)  }
        .           
        .           int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
        .           {
        .           #ifdef IMGUI_USE_STB_SPRINTF
        .               int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
        .           #else
      336 ( 0.00%)      int w = vsnprintf(buf, buf_size, fmt, args);
   36,704 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/vsnprintf.c:vsnprintf (56x)
        .           #endif
       56 ( 0.00%)      if (buf == NULL)
        .                   return w;
      140 ( 0.00%)      if (w == -1 || w >= (int)buf_size)
        .                   w = (int)buf_size - 1;
       56 ( 0.00%)      buf[w] = 0;
        .               return w;
        .           }
        .           #endif // #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        .           
        .           void ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...)
        .           {
        .               va_list args;
        .               va_start(args, fmt);
-- line 2021 ----------------------------------------
-- line 2092 ----------------------------------------
        .           
        .           // Zero-terminated string hash, with support for ### to reset back to seed value
        .           // We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
        .           // Because this syntax is rarely used we are optimizing for the common case.
        .           // - If we reach ### in the string we discard the hash so far and reset to the seed.
        .           // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
        .           // FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
        .           ImGuiID ImHashStr(const char* data_p, size_t data_size, ImGuiID seed)
   13,152 ( 0.00%)  {
   26,304 ( 0.00%)      seed = ~seed;
  101,171 ( 0.00%)      ImU32 crc = seed;
        .               const unsigned char* data = (const unsigned char*)data_p;
        .               const ImU32* crc32_lut = GCrc32LookupTable;
   26,304 ( 0.00%)      if (data_size != 0)
        .               {
      112 ( 0.00%)          while (data_size-- != 0)
        .                   {
      110 ( 0.00%)              unsigned char c = *data++;
      118 ( 0.00%)              if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
        2 ( 0.00%)                  crc = seed;
      330 ( 0.00%)              crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        .                   }
        .               }
        .               else
        .               {
  533,320 ( 0.00%)          while (unsigned char c = *data++)
        .                   {
  470,367 ( 0.00%)              if (c == '#' && data[0] == '#' && data[1] == '#')
    1,142 ( 0.00%)                  crc = seed;
  923,527 ( 0.00%)              crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        .                   }
        .               }
   26,332 ( 0.00%)      return ~crc;
    3,426 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MISC HELPERS/UTILITIES (File functions)
        .           //-----------------------------------------------------------------------------
        .           
        .           // Default file functions
        .           #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        .           
-- line 2133 ----------------------------------------
-- line 2146 ----------------------------------------
        .               if (filename_wsize + mode_wsize > IM_ARRAYSIZE(local_temp_stack))
        .                   local_temp_heap.resize(filename_wsize + mode_wsize);
        .               wchar_t* filename_wbuf = local_temp_heap.Data ? local_temp_heap.Data : local_temp_stack;
        .               wchar_t* mode_wbuf = filename_wbuf + filename_wsize;
        .               ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_wbuf, filename_wsize);
        .               ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, mode_wbuf, mode_wsize);
        .               return ::_wfopen(filename_wbuf, mode_wbuf);
        .           #else
       13 ( 0.00%)      return fopen(filename, mode);
    1,200 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      554 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofopen.c:fopen@@GLIBC_2.2.5 (1x)
        .           #endif
        .           }
        .           
        .           // We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
       10 ( 0.00%)  bool    ImFileClose(ImFileHandle f)     { return fclose(f) == 0; }
    1,274 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      640 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofclose.c:fclose@@GLIBC_2.2.5 (1x)
       34 ( 0.00%)  ImU64   ImFileGetSize(ImFileHandle f)   { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1; }
    2,427 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (2x)
    1,290 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/fseek.c:fseek (2x)
      249 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/ioftell.c:ftell (2x)
       11 ( 0.00%)  ImU64   ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f)           { return fread(data, (size_t)sz, (size_t)count, f); }
    1,167 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      183 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofread.c:fread (1x)
       10 ( 0.00%)  ImU64   ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f)    { return fwrite(data, (size_t)sz, (size_t)count, f); }
    1,231 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      801 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/iofwrite.c:fwrite (1x)
        .           #endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        .           
        .           // Helper: Load file content into memory
        .           // Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
        .           // This can't really be used with "rt" because fseek size won't match read size.
        .           void*   ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)
        .           {
        2 ( 0.00%)      IM_ASSERT(filename && mode);
        .               if (out_file_size)
        .                   *out_file_size = 0;
        .           
        .               ImFileHandle f;
        2 ( 0.00%)      if ((f = ImFileOpen(filename, mode)) == NULL)
        .                   return NULL;
        .           
        .               size_t file_size = (size_t)ImFileGetSize(f);
        .               if (file_size == (size_t)-1)
        .               {
        .                   ImFileClose(f);
        .                   return NULL;
        .               }
        .           
        3 ( 0.00%)      void* file_data = IM_ALLOC(file_size + padding_bytes);
       69 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (1x)
        2 ( 0.00%)      if (file_data == NULL)
        .               {
        .                   ImFileClose(f);
        .                   return NULL;
        .               }
        2 ( 0.00%)      if (ImFileRead(file_data, 1, file_size, f) != file_size)
        .               {
        .                   ImFileClose(f);
        .                   IM_FREE(file_data);
        .                   return NULL;
        .               }
        .               if (padding_bytes > 0)
        .                   memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);
        .           
-- line 2199 ----------------------------------------
-- line 2215 ----------------------------------------
        .           // We handle UTF-8 decoding error by skipping forward.
        .           int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
        .           {
        .               static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
        .               static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
        .               static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
        .               static const int shiftc[] = { 0, 18, 12, 6, 0 };
        .               static const int shifte[] = { 0, 6, 4, 2, 0 };
      772 ( 0.00%)      int len = lengths[*(const unsigned char*)in_text >> 3];
      579 ( 0.00%)      int wanted = len + (len ? 0 : 1);
        .           
        .               if (in_text_end == NULL)
      386 ( 0.00%)          in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
        .           
        .               // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
        .               // so it is fast even with excessive branching.
        .               unsigned char s[4];
      386 ( 0.00%)      s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
      579 ( 0.00%)      s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
    1,158 ( 0.00%)      s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
    1,544 ( 0.00%)      s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
        .           
        .               // Assume a four-byte character and load four bytes. Unused bits are shifted out.
      579 ( 0.00%)      *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
      193 ( 0.00%)      *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
      193 ( 0.00%)      *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
      193 ( 0.00%)      *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
      386 ( 0.00%)      *out_char >>= shiftc[len];
        .           
        .               // Accumulate the various error conditions.
        .               int e = 0;
      772 ( 0.00%)      e  = (*out_char < mins[len]) << 6; // non-canonical encoding
      772 ( 0.00%)      e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
      772 ( 0.00%)      e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
        .               e |= (s[1] & 0xc0) >> 2;
        .               e |= (s[2] & 0xc0) >> 4;
      579 ( 0.00%)      e |= (s[3]       ) >> 6;
      193 ( 0.00%)      e ^= 0x2a; // top two bits of each tail byte correct?
      386 ( 0.00%)      e >>= shifte[len];
        .           
      386 ( 0.00%)      if (e)
        .               {
        .                   // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
        .                   // One byte is consumed in case of invalid first byte of in_text.
        .                   // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
        .                   // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
        .                   wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
        .                   *out_char = IM_UNICODE_CODEPOINT_INVALID;
        .               }
-- line 2263 ----------------------------------------
-- line 2429 ----------------------------------------
        .               return ImVec4(
        .                   ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        .                   ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        .                   ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        .                   ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
        .           }
        .           
        .           ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
      572 ( 0.00%)  {
        .               ImU32 out;
   66,858 ( 0.00%)      out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
   92,002 ( 0.00%)      out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
   92,002 ( 0.00%)      out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
   92,002 ( 0.00%)      out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
        .               return out;
      572 ( 0.00%)  }
        .           
        .           // Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
        .           // Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
        .           void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
        .           {
        .               float K = 0.f;
        .               if (g < b)
        .               {
-- line 2452 ----------------------------------------
-- line 2497 ----------------------------------------
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ImGuiStorage
        .           // Helper: Key->value storage
        .           //-----------------------------------------------------------------------------
        .           
        .           // std::lower_bound but without the bullshit
        .           static ImGuiStorage::ImGuiStoragePair* LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key)
        .           {
    8,027 ( 0.00%)      ImGuiStorage::ImGuiStoragePair* first = data.Data;
   12,052 ( 0.00%)      ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
       11 ( 0.00%)      size_t count = (size_t)(last - first);
   31,473 ( 0.00%)      while (count > 0)
        .               {
   19,430 ( 0.00%)          size_t count2 = count >> 1;
   29,145 ( 0.00%)          ImGuiStorage::ImGuiStoragePair* mid = first + count2;
   19,430 ( 0.00%)          if (mid->key < key)
        .                   {
    5,720 ( 0.00%)              first = ++mid;
    5,720 ( 0.00%)              count -= count2 + 1;
        .                   }
        .                   else
        .                   {
    6,855 ( 0.00%)              count = count2;
        .                   }
        .               }
        .               return first;
        .           }
        .           
        .           // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
        .           void ImGuiStorage::BuildSortByKey()
        .           {
-- line 2527 ----------------------------------------
-- line 2536 ----------------------------------------
        .                   }
        .               };
        .               ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), StaticFunc::PairComparerByID);
        .           }
        .           
        .           int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
        .           {
        .               ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
        8 ( 0.00%)      if (it == Data.end() || it->key != key)
        .                   return default_val;
        2 ( 0.00%)      return it->val_i;
        .           }
        .           
        .           bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
        .           {
        .               return GetInt(key, default_val ? 1 : 0) != 0;
        .           }
        .           
        .           float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
-- line 2554 ----------------------------------------
-- line 2557 ----------------------------------------
        .               if (it == Data.end() || it->key != key)
        .                   return default_val;
        .               return it->val_f;
        .           }
        .           
        .           void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
        .           {
        .               ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
   16,004 ( 0.00%)      if (it == Data.end() || it->key != key)
    3,429 ( 0.00%)          return NULL;
    7,415 ( 0.00%)      return it->val_p;
        .           }
        .           
        .           // References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
        .           int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
        .           {
        .               ImGuiStoragePair* it = LowerBound(Data, key);
        2 ( 0.00%)      if (it == Data.end() || it->key != key)
        .                   it = Data.insert(it, ImGuiStoragePair(key, default_val));
        .               return &it->val_i;
        .           }
        .           
        .           bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
        .           {
        .               return (bool*)GetIntRef(key, default_val ? 1 : 0);
        .           }
-- line 2582 ----------------------------------------
-- line 2617 ----------------------------------------
        .               ImGuiStoragePair* it = LowerBound(Data, key);
        .               if (it == Data.end() || it->key != key)
        .                   Data.insert(it, ImGuiStoragePair(key, val));
        .               else
        .                   it->val_f = val;
        .           }
        .           
        .           void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
       70 ( 0.00%)  {
        .               ImGuiStoragePair* it = LowerBound(Data, key);
       22 ( 0.00%)      if (it == Data.end() || it->key != key)
        .                   Data.insert(it, ImGuiStoragePair(key, val));
        .               else
        .                   it->val_p = val;
       56 ( 0.00%)  }
        .           
        .           void ImGuiStorage::SetAllInt(int v)
        .           {
        .               for (int i = 0; i < Data.Size; i++)
        .                   Data[i].val_i = v;
        .           }
        .           
        .           //-----------------------------------------------------------------------------
-- line 2639 ----------------------------------------
-- line 2745 ----------------------------------------
        .           #else
        .           #define va_copy(dest, src) (dest = src)
        .           #endif
        .           #endif
        .           
        .           char ImGuiTextBuffer::EmptyString[1] = { 0 };
        .           
        .           void ImGuiTextBuffer::append(const char* str, const char* str_end)
       36 ( 0.00%)  {
       28 ( 0.00%)      int len = str_end ? (int)(str_end - str) : (int)strlen(str);
       56 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (4x)
        .           
        .               // Add zero-terminator the first time
       20 ( 0.00%)      const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
        4 ( 0.00%)      const int needed_sz = write_off + len;
       12 ( 0.00%)      if (write_off + len >= Buf.Capacity)
        .               {
        .                   int new_capacity = Buf.Capacity * 2;
        .                   Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
        .               }
        .           
        .               Buf.resize(needed_sz);
       16 ( 0.00%)      memcpy(&Buf[write_off - 1], str, (size_t)len);
       64 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4x)
       12 ( 0.00%)      Buf[write_off - 1 + len] = 0;
       32 ( 0.00%)  }
        .           
        .           void ImGuiTextBuffer::appendf(const char* fmt, ...)
      196 ( 0.00%)  {
        .               va_list args;
      168 ( 0.00%)      va_start(args, fmt);
       56 ( 0.00%)      appendfv(fmt, args);
   38,384 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendfv(char const*, __va_list_tag*) (28x)
        .               va_end(args);
       56 ( 0.00%)  }
        .           
        .           // Helper: Text buffer for logging/accumulating text
        .           void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
      280 ( 0.00%)  {
        .               va_list args_copy;
      112 ( 0.00%)      va_copy(args_copy, args);
        .           
        .               int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
       56 ( 0.00%)      if (len <= 0)
        .               {
        .                   va_end(args_copy);
        .                   return;
        .               }
        .           
        .               // Add zero-terminator the first time
       84 ( 0.00%)      const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
       28 ( 0.00%)      const int needed_sz = write_off + len;
       84 ( 0.00%)      if (write_off + len >= Buf.Capacity)
        .               {
        .                   int new_capacity = Buf.Capacity * 2;
        .                   Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
        .               }
        .           
        .               Buf.resize(needed_sz);
       56 ( 0.00%)      ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
        .               va_end(args_copy);
      224 ( 0.00%)  }
        .           
        .           void ImGuiTextIndex::append(const char* base, int old_size, int new_size)
        .           {
        .               IM_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= EndOffset);
        .               if (old_size == new_size)
        .                   return;
        .               if (EndOffset == 0 || base[EndOffset - 1] == '\n')
        .                   LineOffsets.push_back(EndOffset);
-- line 2811 ----------------------------------------
-- line 3105 ----------------------------------------
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] STYLING
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiStyle& ImGui::GetStyle()
        .           {
        3 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
        1 ( 0.00%)      return GImGui->Style;
        1 ( 0.00%)  }
        .           
        .           ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
        .           {
    3,434 ( 0.00%)      ImGuiStyle& style = GImGui->Style;
   29,157 ( 0.00%)      ImVec4 c = style.Colors[idx];
   22,872 ( 0.00%)      c.w *= style.Alpha * alpha_mul;
    2,860 ( 0.00%)      return ColorConvertFloat4ToU32(c);
   25,695 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ColorConvertFloat4ToU32(ImVec4 const&) (571x)
    2,290 ( 0.00%)  }
        .           
        .           ImU32 ImGui::GetColorU32(const ImVec4& col)
        .           {
        .               ImGuiStyle& style = GImGui->Style;
        .               ImVec4 c = col;
        .               c.w *= style.Alpha;
        .               return ColorConvertFloat4ToU32(c);
        .           }
-- line 3131 ----------------------------------------
-- line 3155 ----------------------------------------
        .               backup.Col = idx;
        .               backup.BackupValue = g.Style.Colors[idx];
        .               g.ColorStack.push_back(backup);
        .               if (g.DebugFlashStyleColorIdx != idx)
        .                   g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
        .           }
        .           
        .           void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
  159,880 ( 0.00%)  {
   15,988 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiColorMod backup;
   15,988 ( 0.00%)      backup.Col = idx;
   63,952 ( 0.00%)      backup.BackupValue = g.Style.Colors[idx];
        .               g.ColorStack.push_back(backup);
   31,976 ( 0.00%)      if (g.DebugFlashStyleColorIdx != idx)
   47,964 ( 0.00%)          g.Style.Colors[idx] = col;
  127,904 ( 0.00%)  }
        .           
        .           void ImGui::PopStyleColor(int count)
    3,997 ( 0.00%)  {
    4,568 ( 0.00%)      ImGuiContext& g = *GImGui;
   14,275 ( 0.00%)      if (g.ColorStack.Size < count)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times!");
        .                   count = g.ColorStack.Size;
        .               }
   86,792 ( 0.00%)      while (count > 0)
        .               {
        .                   ImGuiColorMod& backup = g.ColorStack.back();
   63,952 ( 0.00%)          g.Style.Colors[backup.Col] = backup.BackupValue;
        .                   g.ColorStack.pop_back();
        .                   count--;
        .               }
    7,994 ( 0.00%)  }
        .           
        .           static const ImGuiCol GWindowDockStyleColors[ImGuiWindowDockStyleCol_COUNT] =
        .           {
        .               ImGuiCol_Text, ImGuiCol_Tab, ImGuiCol_TabHovered, ImGuiCol_TabActive, ImGuiCol_TabUnfocused, ImGuiCol_TabUnfocusedActive
        .           };
        .           
        .           static const ImGuiDataVarInfo GStyleVarInfo[] =
        .           {
-- line 3196 ----------------------------------------
-- line 3226 ----------------------------------------
        .               { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, SeparatorTextBorderSize)},    // ImGuiStyleVar_SeparatorTextBorderSize
        .               { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextAlign) },        // ImGuiStyleVar_SeparatorTextAlign
        .               { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextPadding) },      // ImGuiStyleVar_SeparatorTextPadding
        .               { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, DockingSeparatorSize) },      // ImGuiStyleVar_DockingSeparatorSize
        .           };
        .           
        .           const ImGuiDataVarInfo* ImGui::GetStyleVarInfo(ImGuiStyleVar idx)
        .           {
   57,100 ( 0.00%)      IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
        .               IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
        .               return &GStyleVarInfo[idx];
        .           }
        .           
        .           void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
   31,405 ( 0.00%)  {
    6,281 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
   43,967 ( 0.00%)      if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
        .               {
        .                   float* pvar = (float*)var_info->GetVarPtr(&g.Style);
    6,281 ( 0.00%)          g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
    6,281 ( 0.00%)          *pvar = val;
        .                   return;
        .               }
        .               IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
   37,686 ( 0.00%)  }
        .           
        .           void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
   47,964 ( 0.00%)  {
    7,994 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
   55,958 ( 0.00%)      if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
        .               {
        .                   ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
    7,994 ( 0.00%)          g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
   15,988 ( 0.00%)          *pvar = val;
        .                   return;
        .               }
        .               IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
   55,958 ( 0.00%)  }
        .           
      571 ( 0.00%)  void ImGui::PopStyleVar(int count)
    7,994 ( 0.00%)  {
    8,565 ( 0.00%)      ImGuiContext& g = *GImGui;
   25,695 ( 0.00%)      if (g.StyleVarStack.Size < count)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times!");
        .                   count = g.StyleVarStack.Size;
        .               }
   97,070 ( 0.00%)      while (count > 0)
        .               {
        .                   // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        .                   ImGuiStyleMod& backup = g.StyleVarStack.back();
   14,275 ( 0.00%)          const ImGuiDataVarInfo* info = GetStyleVarInfo(backup.VarIdx);
   23,982 ( 0.00%)          void* data = info->GetVarPtr(&g.Style);
  118,197 ( 0.00%)          if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
   55,958 ( 0.00%)          else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        .                   g.StyleVarStack.pop_back();
        .                   count--;
        .               }
   17,130 ( 0.00%)  }
        .           
        .           const char* ImGui::GetStyleColorName(ImGuiCol idx)
        .           {
        .               // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
        .               switch (idx)
        .               {
        .               case ImGuiCol_Text: return "Text";
        .               case ImGuiCol_TextDisabled: return "TextDisabled";
-- line 3294 ----------------------------------------
-- line 3356 ----------------------------------------
        .           // Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
        .           // we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
        .           // Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
        .           //-----------------------------------------------------------------------------
        .           
        .           const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
        .           {
        .               const char* text_display_end = text;
   28,552 ( 0.00%)      if (!text_end)
   42,828 ( 0.00%)          text_end = (const char*)-1;
        .           
  537,046 ( 0.00%)      while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
   65,136 ( 0.00%)          text_display_end++;
        .               return text_display_end;
        .           }
        .           
        .           // Internal ImGui functions to render text
        .           // RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
        .           void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
   27,408 ( 0.00%)  {
    3,426 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .           
        .               // Hide anything after a '##' string
        .               const char* text_display_end;
    6,852 ( 0.00%)      if (hide_text_after_hash)
        .               {
    3,426 ( 0.00%)          text_display_end = FindRenderedTextEnd(text, text_end);
        .               }
        .               else
        .               {
        .                   if (!text_end)
        .                       text_end = text + strlen(text); // FIXME-OPT
        .                   text_display_end = text_end;
        .               }
        .           
    6,852 ( 0.00%)      if (text != text_display_end)
        .               {
   41,112 ( 0.00%)          window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
3,436,207 ( 0.01%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddText(ImFont const*, float, ImVec2 const&, unsigned int, char const*, char const*, float, ImVec4 const*) (3,426x)
   13,704 ( 0.00%)          if (g.LogEnabled)
        .                       LogRenderedText(&pos, text, text_display_end);
        .               }
   20,556 ( 0.00%)  }
        .           
        .           void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .           
        .               if (!text_end)
        .                   text_end = text + strlen(text); // FIXME-OPT
-- line 3406 ----------------------------------------
-- line 3414 ----------------------------------------
        .           }
        .           
        .           // Default clip_rect uses (pos_min,pos_max)
        .           // Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
        .           // FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.
        .           // Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
        .           // better advantage of the render function taking size into account for coarse clipping.
        .           void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
    8,008 ( 0.00%)  {
        .               // Perform CPU side clipping for single clipped element to avoid using scissor state
    1,144 ( 0.00%)      ImVec2 pos = pos_min;
    2,288 ( 0.00%)      const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
        .           
    1,716 ( 0.00%)      const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
      572 ( 0.00%)      const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    5,145 ( 0.00%)      bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
        .               if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
    4,003 ( 0.00%)          need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
        .           
        .               // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    2,288 ( 0.00%)      if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    6,864 ( 0.00%)      if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
        .           
        .               // Render
    1,144 ( 0.00%)      if (need_clipping)
        .               {
        2 ( 0.00%)          ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        5 ( 0.00%)          draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
        .               }
        .               else
        .               {
    6,861 ( 0.00%)          draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
  386,506 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddText(ImFont const*, float, ImVec2 const&, unsigned int, char const*, char const*, float, ImVec4 const*) (572x)
        .               }
    4,576 ( 0.00%)  }
        .           
        .           void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
   27,408 ( 0.00%)  {
        .               // Hide anything after a '##' string
        .               const char* text_display_end = FindRenderedTextEnd(text, text_end);
        .               const int text_len = (int)(text_display_end - text);
    8,568 ( 0.00%)      if (text_len == 0)
        .                   return;
        .           
      572 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
    6,864 ( 0.00%)      RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
  456,866 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderTextClippedEx(ImDrawList*, ImVec2 const&, ImVec2 const&, char const*, char const*, ImVec2 const*, ImVec2 const&, ImRect const*) (572x)
    2,860 ( 0.00%)      if (g.LogEnabled)
        .                   LogRenderedText(&pos_min, text, text_display_end);
   20,556 ( 0.00%)  }
        .           
        .           // Another overly complex function until we reorganize everything into a nice all-in-one helper.
        .           // This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
        .           // This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
        .           void ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (text_end_full == NULL)
-- line 3470 ----------------------------------------
-- line 3607 ----------------------------------------
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] INITIALIZATION, SHUTDOWN
        .           //-----------------------------------------------------------------------------
        .           
        .           // Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
        .           // Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
        .           ImGuiContext* ImGui::GetCurrentContext()
        .           {
        2 ( 0.00%)      return GImGui;
   18,276 ( 0.00%)  }
        .           
        .           void ImGui::SetCurrentContext(ImGuiContext* ctx)
        .           {
        .           #ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
        .               IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
        .           #else
        2 ( 0.00%)      GImGui = ctx;
        .           #endif
        1 ( 0.00%)  }
        .           
        .           void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)
        .           {
        .               GImAllocatorAllocFunc = alloc_func;
        .               GImAllocatorFreeFunc = free_func;
        .               GImAllocatorUserData = user_data;
        .           }
        .           
-- line 3633 ----------------------------------------
-- line 3635 ----------------------------------------
        .           void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)
        .           {
        .               *p_alloc_func = GImAllocatorAllocFunc;
        .               *p_free_func = GImAllocatorFreeFunc;
        .               *p_user_data = GImAllocatorUserData;
        .           }
        .           
        .           ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
        9 ( 0.00%)  {
        .               ImGuiContext* prev_ctx = GetCurrentContext();
        .               ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
        .               SetCurrentContext(ctx);
        2 ( 0.00%)      Initialize();
   19,406 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Initialize() (1x)
        2 ( 0.00%)      if (prev_ctx != NULL)
        .                   SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
        .               return ctx;
        9 ( 0.00%)  }
        .           
        .           void ImGui::DestroyContext(ImGuiContext* ctx)
        .           {
        .               ImGuiContext* prev_ctx = GetCurrentContext();
        .               if (ctx == NULL) //-V1051
        .                   ctx = prev_ctx;
        .               SetCurrentContext(ctx);
        .               Shutdown();
-- line 3659 ----------------------------------------
-- line 3673 ----------------------------------------
        .               { ImGuiLocKey_WindowingPopup,       "(Popup)"                               },
        .               { ImGuiLocKey_WindowingUntitled,    "(Untitled)"                            },
        .               { ImGuiLocKey_DockingHideTabBar,    "Hide tab bar###HideTabBar"             },
        .               { ImGuiLocKey_DockingHoldShiftToDock,       "Hold SHIFT to enable Docking window."  },
        .               { ImGuiLocKey_DockingDragToUndockOrMoveNode,"Click and drag to move or undock whole node."    },
        .           };
        .           
        .           void ImGui::Initialize()
       16 ( 0.00%)  {
        7 ( 0.00%)      ImGuiContext& g = *GImGui;
       11 ( 0.00%)      IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
        .           
        .               // Add .ini handle for ImGuiWindow and ImGuiTable types
        .               {
        .                   ImGuiSettingsHandler ini_handler;
        1 ( 0.00%)          ini_handler.TypeName = "Window";
        .                   ini_handler.TypeHash = ImHashStr("Window");
        3 ( 0.00%)          ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
        1 ( 0.00%)          ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
        .                   ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
        .                   ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
        .                   ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
        3 ( 0.00%)          AddSettingsHandler(&ini_handler);
      199 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::AddSettingsHandler(ImGuiSettingsHandler const*) (1x)
        .               }
        1 ( 0.00%)      TableSettingsAddSettingsHandler();
      218 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_tables.cpp:ImGui::TableSettingsAddSettingsHandler() (1x)
        .           
        .               // Setup default localization table
        .               LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
        .           
        .               // Setup default platform clipboard/IME handlers.
        4 ( 0.00%)      g.IO.GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations
        .               g.IO.SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
        1 ( 0.00%)      g.IO.ClipboardUserData = (void*)&g;                          // Default implementation use the ImGuiContext as user data (ideally those would be arguments to the function)
        1 ( 0.00%)      g.IO.SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;
        .           
        .               // Create default viewport
        .               ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
        2 ( 0.00%)      viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
        1 ( 0.00%)      viewport->Idx = 0;
        1 ( 0.00%)      viewport->PlatformWindowCreated = true;
        .               viewport->Flags = ImGuiViewportFlags_OwnedByApp;
        .               g.Viewports.push_back(viewport);
        .               g.TempBuffer.resize(1024 * 3 + 1, 0);
        1 ( 0.00%)      g.ViewportCreatedCount++;
        2 ( 0.00%)      g.PlatformIO.Viewports.push_back(g.Viewports[0]);
        .           
        .               // Build KeysMayBeCharInput[] lookup table (1 bool per named key)
      280 ( 0.00%)      for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
      776 ( 0.00%)          if ((key >= ImGuiKey_0 && key <= ImGuiKey_9) || (key >= ImGuiKey_A && key <= ImGuiKey_Z) || (key >= ImGuiKey_Keypad0 && key <= ImGuiKey_Keypad9)
        .                       || key == ImGuiKey_Tab || key == ImGuiKey_Space || key == ImGuiKey_Apostrophe || key == ImGuiKey_Comma || key == ImGuiKey_Minus || key == ImGuiKey_Period
        .                       || key == ImGuiKey_Slash || key == ImGuiKey_Semicolon || key == ImGuiKey_Equal || key == ImGuiKey_LeftBracket || key == ImGuiKey_RightBracket || key == ImGuiKey_GraveAccent
        .                       || key == ImGuiKey_KeypadDecimal || key == ImGuiKey_KeypadDivide || key == ImGuiKey_KeypadMultiply || key == ImGuiKey_KeypadSubtract || key == ImGuiKey_KeypadAdd || key == ImGuiKey_KeypadEqual)
        .                       g.KeysMayBeCharInput.SetBit(key);
        .           
        .           #ifdef IMGUI_HAS_DOCK
        .               // Initialize Docking
        2 ( 0.00%)      DockContextInitialize(&g);
      142 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextInitialize(ImGuiContext*) (1x)
        .           #endif
        .           
        1 ( 0.00%)      g.Initialized = true;
        7 ( 0.00%)  }
        .           
        .           // This function is merely here to free heap allocations.
        .           void ImGui::Shutdown()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == NULL, "Forgot to shutdown Platform backend?");
        .               IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == NULL, "Forgot to shutdown Renderer backend?");
        .           
-- line 3741 ----------------------------------------
-- line 3841 ----------------------------------------
        .                       hook.Type = ImGuiContextHookType_PendingRemoval_;
        .           }
        .           
        .           // Call context hooks (used by e.g. test engine)
        .           // We assume a small number of hooks so all stored in same array
        .           void ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)
        .           {
        .               ImGuiContext& g = *ctx;
    6,852 ( 0.00%)      for (ImGuiContextHook& hook : g.Hooks)
        .                   if (hook.Type == hook_type)
        .                       hook.Callback(&g, &hook);
        .           }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
        .           //-----------------------------------------------------------------------------
        .           
        .           // ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
      150 ( 0.00%)  ImGuiWindow::ImGuiWindow(ImGuiContext* ctx, const char* name) : DrawListInst(NULL)
        .           {
       24 ( 0.00%)      memset(this, 0, sizeof(*this));
      496 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (6x)
        6 ( 0.00%)      Ctx = ctx;
        6 ( 0.00%)      Name = ImStrdup(name);
       30 ( 0.00%)      NameBufLen = (int)strlen(name) + 1;
       84 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (6x)
        6 ( 0.00%)      ID = ImHashStr(name);
        .               IDStack.push_back(ID);
        6 ( 0.00%)      ViewportAllowPlatformMonitorExtend = -1;
       12 ( 0.00%)      ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
        6 ( 0.00%)      MoveId = GetID("#MOVE");
        6 ( 0.00%)      TabId = GetID("#TAB");
       12 ( 0.00%)      ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
        .               ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
        6 ( 0.00%)      AutoFitFramesX = AutoFitFramesY = -1;
        6 ( 0.00%)      AutoPosLastDirection = ImGuiDir_None;
        6 ( 0.00%)      SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = 0;
       18 ( 0.00%)      SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
        6 ( 0.00%)      LastFrameActive = -1;
        .               LastFrameJustFocused = -1;
        6 ( 0.00%)      LastTimeActive = -1.0f;
       12 ( 0.00%)      FontWindowScale = FontDpiScale = 1.0f;
        6 ( 0.00%)      SettingsOffset = -1;
        6 ( 0.00%)      DockOrder = -1;
        6 ( 0.00%)      DrawList = &DrawListInst;
       12 ( 0.00%)      DrawList->_Data = &Ctx->DrawListSharedData;
       12 ( 0.00%)      DrawList->_OwnerName = Name;
       12 ( 0.00%)      NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);
        .               IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
       36 ( 0.00%)  }
        .           
        .           ImGuiWindow::~ImGuiWindow()
        .           {
        .               IM_ASSERT(DrawList == &DrawListInst);
        .               IM_DELETE(Name);
        .               ColumnsStorage.clear_destruct();
        .           }
        .           
        .           static void SetCurrentWindow(ImGuiWindow* window)
        .           {
    5,712 ( 0.00%)      ImGuiContext& g = *GImGui;
    5,712 ( 0.00%)      g.CurrentWindow = window;
   37,700 ( 0.00%)      g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
      571 ( 0.00%)      if (window)
        .               {
   10,282 ( 0.00%)          g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
        .                   ImGui::NavUpdateCurrentWindowIsScrollPushableX();
        .               }
        .           }
        .           
        .           void ImGui::GcCompactTransientMiscBuffers()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.ItemFlagsStack.clear();
-- line 3913 ----------------------------------------
-- line 3916 ----------------------------------------
        .           }
        .           
        .           // Free up/compact internal window buffers, we can use this when a window becomes unused.
        .           // Not freed:
        .           // - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
        .           // This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
        .           void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)
        .           {
        1 ( 0.00%)      window->MemoryCompacted = true;
        4 ( 0.00%)      window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
        .               window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
        .               window->IDStack.clear();
        4 ( 0.00%)      window->DrawList->_ClearFreeMemory();
      930 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_ClearFreeMemory() (1x)
        .               window->DC.ChildWindows.clear();
        .               window->DC.ItemWidthStack.clear();
        .               window->DC.TextWrapPosStack.clear();
        .           }
        .           
        .           void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)
        .           {
        .               // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
-- line 3936 ----------------------------------------
-- line 3937 ----------------------------------------
        .               // The other buffers tends to amortize much faster.
        .               window->MemoryCompacted = false;
        .               window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
        .               window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
        .               window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
        .           }
        .           
        .           void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
       40 ( 0.00%)  {
        8 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Clear previous active id
       24 ( 0.00%)      if (g.ActiveId != 0)
        .               {
        .                   // While most behaved code would make an effort to not steal active id during window move/drag operations,
        .                   // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
        .                   // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
       12 ( 0.00%)          if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
        .                   {
        .                       IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
        .                       g.MovingWindow = NULL;
        .                   }
        .           
        .                   // This could be written in a more general way (e.g associate a hook to ActiveId),
        .                   // but since this is currently quite an exception we'll leave it as is.
        .                   // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveId()
        8 ( 0.00%)          if (g.InputTextState.ID == g.ActiveId)
        .                       InputTextDeactivateHook(g.ActiveId);
        .               }
        .           
        .               // Set active id
       16 ( 0.00%)      g.ActiveIdIsJustActivated = (g.ActiveId != id);
        8 ( 0.00%)      if (g.ActiveIdIsJustActivated)
        .               {
       16 ( 0.00%)          IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
        8 ( 0.00%)          g.ActiveIdTimer = 0.0f;
        8 ( 0.00%)          g.ActiveIdHasBeenPressedBefore = false;
        .                   g.ActiveIdHasBeenEditedBefore = false;
        8 ( 0.00%)          g.ActiveIdMouseButton = -1;
        8 ( 0.00%)          if (id != 0)
        .                   {
        4 ( 0.00%)              g.LastActiveId = id;
        4 ( 0.00%)              g.LastActiveIdTimer = 0.0f;
        .                   }
        .               }
        8 ( 0.00%)      g.ActiveId = id;
        8 ( 0.00%)      g.ActiveIdAllowOverlap = false;
        .               g.ActiveIdNoClearOnFocusLoss = false;
        8 ( 0.00%)      g.ActiveIdWindow = window;
        8 ( 0.00%)      g.ActiveIdHasBeenEditedThisFrame = false;
        .               g.ActiveIdFromShortcut = false;
        .               if (id)
        .               {
        4 ( 0.00%)          g.ActiveIdIsAlive = id;
       20 ( 0.00%)          g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
        4 ( 0.00%)          IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);
        .               }
        .           
        .               // Clear declaration of inputs claimed by the widget
        .               // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
        8 ( 0.00%)      g.ActiveIdUsingNavDirMask = 0x00;
        8 ( 0.00%)      g.ActiveIdUsingAllKeyboardKeys = false;
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        8 ( 0.00%)      g.ActiveIdUsingNavInputMask = 0x00;
        .           #endif
       32 ( 0.00%)  }
        .           
        .           void ImGui::ClearActiveID()
        .           {
       12 ( 0.00%)      SetActiveID(0, NULL); // g.ActiveId = 0;
      140 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetActiveID(unsigned int, ImGuiWindow*) (4x)
        .           }
        .           
        .           void ImGui::SetHoveredID(ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.HoveredId = id;
        .               g.HoveredIdAllowOverlap = false;
        .               if (id != 0 && g.HoveredIdPreviousFrame != id)
-- line 4014 ----------------------------------------
-- line 4186 ----------------------------------------
        .           
        .           // Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
        .           // (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
        .           // FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
        .           // If you used this in your legacy/custom widgets code:
        .           // - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.InFlags'.
        .           // - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
        .           bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id, ImGuiItemFlags item_flags)
   19,995 ( 0.00%)  {
    3,999 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,999 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    7,998 ( 0.00%)      if (g.HoveredWindow != window)
    3,999 ( 0.00%)          return false;
        .               if (!IsMouseHoveringRect(bb.Min, bb.Max))
        .                   return false;
        .           
        .               if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        .                   return false;
        .               if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        .                   if (!g.ActiveIdFromShortcut)
        .                       return false;
-- line 4206 ----------------------------------------
-- line 4255 ----------------------------------------
        .                       IM_DEBUG_BREAK();
        .               }
        .           #endif
        .           
        .               if (g.NavDisableMouseHover)
        .                   return false;
        .           
        .               return true;
   19,995 ( 0.00%)  }
        .           
        .           // FIXME: This is inlined/duplicated in ItemAdd()
        .           // FIXME: The id != 0 path is not used by our codebase, may get rid of it?
        .           bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               if (!bb.Overlaps(window->ClipRect))
-- line 4271 ----------------------------------------
-- line 4275 ----------------------------------------
        .               return false;
        .           }
        .           
        .           // This is also inlined in ItemAdd()
        .           // Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
        .           void ImGui::SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)
        .           {
        .               ImGuiContext& g = *GImGui;
    2,856 ( 0.00%)      g.LastItemData.ID = item_id;
    5,141 ( 0.00%)      g.LastItemData.InFlags = in_flags;
        .               g.LastItemData.StatusFlags = item_flags;
   11,424 ( 0.00%)      g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
    2,285 ( 0.00%)  }
        .           
        .           float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
        .           {
        .               if (wrap_pos_x < 0.0f)
        .                   return 0.0f;
        .           
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
-- line 4295 ----------------------------------------
-- line 4307 ----------------------------------------
        .                   wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space
        .               }
        .           
        .               return ImMax(wrap_pos_x - pos.x, 1.0f);
        .           }
        .           
        .           // IM_ALLOC() == ImGui::MemAlloc()
        .           void* ImGui::MemAlloc(size_t size)
    9,128 ( 0.00%)  {
   13,887 ( 0.00%)      void* ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
       47 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:MallocWrapper(unsigned long, void*) (1x)
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
   13,890 ( 0.00%)      if (ImGuiContext* ctx = GImGui)
    4,621 ( 0.00%)          DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
        .           #endif
        .               return ptr;
   13,692 ( 0.00%)  }
        .           
        .           // IM_FREE() == ImGui::MemFree()
        .           void ImGui::MemFree(void* ptr)
        .           {
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    9,096 ( 0.00%)      if (ptr != NULL)
   13,605 ( 0.00%)          if (ImGuiContext* ctx = GImGui)
    4,535 ( 0.00%)              DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
        .           #endif
    9,096 ( 0.00%)      return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
  634,410 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:FreeWrapper(void*, void*) (4,548x)
        .           }
        .           
        .           // We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
        .           void ImGui::DebugAllocHook(ImGuiDebugAllocInfo* info, int frame_count, void* ptr, size_t size)
        .           {
   32,020 ( 0.00%)      ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[info->LastEntriesIdx];
        .               IM_UNUSED(ptr);
   27,468 ( 0.00%)      if (entry->FrameCount != frame_count)
        .               {
      252 ( 0.00%)          info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);
       51 ( 0.00%)          entry = &info->LastEntriesBuf[info->LastEntriesIdx];
       21 ( 0.00%)          entry->FrameCount = frame_count;
       21 ( 0.00%)          entry->AllocCount = entry->FreeCount = 0;
        .               }
    9,128 ( 0.00%)      if (size != (size_t)-1)
        .               {
    4,621 ( 0.00%)          entry->AllocCount++;
    4,622 ( 0.00%)          info->TotalAllocCount++;
        .                   //printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
        .               }
        .               else
        .               {
    4,535 ( 0.00%)          entry->FreeCount++;
    4,535 ( 0.00%)          info->TotalFreeCount++;
        .                   //printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
        .               }
        .           }
        .           
        .           const char* ImGui::GetClipboardText()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData) : "";
-- line 4364 ----------------------------------------
-- line 4373 ----------------------------------------
        .           
        .           const char* ImGui::GetVersion()
        .           {
        .               return IMGUI_VERSION;
        .           }
        .           
        .           ImGuiIO& ImGui::GetIO()
        .           {
   83,972 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
   27,608 ( 0.00%)      return GImGui->IO;
   27,608 ( 0.00%)  }
        .           
        .           ImGuiPlatformIO& ImGui::GetPlatformIO()
        .           {
    1,722 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
        3 ( 0.00%)      return GImGui->PlatformIO;
        3 ( 0.00%)  }
        .           
        .           // Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
        .           ImDrawData* ImGui::GetDrawData()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,142 ( 0.00%)      ImGuiViewportP* viewport = g.Viewports[0];
    2,284 ( 0.00%)      return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
      571 ( 0.00%)  }
        .           
        .           double ImGui::GetTime()
        .           {
        .               return GImGui->Time;
        .           }
        .           
        .           int ImGui::GetFrameCount()
        .           {
       60 ( 0.00%)      return GImGui->FrameCount;
       30 ( 0.00%)  }
        .           
        .           static ImDrawList* GetViewportBgFgDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)
        .           {
        .               // Create the draw list on demand, because they are not frequently used for all viewports
      574 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport->BgFgDrawLists));
        .               ImDrawList* draw_list = viewport->BgFgDrawLists[drawlist_no];
        .               if (draw_list == NULL)
        .               {
        .                   draw_list = IM_NEW(ImDrawList)(&g.DrawListSharedData);
        .                   draw_list->_OwnerName = drawlist_name;
        .                   viewport->BgFgDrawLists[drawlist_no] = draw_list;
        .               }
-- line 4420 ----------------------------------------
-- line 4453 ----------------------------------------
        .           }
        .           
        .           ImDrawListSharedData* ImGui::GetDrawListSharedData()
        .           {
        .               return &GImGui->DrawListSharedData;
        .           }
        .           
        .           void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
       16 ( 0.00%)  {
        .               // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
        .               // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
        .               // This is because we want ActiveId to be set even when the window is not permitted to move.
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
        8 ( 0.00%)      FocusWindow(window);
      346 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FocusWindow(ImGuiWindow*, int) (4x)
       12 ( 0.00%)      SetActiveID(window->MoveId, window);
      148 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetActiveID(unsigned int, ImGuiWindow*) (4x)
        4 ( 0.00%)      g.NavDisableHighlight = true;
        4 ( 0.00%)      g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
        4 ( 0.00%)      g.ActiveIdNoClearOnFocusLoss = true;
        .               SetActiveIdUsingAllKeyboardKeys();
        .           
        .               bool can_move_window = true;
        8 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
        .                   can_move_window = false;
        .               if (ImGuiDockNode* node = window->DockNodeAsHost)
        .                   if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
        .                       can_move_window = false;
        .               if (can_move_window)
        .                   g.MovingWindow = window;
       16 ( 0.00%)  }
        .           
        .           // We use 'undock == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
        .           void ImGui::StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undock)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               bool can_undock_node = false;
        .               if (undock && node != NULL && node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove) == 0 && (node->MergedFlags & ImGuiDockNodeFlags_NoUndocking) == 0)
        .               {
-- line 4489 ----------------------------------------
-- line 4504 ----------------------------------------
        .           }
        .           
        .           // Handle mouse moving window
        .           // Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
        .           // FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
        .           // This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
        .           // but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
        .           void ImGui::UpdateMouseMovingWindowNewFrame()
    2,284 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      if (g.MovingWindow != NULL)
        .               {
        .                   // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        .                   // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        .                   KeepAliveID(g.ActiveId);
        .                   IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
        .                   ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
        .           
        .                   // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
-- line 4522 ----------------------------------------
-- line 4555 ----------------------------------------
        .           
        .                       g.MovingWindow = NULL;
        .                       ClearActiveID();
        .                   }
        .               }
        .               else
        .               {
        .                   // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
    1,731 ( 0.00%)          if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        .                   {
        .                       KeepAliveID(g.ActiveId);
       12 ( 0.00%)              if (!g.IO.MouseDown[0])
        .                           ClearActiveID();
        .                   }
        .               }
    2,851 ( 0.00%)  }
        .           
        .           // Initiate moving window when clicking on empty space or title bar.
        .           // Handle left-click and right-click focus.
        .           void ImGui::UpdateMouseMovingWindowEndFrame()
    1,713 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,420 ( 0.00%)      if (g.ActiveId != 0 || g.HoveredId != 0)
        .                   return;
        .           
        .               // Unless we just made a window/popup appear
    2,845 ( 0.00%)      if (g.NavWindow && g.NavWindow->Appearing)
        .                   return;
        .           
        .               // Click on empty space to focus window and start moving
        .               // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
    1,136 ( 0.00%)      if (g.IO.MouseClicked[0])
        .               {
        .                   // Handle the edge case of a popup being closed while clicking in its empty space.
        .                   // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
       16 ( 0.00%)          ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
       16 ( 0.00%)          const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
        .           
        .                   if (root_window != NULL && !is_closed_popup)
        .                   {
        4 ( 0.00%)              StartMouseMovingWindow(g.HoveredWindow); //-V595
      630 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::StartMouseMovingWindow(ImGuiWindow*) (4x)
        .           
        .                       // Cancel moving if clicked outside of title bar
        8 ( 0.00%)              if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
        .                           if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
        .                               if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
        .                                   g.MovingWindow = NULL;
        .           
        .                       // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
        8 ( 0.00%)              if (g.HoveredIdDisabled)
        .                           g.MovingWindow = NULL;
        .                   }
        .                   else if (root_window == NULL && g.NavWindow != NULL)
        .                   {
        .                       // Clicking on void disable focus
        .                       FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);
        .                   }
        .               }
        .           
        .               // With right mouse button we close popups without changing focus based on where the mouse is aimed
        .               // Instead, focus will be restored to the window under the bottom-most closed popup.
        .               // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
    1,136 ( 0.00%)      if (g.IO.MouseClicked[1])
        .               {
        .                   // Find the top-most window between HoveredWindow and the top-most Modal Window.
        .                   // This is where we can trim the popup stack.
        .                   ImGuiWindow* modal = GetTopMostPopupModal();
        .                   bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
        .                   ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
        .               }
    2,284 ( 0.00%)  }
        .           
        .           // This is called during NewFrame()->UpdateViewportsNewFrame() only.
        .           // Need to keep in sync with SetWindowPos()
        .           static void TranslateWindow(ImGuiWindow* window, const ImVec2& delta)
        .           {
        .               window->Pos += delta;
        .               window->ClipRect.Translate(delta);
        .               window->OuterRectClipped.Translate(delta);
-- line 4633 ----------------------------------------
-- line 4644 ----------------------------------------
        .               window->Pos = ImFloor((window->Pos - origin) * scale + origin);
        .               window->Size = ImTrunc(window->Size * scale);
        .               window->SizeFull = ImTrunc(window->SizeFull * scale);
        .               window->ContentSize = ImTrunc(window->ContentSize * scale);
        .           }
        .           
        .           static bool IsWindowActiveAndVisible(ImGuiWindow* window)
        .           {
   16,002 ( 0.00%)      return (window->Active) && (!window->Hidden);
        .           }
        .           
        .           // The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
        .           void ImGui::UpdateHoveredWindowAndCaptureFlags()
    1,713 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
      571 ( 0.00%)      g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
        .           
        .               // Find the window hovered by mouse:
        .               // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
        .               // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
        .               // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
        .               bool clear_hovered_windows = false;
        .               FindHoveredWindow();
      936 ( 0.00%)      IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
        .           
        .               // Modal windows prevents mouse from hovering behind them.
        .               ImGuiWindow* modal_window = GetTopMostPopupModal();
        .               if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
        .                   clear_hovered_windows = true;
        .           
        .               // Disabled mouse?
    2,284 ( 0.00%)      if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
        .                   clear_hovered_windows = true;
        .           
        .               // We track click ownership. When clicked outside of a window the click is owned by the application and
        .               // won't report hovering nor request capture even while dragging over our windows afterward.
        .               const bool has_open_popup = (g.OpenPopupStack.Size > 0);
        .               const bool has_open_modal = (modal_window != NULL);
      565 ( 0.00%)      int mouse_earliest_down = -1;
        .               bool mouse_any_down = false;
        .               for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
        .               {
    6,848 ( 0.00%)          if (io.MouseClicked[i])
        .                   {
       16 ( 0.00%)              io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
        4 ( 0.00%)              io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
        .                   }
    2,278 ( 0.00%)          mouse_any_down |= io.MouseDown[i];
    5,722 ( 0.00%)          if (io.MouseDown[i])
        .                       if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
        .                           mouse_earliest_down = i;
        .               }
    1,148 ( 0.00%)      const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
      571 ( 0.00%)      const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
        .           
        .               // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
        .               // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    1,713 ( 0.00%)      const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
       12 ( 0.00%)      if (!mouse_avail && !mouse_dragging_extern_payload)
        .                   clear_hovered_windows = true;
        .           
    1,142 ( 0.00%)      if (clear_hovered_windows)
        .                   g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
        .           
        .               // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
        .               // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
    1,713 ( 0.00%)      if (g.WantCaptureMouseNextFrame != -1)
        .               {
        .                   io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
        .               }
        .               else
        .               {
    3,479 ( 0.00%)          io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
    4,362 ( 0.00%)          io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
        .               }
        .           
        .               // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
    3,373 ( 0.00%)      io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    1,142 ( 0.00%)      if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        .                   io.WantCaptureKeyboard = true;
    1,713 ( 0.00%)      if (g.WantCaptureKeyboardNextFrame != -1) // Manual override
        .                   io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
        .           
        .               // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    2,284 ( 0.00%)      io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
    2,284 ( 0.00%)  }
        .           
        .           // Calling SetupDrawListSharedData() is followed by SetCurrentFont() which sets up the remaining data.
        .           static void SetupDrawListSharedData()
        .           {
        .               ImGuiContext& g = *GImGui;
    5,139 ( 0.00%)      ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    5,147 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
        .                   virtual_space.Add(viewport->GetMainRect());
      571 ( 0.00%)      g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
    1,142 ( 0.00%)      g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
    1,713 ( 0.00%)      g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
   13,466 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawListSharedData::SetCircleTessellationMaxError(float) (571x)
        .               g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
      571 ( 0.00%)      if (g.Style.AntiAliasedLines)
        .                   g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
    3,426 ( 0.00%)      if (g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts->Flags & ImFontAtlasFlags_NoBakedLines))
    1,142 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
    1,142 ( 0.00%)      if (g.Style.AntiAliasedFill)
    1,142 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
    1,142 ( 0.00%)      if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
    1,142 ( 0.00%)          g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
        .           }
        .           
        .           void ImGui::NewFrame()
    3,997 ( 0.00%)  {
    1,713 ( 0.00%)      IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
        .               ImGuiContext& g = *GImGui;
        .           
        .               // Remove pending delete hooks before frame start.
        .               // This deferred removal avoid issues of removal while iterating the hook vector
    2,284 ( 0.00%)      for (int n = g.Hooks.Size - 1; n >= 0; n--)
        .                   if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
        .                       g.Hooks.erase(&g.Hooks[n]);
        .           
        .               CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
        .           
        .               // Check and assert for various common IO and Configuration mistakes
    1,142 ( 0.00%)      g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
        .               ErrorCheckNewFrameSanityChecks();
    1,142 ( 0.00%)      g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
        .           
        .               // Load settings on first frame, save settings when modified (after a delay)
        .               UpdateSettings();
        .           
    2,284 ( 0.00%)      g.Time += g.IO.DeltaTime;
      571 ( 0.00%)      g.WithinFrameScope = true;
      571 ( 0.00%)      g.FrameCount += 1;
      571 ( 0.00%)      g.TooltipOverrideCount = 0;
      571 ( 0.00%)      g.WindowsActiveCount = 0;
        .               g.MenusIdSubmittedThisFrame.resize(0);
        .           
        .               // Calculate frame-rate for the user, as a purely luxurious feature
    2,855 ( 0.00%)      g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
      571 ( 0.00%)      g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    7,994 ( 0.00%)      g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    1,142 ( 0.00%)      g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
    5,139 ( 0.00%)      g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
        .           
        .               // Process input queue (trickle as many events as possible), turn events into writes to IO structure
        .               g.InputEventsTrail.resize(0);
    1,142 ( 0.00%)      UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
  493,578 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateInputEvents(bool) (571x)
        .           
        .               // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
        .               UpdateViewportsNewFrame();
        .           
        .               // Setup current font and draw list shared data
        .               // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
    1,142 ( 0.00%)      g.IO.Fonts->Locked = true;
        .               SetupDrawListSharedData();
      571 ( 0.00%)      SetCurrentFont(GetDefaultFont());
   18,272 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetCurrentFont(ImFont*) (571x)
    1,142 ( 0.00%)      IM_ASSERT(g.Font->IsLoaded());
        .           
        .               // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    4,005 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
        .               {
      573 ( 0.00%)          viewport->DrawData = NULL;
      573 ( 0.00%)          viewport->DrawDataP.Valid = false;
        .               }
        .           
        .               // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    1,713 ( 0.00%)      if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        .                   KeepAliveID(g.DragDropPayload.SourceId);
        .           
        .               // Update HoveredId data
    1,713 ( 0.00%)      if (!g.HoveredIdPreviousFrame)
      571 ( 0.00%)          g.HoveredIdTimer = 0.0f;
      571 ( 0.00%)      if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        .                   g.HoveredIdNotActiveTimer = 0.0f;
    1,142 ( 0.00%)      if (g.HoveredId)
        .                   g.HoveredIdTimer += g.IO.DeltaTime;
        .               if (g.HoveredId && g.ActiveId != g.HoveredId)
        .                   g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
      571 ( 0.00%)      g.HoveredIdPreviousFrame = g.HoveredId;
      571 ( 0.00%)      g.HoveredId = 0;
      571 ( 0.00%)      g.HoveredIdAllowOverlap = false;
        .               g.HoveredIdDisabled = false;
        .           
        .               // Clear ActiveID if the item is not alive anymore.
        .               // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
        .               // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
    1,154 ( 0.00%)      if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
        .               {
        .                   IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
        .                   ClearActiveID();
        .               }
        .           
        .               // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
        .               if (g.ActiveId)
       18 ( 0.00%)          g.ActiveIdTimer += g.IO.DeltaTime;
    1,707 ( 0.00%)      g.LastActiveIdTimer += g.IO.DeltaTime;
      571 ( 0.00%)      g.ActiveIdPreviousFrame = g.ActiveId;
    1,142 ( 0.00%)      g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    1,142 ( 0.00%)      g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
      571 ( 0.00%)      g.ActiveIdIsAlive = 0;
      571 ( 0.00%)      g.ActiveIdHasBeenEditedThisFrame = false;
      571 ( 0.00%)      g.ActiveIdPreviousFrameIsAlive = false;
      571 ( 0.00%)      g.ActiveIdIsJustActivated = false;
    1,713 ( 0.00%)      if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
        .                   g.TempInputId = 0;
        .               if (g.ActiveId == 0)
        .               {
      565 ( 0.00%)          g.ActiveIdUsingNavDirMask = 0x00;
      565 ( 0.00%)          g.ActiveIdUsingAllKeyboardKeys = false;
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
      565 ( 0.00%)          g.ActiveIdUsingNavInputMask = 0x00;
        .           #endif
        .               }
        .           
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        .               if (g.ActiveId == 0)
        .                   g.ActiveIdUsingNavInputMask = 0;
       18 ( 0.00%)      else if (g.ActiveIdUsingNavInputMask != 0)
        .               {
        .                   // If your custom widget code used:                 { g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel); }
        .                   // Since IMGUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(ImGuiKey_Escape, g.ActiveId); SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId); }
        .                   if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
        .                       SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
        .                   if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
        .                       IM_ASSERT(0); // Other values unsupported
        .               }
        .           #endif
        .           
        .               // Record when we have been stationary as this state is preserved while over same item.
        .               // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
        .               // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
    1,713 ( 0.00%)      if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
        .                   g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
        .               else if (g.HoverItemDelayId == 0)
      571 ( 0.00%)          g.HoverItemUnlockedStationaryId = 0;
    2,487 ( 0.00%)      if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
      390 ( 0.00%)          g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
        .               else if (g.HoveredWindow == NULL)
      313 ( 0.00%)          g.HoverWindowUnlockedStationaryId = 0;
        .           
        .               // Update hover delay for IsItemHovered() with delays and tooltips
      571 ( 0.00%)      g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
      313 ( 0.00%)      if (g.HoverItemDelayId != 0)
        .               {
        .                   g.HoverItemDelayTimer += g.IO.DeltaTime;
        .                   g.HoverItemDelayClearTimer = 0.0f;
        .                   g.HoverItemDelayId = 0;
        .               }
    2,284 ( 0.00%)      else if (g.HoverItemDelayTimer > 0.0f)
        .               {
        .                   // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
        .                   // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
        .                   g.HoverItemDelayClearTimer += g.IO.DeltaTime;
        .                   if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate
        .                       g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
        .               }
        .           
        .               // Drag and drop
    1,142 ( 0.00%)      g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
        .               g.DragDropAcceptIdCurr = 0;
      571 ( 0.00%)      g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
      571 ( 0.00%)      g.DragDropWithinSource = false;
        .               g.DragDropWithinTarget = false;
      571 ( 0.00%)      g.DragDropHoldJustPressedId = 0;
        .           
        .               // Close popups on focus lost (currently wip/opt-in)
        .               //if (g.IO.AppFocusLost)
        .               //    ClosePopupsExceptModals();
        .           
        .               // Update keyboard input state
      571 ( 0.00%)      UpdateKeyboardInputs();
7,134,794 ( 0.01%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateKeyboardInputs() (571x)
        .           
        .               //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
        .               //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
        .               //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
        .               //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
        .           
        .               // Update gamepad/keyboard navigation
      571 ( 0.00%)      NavUpdate();
  472,090 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavUpdate() (571x)
        .           
        .               // Update mouse input state
        .               UpdateMouseInputs();
        .           
        .               // Undocking
        .               // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
    1,142 ( 0.00%)      DockContextNewFrameUpdateUndocking(&g);
   11,991 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextNewFrameUpdateUndocking(ImGuiContext*) (571x)
        .           
        .               // Find hovered window
        .               // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
      571 ( 0.00%)      UpdateHoveredWindowAndCaptureFlags();
  121,078 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateHoveredWindowAndCaptureFlags() (571x)
        .           
        .               // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
      571 ( 0.00%)      UpdateMouseMovingWindowNewFrame();
    9,344 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseMovingWindowNewFrame() (571x)
        .           
        .               // Background darkening/whitening
    1,142 ( 0.00%)      if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
      571 ( 0.00%)          g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
        .               else
    3,997 ( 0.00%)          g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
        .           
      571 ( 0.00%)      g.MouseCursor = ImGuiMouseCursor_Arrow;
    1,142 ( 0.00%)      g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
        .           
        .               // Platform IME data: reset for the frame
    1,142 ( 0.00%)      g.PlatformImeDataPrev = g.PlatformImeData;
      571 ( 0.00%)      g.PlatformImeData.WantVisible = false;
        .           
        .               // Mouse wheel scrolling, scale
      571 ( 0.00%)      UpdateMouseWheel();
   29,821 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseWheel() (571x)
        .           
        .               // Mark all windows as not visible and compact unused memory.
    1,713 ( 0.00%)      IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
    5,710 ( 0.00%)      const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
   15,392 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
        .               {
    6,840 ( 0.00%)          window->WasActive = window->Active;
    3,420 ( 0.00%)          window->Active = false;
    3,420 ( 0.00%)          window->WriteAccessed = false;
    6,840 ( 0.00%)          window->BeginCountPreviousFrame = window->BeginCount;
    3,420 ( 0.00%)          window->BeginCount = 0;
        .           
        .                   // Garbage collect transient buffers of recently unused windows
   11,811 ( 0.00%)          if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
        .                       GcCompactTransientWindowBuffers(window);
        .               }
        .           
        .               // Garbage collect transient buffers of recently unused tables
    3,426 ( 0.00%)      for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
      571 ( 0.00%)          if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
        .                       TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
    1,713 ( 0.00%)      for (ImGuiTableTempData& table_temp_data : g.TablesTempData)
      571 ( 0.00%)          if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)
        .                       TableGcCompactTransientBuffers(&table_temp_data);
    1,142 ( 0.00%)      if (g.GcCompactAll)
        .                   GcCompactTransientMiscBuffers();
      571 ( 0.00%)      g.GcCompactAll = false;
        .           
        .               // Closing the focused window restore focus to the first active root window in descending z-order
    2,853 ( 0.00%)      if (g.NavWindow && !g.NavWindow->WasActive)
        .                   FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);
        .           
        .               // No window should be open at the beginning of the frame.
        .               // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
        .               g.CurrentWindowStack.resize(0);
        .               g.BeginPopupStack.resize(0);
        .               g.ItemFlagsStack.resize(0);
        .               g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
-- line 4990 ----------------------------------------
-- line 4993 ----------------------------------------
        .               // Docking
        .               DockContextNewFrameUpdateDocking(&g);
        .           
        .               // [DEBUG] Update debug features
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        .               UpdateDebugToolItemPicker();
        .               UpdateDebugToolStackQueries();
        .               UpdateDebugToolFlashStyleColor();
    1,713 ( 0.00%)      if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
        .               {
        .                   g.DebugLocateId = 0;
        .                   g.DebugBreakInLocateId = false;
        .               }
    1,713 ( 0.00%)      if (g.DebugLogAutoDisableFrames > 0 && --g.DebugLogAutoDisableFrames == 0)
        .               {
        .                   DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n");
        .                   g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;
        .                   g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
        .               }
        .           #endif
        .           
        .               // Create implicit/fallback window - which we will only render it if the user has added something to it.
        .               // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
        .               // This fallback is particularly important as it prevents ImGui:: calls from crashing.
      571 ( 0.00%)      g.WithinFrameScopeWithImplicitWindow = true;
        .               SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
    2,284 ( 0.00%)      Begin("Debug##Default");
3,255,706 ( 0.01%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Begin(char const*, bool*, int) (571x)
    2,385 ( 0.00%)      IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
        .           
        .               // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
        .               // allowing to validate correct Begin/End behavior in user code.
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    1,713 ( 0.00%)      if (g.IO.ConfigDebugBeginReturnValueLoop)
      571 ( 0.00%)          g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
        .               else
        .                   g.DebugBeginReturnValueCullDepth = -1;
        .           #endif
        .           
        .               CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
    4,568 ( 0.00%)  }
        .           
        .           // FIXME: Add a more explicit sort order in the window structure.
        .           static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
        .           {
        .               const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
        .               const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
        .               if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        .                   return d;
        .               if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        .                   return d;
        .               return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
        .           }
        .           
        .           static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
   23,982 ( 0.00%)  {
        .               out_sorted_windows->push_back(window);
    6,852 ( 0.00%)      if (window->Active)
        .               {
    4,570 ( 0.00%)          int count = window->DC.ChildWindows.Size;
        .                   ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
    9,138 ( 0.00%)          for (int i = 0; i < count; i++)
        .                   {
    1,142 ( 0.00%)              ImGuiWindow* child = window->DC.ChildWindows[i];
    2,284 ( 0.00%)              if (child->Active)
    3,426 ( 0.00%)                  AddWindowToSortBuffer(out_sorted_windows, child);
   38,257 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToSortBuffer(ImVector<ImGuiWindow*>*, ImGuiWindow*)'2 (571x)
        .                   }
        .               }
   20,556 ( 0.00%)  }
        .           
        .           static void AddWindowToDrawData(ImGuiWindow* window, int layer)
    6,849 ( 0.00%)  {
    2,283 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,283 ( 0.00%)      ImGuiViewportP* viewport = window->Viewport;
    4,566 ( 0.00%)      IM_ASSERT(viewport != NULL);
    6,849 ( 0.00%)      g.IO.MetricsRenderWindows++;
    6,849 ( 0.00%)      if (window->DrawList->_Splitter._Count > 1)
        .                   window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
    9,703 ( 0.00%)      ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);
   45,766 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImGui::AddDrawListToDrawDataEx(ImDrawData*, ImVector<ImDrawList*>*, ImDrawList*) (1,142x)
    9,134 ( 0.00%)      for (ImGuiWindow* child : window->DC.ChildWindows)
        .                   if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
    2,282 ( 0.00%)              AddWindowToDrawData(child, layer);
  203,790 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToDrawData(ImGuiWindow*, int)'2 (571x)
    9,132 ( 0.00%)  }
        .           
        .           static inline int GetWindowDisplayLayer(ImGuiWindow* window)
        .           {
    3,426 ( 0.00%)      return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
        .           }
        .           
        .           // Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
        .           static inline void AddRootWindowToDrawData(ImGuiWindow* window)
        .           {
    1,142 ( 0.00%)      AddWindowToDrawData(window, GetWindowDisplayLayer(window));
  284,958 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToDrawData(ImGuiWindow*, int) (1,142x)
    1,142 ( 0.00%)  }
        .           
        .           static void FlattenDrawDataIntoSingleLayer(ImDrawDataBuilder* builder)
        .           {
    1,148 ( 0.00%)      int n = builder->Layers[0]->Size;
        .               int full_size = n;
        .               for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)
    1,722 ( 0.00%)          full_size += builder->Layers[i]->Size;
        .               builder->Layers[0]->resize(full_size);
        .               for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++)
        .               {
        .                   ImVector<ImDrawList*>* layer = builder->Layers[layer_n];
    1,148 ( 0.00%)          if (layer->empty())
        .                       continue;
        .                   memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList*));
        .                   n += layer->Size;
        .                   layer->resize(0);
        .               }
        .           }
        .           
        .           static void InitViewportDrawData(ImGuiViewportP* viewport)
        .           {
        .               ImGuiIO& io = ImGui::GetIO();
      574 ( 0.00%)      ImDrawData* draw_data = &viewport->DrawDataP;
        .           
      574 ( 0.00%)      viewport->DrawData = draw_data; // Make publicly accessible
    2,296 ( 0.00%)      viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
      574 ( 0.00%)      viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
        .               viewport->DrawDataBuilder.Layers[0]->resize(0);
        .               viewport->DrawDataBuilder.Layers[1]->resize(0);
        .           
        .               // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
        .               // and to allow applications/backends to easily skip rendering.
        .               // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
        .               // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
        .               // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
        .               const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0;
        .           
      574 ( 0.00%)      draw_data->Valid = true;
      574 ( 0.00%)      draw_data->CmdListsCount = 0;
      574 ( 0.00%)      draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    1,722 ( 0.00%)      draw_data->DisplayPos = viewport->Pos;
    2,296 ( 0.00%)      draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
    1,148 ( 0.00%)      draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
    1,148 ( 0.00%)      draw_data->OwnerViewport = viewport;
        .           }
        .           
        .           // Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
        .           // - When using this function it is sane to ensure that float are perfectly rounded to integer values,
        .           //   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
        .           // - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
        .           //   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
        .           //   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
        .           void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
      571 ( 0.00%)  {
        .               ImGuiWindow* window = GetCurrentWindow();
   26,846 ( 0.00%)      window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
  331,153 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PushClipRect(ImVec2 const&, ImVec2 const&, bool) (5,141x)
   25,704 ( 0.00%)      window->ClipRect = window->DrawList->_ClipRectStack.back();
    3,427 ( 0.00%)  }
        .           
        .           void ImGui::PopClipRect()
      571 ( 0.00%)  {
        .               ImGuiWindow* window = GetCurrentWindow();
    5,712 ( 0.00%)      window->DrawList->PopClipRect();
   79,414 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PopClipRect() (2,285x)
   11,424 ( 0.00%)      window->ClipRect = window->DrawList->_ClipRectStack.back();
    1,142 ( 0.00%)  }
        .           
        .           static ImGuiWindow* FindFrontMostVisibleChildWindow(ImGuiWindow* window)
        .           {
        .               for (int n = window->DC.ChildWindows.Size - 1; n >= 0; n--)
        .                   if (IsWindowActiveAndVisible(window->DC.ChildWindows[n]))
        .                       return FindFrontMostVisibleChildWindow(window->DC.ChildWindows[n]);
        .               return window;
        .           }
-- line 5158 ----------------------------------------
-- line 5212 ----------------------------------------
        .               }
        .               return bottom_most_visible_window;
        .           }
        .           
        .           // Important: AddWindowToDrawData() has not been called yet, meaning DockNodeHost windows needs a DrawList->ChannelsMerge() before usage.
        .           // We call ChannelsMerge() lazily here at it is faster that doing a full iteration of g.Windows[] prior to calling RenderDimmedBackgrounds().
        .           static void ImGui::RenderDimmedBackgrounds()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
    3,997 ( 0.00%)      if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
        .                   return;
        .               const bool dim_bg_for_modal = (modal_window != NULL);
        .               const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
        .               if (!dim_bg_for_modal && !dim_bg_for_window_list)
        .                   return;
        .           
        .               ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
        .               if (dim_bg_for_modal)
-- line 5230 ----------------------------------------
-- line 5269 ----------------------------------------
        .                   ImDrawList* draw_list = GetForegroundDrawList(viewport);
        .                   const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
        .                   draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
        .               }
        .           }
        .           
        .           // This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
        .           void ImGui::EndFrame()
    5,139 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,142 ( 0.00%)      IM_ASSERT(g.Initialized);
        .           
        .               // Don't process EndFrame() multiple times.
    1,713 ( 0.00%)      if (g.FrameCountEnded == g.FrameCount)
        .                   return;
    1,142 ( 0.00%)      IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
        .           
        .               CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
        .           
        .               ErrorCheckEndFrameSanityChecks();
        .           
        .               // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
      571 ( 0.00%)      ImGuiPlatformImeData* ime_data = &g.PlatformImeData;
    3,426 ( 0.00%)      if (g.IO.SetPlatformImeDataFn && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
        .               {
        .                   ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
        .                   IMGUI_DEBUG_LOG_IO("[io] Calling io.SetPlatformImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
        .                   if (viewport == NULL)
        .                       viewport = GetMainViewport();
        .                   g.IO.SetPlatformImeDataFn(viewport, ime_data);
        .               }
        .           
        .               // Hide implicit/fallback "Debug" window if it hasn't been used
      571 ( 0.00%)      g.WithinFrameScopeWithImplicitWindow = false;
    2,855 ( 0.00%)      if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
      571 ( 0.00%)          g.CurrentWindow->Active = false;
      571 ( 0.00%)      End();
  109,632 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::End() (571x)
        .           
        .               // Update navigation: CTRL+Tab, wrap-around requests
        .               NavEndFrame();
        .           
        .               // Update docking
    1,142 ( 0.00%)      DockContextEndFrame(&g);
   23,411 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextEndFrame(ImGuiContext*) (571x)
        .           
        .               SetCurrentViewport(NULL, NULL);
        .           
        .               // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    1,142 ( 0.00%)      if (g.DragDropActive)
        .               {
        .                   bool is_delivered = g.DragDropPayload.Delivery;
      571 ( 0.00%)          bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        .                   if (is_delivered || is_elapsed)
        .                       ClearDragDrop();
        .               }
        .           
        .               // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
        .               if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        .               {
        .                   g.DragDropWithinSource = true;
        .                   SetTooltip("...");
        .                   g.DragDropWithinSource = false;
        .               }
        .           
        .               // End frame
      571 ( 0.00%)      g.WithinFrameScope = false;
      571 ( 0.00%)      g.FrameCountEnded = g.FrameCount;
        .           
        .               // Initiate moving window + handle left-click and right-click focus
      571 ( 0.00%)      UpdateMouseMovingWindowEndFrame();
   13,787 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateMouseMovingWindowEndFrame() (571x)
        .           
        .               // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
        .               UpdateViewportsEndFrame();
        .           
        .               // Sort the window list so that all child windows are after their parent
        .               // We cannot do that on FocusWindow() because children may not exist yet
      571 ( 0.00%)      g.WindowsTempSortBuffer.resize(0);
      571 ( 0.00%)      g.WindowsTempSortBuffer.reserve(g.Windows.Size);
   15,417 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
        .               {
   11,422 ( 0.00%)          if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
        .                       continue;
    4,568 ( 0.00%)          AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
  100,502 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:AddWindowToSortBuffer(ImVector<ImGuiWindow*>*, ImGuiWindow*) (2,284x)
        .               }
        .           
        .               // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    1,713 ( 0.00%)      IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
        .               g.Windows.swap(g.WindowsTempSortBuffer);
    1,142 ( 0.00%)      g.IO.MetricsActiveWindows = g.WindowsActiveCount;
        .           
        .               // Unlock font atlas
    1,142 ( 0.00%)      g.IO.Fonts->Locked = false;
        .           
        .               // Clear Input data for next frame
    1,142 ( 0.00%)      g.IO.MousePosPrev = g.IO.MousePos;
      571 ( 0.00%)      g.IO.AppFocusLost = false;
      571 ( 0.00%)      g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
        .               g.IO.InputQueueCharacters.resize(0);
        .           
        .               CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
    5,139 ( 0.00%)  }
        .           
        .           // Prepare the data for rendering so you can call GetDrawData()
        .           // (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
        .           // it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
        .           void ImGui::Render()
    3,997 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,142 ( 0.00%)      IM_ASSERT(g.Initialized);
        .           
    1,713 ( 0.00%)      if (g.FrameCountEnded != g.FrameCount)
      571 ( 0.00%)          EndFrame();
  377,068 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::EndFrame() (571x)
    1,713 ( 0.00%)      if (g.FrameCountRendered == g.FrameCount)
        .                   return;
      571 ( 0.00%)      g.FrameCountRendered = g.FrameCount;
        .           
      571 ( 0.00%)      g.IO.MetricsRenderWindows = 0;
        .               CallContextHooks(&g, ImGuiContextHookType_RenderPre);
        .           
        .               // Add background ImDrawList (for each active viewport)
    4,009 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
        .               {
        .                   InitViewportDrawData(viewport);
    1,722 ( 0.00%)          if (viewport->BgFgDrawLists[0] != NULL)
        .                       AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
        .               }
        .           
        .               // Draw modal/window whitening backgrounds
        .               RenderDimmedBackgrounds();
        .           
        .               // Add ImDrawList to render
        .               ImGuiWindow* windows_to_render_top_most[2];
    3,426 ( 0.00%)      windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
      571 ( 0.00%)      windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
   15,417 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
        .               {
        .                   IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
   21,688 ( 0.00%)          if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
        .                       AddRootWindowToDrawData(window);
        .               }
    5,139 ( 0.00%)      for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
    3,426 ( 0.00%)          if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
        .                       AddRootWindowToDrawData(windows_to_render_top_most[n]);
        .           
        .               // Draw software mouse cursor if requested by io.MouseDrawCursor flag
    1,142 ( 0.00%)      if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
        .                   RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
        .           
        .               // Setup ImDrawData structures for end-user
      571 ( 0.00%)      g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
    4,009 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
        .               {
        .                   FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);
        .           
        .                   // Add foreground ImDrawList (for each active viewport)
    1,148 ( 0.00%)          if (viewport->BgFgDrawLists[1] != NULL)
        .                       AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
        .           
        .                   // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
        .                   ImDrawData* draw_data = &viewport->DrawDataP;
    1,722 ( 0.00%)          IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
    3,435 ( 0.00%)          for (ImDrawList* draw_list : draw_data->CmdLists)
    1,144 ( 0.00%)              draw_list->_PopUnusedDrawCmd();
   13,146 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_PopUnusedDrawCmd() (572x)
        .           
    1,148 ( 0.00%)          g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
    1,148 ( 0.00%)          g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
        .               }
        .           
        .               CallContextHooks(&g, ImGuiContextHookType_RenderPost);
    4,568 ( 0.00%)  }
        .           
        .           // Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
        .           // CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
        .           ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
   11,422 ( 0.00%)  {
    7,424 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               const char* text_display_end;
   14,848 ( 0.00%)      if (hide_text_after_double_hash)
    7,424 ( 0.00%)          text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
        .               else
        .                   text_display_end = text_end;
        .           
        .               ImFont* font = g.Font;
    7,424 ( 0.00%)      const float font_size = g.FontSize;
   14,848 ( 0.00%)      if (text == text_display_end)
    6,852 ( 0.00%)          return ImVec2(0.0f, font_size);
   31,984 ( 0.00%)      ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
  827,272 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImFont::CalcTextSizeA(float, float, float, char const*, char const*, char const**) const (3,998x)
        .           
        .               // Round
        .               // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
        .               // FIXME: Investigate using ceilf or e.g.
        .               // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
        .               // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
    7,996 ( 0.00%)      text_size.x = IM_TRUNC(text_size.x + 0.99999f);
        .           
   23,988 ( 0.00%)      return text_size;
   18,846 ( 0.00%)  }
        .           
        .           // Find window given position, search front-to-back
        .           // FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
        .           // with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
        .           // called, aka before the next Begin(). Moving window isn't affected.
        .           static void FindHoveredWindow()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
    3,997 ( 0.00%)      ImGuiViewportP* moving_window_viewport = g.MovingWindow ? g.MovingWindow->Viewport : NULL;
        .               if (g.MovingWindow)
        .                   g.MovingWindow->Viewport = g.MouseViewport;
        .           
    1,142 ( 0.00%)      ImGuiWindow* hovered_window = NULL;
        .               ImGuiWindow* hovered_window_ignoring_moving_window = NULL;
        .               if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        .                   hovered_window = g.MovingWindow;
        .           
    1,142 ( 0.00%)      ImVec2 padding_regular = g.Style.TouchExtraPadding;
    2,284 ( 0.00%)      ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
   13,081 ( 0.00%)      for (int i = g.Windows.Size - 1; i >= 0; i--)
        .               {
    2,908 ( 0.00%)          ImGuiWindow* window = g.Windows[i];
        .                   IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
    9,354 ( 0.00%)          if (!window->Active || window->Hidden)
        .                       continue;
    5,301 ( 0.00%)          if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
        .                       continue;
    3,609 ( 0.00%)          IM_ASSERT(window->Viewport);
    2,394 ( 0.00%)          if (window->Viewport != g.MouseViewport)
        .                       continue;
        .           
        .                   // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
    6,342 ( 0.00%)          ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
        .                   if (!window->OuterRectClipped.ContainsWithPad(g.IO.MousePos, hit_padding))
        .                       continue;
        .           
        .                   // Support for one rectangular hole in any given window
        .                   // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
      777 ( 0.00%)          if (window->HitTestHoleSize.x != 0)
        .                   {
        .                       ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
        .                       ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
        .                       if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
        .                           continue;
        .                   }
        .           
      518 ( 0.00%)          if (hovered_window == NULL)
        .                       hovered_window = window;
        .                   IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
      777 ( 0.00%)          if (hovered_window_ignoring_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
        .                       hovered_window_ignoring_moving_window = window;
        .                   if (hovered_window && hovered_window_ignoring_moving_window)
        .                       break;
        .               }
        .           
    1,712 ( 0.00%)      g.HoveredWindow = hovered_window;
        .               g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
        .           
        4 ( 0.00%)      if (g.MovingWindow)
        .                   g.MovingWindow->Viewport = moving_window_viewport;
        .           }
        .           
        .           bool ImGui::IsItemActive()
        .           {
      572 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,716 ( 0.00%)      if (g.ActiveId)
        4 ( 0.00%)          return g.ActiveId == g.LastItemData.ID;
      572 ( 0.00%)      return false;
      572 ( 0.00%)  }
        .           
        .           bool ImGui::IsItemActivated()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.ActiveId)
        .                   if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)
        .                       return true;
        .               return false;
-- line 5544 ----------------------------------------
-- line 5647 ----------------------------------------
        .               if (g.ActiveId == id) // Before we made this obsolete, most calls to SetItemAllowOverlap() used to avoid this path by testing g.ActiveId != id.
        .                   g.ActiveIdAllowOverlap = true;
        .           }
        .           #endif
        .           
        .           // FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version for the two users of this function.
        .           void ImGui::SetActiveIdUsingAllKeyboardKeys()
        .           {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
       12 ( 0.00%)      IM_ASSERT(g.ActiveId != 0);
        4 ( 0.00%)      g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
        4 ( 0.00%)      g.ActiveIdUsingAllKeyboardKeys = true;
        .               NavMoveRequestCancel();
        .           }
        .           
        .           ImGuiID ImGui::GetItemID()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return g.LastItemData.ID;
        .           }
-- line 5666 ----------------------------------------
-- line 5841 ----------------------------------------
        .                       g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
        .               }
        .               g.WithinEndChild = false;
        .               g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
        .           }
        .           
        .           static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
        .           {
       16 ( 0.00%)      window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
        .               window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
        .               window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
        .               window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
        .           }
        .           
        .           ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
        .           {
    2,859 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
        .           }
        .           
        .           ImGuiWindow* ImGui::FindWindowByName(const char* name)
   39,990 ( 0.00%)  {
        .               ImGuiID id = ImHashStr(name);
        .               return FindWindowByID(id);
        4 ( 0.00%)  }
        .           
        .           static void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
        .           {
        .               const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
       12 ( 0.00%)      window->ViewportPos = main_viewport->Pos;
       12 ( 0.00%)      if (settings->ViewportId)
        .               {
        .                   window->ViewportId = settings->ViewportId;
        .                   window->ViewportPos = ImVec2(settings->ViewportPos.x, settings->ViewportPos.y);
        .               }
       32 ( 0.00%)      window->Pos = ImTrunc(ImVec2(settings->Pos.x + window->ViewportPos.x, settings->Pos.y + window->ViewportPos.y));
       20 ( 0.00%)      if (settings->Size.x > 0 && settings->Size.y > 0)
        4 ( 0.00%)          window->Size = window->SizeFull = ImTrunc(ImVec2(settings->Size.x, settings->Size.y));
        8 ( 0.00%)      window->Collapsed = settings->Collapsed;
        8 ( 0.00%)      window->DockId = settings->DockId;
        8 ( 0.00%)      window->DockOrder = settings->DockOrder;
        4 ( 0.00%)  }
        .           
        .           static void UpdateWindowInFocusOrderList(ImGuiWindow* window, bool just_created, ImGuiWindowFlags new_flags)
        .           {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
   11,423 ( 0.00%)      const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
    3,427 ( 0.00%)      const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
   11,412 ( 0.00%)      if ((just_created || child_flag_changed) && !new_is_explicit_child)
        .               {
        .                   IM_ASSERT(!g.WindowsFocusOrder.contains(window));
        .                   g.WindowsFocusOrder.push_back(window);
       10 ( 0.00%)          window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
        .               }
        2 ( 0.00%)      else if (!just_created && child_flag_changed && new_is_explicit_child)
        .               {
        .                   IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
        .                   for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
        .                       g.WindowsFocusOrder[n]->FocusOrder--;
        .                   g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
        .                   window->FocusOrder = -1;
        .               }
    2,856 ( 0.00%)      window->IsExplicitChild = new_is_explicit_child;
        .           }
        .           
        .           static void InitOrLoadWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
        .           {
        .               // Initial window state with e.g. default/arbitrary window position
        .               // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
        .               const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
        6 ( 0.00%)      window->Pos = main_viewport->Pos + ImVec2(60, 60);
       12 ( 0.00%)      window->Size = window->SizeFull = ImVec2(0, 0);
       12 ( 0.00%)      window->ViewportPos = main_viewport->Pos;
       20 ( 0.00%)      window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = window->SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
        .           
       12 ( 0.00%)      if (settings != NULL)
        .               {
        .                   SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
        .                   ApplyWindowSettings(window, settings);
        .               }
       24 ( 0.00%)      window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
        .           
       12 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
        .               {
        .                   window->AutoFitFramesX = window->AutoFitFramesY = 2;
        6 ( 0.00%)          window->AutoFitOnlyGrows = false;
        .               }
        .               else
        .               {
       18 ( 0.00%)          if (window->Size.x <= 0.0f)
        2 ( 0.00%)              window->AutoFitFramesX = 2;
       18 ( 0.00%)          if (window->Size.y <= 0.0f)
        2 ( 0.00%)              window->AutoFitFramesY = 2;
       28 ( 0.00%)          window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
        .               }
        .           }
        .           
        .           static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)
        .           {
        .               // Create window the first time
        .               //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
        .               ImGuiContext& g = *GImGui;
       42 ( 0.00%)      ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
    5,091 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::ImGuiWindow(ImGuiContext*, char const*) (6x)
    2,985 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemAlloc(unsigned long) (6x)
        6 ( 0.00%)      window->Flags = flags;
       24 ( 0.00%)      g.WindowsById.SetVoidPtr(window->ID, window);
      573 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::SetVoidPtr(unsigned int, void*) (6x)
        .           
        6 ( 0.00%)      ImGuiWindowSettings* settings = NULL;
       12 ( 0.00%)      if (!(flags & ImGuiWindowFlags_NoSavedSettings))
       12 ( 0.00%)          if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
        4 ( 0.00%)              window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
        .           
        .               InitOrLoadWindowSettings(window, settings);
        .           
       12 ( 0.00%)      if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        .                   g.Windows.push_front(window); // Quite slow but rare and only once
        .               else
        .                   g.Windows.push_back(window);
        .           
        .               return window;
        .           }
        .           
        .           static ImGuiWindow* GetWindowForTitleDisplay(ImGuiWindow* window)
        .           {
        .               return window->DockNodeAsHost ? window->DockNodeAsHost->VisibleWindow : window;
        .           }
        .           
        .           static ImGuiWindow* GetWindowForTitleAndMenuHeight(ImGuiWindow* window)
        .           {
   43,407 ( 0.00%)      return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
        .           }
        .           
        .           static inline ImVec2 CalcWindowMinSize(ImGuiWindow* window)
        .           {
        .               // We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
        .               // FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
        .               // Perhaps should tend further a neater test for this.
        .               ImGuiContext& g = *GImGui;
        .               ImVec2 size_min;
   34,272 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))
        .               {
   13,704 ( 0.00%)          size_min.x = (window->ChildFlags & ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0f;
   10,278 ( 0.00%)          size_min.y = (window->ChildFlags & ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0f;
        .               }
        .               else
        .               {
   17,140 ( 0.00%)          size_min.x = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0f;
    8,570 ( 0.00%)          size_min.y = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0f;
        .               }
        .           
        .               // Reduce artifacts with very small windows
        .               ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
  117,096 ( 0.00%)      size_min.y = ImMax(size_min.y, window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f));
        .               return size_min;
        .           }
        .           
   17,136 ( 0.00%)  static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)
        .           {
    5,712 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImVec2 new_size = size_desired;
   17,136 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
        .               {
        .                   // See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
        .                   ImRect cr = g.NextWindowData.SizeConstraintRect;
        .                   new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        .                   new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        .                   if (g.NextWindowData.SizeCallback)
        .                   {
        .                       ImGuiSizeCallbackData data;
-- line 6009 ----------------------------------------
-- line 6016 ----------------------------------------
        .                   }
        .                   new_size.x = IM_TRUNC(new_size.x);
        .                   new_size.y = IM_TRUNC(new_size.y);
        .               }
        .           
        .               // Minimum size
        .               ImVec2 size_min = CalcWindowMinSize(window);
        .               return ImMax(new_size, size_min);
   17,136 ( 0.00%)  }
        .           
        .           static void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)
        .           {
        .               bool preserve_old_content_sizes = false;
    5,712 ( 0.00%)      if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        .                   preserve_old_content_sizes = true;
   11,428 ( 0.00%)      else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
        .                   preserve_old_content_sizes = true;
        .               if (preserve_old_content_sizes)
        .               {
        .                   *content_size_current = window->ContentSize;
        .                   *content_size_ideal = window->ContentSizeIdeal;
        .                   return;
        .               }
        .           
   34,272 ( 0.00%)      content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
   34,843 ( 0.00%)      content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
   22,848 ( 0.00%)      content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
   34,272 ( 0.00%)      content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
        .           }
        .           
        .           static ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)
   22,848 ( 0.00%)  {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiStyle& style = g.Style;
   17,136 ( 0.00%)      const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
        .               const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
        .               ImVec2 size_pad = window->WindowPadding * 2.0f;
        .               ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
    8,568 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_Tooltip)
        .               {
        .                   // Tooltip always resize
        .                   return size_desired;
        .               }
        .               else
        .               {
        .                   // Maximum window size is determined by the viewport size or monitor size
        .                   ImVec2 size_min = CalcWindowMinSize(window);
   11,422 ( 0.00%)          ImVec2 size_max = (window->ViewportOwned || ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))) ? ImVec2(FLT_MAX, FLT_MAX) : ImGui::GetMainViewport()->WorkSize - style.DisplaySafeAreaPadding * 2.0f;
    2,856 ( 0.00%)          const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
   13,140 ( 0.00%)          if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0)
        .                       size_max = g.PlatformIO.Monitors[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0f;
        .                   ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, size_max));
        .           
        .                   // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        .                   // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
   22,848 ( 0.00%)          ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
  151,368 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowSizeAfterConstraint(ImGuiWindow*, ImVec2 const&) [clone .isra.0] (2,856x)
   39,973 ( 0.00%)          bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x  && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
   31,416 ( 0.00%)          bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
    5,712 ( 0.00%)          if (will_have_scrollbar_x)
      569 ( 0.00%)              size_auto_fit.y += style.ScrollbarSize;
        .                   if (will_have_scrollbar_y)
      569 ( 0.00%)              size_auto_fit.x += style.ScrollbarSize;
    2,856 ( 0.00%)          return size_auto_fit;
        .               }
   14,280 ( 0.00%)  }
        .           
        .           ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)
        .           {
        .               ImVec2 size_contents_current;
        .               ImVec2 size_contents_ideal;
        .               CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
        .               ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
        .               ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
        .               return size_final;
        .           }
        .           
        .           static ImGuiCol GetWindowBgColorIdx(ImGuiWindow* window)
        .           {
    1,144 ( 0.00%)      if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
      572 ( 0.00%)          return ImGuiCol_PopupBg;
    2,288 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
        .                   return ImGuiCol_ChildBg;
      572 ( 0.00%)      return ImGuiCol_WindowBg;
        .           }
        .           
        .           static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
        .           {
        .               ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
        .               ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
        .               ImVec2 size_expected = pos_max - pos_min;
        .               ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
-- line 6106 ----------------------------------------
-- line 6173 ----------------------------------------
        .               ImGuiID id = window->DockIsActive ? window->DockNode->HostWindow->ID : window->ID;
        .               id = ImHashStr("#RESIZE", 0, id);
        .               id = ImHashData(&n, sizeof(int), id);
        .               return id;
        .           }
        .           
        .           // Handle resize for: Resize Grips, Borders, Gamepad
        .           // Return true when using auto-fit (double-click on resize grip)
   25,135 ( 0.00%)  static int ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_hovered, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)
        .           {
        .               ImGuiContext& g = *GImGui;
    2,285 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
        .           
    9,715 ( 0.00%)      if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
    1,713 ( 0.00%)          return false;
    2,288 ( 0.00%)      if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
        .                   return false;
        .           
        .               int ret_auto_fit_mask = 0x00;
        .               const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
        .               const float grip_hover_inner_size = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75f) : 0.0f;
        .               const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
        .           
        .               ImRect clamp_rect = visibility_rect;
-- line 6196 ----------------------------------------
-- line 6392 ----------------------------------------
        .               if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y || curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)
        .                   MarkIniSettingsDirty(window);
        .           
        .               // Recalculate next expected border expected coordinates
        .               if (*border_held != -1)
        .                   g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
        .           
        .               return ret_auto_fit_mask;
   18,280 ( 0.00%)  }
        .           
        .           static inline void ClampWindowPos(ImGuiWindow* window, const ImRect& visibility_rect)
        .           {
      572 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,146 ( 0.00%)      ImVec2 size_for_clamping = window->Size;
    4,000 ( 0.00%)      if (g.IO.ConfigWindowsMoveFromTitleBarOnly && (!(window->Flags & ImGuiWindowFlags_NoTitleBar) || window->DockNodeAsHost))
        .                   size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
        .               window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
      571 ( 0.00%)  }
        .           
        .           static void RenderWindowOuterSingleBorder(ImGuiWindow* window, int border_n, ImU32 border_col, float border_size)
        .           {
        .               const ImGuiResizeBorderDef& def = resize_border_def[border_n];
        .               const float rounding = window->WindowRounding;
        .               const ImRect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);
        .               window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
        .               window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
        .               window->DrawList->PathStroke(border_col, ImDrawFlags_None, border_size);
        .           }
        .           
        .           static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)
   13,716 ( 0.00%)  {
    2,286 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,572 ( 0.00%)      const float border_size = window->WindowBorderSize;
        .               const ImU32 border_col = GetColorU32(ImGuiCol_Border);
   11,430 ( 0.00%)      if (border_size > 0.0f && (window->Flags & ImGuiWindowFlags_NoBackground) == 0)
    5,720 ( 0.00%)          window->DrawList->AddRect(window->Pos, window->Pos + window->Size, border_col, window->WindowRounding, 0, window->WindowBorderSize);
  378,343 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRect(ImVec2 const&, ImVec2 const&, unsigned int, float, int, float) (572x)
        .               else if (border_size > 0.0f)
        .               {
    1,713 ( 0.00%)          if (window->ChildFlags & ImGuiChildFlags_ResizeX) // Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
        .                       RenderWindowOuterSingleBorder(window, 1, border_col, border_size);
    1,142 ( 0.00%)          if (window->ChildFlags & ImGuiChildFlags_ResizeY)
        .                       RenderWindowOuterSingleBorder(window, 3, border_col, border_size);
        .               }
   16,002 ( 0.00%)      if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1)
        .               {
        .                   const int border_n = (window->ResizeBorderHeld != -1) ? window->ResizeBorderHeld : window->ResizeBorderHovered;
        .                   const ImU32 border_col_resizing = GetColorU32((window->ResizeBorderHeld != -1) ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
        .                   RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0f, window->WindowBorderSize)); // Thicker than usual
        .               }
    9,144 ( 0.00%)      if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
        .               {
        .                   float y = window->Pos.y + window->TitleBarHeight() - 1;
        .                   window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), border_col, g.Style.FrameBorderSize);
        .               }
   11,430 ( 0.00%)  }
        .           
        .           // Draw background and borders
        .           // Draw and handle scrollbars
        .           void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)
   28,550 ( 0.00%)  {
    2,855 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiStyle& style = g.Style;
    2,855 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
        .           
        .               // Ensure that ScrollBar doesn't read last frame's SkipItems
    5,710 ( 0.00%)      IM_ASSERT(window->BeginCount == 0);
    2,855 ( 0.00%)      window->SkipItems = false;
        .           
        .               // Draw window + handle manual resize
        .               // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
    5,710 ( 0.00%)      const float window_rounding = window->WindowRounding;
    5,710 ( 0.00%)      const float window_border_size = window->WindowBorderSize;
   14,275 ( 0.00%)      if (window->Collapsed)
        .               {
        .                   // Title bar only
        .                   const float backup_border_size = style.FrameBorderSize;
        .                   g.Style.FrameBorderSize = window->WindowBorderSize;
        .                   ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
        .                   if (window->ViewportOwned)
        .                       title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
        .                   RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
        .                   g.Style.FrameBorderSize = backup_border_size;
        .               }
        .               else
        .               {
        .                   // Window background
   11,420 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoBackground))
        .                   {
        .                       bool is_docking_transparent_payload = false;
    1,716 ( 0.00%)              if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
        .                           if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
        .                               is_docking_transparent_payload = true;
        .           
    2,288 ( 0.00%)              ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
   28,028 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (572x)
    1,716 ( 0.00%)              if (window->ViewportOwned)
        .                       {
        1 ( 0.00%)                  bg_col |= IM_COL32_A_MASK; // No alpha
        2 ( 0.00%)                  if (is_docking_transparent_payload)
        .                               window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
        .                       }
        .                       else
        .                       {
        .                           // Adjust alpha. For docking
        .                           bool override_alpha = false;
        .                           float alpha = 1.0f;
    1,142 ( 0.00%)                  if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
        .                           {
        .                               alpha = g.NextWindowData.BgAlphaVal;
        .                               override_alpha = true;
        .                           }
    1,142 ( 0.00%)                  if (is_docking_transparent_payload)
        .                           {
        .                               alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
        .                               override_alpha = true;
        .                           }
        .                           if (override_alpha)
        .                               bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
        .                       }
        .           
        .                       // Render, for docked windows and host windows we ensure bg goes before decorations
    1,144 ( 0.00%)              if (window->DockIsActive)
        .                           window->DockNode->LastBgColor = bg_col;
      572 ( 0.00%)              ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
    1,716 ( 0.00%)              if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
        .                           bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
   16,573 ( 0.00%)              bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
   66,118 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (572x)
    2,860 ( 0.00%)              if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
        .                           bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
        .                   }
    4,566 ( 0.00%)          if (window->DockIsActive)
    1,140 ( 0.00%)              window->DockNode->IsBgDrawnThisFrame = true;
        .           
        .                   // Title bar
        .                   // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
        .                   // in order for their pos/size to be matching their undocking state.)
    6,855 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
        .                   {
    2,860 ( 0.00%)              ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
   28,028 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::GetColorU32(int, float) (572x)
    2,288 ( 0.00%)              if (window->ViewportOwned)
        .                           title_bar_col |= IM_COL32_A_MASK; // No alpha
    3,432 ( 0.00%)              window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
   66,208 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (572x)
        .                   }
        .           
        .                   // Menu bar
   11,423 ( 0.00%)          if (flags & ImGuiWindowFlags_MenuBar)
        .                   {
        .                       ImRect menu_bar_rect = window->MenuBarRect();
        .                       menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
   10,849 ( 0.00%)              window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
   65,834 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (571x)
    2,284 ( 0.00%)              if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
        .                           window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
        .                   }
        .           
        .                   // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
        .                   ImGuiDockNode* node = window->DockNode;
    3,426 ( 0.00%)          if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
        .                   {
        .                       float unhide_sz_draw = ImTrunc(g.FontSize * 0.70f);
        .                       float unhide_sz_hit = ImTrunc(g.FontSize * 0.55f);
        .                       ImVec2 p = node->Pos;
        .                       ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
        .                       ImGuiID unhide_id = window->GetID("#UNHIDE");
        .                       KeepAliveID(unhide_id);
        .                       bool hovered, held;
-- line 6555 ----------------------------------------
-- line 6559 ----------------------------------------
        .                           StartMouseMovingWindowOrNode(window, node, true); // Undock from tab-bar triangle = same as window/collapse menu button
        .           
        .                       // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
        .                       ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
        .                       window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
        .                   }
        .           
        .                   // Scrollbars
    5,710 ( 0.00%)          if (window->ScrollbarX)
        .                       Scrollbar(ImGuiAxis_X);
    5,710 ( 0.00%)          if (window->ScrollbarY)
        .                       Scrollbar(ImGuiAxis_Y);
        .           
        .                   // Render resize grips (after their input handling so we don't have a frame of latency)
   10,280 ( 0.00%)          if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
        .                   {
    2,860 ( 0.00%)              for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
        .                       {
    4,576 ( 0.00%)                  const ImU32 col = resize_grip_col[resize_grip_n];
    3,432 ( 0.00%)                  if ((col & IM_COL32_A_MASK) == 0)
        .                               continue;
        .                           const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
        .                           const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
        .                           window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
        .                           window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
        .                           window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
        .                           window->DrawList->PathFillConvex(col);
        .                       }
        .                   }
        .           
        .                   // Borders (for dock node host they will be rendered over after the tab bar)
    4,570 ( 0.00%)          if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
    3,430 ( 0.00%)              RenderWindowOuterBorders(window);
  514,400 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowOuterBorders(ImGuiWindow*) (1,715x)
        .               }
   21,125 ( 0.00%)  }
        .           
        .           // When inside a dock node, this is handled in DockNodeCalcTabBarLayout() instead.
        .           // Render title text, collapse button, close button
        .           void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)
        .           {
      572 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiStyle& style = g.Style;
      572 ( 0.00%)      ImGuiWindowFlags flags = window->Flags;
        .           
        .               const bool has_close_button = (p_open != NULL);
    1,716 ( 0.00%)      const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
        .           
        .               // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
        .               // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
      572 ( 0.00%)      const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
    1,716 ( 0.00%)      g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
      572 ( 0.00%)      window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
        .           
        .               // Layout buttons
        .               // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
      572 ( 0.00%)      float pad_l = style.FramePadding.x;
    1,142 ( 0.00%)      float pad_r = style.FramePadding.x;
      572 ( 0.00%)      float button_sz = g.FontSize;
      572 ( 0.00%)      ImVec2 close_button_pos;
      572 ( 0.00%)      ImVec2 collapse_button_pos;
    1,144 ( 0.00%)      if (has_close_button)
        .               {
        5 ( 0.00%)          close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
        2 ( 0.00%)          pad_r += button_sz + style.ItemInnerSpacing.x;
        .               }
    2,288 ( 0.00%)      if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
        .               {
        .                   collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
        .                   pad_r += button_sz + style.ItemInnerSpacing.x;
        .               }
    1,144 ( 0.00%)      if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
        .               {
    2,860 ( 0.00%)          collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);
    1,144 ( 0.00%)          pad_l += button_sz + style.ItemInnerSpacing.x;
        .               }
        .           
        .               // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
        .               if (has_collapse_button)
   10,868 ( 0.00%)          if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
  485,461 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGui::CollapseButton(unsigned int, ImVec2 const&, ImGuiDockNode*) (572x)
   83,512 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) [clone .constprop.0] (572x)
        .                       window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
        .           
        .               // Close button
    1,144 ( 0.00%)      if (has_close_button)
       18 ( 0.00%)          if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
      107 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiWindow::GetID(char const*, char const*) [clone .constprop.0] (1x)
    1,678 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGui::CloseButton(unsigned int, ImVec2 const&) (1x)
        .                       *p_open = false;
        .           
      572 ( 0.00%)      window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
      572 ( 0.00%)      g.CurrentItemFlags = item_flags_backup;
        .           
        .               // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
        .               // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
    1,716 ( 0.00%)      const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
    5,720 ( 0.00%)      const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
  130,287 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CalcTextSize(char const*, char const*, bool, float) (572x)
        .           
        .               // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
        .               // while uncentered title text will still reach edges correctly.
    4,004 ( 0.00%)      if (pad_l > style.FramePadding.x)
    1,144 ( 0.00%)          pad_l += g.Style.ItemInnerSpacing.x;
    1,144 ( 0.00%)      if (pad_r > style.FramePadding.x)
        1 ( 0.00%)          pad_r += g.Style.ItemInnerSpacing.x;
    2,288 ( 0.00%)      if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
        .               {
        .                   float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
        .                   float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
        .                   pad_l = ImMax(pad_l, pad_extend * centerness);
        .                   pad_r = ImMax(pad_r, pad_extend * centerness);
        .               }
        .           
    1,144 ( 0.00%)      ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
    1,144 ( 0.00%)      ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
    1,144 ( 0.00%)      if (flags & ImGuiWindowFlags_UnsavedDocument)
        .               {
        .                   ImVec2 marker_pos;
        .                   marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
        .                   marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
        .                   if (marker_pos.x > layout_r.Min.x)
        .                   {
        .                       RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
        .                       clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
        .                   }
        .               }
        .               //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
        .               //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
      572 ( 0.00%)      RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
        .           }
        .           
        .           void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
        .           {
    2,857 ( 0.00%)      window->ParentWindow = parent_window;
   11,428 ( 0.00%)      window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
   10,286 ( 0.00%)      if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        .               {
    2,286 ( 0.00%)          window->RootWindowDockTree = parent_window->RootWindowDockTree;
    3,430 ( 0.00%)          if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
    1,142 ( 0.00%)              window->RootWindow = parent_window->RootWindow;
        .               }
    2,857 ( 0.00%)      if (parent_window && (flags & ImGuiWindowFlags_Popup))
        .                   window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
    6,858 ( 0.00%)      if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
    3,429 ( 0.00%)          window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
   14,285 ( 0.00%)      while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
        .               {
        .                   IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
        .                   window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
        .               }
        .           }
        .           
        .           // [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
        .           // This is designed as a toy/test-bed for
        .           void ImGui::UpdateWindowSkipRefresh(ImGuiWindow* window)
        .           {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,856 ( 0.00%)      window->SkipRefresh = false;
    5,712 ( 0.00%)      if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0)
        .                   return;
        .               if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh)
        .               {
        .                   // FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
        .                   if (window->Appearing) // If currently appearing
        .                       return;
        .                   if (window->Hidden) // If was hidden (previous frame)
        .                       return;
        .                   if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow && window->RootWindow == g.HoveredWindow->RootWindow)
        .                       return;
        .                   if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow && window->RootWindow == g.NavWindow->RootWindow)
        .                       return;
        .                   window->DrawList = NULL;
        .                   window->SkipRefresh = true;
        .               }
    2,856 ( 0.00%)  }
        .           
        .           // When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
        .           // should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
        .           // In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
        .           // - WindowA            // FindBlockingModal() returns Modal1
        .           //   - WindowB          //                  .. returns Modal1
        .           //   - Modal1           //                  .. returns Modal2
        .           //      - WindowC       //                  .. returns Modal2
-- line 6736 ----------------------------------------
-- line 6737 ----------------------------------------
        .           //          - WindowD   //                  .. returns Modal2
        .           //          - Modal2    //                  .. returns Modal2
        .           //            - WindowE //                  .. returns NULL
        .           // Notes:
        .           // - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
        .           //   Only difference is here we check for ->Active/WasActive but it may be unecessary.
        .           ImGuiWindow* ImGui::FindBlockingModal(ImGuiWindow* window)
        .           {
        5 ( 0.00%)      ImGuiContext& g = *GImGui;
       15 ( 0.00%)      if (g.OpenPopupStack.Size <= 0)
        5 ( 0.00%)          return NULL;
        .           
        .               // Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
        .               for (ImGuiPopupData& popup_data : g.OpenPopupStack)
        .               {
        .                   ImGuiWindow* popup_window = popup_data.Window;
        .                   if (popup_window == NULL || !(popup_window->Flags & ImGuiWindowFlags_Modal))
        .                       continue;
        .                   if (!popup_window->Active && !popup_window->WasActive)      // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
-- line 6755 ----------------------------------------
-- line 6756 ----------------------------------------
        .                       continue;
        .                   if (window == NULL)                                         // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
        .                       return popup_window;
        .                   if (IsWindowWithinBeginStackOf(window, popup_window))       // Window may be over modal
        .                       continue;
        .                   return popup_window;                                        // Place window right below first block modal
        .               }
        .               return NULL;
       10 ( 0.00%)  }
        .           
        .           // Push a new Dear ImGui window to add widgets to.
        .           // - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
        .           // - Begin/End can be called multiple times during the frame with the same window name to append content.
        .           // - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
        .           //   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
        .           // - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
        .           // - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
        .           bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
   39,984 ( 0.00%)  {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               const ImGuiStyle& style = g.Style;
   11,424 ( 0.00%)      IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
   11,424 ( 0.00%)      IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
   11,424 ( 0.00%)      IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
        .           
        .               // Find or create
    8,568 ( 0.00%)      ImGuiWindow* window = FindWindowByName(name);
  723,123 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowByName(char const*) (2,856x)
    5,712 ( 0.00%)      const bool window_just_created = (window == NULL);
    2,856 ( 0.00%)      if (window_just_created)
        .                   window = CreateNewWindow(name, flags);
        .           
        .               // [DEBUG] Debug break requested by user
    8,568 ( 0.00%)      if (g.DebugBreakInWindow == window->ID)
        .                   IM_DEBUG_BREAK();
        .           
        .               // Automatically disable manual moving/resizing when NoInputs is set
        .               if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
   17,136 ( 0.00%)          flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
        .           
    5,712 ( 0.00%)      if (flags & ImGuiWindowFlags_NavFlattened)
        .                   IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
        .           
    5,712 ( 0.00%)      const int current_frame = g.FrameCount;
    5,712 ( 0.00%)      const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
   15,422 ( 0.00%)      window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
        .           
        .               // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
   11,424 ( 0.00%)      bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    5,712 ( 0.00%)      if (flags & ImGuiWindowFlags_Popup)
        .               {
        .                   ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        .                   window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        .                   window_just_activated_by_user |= (window != popup_ref.Window);
        .               }
        .           
        .               // Update Flags, LastFrameActive, BeginOrderXXX fields
    2,856 ( 0.00%)      const bool window_was_appearing = window->Appearing;
    8,568 ( 0.00%)      if (first_begin_of_the_frame)
        .               {
        .                   UpdateWindowInFocusOrderList(window, window_just_created, flags);
    5,712 ( 0.00%)          window->Appearing = window_just_activated_by_user;
    5,712 ( 0.00%)          if (window->Appearing)
        .                       SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
        .                   window->FlagsPreviousFrame = window->Flags;
    8,568 ( 0.00%)          window->Flags = (ImGuiWindowFlags)flags;
   11,424 ( 0.00%)          window->ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0;
    5,712 ( 0.00%)          window->LastFrameActive = current_frame;
    8,568 ( 0.00%)          window->LastTimeActive = (float)g.Time;
    2,856 ( 0.00%)          window->BeginOrderWithinParent = 0;
   14,280 ( 0.00%)          window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
        .               }
        .               else
        .               {
        .                   flags = window->Flags;
        .               }
        .           
        .               // Docking
        .               // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
    6,852 ( 0.00%)      IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
    5,712 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
        .                   SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
    8,568 ( 0.00%)      if (first_begin_of_the_frame)
        .               {
   13,138 ( 0.00%)          bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
        .                   bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
    2,284 ( 0.00%)          bool dock_node_was_visible = window->DockNodeIsVisible;
    1,142 ( 0.00%)          bool dock_tab_was_visible = window->DockTabIsVisible;
      571 ( 0.00%)          if (has_dock_node || new_auto_dock_node)
        .                   {
    1,713 ( 0.00%)              BeginDocked(window, p_open);
  287,938 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BeginDocked(ImGuiWindow*, bool*) (571x)
      571 ( 0.00%)              flags = window->Flags;
    2,284 ( 0.00%)              if (window->DockIsActive)
        .                       {
    1,142 ( 0.00%)                  IM_ASSERT(window->DockNode != NULL);
      571 ( 0.00%)                  g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
        .                       }
        .           
        .                       // Amend the Appearing flag
    2,859 ( 0.00%)              if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
        .                       {
        .                           window->Appearing = true;
        .                           SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
        .                       }
        .                   }
        .                   else
        .                   {
    2,285 ( 0.00%)              window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
        .                   }
        .               }
        .           
        .               // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
   15,994 ( 0.00%)      ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
   13,138 ( 0.00%)      ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    4,570 ( 0.00%)      IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
        .           
        .               // We allow window memory to be compacted so recreate the base stack when needed.
    8,568 ( 0.00%)      if (window->IDStack.Size == 0)
        .                   window->IDStack.push_back(window->ID);
        .           
        .               // Add to stack
    2,856 ( 0.00%)      g.CurrentWindow = window;
        .               ImGuiWindowStackData window_stack_data;
    2,856 ( 0.00%)      window_stack_data.Window = window;
   17,136 ( 0.00%)      window_stack_data.ParentLastItemDataBackup = g.LastItemData;
        .               window_stack_data.StackSizesOnBegin.SetToContextState(&g);
        .               g.CurrentWindowStack.push_back(window_stack_data);
    5,712 ( 0.00%)      if (flags & ImGuiWindowFlags_ChildMenu)
        .                   g.BeginMenuDepth++;
        .           
        .               // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
    8,568 ( 0.00%)      if (first_begin_of_the_frame)
        .               {
   14,280 ( 0.00%)          UpdateWindowParentAndRootLinks(window, flags, parent_window);
   58,825 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow*, int, ImGuiWindow*) (2,856x)
    5,712 ( 0.00%)          window->ParentWindowInBeginStack = parent_window_in_stack;
        .           
        .                   // Focus route
        .                   // There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
        .                   // Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
    8,568 ( 0.00%)          window->ParentWindowForFocusRoute = (window->RootWindow != window) ? parent_window_in_stack : NULL;
    7,997 ( 0.00%)          if (window->ParentWindowForFocusRoute == NULL && window->DockNode != NULL)
    1,142 ( 0.00%)              if (window->DockNode->MergedFlags & ImGuiDockNodeFlags_DockedWindowsInFocusRoute)
        .                           window->ParentWindowForFocusRoute = window->DockNode->HostWindow;
        .           
        .                   // Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
    8,568 ( 0.00%)          if (window->WindowClass.FocusRouteParentWindowId != 0)
        .                   {
        .                       window->ParentWindowForFocusRoute = FindWindowByID(window->WindowClass.FocusRouteParentWindowId);
        .                       IM_ASSERT(window->ParentWindowForFocusRoute != 0); // Invalid value for FocusRouteParentWindowId.
        .                   }
        .               }
        .           
        .               // Add to focus scope stack
   11,424 ( 0.00%)      PushFocusScope((flags & ImGuiWindowFlags_NavFlattened) ? g.CurrentFocusScopeId : window->ID);
    5,712 ( 0.00%)      window->NavRootFocusScopeId = g.CurrentFocusScopeId;
        .           
        .               // Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
    5,712 ( 0.00%)      if (flags & ImGuiWindowFlags_Popup)
        .               {
        .                   ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        .                   popup_ref.Window = window;
        .                   popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
        .                   g.BeginPopupStack.push_back(popup_ref);
        .                   window->PopupId = popup_ref.PopupId;
        .               }
        .           
        .               // Process SetNextWindow***() calls
        .               // (FIXME: Consider splitting the HasXXX flags into X/Y components
    2,856 ( 0.00%)      bool window_pos_set_by_api = false;
    1,147 ( 0.00%)      bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    8,568 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
        .               {
   11,420 ( 0.00%)          window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
    9,136 ( 0.00%)          if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        .                   {
        .                       // May be processed on the next frame if this is our first frame and we are measuring size
        .                       // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
        .                       window->SetWindowPosVal = g.NextWindowData.PosVal;
        .                       window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
        .                       window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        .                   }
        .                   else
        .                   {
    9,136 ( 0.00%)              SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
  121,058 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetWindowPos(ImGuiWindow*, ImVec2 const&, int) (2,284x)
        .                   }
        .               }
    7,996 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
        .               {
   23,982 ( 0.00%)          window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
    7,994 ( 0.00%)          window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
    8,565 ( 0.00%)          if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0) // Axis-specific conditions for BeginChild()
        .                       g.NextWindowData.SizeVal.x = window->SizeFull.x;
   11,420 ( 0.00%)          if ((window->ChildFlags & ImGuiChildFlags_ResizeY) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0)
        .                       g.NextWindowData.SizeVal.y = window->SizeFull.y;
    8,565 ( 0.00%)          SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
  110,223 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetWindowSize(ImGuiWindow*, ImVec2 const&, int) (2,855x)
        .               }
    8,567 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
        .               {
        .                   if (g.NextWindowData.ScrollVal.x >= 0.0f)
        .                   {
        .                       window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
        .                       window->ScrollTargetCenterRatio.x = 0.0f;
        .                   }
        .                   if (g.NextWindowData.ScrollVal.y >= 0.0f)
        .                   {
        .                       window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
        .                       window->ScrollTargetCenterRatio.y = 0.0f;
        .                   }
        .               }
    5,712 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
        .                   window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
    8,568 ( 0.00%)      else if (first_begin_of_the_frame)
    5,712 ( 0.00%)          window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
    5,712 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
        .                   window->WindowClass = g.NextWindowData.WindowClass;
    5,712 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
        .                   SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    5,712 ( 0.00%)      if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
        .                   FocusWindow(window);
    5,712 ( 0.00%)      if (window->Appearing)
        .                   SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
        .           
        .               // [EXPERIMENTAL] Skip Refresh mode
    5,712 ( 0.00%)      UpdateWindowSkipRefresh(window);
   14,280 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowSkipRefresh(ImGuiWindow*) (2,856x)
        .           
        .               // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    2,856 ( 0.00%)      g.CurrentWindow = NULL;
        .           
        .               // When reusing window again multiple times a frame, just append content (don't need to setup again)
   17,136 ( 0.00%)      if (first_begin_of_the_frame && !window->SkipRefresh)
        .               {
        .                   // Initialize
    2,856 ( 0.00%)          const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
    5,712 ( 0.00%)          const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
    5,712 ( 0.00%)          window->Active = true;
    8,568 ( 0.00%)          window->HasCloseButton = (p_open != NULL);
    5,712 ( 0.00%)          window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
        .                   window->IDStack.resize(1);
    5,712 ( 0.00%)          window->DrawList->_ResetForNewFrame();
  190,081 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::_ResetForNewFrame() (2,856x)
    2,856 ( 0.00%)          window->DC.CurrentTableIdx = -1;
    5,712 ( 0.00%)          if (flags & ImGuiWindowFlags_DockNodeHost)
        .                   {
      571 ( 0.00%)              window->DrawList->ChannelsSplit(2);
      571 ( 0.00%)              window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
        .                   }
        .           
        .                   // Restore buffer capacity when woken from a compacted state, to avoid
    5,712 ( 0.00%)          if (window->MemoryCompacted)
        .                       GcAwakeTransientWindowBuffers(window);
        .           
        .                   // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        .                   // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
        .                   bool window_title_visible_elsewhere = false;
   19,980 ( 0.00%)          if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
        .                       window_title_visible_elsewhere = true;
    6,855 ( 0.00%)          else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
        .                       window_title_visible_elsewhere = true;
    6,274 ( 0.00%)          if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
   11,400 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 (570x)
        .                   {
        .                       size_t buf_len = (size_t)window->NameBufLen;
        .                       window->Name = ImStrdupcpy(window->Name, &buf_len, name);
        .                       window->NameBufLen = (int)buf_len;
        .                   }
        .           
        .                   // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
        .           
        .                   // Update contents size from last frame for auto-fitting (or use explicit size)
    5,712 ( 0.00%)          CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
        .           
        .                   // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
        .                   // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
        .                   // it has a single usage before this code block and may be set below before it is finally checked.
    5,712 ( 0.00%)          if (window->HiddenFramesCanSkipItems > 0)
        .                       window->HiddenFramesCanSkipItems--;
    5,712 ( 0.00%)          if (window->HiddenFramesCannotSkipItems > 0)
        4 ( 0.00%)              window->HiddenFramesCannotSkipItems--;
    8,568 ( 0.00%)          if (window->HiddenFramesForRenderOnly > 0)
        .                       window->HiddenFramesForRenderOnly--;
        .           
        .                   // Hide new windows for one frame until they calculate their size
    5,732 ( 0.00%)          if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
        4 ( 0.00%)              window->HiddenFramesCannotSkipItems = 1;
        .           
        .                   // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        .                   // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
    5,724 ( 0.00%)          if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        .                   {
        .                       window->HiddenFramesCannotSkipItems = 1;
        .                       if (flags & ImGuiWindowFlags_AlwaysAutoResize)
        .                       {
        .                           if (!window_size_x_set_by_api)
        .                               window->Size.x = window->SizeFull.x = 0.f;
        .                           if (!window_size_y_set_by_api)
        .                               window->Size.y = window->SizeFull.y = 0.f;
-- line 7048 ----------------------------------------
-- line 7050 ----------------------------------------
        .                       }
        .                   }
        .           
        .                   // SELECT VIEWPORT
        .                   // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
        .           
        .                   WindowSelectViewport(window);
        .                   SetCurrentViewport(window, window->Viewport);
   11,424 ( 0.00%)          window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
    5,712 ( 0.00%)          SetCurrentWindow(window);
   65,688 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetCurrentWindow(ImGuiWindow*) (2,856x)
    2,856 ( 0.00%)          flags = window->Flags;
        .           
        .                   // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
        .                   // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
        .           
   13,138 ( 0.00%)          if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow))
      571 ( 0.00%)              window->WindowBorderSize = style.ChildBorderSize;
        .                   else
    9,711 ( 0.00%)              window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
    5,712 ( 0.00%)          window->WindowPadding = style.WindowPadding;
    7,995 ( 0.00%)          if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !(window->ChildFlags & ImGuiChildFlags_AlwaysUseWindowPadding) && window->WindowBorderSize == 0.0f)
    9,709 ( 0.00%)              window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        .           
        .                   // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
   18,850 ( 0.00%)          window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
    5,712 ( 0.00%)          window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
        .           
        .                   // Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
        .                   // Those flags will be altered further down in the function depending on more conditions.
    8,568 ( 0.00%)          bool use_current_size_for_scrollbar_x = window_just_created;
    5,712 ( 0.00%)          bool use_current_size_for_scrollbar_y = window_just_created;
   24,556 ( 0.00%)          if (window_size_x_set_by_api && window->ContentSizeExplicit.x != 0.0f)
        .                       use_current_size_for_scrollbar_x = true;
   21,700 ( 0.00%)          if (window_size_y_set_by_api && window->ContentSizeExplicit.y != 0.0f) // #7252
        .                       use_current_size_for_scrollbar_y = true;
        .           
        .                   // Collapse window by double-clicking on title bar
        .                   // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
    6,856 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
        .                   {
        .                       // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
    2,288 ( 0.00%)              ImRect title_bar_rect = window->TitleBarRect();
    1,144 ( 0.00%)              if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max))
        .                           if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey_MouseLeft) == ImGuiKeyOwner_None)
        .                               window->WantCollapseToggle = true;
    1,144 ( 0.00%)              if (window->WantCollapseToggle)
        .                       {
        .                           window->Collapsed = !window->Collapsed;
        .                           if (!window->Collapsed)
        .                               use_current_size_for_scrollbar_y = true;
        .                           MarkIniSettingsDirty(window);
        .                       }
        .                   }
        .                   else
        .                   {
    2,284 ( 0.00%)              window->Collapsed = false;
        .                   }
      572 ( 0.00%)          window->WantCollapseToggle = false;
        .           
        .                   // SIZE
        .           
        .                   // Outer Decoration Sizes
        .                   // (we need to clear ScrollbarSize immediatly as CalcWindowAutoFitSize() needs it and can be called from other locations).
   11,424 ( 0.00%)          const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
    2,856 ( 0.00%)          window->DecoOuterSizeX1 = 0.0f;
    2,856 ( 0.00%)          window->DecoOuterSizeX2 = 0.0f;
    5,712 ( 0.00%)          window->DecoOuterSizeY1 = window->TitleBarHeight() + window->MenuBarHeight();
    2,856 ( 0.00%)          window->DecoOuterSizeY2 = 0.0f;
    2,856 ( 0.00%)          window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
        .           
        .                   // Calculate auto-fit size, handle automatic resize
   11,424 ( 0.00%)          const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
  525,488 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowAutoFitSize(ImGuiWindow*, ImVec2 const&) (2,856x)
    5,712 ( 0.00%)          if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        .                   {
        .                       // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
        .                       if (!window_size_x_set_by_api)
        .                       {
        .                           window->SizeFull.x = size_auto_fit.x;
        .                           use_current_size_for_scrollbar_x = true;
        .                       }
        .                       if (!window_size_y_set_by_api)
        .                       {
        .                           window->SizeFull.y = size_auto_fit.y;
        .                           use_current_size_for_scrollbar_y = true;
        .                       }
        .                   }
   11,424 ( 0.00%)          else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        .                   {
        .                       // Auto-fit may only grow window during the first few frames
        .                       // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
        .                       if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
        .                       {
        .                           window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
        .                           use_current_size_for_scrollbar_x = true;
        .                       }
-- line 7144 ----------------------------------------
-- line 7147 ----------------------------------------
        .                           window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
        .                           use_current_size_for_scrollbar_y = true;
        .                       }
        .                       if (!window->Collapsed)
        .                           MarkIniSettingsDirty(window);
        .                   }
        .           
        .                   // Apply minimum/maximum window size constraints and final size
    8,568 ( 0.00%)          window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
  151,368 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcWindowSizeAfterConstraint(ImGuiWindow*, ImVec2 const&) [clone .isra.0] (2,856x)
   11,424 ( 0.00%)          window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
        .           
        .                   // POSITION
        .           
        .                   // Popup latch its initial position, will position itself when it appears next frame
    5,712 ( 0.00%)          if (window_just_activated_by_user)
        .                   {
        6 ( 0.00%)              window->AutoPosLastDirection = ImGuiDir_None;
       24 ( 0.00%)              if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
        .                           window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        .                   }
        .           
        .                   // Position child window
    5,712 ( 0.00%)          if (flags & ImGuiWindowFlags_ChildWindow)
        .                   {
    6,852 ( 0.00%)              IM_ASSERT(parent_window && parent_window->Active);
    2,284 ( 0.00%)              window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
        .                       parent_window->DC.ChildWindows.push_back(window);
   13,706 ( 0.00%)              if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
        .                           window->Pos = parent_window->DC.CursorPos;
        .                   }
        .           
   11,424 ( 0.00%)          const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
        .                   if (window_pos_with_pivot)
        .                       SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
    5,712 ( 0.00%)          else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
    4,568 ( 0.00%)              window->Pos = FindBestWindowPosForPopup(window);
   11,998 ( 0.00%)          else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
        .                       window->Pos = FindBestWindowPosForPopup(window);
    3,428 ( 0.00%)          else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
        .                       window->Pos = FindBestWindowPosForPopup(window);
        .           
        .                   // Late create viewport if we don't fit within our current host viewport.
   15,426 ( 0.00%)          if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_IsMinimized))
        .                       if (!window->Viewport->GetMainRect().Contains(window->Rect()))
        .                       {
        .                           // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
        .                           //ImGuiViewport* old_viewport = window->Viewport;
        .                           window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
        .           
        .                           // FIXME-DPI
        .                           //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
        .                           SetCurrentViewport(window, window->Viewport);
        .                           window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
        .                           SetCurrentWindow(window);
        .                       }
        .           
    5,139 ( 0.00%)          if (window->ViewportOwned)
        .                       WindowSyncOwnedViewport(window, parent_window_in_stack);
        .           
        .                   // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
        .                   // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
        .                   ImRect viewport_rect(window->Viewport->GetMainRect());
        .                   ImRect viewport_work_rect(window->Viewport->GetWorkRect());
        .                   ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
        .                   ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
        .           
        .                   // Clamp position/size so window stays visible within its viewport or monitor
        .                   // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        .                   // FIXME: Similar to code in GetWindowAllowedExtentRect()
    5,712 ( 0.00%)          if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
        .                   {
    4,571 ( 0.00%)              if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
        .                       {
        .                           ClampWindowPos(window, visibility_rect);
        .                       }
        3 ( 0.00%)              else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
        .                       {
        3 ( 0.00%)                  if (g.MovingWindow != NULL && window->RootWindowDockTree == g.MovingWindow->RootWindowDockTree)
        .                           {
        .                               // While moving windows we allow them to straddle monitors (#7299, #3071)
        .                               visibility_rect = g.PlatformMonitorsFullWorkRect;
        .                           }
        .                           else
        .                           {
        .                               // When not moving ensure visible in its monitor
        .                               // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
-- line 7232 ----------------------------------------
-- line 7236 ----------------------------------------
        .                           visibility_rect.Expand(-visibility_padding);
        .                           ClampWindowPos(window, visibility_rect);
        .                       }
        .                   }
        .                   window->Pos = ImTrunc(window->Pos);
        .           
        .                   // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        .                   // Large values tend to lead to variety of artifacts and are not recommended.
   10,850 ( 0.00%)          if (window->ViewportOwned || window->DockIsActive)
    4,572 ( 0.00%)              window->WindowRounding = 0.0f;
        .                   else
   17,701 ( 0.00%)              window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
        .           
        .                   // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
        .                   //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
        .                   //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
        .           
        .                   // Apply window focus (new and reactivated windows are moved to front)
    2,850 ( 0.00%)          bool want_focus = false;
    8,580 ( 0.00%)          if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
        .                   {
       24 ( 0.00%)              if (flags & ImGuiWindowFlags_Popup)
        .                           want_focus = true;
    6,926 ( 0.00%)              else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
        .                           want_focus = true;
        .                   }
        .           
        .                   // [Test Engine] Register whole window in the item system (before submitting further decorations)
        .           #ifdef IMGUI_ENABLE_TEST_ENGINE
        .                   if (g.TestEngineHookItems)
        .                   {
        .                       IM_ASSERT(window->IDStack.Size == 1);
-- line 7267 ----------------------------------------
-- line 7268 ----------------------------------------
        .                       window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
        .                       IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
        .                       IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
        .                       window->IDStack.Size = 1;
        .                   }
        .           #endif
        .           
        .                   // Decide if we are going to handle borders and resize grips
   10,286 ( 0.00%)          const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
        .           
        .                   // Handle manual resize: Resize Grips, Borders, Gamepad
    5,712 ( 0.00%)          int border_hovered = -1, border_held = -1;
    5,712 ( 0.00%)          ImU32 resize_grip_col[4] = {};
   13,710 ( 0.00%)          const int resize_grip_count = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
   39,412 ( 0.00%)          const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
   11,997 ( 0.00%)          if (handle_borders_and_resize_grips && !window->Collapsed)
   52,555 ( 0.00%)              if (int auto_fit_mask = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
   59,416 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowManualResize(ImGuiWindow*, ImVec2 const&, int*, int*, int, unsigned int*, ImRect const&) [clone .constprop.0] (2,285x)
        .                       {
        .                           if (auto_fit_mask & (1 << ImGuiAxis_X))
        .                               use_current_size_for_scrollbar_x = true;
        .                           if (auto_fit_mask & (1 << ImGuiAxis_Y))
        .                               use_current_size_for_scrollbar_y = true;
        .                       }
    8,568 ( 0.00%)          window->ResizeBorderHovered = (signed char)border_hovered;
        .                   window->ResizeBorderHeld = (signed char)border_held;
        .           
        .                   // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
    5,712 ( 0.00%)          if (window->ViewportOwned)
        .                   {
    2,287 ( 0.00%)              if (!window->Viewport->PlatformRequestMove)
        2 ( 0.00%)                  window->Viewport->Pos = window->Pos;
        2 ( 0.00%)              if (!window->Viewport->PlatformRequestResize)
        2 ( 0.00%)                  window->Viewport->Size = window->Size;
        .                       window->Viewport->UpdateWorkRect();
        .                       viewport_rect = window->Viewport->GetMainRect();
        .                   }
        .           
        .                   // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
    5,712 ( 0.00%)          window->ViewportPos = window->Viewport->Pos;
        .           
        .                   // SCROLLBAR VISIBILITY
        .           
        .                   // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
    9,139 ( 0.00%)          if (!window->Collapsed)
        .                   {
        .                       // When reading the current size we need to read it after size constraints have been applied.
        .                       // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
        .                       // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
   11,442 ( 0.00%)              ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
        .                       ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
   11,412 ( 0.00%)              ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
    8,568 ( 0.00%)              float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
    5,712 ( 0.00%)              float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
        .                       //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
   14,280 ( 0.00%)              window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
   19,992 ( 0.00%)              window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
        .                       if (window->ScrollbarX && !window->ScrollbarY)
        .                           window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
   11,424 ( 0.00%)              window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        .           
        .                       // Amend the partially filled window->DecorationXXX values.
   11,424 ( 0.00%)              window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
    2,856 ( 0.00%)              window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
        .                   }
        .           
        .                   // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
        .                   // Update various regions. Variables they depend on should be set above in this function.
        .                   // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
        .           
        .                   // Outer rectangle
        .                   // Not affected by window border size. Used by:
        .                   // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
        .                   // - Begin() initial clipping rect for drawing window background and borders.
        .                   // - Begin() clipping whole child
   19,420 ( 0.00%)          const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
        .                   const ImRect outer_rect = window->Rect();
    8,568 ( 0.00%)          const ImRect title_bar_rect = window->TitleBarRect();
    2,856 ( 0.00%)          window->OuterRectClipped = outer_rect;
    5,712 ( 0.00%)          if (window->DockIsActive)
      571 ( 0.00%)              window->OuterRectClipped.Min.y += window->TitleBarHeight();
        .                   window->OuterRectClipped.ClipWith(host_rect);
        .           
        .                   // Inner rectangle
        .                   // Not affected by window border size. Used by:
        .                   // - InnerClipRect
        .                   // - ScrollToRectEx()
        .                   // - NavUpdatePageUpPageDown()
        .                   // - Scrollbar()
   17,136 ( 0.00%)          window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
        .                   window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
    8,568 ( 0.00%)          window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
        .                   window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
        .           
        .                   // Inner clipping rectangle.
        .                   // - Extend a outside of normal work region up to borders.
        .                   // - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
        .                   // - It also makes clipped items be more noticeable.
        .                   // - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
        .                   // - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        .                   // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        .                   // Affected by window/frame border size. Used by:
        .                   // - Begin() initial clip rect
   18,279 ( 0.00%)          float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
    5,712 ( 0.00%)          window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + window->WindowBorderSize);
    5,712 ( 0.00%)          window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
    5,712 ( 0.00%)          window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - window->WindowBorderSize);
    5,712 ( 0.00%)          window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
        .                   window->InnerClipRect.ClipWithFull(host_rect);
        .           
        .                   // Default item width. Make it proportional to window size if window manually resizes
   17,136 ( 0.00%)          if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
    2,856 ( 0.00%)              window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);
        .                   else
        .                       window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);
        .           
        .                   // SCROLLING
        .           
        .                   // Lock down maximum scrolling
        .                   // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
        .                   // for right/bottom aligned items without creating a scrollbar.
   25,704 ( 0.00%)          window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
        .                   window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
        .           
        .                   // Apply scrolling
   11,424 ( 0.00%)          window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
  182,784 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow*) (2,856x)
    5,712 ( 0.00%)          window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    2,856 ( 0.00%)          window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
        .           
        .                   // DRAWING
        .           
        .                   // Setup draw list and outer clipping rectangle
   22,848 ( 0.00%)          IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
   14,280 ( 0.00%)          window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
   97,923 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::PushTextureID(void*) (2,856x)
        .                   PushClipRect(host_rect.Min, host_rect.Max, false);
        .           
        .                   // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
        .                   // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
        .                   // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
    9,710 ( 0.00%)          const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
        .                   if (is_undocked_or_docked_visible)
        .                   {
    1,141 ( 0.00%)              bool render_decorations_in_parent = false;
   19,985 ( 0.00%)              if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
        .                       {
        .                           // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
        .                           // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
    4,564 ( 0.00%)                  ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
    1,141 ( 0.00%)                  bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
    2,282 ( 0.00%)                  bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
   17,115 ( 0.00%)                  if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)
        .                               render_decorations_in_parent = true;
        .                       }
        .                       if (render_decorations_in_parent)
    1,142 ( 0.00%)                  window->DrawList = parent_window->DrawList;
        .           
        .                       // Handle title bar, scrollbar, resize grips and resize borders
   14,267 ( 0.00%)              const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
   33,658 ( 0.00%)              const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
   19,985 ( 0.00%)              RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
1,062,789 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowDecorations(ImGuiWindow*, ImRect const&, bool, bool, int, unsigned int const*, float) (2,855x)
        .           
    5,710 ( 0.00%)              if (render_decorations_in_parent)
    1,142 ( 0.00%)                  window->DrawList = &window->DrawListInst;
        .                   }
        .           
        .                   // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
        .           
        .                   // Work rectangle.
        .                   // Affected by window padding and border size. Used by:
        .                   // - Columns() for right-most edge
        .                   // - TreeNode(), CollapsingHeader() for right-most edge
        .                   // - BeginTabBar() for right-most edge
        .                   const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
        .                   const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
   51,408 ( 0.00%)          const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
   53,122 ( 0.00%)          const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
   34,272 ( 0.00%)          window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
   17,136 ( 0.00%)          window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
    2,856 ( 0.00%)          window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
    2,856 ( 0.00%)          window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
    2,856 ( 0.00%)          window->ParentWorkRect = window->WorkRect;
        .           
        .                   // [LEGACY] Content Region
        .                   // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        .                   // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
        .                   // Used by:
        .                   // - Mouse wheel scrolling + many other things
   45,696 ( 0.00%)          window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
        .                   window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
   28,560 ( 0.00%)          window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
   28,560 ( 0.00%)          window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
        .           
        .                   // Setup drawing context
        .                   // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
    8,568 ( 0.00%)          window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
        .                   window->DC.GroupOffset.x = 0.0f;
    2,856 ( 0.00%)          window->DC.ColumnsOffset.x = 0.0f;
        .           
        .                   // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
        .                   // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
   28,560 ( 0.00%)          double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
    8,568 ( 0.00%)          double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
    8,568 ( 0.00%)          window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
   28,560 ( 0.00%)          window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
    2,856 ( 0.00%)          window->DC.CursorPos = window->DC.CursorStartPos;
    2,856 ( 0.00%)          window->DC.CursorPosPrevLine = window->DC.CursorPos;
    2,856 ( 0.00%)          window->DC.CursorMaxPos = window->DC.CursorStartPos;
    2,856 ( 0.00%)          window->DC.IdealMaxPos = window->DC.CursorStartPos;
    5,712 ( 0.00%)          window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
    5,712 ( 0.00%)          window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
    2,856 ( 0.00%)          window->DC.IsSameLine = window->DC.IsSetPos = false;
        .           
    2,856 ( 0.00%)          window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    5,712 ( 0.00%)          window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
    2,856 ( 0.00%)          window->DC.NavLayersActiveMaskNext = 0x00;
        .                   window->DC.NavIsScrollPushableX = true;
        .                   window->DC.NavHideHighlightOneFrame = false;
   11,424 ( 0.00%)          window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);
        .           
    2,856 ( 0.00%)          window->DC.MenuBarAppending = false;
   14,280 ( 0.00%)          window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
  145,668 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGuiMenuColumns::Update(float, bool) (2,856x)
    2,856 ( 0.00%)          window->DC.TreeDepth = 0;
        .                   window->DC.TreeJumpToParentOnPopMask = 0x00;
        .                   window->DC.ChildWindows.resize(0);
    5,712 ( 0.00%)          window->DC.StateStorage = &window->StateStorage;
    2,856 ( 0.00%)          window->DC.CurrentColumns = NULL;
    2,856 ( 0.00%)          window->DC.LayoutType = ImGuiLayoutType_Vertical;
   12,566 ( 0.00%)          window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        .           
    5,712 ( 0.00%)          window->DC.ItemWidth = window->ItemWidthDefault;
    2,856 ( 0.00%)          window->DC.TextWrapPos = -1.0f; // disabled
        .                   window->DC.ItemWidthStack.resize(0);
        .                   window->DC.TextWrapPosStack.resize(0);
    5,712 ( 0.00%)          if (flags & ImGuiWindowFlags_Modal)
        .                       window->DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_ModalWindowDimBg));
        .           
    8,568 ( 0.00%)          if (window->AutoFitFramesX > 0)
        .                       window->AutoFitFramesX--;
    8,568 ( 0.00%)          if (window->AutoFitFramesY > 0)
        .                       window->AutoFitFramesY--;
        .           
        .                   // Clear SetNextWindowXXX data (can aim to move this higher in the function)
        .                   g.NextWindowData.ClearFlags();
        .           
        .                   // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        .                   // We ImGuiFocusRequestFlags_UnlessBelowModal to:
        .                   // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
        .                   // - Position window behind the modal that is not a begin-parent of this window.
    5,712 ( 0.00%)          if (want_focus)
       15 ( 0.00%)              FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
    1,305 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FocusWindow(ImGuiWindow*, int) (5x)
       10 ( 0.00%)          if (want_focus && window == g.NavWindow)
       20 ( 0.00%)              NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
      573 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::NavInitWindow(ImGuiWindow*, bool) (5x)
        .           
        .                   // Close requested by platform window (apply to all windows in this viewport)
    5,715 ( 0.00%)          if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
        .                   {
        .                       IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window->Name);
        .                       *p_open = false;
        .                       g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
        .                   }
        .           
        .                   // Title bar
    9,712 ( 0.00%)          if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
    5,148 ( 0.00%)              RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
        .           
        .                   // Clear hit test shape every frame
    2,856 ( 0.00%)          window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
        .           
        .                   // Pressing CTRL+C while holding on a window copy its content to the clipboard
        .                   // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        .                   // Maybe we can support CTRL+C on every element?
        .                   /*
        .                   //if (g.NavWindow == window && g.ActiveId == 0)
        .                   if (g.ActiveId == window->MoveId)
        .                       if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
        .                           LogToClipboard();
        .                   */
        .           
    5,712 ( 0.00%)          if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
        .                   {
        .                       // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
        .                       // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
    5,712 ( 0.00%)              if (g.MovingWindow == window && (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
        .                           BeginDockableDragDropSource(window);
        .           
        .                       // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
    5,712 ( 0.00%)              if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
        .                           if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
        .                               if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
        .                                   BeginDockableDragDropTarget(window);
        .                   }
        .           
        .                   // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        .                   // This is useful to allow creating context menus on title bar only, etc.
    8,568 ( 0.00%)          SetLastItemDataForWindow(window, title_bar_rect);
   70,872 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetLastItemDataForWindow(ImGuiWindow*, ImRect const&) (2,856x)
        .           
        .                   // [DEBUG]
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    8,568 ( 0.00%)          if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
        .                       DebugLocateItemResolveWithLastItem();
        .           #endif
        .           
        .                   // [Test Engine] Register title bar / tab with MoveId.
        .           #ifdef IMGUI_ENABLE_TEST_ENGINE
        .                   if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
        .                       IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
        .           #endif
-- line 7573 ----------------------------------------
-- line 7580 ----------------------------------------
        .           
        .                   // Append
        .                   SetCurrentViewport(window, window->Viewport);
        .                   SetCurrentWindow(window);
        .                   g.NextWindowData.ClearFlags();
        .                   SetLastItemDataForWindow(window, window->TitleBarRect());
        .               }
        .           
   10,282 ( 0.00%)      if (!(flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)
    4,570 ( 0.00%)          PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
        .           
        .               // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    2,856 ( 0.00%)      window->WriteAccessed = false;
    2,856 ( 0.00%)      window->BeginCount++;
        .           
        .               // Update visibility
   15,994 ( 0.00%)      if (first_begin_of_the_frame && !window->SkipRefresh)
        .               {
        .                   // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
        .                   // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
        .                   // This is analogous to regular windows being hidden from one frame.
        .                   // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
   15,422 ( 0.00%)          if (window->DockIsActive && !window->DockTabIsVisible)
        .                   {
        3 ( 0.00%)              if (window->LastFrameJustFocused == g.FrameCount)
        1 ( 0.00%)                  window->HiddenFramesCannotSkipItems = 1;
        .                       else
        .                           window->HiddenFramesCanSkipItems = 1;
        .                   }
        .           
    5,713 ( 0.00%)          if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_ChildMenu))
        .                   {
        .                       // Child window can be out of sight and have "negative" clip windows.
        .                       // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
    1,142 ( 0.00%)              IM_ASSERT((flags& ImGuiWindowFlags_NoTitleBar) != 0 || window->DockIsActive);
    2,284 ( 0.00%)              const bool nav_request = (flags & ImGuiWindowFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
    2,284 ( 0.00%)              if (!g.LogEnabled && !nav_request)
    6,852 ( 0.00%)                  if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
        .                           {
        .                               if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        .                                   window->HiddenFramesCannotSkipItems = 1;
        .                               else
        .                                   window->HiddenFramesCanSkipItems = 1;
        .                           }
        .           
        .                       // Hide along with parent or if parent is collapsed
    7,994 ( 0.00%)              if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
        .                           window->HiddenFramesCanSkipItems = 1;
    3,426 ( 0.00%)              if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
        .                           window->HiddenFramesCannotSkipItems = 1;
        .                   }
        .           
        .                   // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    8,568 ( 0.00%)          if (style.Alpha <= 0.0f)
        .                       window->HiddenFramesCanSkipItems = 1;
        .           
        .                   // Update the Hidden flag
   11,427 ( 0.00%)          bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
   14,271 ( 0.00%)          window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
        .           
        .                   // Disable inputs for requested number of frames
    8,568 ( 0.00%)          if (window->DisableInputsFrames > 0)
        .                   {
        .                       window->DisableInputsFrames--;
        .                       window->Flags |= ImGuiWindowFlags_NoInputs;
        .                   }
        .           
        .                   // Update the SkipItems flag, used to early out of all items functions (no layout required)
        .                   bool skip_items = false;
   17,136 ( 0.00%)          if (window->Collapsed || !window->Active || hidden_regular)
       18 ( 0.00%)              if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
        .                           skip_items = true;
    2,856 ( 0.00%)          window->SkipItems = skip_items;
        .           
        .                   // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
        .                   if (window->SkipItems)
        .                       window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
        .           
        .                   // Sanity check: there are two spots which can set Appearing = true
        .                   // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
        .                   // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
-- line 7660 ----------------------------------------
-- line 7665 ----------------------------------------
        .               {
        .                   // Skip refresh mode
        .                   window->SkipItems = true;
        .               }
        .           
        .               // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
        .               // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
    8,568 ( 0.00%)      if (!window->IsFallbackWindow)
    9,140 ( 0.00%)          if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size))
        .                   {
        .                       if (window->AutoFitFramesX > 0) { window->AutoFitFramesX++; }
        .                       if (window->AutoFitFramesY > 0) { window->AutoFitFramesY++; }
        .                       return false;
        .                   }
        .           #endif
        .           
    5,712 ( 0.00%)      return !window->SkipItems;
   28,560 ( 0.00%)  }
        .           
        .           static void ImGui::SetLastItemDataForWindow(ImGuiWindow* window, const ImRect& rect)
        .           {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
    5,712 ( 0.00%)      if (window->DockIsActive)
    6,283 ( 0.00%)          SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
        .               else
    2,285 ( 0.00%)          SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, rect);
    2,856 ( 0.00%)  }
        .           
        .           void ImGui::End()
   22,848 ( 0.00%)  {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,856 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
        .               // Error checking: verify that user hasn't called End() too many times!
    9,710 ( 0.00%)      if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
        .                   return;
        .               }
    1,142 ( 0.00%)      IM_ASSERT(g.CurrentWindowStack.Size > 0);
        .           
        .               // Error checking: verify that user doesn't directly call End() on a child window.
   12,566 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
        .                   IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
        .           
        .               // Close anything that is open
    5,712 ( 0.00%)      if (window->DC.CurrentColumns)
        .                   EndColumns();
   10,282 ( 0.00%)      if (!(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)   // Pop inner window clip rectangle
        .                   PopClipRect();
    2,856 ( 0.00%)      PopFocusScope();
   43,983 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PopFocusScope() (2,856x)
        .           
    5,712 ( 0.00%)      if (window->SkipRefresh)
        .               {
        .                   IM_ASSERT(window->DrawList == NULL);
        .                   window->DrawList = &window->DrawListInst;
        .               }
        .           
        .               // Stop logging
    5,712 ( 0.00%)      if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
    1,714 ( 0.00%)          LogFinish();
   10,284 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LogFinish() (1,714x)
        .           
    5,712 ( 0.00%)      if (window->DC.IsSetPos)
        .                   ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
        .           
        .               // Docking: report contents sizes to parent to allow for auto-resize
    9,710 ( 0.00%)      if (window->DockNode && window->DockTabIsVisible)
    1,710 ( 0.00%)          if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
      570 ( 0.00%)              host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
        .           
        .               // Pop from window stack
   22,848 ( 0.00%)      g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
    8,568 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_ChildMenu)
        .                   g.BeginMenuDepth--;
    5,712 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_Popup)
        .                   g.BeginPopupStack.pop_back();
   11,424 ( 0.00%)      g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithContextState(&g);
   88,536 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStackSizes::CompareWithContextState(ImGuiContext*) (2,856x)
        .               g.CurrentWindowStack.pop_back();
   13,138 ( 0.00%)      SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
   55,981 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:SetCurrentWindow(ImGuiWindow*) (2,856x)
    8,568 ( 0.00%)      if (g.CurrentWindow)
    2,285 ( 0.00%)          SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
   22,848 ( 0.00%)  }
        .           
        .           void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
        9 ( 0.00%)  {
        9 ( 0.00%)      ImGuiContext& g = *GImGui;
       18 ( 0.00%)      IM_ASSERT(window == window->RootWindow);
        .           
       27 ( 0.00%)      const int cur_order = window->FocusOrder;
       27 ( 0.00%)      IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
       18 ( 0.00%)      if (g.WindowsFocusOrder.back() == window)
        .                   return;
        .           
        1 ( 0.00%)      const int new_order = g.WindowsFocusOrder.Size - 1;
        6 ( 0.00%)      for (int n = cur_order; n < new_order; n++)
        .               {
        3 ( 0.00%)          g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
        3 ( 0.00%)          g.WindowsFocusOrder[n]->FocusOrder--;
        4 ( 0.00%)          IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
        .               }
        1 ( 0.00%)      g.WindowsFocusOrder[new_order] = window;
        1 ( 0.00%)      window->FocusOrder = (short)new_order;
       18 ( 0.00%)  }
        .           
        .           void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
       15 ( 0.00%)  {
        5 ( 0.00%)      ImGuiContext& g = *GImGui;
       15 ( 0.00%)      ImGuiWindow* current_front_window = g.Windows.back();
       10 ( 0.00%)      if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
        .                   return;
        .               for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
        .                   if (g.Windows[i] == window)
        .                   {
        .                       memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
        .                       g.Windows[g.Windows.Size - 1] = window;
        .                       break;
        .                   }
       20 ( 0.00%)  }
        .           
        .           void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.Windows[0] == window)
        .                   return;
        .               for (int i = 0; i < g.Windows.Size; i++)
        .                   if (g.Windows[i] == window)
-- line 7791 ----------------------------------------
-- line 7821 ----------------------------------------
        .           int ImGui::FindWindowDisplayIndex(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return g.Windows.index_from_ptr(g.Windows.find(window));
        .           }
        .           
        .           // Moving window to front of display and set focus (which happens to be back of our sorted list)
        .           void ImGui::FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags)
       63 ( 0.00%)  {
        9 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Modal check?
       28 ( 0.00%)      if ((flags & ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window)) // Early out in common case.
       20 ( 0.00%)          if (ImGuiWindow* blocking_modal = FindBlockingModal(window))
       35 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindBlockingModal(ImGuiWindow*) (5x)
        .                   {
        .                       IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window->Name : "<NULL>", blocking_modal->Name);
        .                       if (window && window == window->RootWindow && (window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
        .                           BringWindowToDisplayBehind(window, blocking_modal); // Still bring to right below modal.
        .                       return;
        .                   }
        .           
        .               // Find last focused child (if any) and focus it instead.
       23 ( 0.00%)      if ((flags & ImGuiFocusRequestFlags_RestoreFocusedChild) && window != NULL)
        .                   window = NavRestoreLastChildNavWindow(window);
        .           
        .               // Apply focus
        8 ( 0.00%)      if (g.NavWindow != window)
        .               {
        .                   SetNavWindow(window);
       24 ( 0.00%)          if (window && g.NavDisableMouseHover)
        .                       g.NavMousePosDirty = true;
       12 ( 0.00%)          g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        6 ( 0.00%)          g.NavLayer = ImGuiNavLayer_Main;
       12 ( 0.00%)          SetNavFocusScope(window ? window->NavRootFocusScopeId : 0);
      743 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavFocusScope(unsigned int) (6x)
        6 ( 0.00%)          g.NavIdIsAlive = false;
        6 ( 0.00%)          g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        .           
        .                   // Close popups if any
       18 ( 0.00%)          ClosePopupsOverWindow(window, false);
       90 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ClosePopupsOverWindow(ImGuiWindow*, bool) (6x)
        .               }
        .           
        .               // Move the root window to the top of the pile
       33 ( 0.00%)      IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
        9 ( 0.00%)      ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
        .               ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
        .               ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
       27 ( 0.00%)      bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
        .           
        .               // Steal active widgets. Some of the cases it triggers includes:
        .               // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
        .               // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
        .               // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
        .               if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
        .                   if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
        .                       ClearActiveID();
        .           
        .               // Passing NULL allow to disable keyboard focus
        .               if (!window)
        .                   return;
       18 ( 0.00%)      window->LastFrameJustFocused = g.FrameCount;
        .           
        .               // Select in dock node
        .               // For #2304 we avoid applying focus immediately before the tabbar is visible.
        .               //if (dock_node && dock_node->TabBar)
        .               //    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
        .           
        .               // Bring to front
       18 ( 0.00%)      BringWindowToFocusFront(focus_front_window);
      202 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BringWindowToFocusFront(ImGuiWindow*) (9x)
       45 ( 0.00%)      if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
        6 ( 0.00%)          BringWindowToDisplayFront(display_front_window);
       51 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BringWindowToDisplayFront(ImGuiWindow*) (3x)
       51 ( 0.00%)  }
        .           
        .           void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window, ImGuiViewport* filter_viewport, ImGuiFocusRequestFlags flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               int start_idx = g.WindowsFocusOrder.Size - 1;
        .               if (under_this_window != NULL)
        .               {
        .                   // Aim at root window behind us, if we are in a child window that's our own root (see #4640)
-- line 7899 ----------------------------------------
-- line 7924 ----------------------------------------
        .                       return;
        .                   }
        .               }
        .               FocusWindow(NULL, flags);
        .           }
        .           
        .           // Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
        .           void ImGui::SetCurrentFont(ImFont* font)
      571 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,284 ( 0.00%)      IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    2,284 ( 0.00%)      IM_ASSERT(font->Scale > 0.0f);
      571 ( 0.00%)      g.Font = font;
    3,997 ( 0.00%)      g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    2,855 ( 0.00%)      g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
        .           
        .               ImFontAtlas* atlas = g.Font->ContainerAtlas;
    1,142 ( 0.00%)      g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    1,142 ( 0.00%)      g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
      571 ( 0.00%)      g.DrawListSharedData.Font = g.Font;
      571 ( 0.00%)      g.DrawListSharedData.FontSize = g.FontSize;
    1,142 ( 0.00%)  }
        .           
        .           void ImGui::PushFont(ImFont* font)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (!font)
        .                   font = GetDefaultFont();
        .               SetCurrentFont(font);
        .               g.FontStack.push_back(font);
-- line 7953 ----------------------------------------
-- line 8049 ----------------------------------------
        .               ImGuiWindow* window = GetCurrentWindow();
        .               window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
        .               window->DC.TextWrapPosStack.pop_back();
        .           }
        .           
        .           static ImGuiWindow* GetCombinedRootWindow(ImGuiWindow* window, bool popup_hierarchy, bool dock_hierarchy)
        .           {
        .               ImGuiWindow* last_window = NULL;
    2,560 ( 0.00%)      while (last_window != window)
        .               {
        .                   last_window = window;
      512 ( 0.00%)          window = window->RootWindow;
        .                   if (popup_hierarchy)
        .                       window = window->RootWindowPopupTree;
        .           		if (dock_hierarchy)
    1,024 ( 0.00%)  			window = window->RootWindowDockTree;
        .           	}
        .               return window;
        .           }
        .           
        .           bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy, bool dock_hierarchy)
        .           {
        .               ImGuiWindow* window_root = GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy);
      512 ( 0.00%)      if (window_root == potential_parent)
        .                   return true;
      512 ( 0.00%)      while (window != NULL)
        .               {
    1,024 ( 0.00%)          if (window == potential_parent)
        .                       return true;
      512 ( 0.00%)          if (window == window_root) // end of chain
        .                       return false;
      256 ( 0.00%)          window = window->ParentWindow;
        .               }
        .               return false;
        .           }
        .           
        .           bool ImGui::IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
        .           {
        .               if (window->RootWindow == potential_parent)
        .                   return true;
-- line 8088 ----------------------------------------
-- line 8218 ----------------------------------------
        .           {
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->Size.y;
        .           }
        .           
        .           ImVec2 ImGui::GetWindowPos()
        .           {
        .               ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    3,426 ( 0.00%)      return window->Pos;
    1,713 ( 0.00%)  }
        .           
        .           void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
    2,284 ( 0.00%)  {
        .               // Test condition (NB: bit 0 is always true) and clear flags for next time
   13,704 ( 0.00%)      if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        .                   return;
        .           
        .               IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    4,568 ( 0.00%)      window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    4,568 ( 0.00%)      window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
        .           
        .               // Set
    6,852 ( 0.00%)      const ImVec2 old_pos = window->Pos;
    2,284 ( 0.00%)      window->Pos = ImTrunc(pos);
        .               ImVec2 offset = window->Pos - old_pos;
   27,398 ( 0.00%)      if (offset.x == 0.0f && offset.y == 0.0f)
        .                   return;
        .               MarkIniSettingsDirty(window);
        .               // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
        .               window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
        .               window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
        .               window->DC.IdealMaxPos += offset;
        .               window->DC.CursorStartPos += offset;
        .           }
-- line 8252 ----------------------------------------
-- line 8265 ----------------------------------------
        .           
        .           ImVec2 ImGui::GetWindowSize()
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               return window->Size;
        .           }
        .           
        .           void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
    5,710 ( 0.00%)  {
        .               // Test condition (NB: bit 0 is always true) and clear flags for next time
   17,130 ( 0.00%)      if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        .                   return;
        .           
        .               IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    4,568 ( 0.00%)      window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        .           
        .               // Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
   11,416 ( 0.00%)      if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
    5,720 ( 0.00%)          window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
        .               if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
    5,720 ( 0.00%)          window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
        .           
        .               // Set
    6,852 ( 0.00%)      ImVec2 old_size = window->SizeFull;
    9,136 ( 0.00%)      if (size.x <= 0.0f)
        .                   window->AutoFitOnlyGrows = false;
        .               else
    6,852 ( 0.00%)          window->SizeFull.x = IM_TRUNC(size.x);
    9,136 ( 0.00%)      if (size.y <= 0.0f)
        .                   window->AutoFitOnlyGrows = false;
        .               else
    6,852 ( 0.00%)          window->SizeFull.y = IM_TRUNC(size.y);
   16,540 ( 0.00%)      if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
        .                   MarkIniSettingsDirty(window);
        .           }
        .           
        .           void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
        .           {
        .               SetWindowSize(GImGui->CurrentWindow, size, cond);
        .           }
        .           
-- line 8305 ----------------------------------------
-- line 8371 ----------------------------------------
        .               else
        .               {
        .                   FocusWindow(NULL);
        .               }
        .           }
        .           
        .           void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
        .           {
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,284 ( 0.00%)      IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    3,426 ( 0.00%)      g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
    3,997 ( 0.00%)      g.NextWindowData.PosVal = pos;
    3,426 ( 0.00%)      g.NextWindowData.PosPivotVal = pivot;
    3,426 ( 0.00%)      g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
    3,426 ( 0.00%)      g.NextWindowData.PosUndock = true;
        .           }
        .           
        .           void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
        .           {
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,284 ( 0.00%)      IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    5,139 ( 0.00%)      g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
    6,281 ( 0.00%)      g.NextWindowData.SizeVal = size;
    5,139 ( 0.00%)      g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
        .           }
        .           
        .           // For each axis:
        .           // - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
        .           // - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
        .           // - See "Demo->Examples->Constrained-resizing window" for examples.
        .           void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
        .           {
-- line 8402 ----------------------------------------
-- line 8442 ----------------------------------------
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
        .               g.NextWindowData.BgAlphaVal = alpha;
        .           }
        .           
        .           void ImGui::SetNextWindowViewport(ImGuiID id)
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
      571 ( 0.00%)      g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;
      571 ( 0.00%)      g.NextWindowData.ViewportId = id;
      571 ( 0.00%)  }
        .           
        .           void ImGui::SetNextWindowDockID(ImGuiID id, ImGuiCond cond)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasDock;
        .               g.NextWindowData.DockCond = cond ? cond : ImGuiCond_Always;
        .               g.NextWindowData.DockId = id;
        .           }
-- line 8461 ----------------------------------------
-- line 8516 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = GetCurrentWindow();
        .               window->FontWindowScale = scale;
        .               g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
        .           }
        .           
        .           void ImGui::PushFocusScope(ImGuiID id)
        .           {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiFocusScopeData data;
        .               data.ID = id;
    5,712 ( 0.00%)      data.WindowID = g.CurrentWindow->ID;
        .               g.FocusScopeStack.push_back(data);
    2,856 ( 0.00%)      g.CurrentFocusScopeId = id;
        .           }
        .           
        .           void ImGui::PopFocusScope()
    2,856 ( 0.00%)  {
    2,856 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,568 ( 0.00%)      if (g.FocusScopeStack.Size == 0)
        .               {
        .                   IM_ASSERT_USER_ERROR(g.FocusScopeStack.Size > 0, "Calling PopFocusScope() too many times!");
        .                   return;
        .               }
        .               g.FocusScopeStack.pop_back();
   13,138 ( 0.00%)      g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back().ID : 0;
    5,712 ( 0.00%)  }
        .           
        .           void ImGui::SetNavFocusScope(ImGuiID focus_scope_id)
       88 ( 0.00%)  {
       11 ( 0.00%)      ImGuiContext& g = *GImGui;
       11 ( 0.00%)      g.NavFocusScopeId = focus_scope_id;
        .               g.NavFocusRoute.resize(0); // Invalidate
       22 ( 0.00%)      if (focus_scope_id == 0)
        .                   return;
       33 ( 0.00%)      IM_ASSERT(g.NavWindow != NULL);
        .           
        .               // Store current path (in reverse order)
       22 ( 0.00%)      if (focus_scope_id == g.CurrentFocusScopeId)
        .               {
        .                   // Top of focus stack contains local focus scopes inside current window
      248 ( 0.00%)          for (int n = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow->ID; n--)
        .                       g.NavFocusRoute.push_back(g.FocusScopeStack.Data[n]);
        .               }
        2 ( 0.00%)      else if (focus_scope_id == g.NavWindow->NavRootFocusScopeId)
        .                   g.NavFocusRoute.push_back({ focus_scope_id, g.NavWindow->ID });
        .               else
        .                   return;
        .           
        .               // Then follow on manually set ParentWindowForFocusRoute field (#6798)
       55 ( 0.00%)      for (ImGuiWindow* window = g.NavWindow->ParentWindowForFocusRoute; window != NULL; window = window->ParentWindowForFocusRoute)
        .                   g.NavFocusRoute.push_back({ window->NavRootFocusScopeId, window->ID });
       22 ( 0.00%)      IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
       88 ( 0.00%)  }
        .           
        .           // Focus = move navigation cursor, set scrolling, set focus window.
        .           void ImGui::FocusItem()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               IMGUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window->Name);
        .               if (g.DragDropActive || g.MovingWindow != NULL) // FIXME: Opt-in flags for this?
-- line 8577 ----------------------------------------
-- line 8672 ----------------------------------------
        .           }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ID STACK
        .           //-----------------------------------------------------------------------------
        .           
        .           // This is one of the very rare legacy case where we use ImGuiWindow methods,
        .           // it should ideally be flattened at some point but it's been used a lots by widgets.
    1,719 ( 0.00%)  ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
   27,408 ( 0.00%)  {
   17,130 ( 0.00%)      ImGuiID seed = IDStack.back();
   86,293 ( 0.00%)      ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
  503,051 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (3,997x)
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        .               ImGuiContext& g = *Ctx;
   39,435 ( 0.00%)      if (g.DebugHookIdInfo == id)
        .                   ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
        .           #endif
        .               return id;
   14,850 ( 0.00%)  }
        .           
        .           ImGuiID ImGuiWindow::GetID(const void* ptr)
        .           {
        .               ImGuiID seed = IDStack.back();
        .               ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        .               ImGuiContext& g = *Ctx;
        .               if (g.DebugHookIdInfo == id)
-- line 8698 ----------------------------------------
-- line 8718 ----------------------------------------
        .           {
        .               ImGuiID seed = IDStack.back();
        .               ImRect r_rel = ImGui::WindowRectAbsToRel(this, r_abs);
        .               ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
        .               return id;
        .           }
        .           
        .           void ImGui::PushID(const char* str_id)
   19,985 ( 0.00%)  {
        .               ImGuiContext& g = *GImGui;
    7,994 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .               ImGuiID id = window->GetID(str_id);
        .               window->IDStack.push_back(id);
   23,982 ( 0.00%)  }
        .           
        .           void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               ImGuiID id = window->GetID(str_id_begin, str_id_end);
        .               window->IDStack.push_back(id);
        .           }
-- line 8739 ----------------------------------------
-- line 8788 ----------------------------------------
        .               if (g.DebugHookIdInfo == id)
        .                   DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
        .           #endif
        .               return id;
        .           }
        .           
        .           void ImGui::PopID()
        .           {
    7,994 ( 0.00%)      ImGuiWindow* window = GImGui->CurrentWindow;
   11,991 ( 0.00%)      IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
        .               window->IDStack.pop_back();
        .           }
        .           
        .           ImGuiID ImGui::GetID(const char* str_id)
      571 ( 0.00%)  {
    1,142 ( 0.00%)      ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->GetID(str_id);
    1,142 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
        .           {
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->GetID(str_id_begin, str_id_end);
        .           }
        .           
        .           ImGuiID ImGui::GetID(const void* ptr_id)
-- line 8813 ----------------------------------------
-- line 8876 ----------------------------------------
        .           // - GetKeyOwner() [Internal]
        .           // - TestKeyOwner() [Internal]
        .           // - SetKeyOwner() [Internal]
        .           // - SetItemKeyOwner() [Internal]
        .           // - Shortcut() [Internal]
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiKeyChord ImGui::FixupKeyChord(ImGuiContext* ctx, ImGuiKeyChord key_chord)
    1,142 ( 0.00%)  {
        .               // Convert ImGuiMod_Shortcut and add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
    4,568 ( 0.00%)      ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    4,568 ( 0.00%)      if (IsModKey(key))
        .               {
        .                   if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)
        .                       key_chord |= ImGuiMod_Ctrl;
        .                   if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)
        .                       key_chord |= ImGuiMod_Shift;
        .                   if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)
        .                       key_chord |= ImGuiMod_Alt;
        .                   if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)
        .                       key_chord |= ImGuiMod_Super;
        .               }
    4,568 ( 0.00%)      if (key_chord & ImGuiMod_Shortcut)
        .                   return (key_chord & ~ImGuiMod_Shortcut) | (ctx->IO.ConfigMacOSXBehaviors ? ImGuiMod_Super : ImGuiMod_Ctrl);
        .               return key_chord;
    1,142 ( 0.00%)  }
        .           
        .           ImGuiKeyData* ImGui::GetKeyData(ImGuiContext* ctx, ImGuiKey key)
        .           {
        .               ImGuiContext& g = *ctx;
        .           
        .               // Special storage location for mods
    8,766 ( 0.00%)      if (key & ImGuiMod_Mask_)
    2,492 ( 0.00%)          key = ConvertSingleModFlagToKey(ctx, key);
        .           
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    7,347 ( 0.00%)      IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
    9,244 ( 0.00%)      if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
        .                   key = (ImGuiKey)g.IO.KeyMap[key];  // Remap native->imgui or imgui->native
        .           #else
        .               IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
        .           #endif
        .               return &g.IO.KeysData[key - ImGuiKey_KeysData_OFFSET];
        .           }
        .           
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
-- line 8921 ----------------------------------------
-- line 9045 ----------------------------------------
        .           // Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
        .           //   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
        .           //   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
        .           // See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
        .           static void ImGui::UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               rt->EntriesNext.resize(0);
  352,307 ( 0.00%)      for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
        .               {
        .                   const int new_routing_start_idx = rt->EntriesNext.Size;
        .                   ImGuiKeyRoutingData* routing_entry;
  439,670 ( 0.00%)          for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
        .                   {
        .                       routing_entry = &rt->Entries[old_routing_idx];
        .                       routing_entry->RoutingCurrScore = routing_entry->RoutingNextScore;
        .                       routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
        .                       routing_entry->RoutingNext = ImGuiKeyOwner_None;
        .                       routing_entry->RoutingNextScore = 255;
        .                       if (routing_entry->RoutingCurr == ImGuiKeyOwner_None)
        .                           continue;
-- line 9065 ----------------------------------------
-- line 9074 ----------------------------------------
        .                           {
        .                               owner_data->OwnerCurr = routing_entry->RoutingCurr;
        .                               //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
        .                           }
        .                       }
        .                   }
        .           
        .                   // Rewrite linked-list
  263,802 ( 0.00%)          rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
        .                   for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
        .                       rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
        .               }
        .               rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
        .           }
        .           
        .           // owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
        .           static inline ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)
-- line 9090 ----------------------------------------
-- line 9191 ----------------------------------------
        .           }
        .           
        .           // Request a desired route for an input chord (key + mods).
        .           // Return true if the route is available this frame.
        .           // - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
        .           //   (Conceptually this does a "Submit for next frame" + "Test for current frame".
        .           //   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
        .           bool ImGui::SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
    7,994 ( 0.00%)  {
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,426 ( 0.00%)      if ((flags & ImGuiInputFlags_RouteMask_) == 0)
        .                   flags |= ImGuiInputFlags_RouteGlobalHigh; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
        .               else
        .                   IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)); // Check that only 1 routing flag is used
    3,426 ( 0.00%)      IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_None);
        .           
        .               // Convert ImGuiMod_Shortcut and add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
    4,568 ( 0.00%)      key_chord = FixupKeyChord(&g, key_chord);
   10,278 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FixupKeyChord(ImGuiContext*, int) (1,142x)
        .           
        .               // [DEBUG] Debug break requested by user
    2,284 ( 0.00%)      if (g.DebugBreakInShortcutRouting == key_chord)
        .                   IM_DEBUG_BREAK();
        .           
    2,284 ( 0.00%)      if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
        .                   if (g.NavWindow == NULL)
        .                       return false;
        .           
        .               // Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
    2,284 ( 0.00%)      if (flags & ImGuiInputFlags_RouteAlways)
        .               {
    2,284 ( 0.00%)          IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, owner_id=0x%08X, flags=%04X) -> always\n", GetKeyChordName(key_chord), owner_id, flags);
    1,142 ( 0.00%)          return true;
        .               }
        .           
        .               // Specific culling when there's an active.
        .               if (g.ActiveId != 0 && g.ActiveId != owner_id)
        .               {
        .                   // Cull shortcuts with no modifiers when it could generate a character.
        .                   // e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
        .                   // but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
-- line 9230 ----------------------------------------
-- line 9262 ----------------------------------------
        .                   routing_data->RoutingNext = owner_id;
        .                   routing_data->RoutingNextScore = (ImU8)score;
        .               }
        .           
        .               // Return routing state for CURRENT frame
        .               if (routing_data->RoutingCurr == owner_id)
        .                   IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n");
        .               return routing_data->RoutingCurr == owner_id;
    6,852 ( 0.00%)  }
        .           
        .           // Currently unused by core (but used by tests)
        .           // Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.
        .           bool ImGui::TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
        .               key_chord = FixupKeyChord(&g, key_chord);
-- line 9278 ----------------------------------------
-- line 9280 ----------------------------------------
        .               return routing_data->RoutingCurr == routing_id;
        .           }
        .           
        .           // Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
        .           // Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)
        .           bool ImGui::IsKeyDown(ImGuiKey key)
        .           {
        .               return IsKeyDown(key, ImGuiKeyOwner_Any);
    1,142 ( 0.00%)  }
        .           
        .           bool ImGui::IsKeyDown(ImGuiKey key, ImGuiID owner_id)
        .           {
        .               const ImGuiKeyData* key_data = GetKeyData(key);
   15,046 ( 0.00%)      if (!key_data->Down)
        .                   return false;
      100 ( 0.00%)      if (!TestKeyOwner(key, owner_id))
      700 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:ImGui::TestKeyOwner(ImGuiKey, unsigned int) (50x)
        .                   return false;
        .               return true;
        .           }
        .           
        .           bool ImGui::IsKeyPressed(ImGuiKey key, bool repeat)
    1,713 ( 0.00%)  {
        .               return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
    5,139 ( 0.00%)  }
        .           
        .           // Important: unless legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
      522 ( 0.00%)  bool ImGui::IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
        .           {
        .               const ImGuiKeyData* key_data = GetKeyData(key);
   11,175 ( 0.00%)      if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
        .                   return false;
        .               const float t = key_data->DownDuration;
        .               if (t < 0.0f)
        .                   return false;
        .               IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
        .               if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) // Setting any _RepeatXXX option enables _Repeat
        .                   flags |= ImGuiInputFlags_Repeat;
        .           
-- line 9317 ----------------------------------------
-- line 9335 ----------------------------------------
        .                           pressed = false;
        .                   }
        .               }
        .               if (!pressed)
        .                   return false;
        .               if (!TestKeyOwner(key, owner_id))
        .                   return false;
        .               return true;
    1,566 ( 0.00%)  }
        .           
        .           bool ImGui::IsKeyReleased(ImGuiKey key)
        .           {
        .               return IsKeyReleased(key, ImGuiKeyOwner_Any);
        .           }
        .           
        .           bool ImGui::IsKeyReleased(ImGuiKey key, ImGuiID owner_id)
        .           {
-- line 9351 ----------------------------------------
-- line 9438 ----------------------------------------
        .           // NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
        .           bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               // Clip
        .               ImRect rect_clipped(r_min, r_max);
        .               if (clip)
    4,570 ( 0.00%)          rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
        .           
        .               // Hit testing, expanded for touch input
        .               if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
        .                   return false;
      256 ( 0.00%)      if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
        .                   return false;
        .               return true;
        .           }
        .           
        .           // Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
        .           // [Internal] This doesn't test if the button is pressed
        .           bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)
        .           {
-- line 9459 ----------------------------------------
-- line 9501 ----------------------------------------
        .           
        .           // We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
        .           bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
        .           {
        .               // The assert is only to silence a false-positive in XCode Static Analysis.
        .               // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
        .               IM_ASSERT(GImGui != NULL);
        .               const float MOUSE_INVALID = -256000.0f;
    2,942 ( 0.00%)      ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
    4,228 ( 0.00%)      return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
        .           }
        .           
        .           // [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
        .           bool ImGui::IsAnyMouseDown()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
       54 ( 0.00%)          if (g.IO.MouseDown[n])
        .                       return true;
        .               return false;
        .           }
        .           
        .           // Return the delta from the initial clicking position while the mouse button is clicked or was just released.
        .           // This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
        .           // NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
        .           ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)
-- line 9526 ----------------------------------------
-- line 9559 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               g.MouseCursor = cursor_type;
        .           }
        .           
        .           static void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)
        .           {
        .               IM_ASSERT(ImGui::IsAliasKey(key));
        .               ImGuiKeyData* key_data = ImGui::GetKeyData(key);
    2,855 ( 0.00%)      key_data->Down = v;
    3,997 ( 0.00%)      key_data->AnalogValue = analog_value;
        .           }
        .           
        .           // [Internal] Do not use directly
        .           static ImGuiKeyChord GetMergedModsFromKeys()
        .           {
    1,142 ( 0.00%)      ImGuiKeyChord mods = 0;
        .               if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
        .               if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
        .               if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
        .               if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
        .               return mods;
    1,142 ( 0.00%)  }
        .           
        .           static void ImGui::UpdateKeyboardInputs()
    3,997 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
        .           
        .               // Import legacy keys or verify they are not used
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    2,747 ( 0.00%)      if (io.BackendUsingLegacyKeyArrays == 0)
        .               {
        .                   // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
  794,112 ( 0.00%)          for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
  529,508 ( 0.00%)              IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
        .               }
        .               else
        .               {
      270 ( 0.00%)          if (g.FrameCount == 0)
        .                       for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
        .                           IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
        .           
        .                   // Build reverse KeyMap (Named -> Legacy)
   24,948 ( 0.00%)          for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
   24,948 ( 0.00%)              if (io.KeyMap[n] != -1)
        .                       {
        .                           IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
        .                           io.KeyMap[io.KeyMap[n]] = n;
        .                       }
        .           
        .                   // Import legacy keys into new ones
   82,944 ( 0.00%)          for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
   83,160 ( 0.00%)              if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
        .                       {
        .                           const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
        .                           IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
        .                           io.KeysData[key].Down = io.KeysDown[n];
        .                           if (key != n)
        .                               io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
        .                           io.BackendUsingLegacyKeyArrays = 1;
        .                       }
-- line 9619 ----------------------------------------
-- line 9624 ----------------------------------------
        .                       GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
        .                       GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
        .                   }
        .               }
        .           #endif
        .           
        .               // Import legacy ImGuiNavInput_ io inputs and convert to gamepad keys
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    1,713 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    2,284 ( 0.00%)      if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
        .               {
        .                   #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
        .                   #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
-- line 9641 ----------------------------------------
-- line 9649 ----------------------------------------
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
        .                   MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
        .                   #undef NAV_MAP_KEY
        .               }
        .           #endif
        .           
        .               // Update aliases
        .               for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
   13,139 ( 0.00%)          UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
    3,997 ( 0.00%)      UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
    2,855 ( 0.00%)      UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
        .           
        .               // Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
        .               // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
        .               // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
        .               // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
      571 ( 0.00%)      const ImGuiKeyChord prev_key_mods = io.KeyMods;
    1,713 ( 0.00%)      io.KeyMods = GetMergedModsFromKeys();
    6,281 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:GetMergedModsFromKeys() (571x)
    7,423 ( 0.00%)      io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
    1,142 ( 0.00%)      io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
    1,142 ( 0.00%)      io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
        .               io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
    1,142 ( 0.00%)      if (prev_key_mods != io.KeyMods)
        .                   g.LastKeyModsChangeTime = g.Time;
        .               if (prev_key_mods != io.KeyMods && prev_key_mods == 0)
        .                   g.LastKeyModsChangeFromNoneTime = g.Time;
        .           
        .               // Clear gamepad data if disabled
    1,142 ( 0.00%)      if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
   41,683 ( 0.00%)          for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
        .                   {
   13,704 ( 0.00%)              io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
   13,704 ( 0.00%)              io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
        .                   }
        .           
        .               // Update keys
1,524,560 ( 0.00%)      for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
        .               {
        .                   ImGuiKeyData* key_data = &io.KeysData[i];
  760,572 ( 0.00%)          key_data->DownDurationPrev = key_data->DownDuration;
1,142,729 ( 0.00%)          key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
      148 ( 0.00%)          if (key_data->DownDuration == 0.0f)
        .                   {
        .                       ImGuiKey key = (ImGuiKey)(ImGuiKey_KeysData_OFFSET + i);
       30 ( 0.00%)              if (IsKeyboardKey(key))
       12 ( 0.00%)                  g.LastKeyboardKeyPressTime = g.Time;
        8 ( 0.00%)              else if (key == ImGuiKey_ReservedForModCtrl || key == ImGuiKey_ReservedForModShift || key == ImGuiKey_ReservedForModAlt || key == ImGuiKey_ReservedForModSuper)
        .                           g.LastKeyboardKeyPressTime = g.Time;
        .                   }
        .               }
        .           
        .               // Update keys/input owner (named keys only): one entry per key
  351,736 ( 0.00%)      for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
        .               {
        .                   ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
        .                   ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
  175,868 ( 0.00%)          owner_data->OwnerCurr = owner_data->OwnerNext;
  175,868 ( 0.00%)          if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
   87,878 ( 0.00%)              owner_data->OwnerNext = ImGuiKeyOwner_None;
  175,868 ( 0.00%)          owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
        .               }
        .           
        .               // Update key routing (for e.g. shortcuts)
        .               UpdateKeyRoutingTable(&g.KeysRoutingTable);
    4,568 ( 0.00%)  }
        .           
        .           static void ImGui::UpdateMouseInputs()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
        .           
        .               // Mouse Wheel swapping flag
        .               // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
        .               // - We avoid doing it on OSX as it the OS input layer handles this already.
        .               // - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
        .               // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
    2,284 ( 0.00%)      io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;
        .           
        .               // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
      571 ( 0.00%)      if (IsMousePosValid(&io.MousePos))
      927 ( 0.00%)          io.MousePos = g.MouseLastValidPos = ImFloor(io.MousePos);
        .           
        .               // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
        .               if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
      604 ( 0.00%)          io.MouseDelta = io.MousePos - io.MousePosPrev;
        .               else
      269 ( 0.00%)          io.MouseDelta = ImVec2(0.0f, 0.0f);
        .           
        .               // Update stationary timer.
        .               // FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
    1,208 ( 0.00%)      const float mouse_stationary_threshold = (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0f : 3.0f; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
        .               const bool mouse_stationary = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
    2,317 ( 0.00%)      g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
        .               //IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);
        .           
        .               // If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
    3,209 ( 0.00%)      if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
      172 ( 0.00%)          g.NavDisableMouseHover = false;
        .           
   17,130 ( 0.00%)      for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
        .               {
   11,426 ( 0.00%)          io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
    2,849 ( 0.00%)          io.MouseClickedCount[i] = 0; // Will be filled below
   10,839 ( 0.00%)          io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
        6 ( 0.00%)          io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
    4,570 ( 0.00%)          io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
        .                   if (io.MouseClicked[i])
        .                   {
        .                       bool is_repeated_click = false;
       28 ( 0.00%)              if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
        .                       {
        .                           ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
        .                           if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
        .                               is_repeated_click = true;
        .                       }
        .                       if (is_repeated_click)
        .                           io.MouseClickedLastCount[i]++;
        .                       else
        4 ( 0.00%)                  io.MouseClickedLastCount[i] = 1;
        4 ( 0.00%)              io.MouseClickedTime[i] = g.Time;
       12 ( 0.00%)              io.MouseClickedPos[i] = io.MousePos;
        4 ( 0.00%)              io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
        4 ( 0.00%)              io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
        4 ( 0.00%)              io.MouseDragMaxDistanceSqr[i] = 0.0f;
        .                   }
        .                   else if (io.MouseDown[i])
        .                   {
        .                       // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
        .                       ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
        8 ( 0.00%)              io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
       20 ( 0.00%)              io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
       16 ( 0.00%)              io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        .                   }
        .           
        .                   // We provide io.MouseDoubleClicked[] as a legacy service
    2,855 ( 0.00%)          io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
        .           
        .                   // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
    2,851 ( 0.00%)          if (io.MouseClicked[i])
        8 ( 0.00%)              g.NavDisableMouseHover = false;
        .               }
        .           }
        .           
        .           static void LockWheelingWindow(ImGuiWindow* window, float wheel_amount)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (window)
        .                   g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
-- line 9796 ----------------------------------------
-- line 9844 ----------------------------------------
        .                   g.WheelingWindowWheelRemainder = wheel;
        .                   return NULL;
        .               }
        .               return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
        .           }
        .           
        .           // Called by NewFrame()
        .           void ImGui::UpdateMouseWheel()
    2,855 ( 0.00%)  {
        .               // Reset the locked window if we move the mouse or after the timer elapses.
        .               // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      if (g.WheelingWindow != NULL)
        .               {
        .                   g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
        .                   if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
        .                       g.WheelingWindowReleaseTimer = 0.0f;
        .                   if (g.WheelingWindowReleaseTimer <= 0.0f)
        .                       LockWheelingWindow(NULL, 0.0f);
        .               }
        .           
        .               ImVec2 wheel;
      571 ( 0.00%)      wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_None) ? g.IO.MouseWheelH : 0.0f;
      259 ( 0.00%)      wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_None) ? g.IO.MouseWheel : 0.0f;
        .           
        .               //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
    2,284 ( 0.00%)      ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
    1,919 ( 0.00%)      if (!mouse_window || mouse_window->Collapsed)
        .                   return;
        .           
        .               // Zoom / Scale window
        .               // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    1,295 ( 0.00%)      if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
        .               {
        .                   LockWheelingWindow(mouse_window, wheel.y);
        .                   ImGuiWindow* window = mouse_window;
        .                   const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
        .                   const float scale = new_font_scale / window->FontWindowScale;
        .                   window->FontWindowScale = new_font_scale;
        .                   if (window == window->RootWindow)
        .                   {
        .                       const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
        .                       SetWindowPos(window, window->Pos + offset, 0);
        .                       window->Size = ImTrunc(window->Size * scale);
        .                       window->SizeFull = ImTrunc(window->SizeFull * scale);
        .                   }
        .                   return;
        .               }
      518 ( 0.00%)      if (g.IO.KeyCtrl)
        .                   return;
        .           
        .               // Mouse wheel scrolling
        .               // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
      518 ( 0.00%)      if (g.IO.MouseWheelRequestAxisSwap)
        .                   wheel = ImVec2(wheel.y, 0.0f);
        .           
        .               // Maintain a rough average of moving magnitude on both axises
        .               // FIXME: should by based on wall clock time rather than frame-counter
      259 ( 0.00%)      g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
        .               g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
        .           
        .               // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
        .               wheel += g.WheelingWindowWheelRemainder;
      259 ( 0.00%)      g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
    2,849 ( 0.00%)      if (wheel.x == 0.0f && wheel.y == 0.0f)
        .                   return;
        .           
        .               // Mouse wheel scrolling: find target and apply
        .               // - don't renew lock if axis doesn't apply on the window.
        .               // - select a main axis when both axises are being moved.
        .               if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
        .                   if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
        .                   {
-- line 9916 ----------------------------------------
-- line 9929 ----------------------------------------
        .                       {
        .                           LockWheelingWindow(window, wheel.y);
        .                           float max_step = window->InnerRect.GetHeight() * 0.67f;
        .                           float scroll_step = ImTrunc(ImMin(5 * window->CalcFontSize(), max_step));
        .                           SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
        .                           g.WheelingWindowScrolledFrame = g.FrameCount;
        .                       }
        .                   }
    3,426 ( 0.00%)  }
        .           
        .           void ImGui::SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
        .           }
        .           
        .           void ImGui::SetNextFrameWantCaptureMouse(bool want_capture_mouse)
-- line 9945 ----------------------------------------
-- line 9974 ----------------------------------------
        .           }
        .           #endif
        .           
        .           // Process input queue
        .           // We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
        .           // - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
        .           // - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
        .           void ImGui::UpdateInputEvents(bool trickle_fast_inputs)
    5,139 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
        .           
        .               // Only trickle chars<>key when working with InputText()
        .               // FIXME: InputText() could parse event trail?
        .               // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
    2,284 ( 0.00%)      const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
        .           
      952 ( 0.00%)      bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
      136 ( 0.00%)      int  mouse_button_changed = 0x00;
        .               ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
        .           
      136 ( 0.00%)      int event_n = 0;
   23,664 ( 0.00%)      for (; event_n < g.InputEventsQueue.Size; event_n++)
        .               {
        .                   ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
   20,204 ( 0.00%)          if (e->Type == ImGuiInputEventType_MousePos)
        .                   {
    9,722 ( 0.00%)              if (g.IO.WantSetMousePos)
        .                           continue;
        .                       // Trickling Rule: Stop processing queued events if we already handled a mouse button change
    4,861 ( 0.00%)              ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
   34,012 ( 0.00%)              if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
        .                           break;
    4,856 ( 0.00%)              io.MousePos = event_pos;
   19,424 ( 0.00%)              io.MouseSource = e->MousePos.MouseSource;
   14,568 ( 0.00%)              mouse_moved = true;
        .                   }
        .                   else if (e->Type == ImGuiInputEventType_MouseButton)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if we got multiple action on the same button
        9 ( 0.00%)              const ImGuiMouseButton button = e->MouseButton.Button;
       18 ( 0.00%)              IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
       34 ( 0.00%)              if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
        .                           break;
       40 ( 0.00%)              if (trickle_fast_inputs && e->MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) // #2702: TouchScreen have no initial hover.
        .                           break;
       35 ( 0.00%)              io.MouseDown[button] = e->MouseButton.Down;
        8 ( 0.00%)              io.MouseSource = e->MouseButton.MouseSource;
       32 ( 0.00%)              mouse_button_changed |= (1 << button);
        .                   }
        .                   else if (e->Type == ImGuiInputEventType_MouseWheel)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if we got multiple action on the event
        .                       if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
        .                           break;
        .                       io.MouseWheelH += e->MouseWheel.WheelX;
        .                       io.MouseWheel += e->MouseWheel.WheelY;
        .                       io.MouseSource = e->MouseWheel.MouseSource;
        .                       mouse_wheeled = true;
        .                   }
        .                   else if (e->Type == ImGuiInputEventType_MouseViewport)
        .                   {
       57 ( 0.00%)              io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
        .                   }
        .                   else if (e->Type == ImGuiInputEventType_Key)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if we got multiple action on the same button
       11 ( 0.00%)              ImGuiKey key = e->Key.Key;
       22 ( 0.00%)              IM_ASSERT(key != ImGuiKey_None);
        .                       ImGuiKeyData* key_data = GetKeyData(key);
       66 ( 0.00%)              const int key_data_index = (int)(key_data - g.IO.KeysData);
       99 ( 0.00%)              if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
        .                           break;
       11 ( 0.00%)              key_data->Down = e->Key.Down;
       22 ( 0.00%)              key_data->AnalogValue = e->Key.AnalogValue;
      555 ( 0.00%)              key_changed = true;
        .                       key_changed_mask.SetBit(key_data_index);
        .           
        .                       // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
       22 ( 0.00%)              io.KeysDown[key_data_index] = key_data->Down;
       33 ( 0.00%)              if (io.KeyMap[key_data_index] != -1)
       22 ( 0.00%)                  io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
        .           #endif
        .                   }
        .                   else if (e->Type == ImGuiInputEventType_Text)
        .                   {
        .                       // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
    1,160 ( 0.00%)              if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
        .                           break;
      130 ( 0.00%)              unsigned int c = e->Text.Char;
      390 ( 0.00%)              io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
      390 ( 0.00%)              if (trickle_interleaved_keys_and_text)
        .                           text_inputted = true;
        .                   }
        .                   else if (e->Type == ImGuiInputEventType_Focus)
        .                   {
        .                       // We intentionally overwrite this and process in NewFrame(), in order to give a chance
        .                       // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
       12 ( 0.00%)              const bool focus_lost = !e->AppFocused.Focused;
       12 ( 0.00%)              io.AppFocusLost = focus_lost;
        .                   }
        .                   else
        .                   {
        .                       IM_ASSERT(0 && "Unknown event!");
        .                   }
        .               }
        .           
        .               // Record trail (for domain-specific applications wanting to access a precise trail)
        .               //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
   25,056 ( 0.00%)      for (int n = 0; n < event_n; n++)
        .                   g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
        .           
        .               // [DEBUG]
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
      272 ( 0.00%)      if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
    5,030 ( 0.00%)          for (int n = 0; n < g.InputEventsQueue.Size; n++)
        .                       DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
        .           #endif
        .           
        .               // Remaining events will be processed on the next frame
    1,142 ( 0.00%)      if (event_n == g.InputEventsQueue.Size)
        .                   g.InputEventsQueue.resize(0);
        .               else
      105 ( 0.00%)          g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
        .           
        .               // Clear buttons state when focus is lost
        .               // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
        .               // - we clear in EndFrame() and not now in order allow application/user code polling this flag
        .               //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
    1,142 ( 0.00%)      if (g.IO.AppFocusLost)
       12 ( 0.00%)          g.IO.ClearInputKeys();
    8,898 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiIO::ClearInputKeys() (6x)
    4,562 ( 0.00%)  }
        .           
        .           ImGuiID ImGui::GetKeyOwner(ImGuiKey key)
        .           {
        .               if (!IsNamedKeyOrModKey(key))
        .                   return ImGuiKeyOwner_None;
        .           
        .               ImGuiContext& g = *GImGui;
        .               ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
-- line 10114 ----------------------------------------
-- line 10122 ----------------------------------------
        .           }
        .           
        .           // TestKeyOwner(..., ID)   : (owner == None || owner == ID)
        .           // TestKeyOwner(..., None) : (owner == None)
        .           // TestKeyOwner(..., Any)  : no owner test
        .           // All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
        .           bool ImGui::TestKeyOwner(ImGuiKey key, ImGuiID owner_id)
        .           {
      200 ( 0.00%)      if (!IsNamedKeyOrModKey(key))
       50 ( 0.00%)          return true;
        .           
        .               ImGuiContext& g = *GImGui;
      571 ( 0.00%)      if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
        .                   if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
        .                       return false;
        .           
        .               ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
        .               if (owner_id == ImGuiKeyOwner_Any)
        .                   return (owner_data->LockThisFrame == false);
        .           
        .               // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
        .               // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
        .               // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
    3,426 ( 0.00%)      if (owner_data->OwnerCurr != owner_id)
        .               {
        .                   if (owner_data->LockThisFrame)
        .                       return false;
        .                   if (owner_data->OwnerCurr != ImGuiKeyOwner_None)
        .                       return false;
        .               }
        .           
        .               return true;
       50 ( 0.00%)  }
        .           
        .           // _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
        .           // When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
        .           // - SetKeyOwner(..., None)              : clears owner
        .           // - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
        .           // - SetKeyOwner(..., Any or None, Lock) : set lock
        .           void ImGui::SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
        .           {
-- line 10162 ----------------------------------------
-- line 10210 ----------------------------------------
        .           bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord)
        .           {
        .               return IsKeyChordPressed(key_chord, 0, ImGuiInputFlags_None);
        .           }
        .           
        .           // This is equivalent to comparing KeyMods + doing a IsKeyPressed()
        .           bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
        .           {
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               key_chord = FixupKeyChord(&g, key_chord);
    2,284 ( 0.00%)      ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
    2,284 ( 0.00%)      if (g.IO.KeyMods != mods)
        .                   return false;
        .           
        .               // Special storage location for mods
        .               ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
        .               if (key == ImGuiKey_None)
        .                   key = ConvertSingleModFlagToKey(&g, mods);
        .               if (!IsKeyPressed(key, owner_id, (flags & ImGuiInputFlags_RepeatMask_)))
        .                   return false;
-- line 10229 ----------------------------------------
-- line 10233 ----------------------------------------
        .           void ImGui::SetNextItemShortcut(ImGuiKeyChord key_chord)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasShortcut;
        .               g.NextItemData.Shortcut = key_chord;
        .           }
        .           
        .           bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
    6,852 ( 0.00%)  {
        .               //ImGuiContext& g = *GImGui;
        .               //IMGUI_DEBUG_LOG("Shortcut(%s, owner_id=0x%08X, flags=%X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), owner_id, flags);
        .           
        .               // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
        .               if ((flags & ImGuiInputFlags_RouteMask_) == 0)
    4,568 ( 0.00%)          flags |= ImGuiInputFlags_RouteFocused;
        .           
        .               // Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
        .               // Effectively makes Shortcut() always input-owner aware.
    3,426 ( 0.00%)      if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_None)
        .                   owner_id = GetRoutingIdFromOwnerId(owner_id);
        .           
        .               // Submit route
    6,852 ( 0.00%)      if (!SetShortcutRouting(key_chord, owner_id, flags))
   50,248 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetShortcutRouting(int, unsigned int, int) (1,142x)
    1,142 ( 0.00%)          return false;
        .           
        .               // Default repeat behavior for Shortcut()
        .               // So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
    2,284 ( 0.00%)      if ((flags & ImGuiInputFlags_Repeat) != 0 && (flags & ImGuiInputFlags_RepeatUntilMask_) == 0)
    4,568 ( 0.00%)          flags |= ImGuiInputFlags_RepeatUntilKeyModsChange;
        .           
        .               if (!IsKeyChordPressed(key_chord, owner_id, flags))
        .                   return false;
        .               IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
        .               return true;
    4,568 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ERROR CHECKING
        .           //-----------------------------------------------------------------------------
        .           
        .           // Helper function to verify ABI compatibility between caller code and compiled version of Dear ImGui.
        .           // This is called by IMGUI_CHECKVERSION().
-- line 10275 ----------------------------------------
-- line 10323 ----------------------------------------
        .               IM_ASSERT(0 && "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.");
        .           #else
        .               window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
        .           #endif
        .           }
        .           
        .           static void ImGui::ErrorCheckNewFrameSanityChecks()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Check user IM_ASSERT macro
        .               // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
        .               //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
        .               //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
        .               // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
        .               // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
        .               if (true) IM_ASSERT(1); else IM_ASSERT(0);
-- line 10339 ----------------------------------------
-- line 10342 ----------------------------------------
        .               // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
        .           #ifdef __EMSCRIPTEN__
        .               if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
        .                   g.IO.DeltaTime = 0.00001f;
        .           #endif
        .           
        .               // Check user data
        .               // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    1,142 ( 0.00%)      IM_ASSERT(g.Initialized);
    2,855 ( 0.00%)      IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
    2,282 ( 0.00%)      IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    3,997 ( 0.00%)      IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
    1,713 ( 0.00%)      IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
    1,713 ( 0.00%)      IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
    1,713 ( 0.00%)      IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
    3,426 ( 0.00%)      IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
    3,426 ( 0.00%)      IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
    5,139 ( 0.00%)      IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
    3,426 ( 0.00%)      IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
        .           #ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
  263,802 ( 0.00%)      for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
  351,736 ( 0.00%)          IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
        .           
        .               // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
    1,713 ( 0.00%)      if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
        .                   IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
        .           #endif
        .           
        .               // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    2,284 ( 0.00%)      if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        .                   g.IO.ConfigWindowsResizeFromEdges = false;
        .           
        .               // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
    1,146 ( 0.00%)      if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
        .                   IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
        4 ( 0.00%)      if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
        .                   IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
        .           
        .               // Perform simple checks: multi-viewport and platform windows support
    1,140 ( 0.00%)      if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        .               {
    2,284 ( 0.00%)          if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
        .                   {
    2,280 ( 0.00%)              IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
    1,142 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
    1,142 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
    1,142 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
    1,142 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
    1,142 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
    1,142 ( 0.00%)              IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
    1,713 ( 0.00%)              IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
    2,284 ( 0.00%)              IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
    1,142 ( 0.00%)              if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .                           IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
        .                   }
        .                   else
        .                   {
        .                       // Disable feature, our backends do not support it
        .                       g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
        .                   }
        .           
        .                   // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
    4,568 ( 0.00%)          for (ImGuiPlatformMonitor& mon : g.PlatformIO.Monitors)
        .                   {
        .                       IM_UNUSED(mon);
    7,423 ( 0.00%)              IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
        .                       IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
    3,426 ( 0.00%)              IM_ASSERT(mon.DpiScale != 0.0f);
        .                   }
        .               }
        .           }
        .           
        .           static void ImGui::ErrorCheckEndFrameSanityChecks()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
        .               // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
        .               // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
        .               // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
        .               // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
        .               // while still correctly asserting on mid-frame key press events.
      571 ( 0.00%)      const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
    6,281 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:GetMergedModsFromKeys() (571x)
    1,142 ( 0.00%)      IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
        .               IM_UNUSED(key_mods);
        .           
        .               // [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
        .               //ErrorCheckEndFrameRecover();
        .           
        .               // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
        .               // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
    1,713 ( 0.00%)      if (g.CurrentWindowStack.Size != 1)
        .               {
        .                   if (g.CurrentWindowStack.Size > 1)
        .                   {
        .                       ImGuiWindow* window = g.CurrentWindowStack.back().Window; // <-- This window was not Ended!
        .                       IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
        .                       IM_UNUSED(window);
        .                       while (g.CurrentWindowStack.Size > 1)
        .                           End();
        .                   }
        .                   else
        .                   {
        .                       IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
        .                   }
        .               }
        .           
    1,713 ( 0.00%)      IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
        .           }
        .           
        .           // Experimental recovery from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
        .           // Must be called during or before EndFrame().
        .           // This is generally flawed as we are not necessarily End/Popping things in the right order.
        .           // FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
        .           // FIXME: Can't recover from interleaved BeginTabBar/Begin
        .           void    ImGui::ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data)
-- line 10457 ----------------------------------------
-- line 10545 ----------------------------------------
        .               }
        .           }
        .           
        .           // Save current stack sizes for later compare
        .           void ImGuiStackSizes::SetToContextState(ImGuiContext* ctx)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiWindow* window = g.CurrentWindow;
   34,272 ( 0.00%)      SizeOfIDStack = (short)window->IDStack.Size;
        .               SizeOfColorStack = (short)g.ColorStack.Size;
        .               SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
        .               SizeOfFontStack = (short)g.FontStack.Size;
        .               SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
        .               SizeOfGroupStack = (short)g.GroupStack.Size;
        .               SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
        .               SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
    5,712 ( 0.00%)      SizeOfDisabledStack = (short)g.DisabledStackSize;
        .           }
        .           
        .           // Compare to detect usage errors
        .           void ImGuiStackSizes::CompareWithContextState(ImGuiContext* ctx)
    2,856 ( 0.00%)  {
        .               ImGuiContext& g = *ctx;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               IM_UNUSED(window);
        .           
        .               // Window stacks
        .               // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
   11,424 ( 0.00%)      IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");
        .           
        .               // Global stacks
        .               // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    8,568 ( 0.00%)      IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfDisabledStack   == g.DisabledStackSize      && "BeginDisabled/EndDisabled Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfItemFlagsStack  >= g.ItemFlagsStack.Size    && "PushItemFlag/PopItemFlag Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
    8,568 ( 0.00%)      IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
    5,712 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] ITEM SUBMISSION
        .           //-----------------------------------------------------------------------------
        .           // - KeepAliveID()
        .           // - ItemHandleShortcut() [Internal]
        .           // - ItemAdd()
        .           //-----------------------------------------------------------------------------
        .           
        .           // Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
        .           void ImGui::KeepAliveID(ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
   13,710 ( 0.00%)      if (g.ActiveId == id)
        6 ( 0.00%)          g.ActiveIdIsAlive = id;
    9,152 ( 0.00%)      if (g.ActiveIdPreviousFrame == id)
       12 ( 0.00%)          g.ActiveIdPreviousFrameIsAlive = true;
        .           }
        .           
        .           static void ItemHandleShortcut(ImGuiID id)
        .           {
        .               // FIXME: Generalize Activation queue?
        .               ImGuiContext& g = *GImGui;
        .               if (ImGui::Shortcut(g.NextItemData.Shortcut, id, ImGuiInputFlags_None) && g.NavActivateId == 0)
        .               {
-- line 10610 ----------------------------------------
-- line 10616 ----------------------------------------
        .               }
        .           }
        .           
        .           // Declare item bounding box for clipping and interaction.
        .           // Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
        .           // declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
        .           // THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)
        .           bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg, ImGuiItemFlags extra_flags)
   36,560 ( 0.00%)  {
    9,140 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,570 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
        .               // Set item data
        .               // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
    4,570 ( 0.00%)      g.LastItemData.ID = id;
    9,140 ( 0.00%)      g.LastItemData.Rect = bb;
   18,280 ( 0.00%)      g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
   18,280 ( 0.00%)      g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
    4,570 ( 0.00%)      g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
        .               // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.
        .           
    9,140 ( 0.00%)      if (id != 0)
        .               {
        .                   KeepAliveID(id);
        .           
        .                   // Directional navigation processing
        .                   // Runs prior to clipping early-out
        .                   //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        .                   //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
        .                   //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
        .                   //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        .                   //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
        .                   //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
        .                   // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
        .                   // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
    9,140 ( 0.00%)          if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
        .                   {
        .                       // FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
   15,996 ( 0.00%)              window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
   19,995 ( 0.00%)              if (g.NavId == id || g.NavAnyRequest)
       36 ( 0.00%)                  if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
       18 ( 0.00%)                      if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
        .                                   NavProcessItem();
        .                   }
        .           
    9,140 ( 0.00%)          if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasShortcut)
        .                       ItemHandleShortcut(id);
        .               }
        .           
        .               // Lightweight clear of SetNextItemXXX data.
    4,570 ( 0.00%)      g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
        .               g.NextItemData.ItemFlags = ImGuiItemFlags_None;
        .           
        .           #ifdef IMGUI_ENABLE_TEST_ENGINE
        .               if (id != 0)
        .                   IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
        .           #endif
        .           
        .               // Clipping test
-- line 10674 ----------------------------------------
-- line 10682 ----------------------------------------
        .                   if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
        .                       if (!g.LogEnabled)
        .                           return false;
        .           
        .               // [DEBUG]
        .           #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        .               if (id != 0)
        .               {
    9,140 ( 0.00%)          if (id == g.DebugLocateId)
        .                       DebugLocateItemResolveWithLastItem();
        .           
        .                   // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
        .                   // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
        .                   // READ THE FAQ: https://dearimgui.com/faq
   13,710 ( 0.00%)          IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
        .               }
        .               //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
        .               //if ((g.LastItemData.InFlags & ImGuiItemFlags_NoNav) == 0)
        .               //    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
        .           #endif
        .           
        .               // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
        .               if (is_rect_visible)
    4,570 ( 0.00%)          g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
        .               if (IsMouseHoveringRect(bb.Min, bb.Max))
      256 ( 0.00%)          g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    4,570 ( 0.00%)      return true;
   36,560 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] LAYOUT
        .           //-----------------------------------------------------------------------------
        .           // - ItemSize()
        .           // - SameLine()
        .           // - GetCursorScreenPos()
-- line 10717 ----------------------------------------
-- line 10740 ----------------------------------------
        .           // Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
        .           //-----------------------------------------------------------------------------
        .           
        .           // Advance cursor given item size for layout.
        .           // Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
        .           // See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
        .           // THIS IS IN THE PERFORMANCE CRITICAL PATH.
        .           void ImGui::ItemSize(const ImVec2& size, float text_baseline_y)
    3,997 ( 0.00%)  {
    3,997 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,997 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    7,994 ( 0.00%)      if (window->SkipItems)
        .                   return;
        .           
        .               // We increase the height in this function to accommodate for baseline offset.
        .               // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
        .               // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
   34,260 ( 0.00%)      const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
        .           
   18,843 ( 0.00%)      const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
   15,988 ( 0.00%)      const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
        .           
        .               // Always align ourselves on pixel boundaries
        .               //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
   15,988 ( 0.00%)      window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
    3,997 ( 0.00%)      window->DC.CursorPosPrevLine.y = line_y1;
   31,976 ( 0.00%)      window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
   19,985 ( 0.00%)      window->DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
   15,988 ( 0.00%)      window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
   23,982 ( 0.00%)      window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
        .               //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
        .           
    3,997 ( 0.00%)      window->DC.PrevLineSize.y = line_height;
    3,997 ( 0.00%)      window->DC.CurrLineSize.y = 0.0f;
    7,994 ( 0.00%)      window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
    3,997 ( 0.00%)      window->DC.CurrLineTextBaseOffset = 0.0f;
    3,997 ( 0.00%)      window->DC.IsSameLine = window->DC.IsSetPos = false;
        .           
        .               // Horizontal layout mode
   11,991 ( 0.00%)      if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        .                   SameLine();
    3,997 ( 0.00%)  }
        .           
        .           // Gets back to previous line and continue with horizontal layout
        .           //      offset_from_start_x == 0 : follow right after previous item
        .           //      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
        .           //      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
        .           //      spacing_w >= 0           : enforce spacing amount
        .           void ImGui::SameLine(float offset_from_start_x, float spacing_w)
        .           {
-- line 10789 ----------------------------------------
-- line 10798 ----------------------------------------
        .                       spacing_w = 0.0f;
        .                   window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        .                   window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
        .               }
        .               else
        .               {
        .                   if (spacing_w < 0.0f)
        .                       spacing_w = g.Style.ItemSpacing.x;
   10,278 ( 0.00%)          window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        .                   window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
        .               }
    6,852 ( 0.00%)      window->DC.CurrLineSize = window->DC.PrevLineSize;
    3,426 ( 0.00%)      window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
    3,426 ( 0.00%)      window->DC.IsSameLine = true;
        .           }
        .           
        .           ImVec2 ImGui::GetCursorScreenPos()
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               return window->DC.CursorPos;
        .           }
        .           
-- line 10819 ----------------------------------------
-- line 10857 ----------------------------------------
        .           {
        .               ImGuiWindow* window = GetCurrentWindow();
        .               window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
        .               //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
        .               window->DC.IsSetPos = true;
        .           }
        .           
        .           void ImGui::SetCursorPosY(float y)
    2,855 ( 0.00%)  {
        .               ImGuiWindow* window = GetCurrentWindow();
   11,420 ( 0.00%)      window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
        .               //window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
    2,855 ( 0.00%)      window->DC.IsSetPos = true;
    2,855 ( 0.00%)  }
        .           
        .           ImVec2 ImGui::GetCursorStartPos()
        .           {
        .               ImGuiWindow* window = GetCurrentWindowRead();
        .               return window->DC.CursorStartPos - window->Pos;
        .           }
        .           
        .           void ImGui::Indent(float indent_w)
-- line 10878 ----------------------------------------
-- line 11016 ----------------------------------------
        .               return mx - window->Pos;
        .           }
        .           
        .           // [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.
        .           ImVec2 ImGui::GetContentRegionMaxAbs()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
   10,278 ( 0.00%)      ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
        .               return mx;
        .           }
        .           
        .           ImVec2 ImGui::GetContentRegionAvail()
        .           {
    3,426 ( 0.00%)      ImGuiWindow* window = GImGui->CurrentWindow;
        .               return GetContentRegionMaxAbs() - window->DC.CursorPos;
    1,142 ( 0.00%)  }
        .           
        .           // In window space (not screen space!)
        .           ImVec2 ImGui::GetWindowContentRegionMin()
        .           {
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->ContentRegionRect.Min - window->Pos;
        .           }
        .           
-- line 11040 ----------------------------------------
-- line 11043 ----------------------------------------
        .               ImGuiWindow* window = GImGui->CurrentWindow;
        .               return window->ContentRegionRect.Max - window->Pos;
        .           }
        .           
        .           // Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
        .           // Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
        .           // FIXME-OPT: Could we safely early out on ->SkipItems?
        .           void ImGui::BeginGroup()
    2,855 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
      571 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
        .           
    1,142 ( 0.00%)      g.GroupStack.resize(g.GroupStack.Size + 1);
        .               ImGuiGroupData& group_data = g.GroupStack.back();
    1,142 ( 0.00%)      group_data.WindowID = window->ID;
    1,142 ( 0.00%)      group_data.BackupCursorPos = window->DC.CursorPos;
    1,142 ( 0.00%)      group_data.BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
    1,142 ( 0.00%)      group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    1,142 ( 0.00%)      group_data.BackupIndent = window->DC.Indent;
    1,142 ( 0.00%)      group_data.BackupGroupOffset = window->DC.GroupOffset;
    1,142 ( 0.00%)      group_data.BackupCurrLineSize = window->DC.CurrLineSize;
    1,142 ( 0.00%)      group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
    1,142 ( 0.00%)      group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    1,713 ( 0.00%)      group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
    1,142 ( 0.00%)      group_data.BackupIsSameLine = window->DC.IsSameLine;
    1,142 ( 0.00%)      group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
      571 ( 0.00%)      group_data.EmitItem = true;
        .           
    2,284 ( 0.00%)      window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
      571 ( 0.00%)      window->DC.Indent = window->DC.GroupOffset;
    1,142 ( 0.00%)      window->DC.CursorMaxPos = window->DC.CursorPos;
      571 ( 0.00%)      window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    1,142 ( 0.00%)      if (g.LogEnabled)
        .                   g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
    3,426 ( 0.00%)  }
        .           
        .           void ImGui::EndGroup()
    2,855 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
      571 ( 0.00%)      ImGuiWindow* window = g.CurrentWindow;
    1,713 ( 0.00%)      IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls
        .           
        .               ImGuiGroupData& group_data = g.GroupStack.back();
    1,713 ( 0.00%)      IM_ASSERT(group_data.WindowID == window->ID); // EndGroup() in wrong window?
        .           
    1,142 ( 0.00%)      if (window->DC.IsSetPos)
        .                   ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
        .           
        .               ImRect group_bb(group_data.BackupCursorPos, ImMax(window->DC.CursorMaxPos, group_data.BackupCursorPos));
        .           
    1,142 ( 0.00%)      window->DC.CursorPos = group_data.BackupCursorPos;
    1,713 ( 0.00%)      window->DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine;
      571 ( 0.00%)      window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    1,142 ( 0.00%)      window->DC.Indent = group_data.BackupIndent;
    1,142 ( 0.00%)      window->DC.GroupOffset = group_data.BackupGroupOffset;
    1,713 ( 0.00%)      window->DC.CurrLineSize = group_data.BackupCurrLineSize;
    1,142 ( 0.00%)      window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
    1,142 ( 0.00%)      window->DC.IsSameLine = group_data.BackupIsSameLine;
    1,142 ( 0.00%)      if (g.LogEnabled)
        .                   g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
        .           
    1,142 ( 0.00%)      if (!group_data.EmitItem)
        .               {
        .                   g.GroupStack.pop_back();
        .                   return;
        .               }
        .           
        .               window->DC.CurrLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        .               ItemSize(group_bb.GetSize());
        .               ItemAdd(group_bb, 0, NULL, ImGuiItemFlags_NoTabStop);
-- line 11112 ----------------------------------------
-- line 11135 ----------------------------------------
        .               // Forward Deactivated flag
        .               g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
        .               if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
        .                   g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Deactivated;
        .           
        .               g.GroupStack.pop_back();
        .               if (g.DebugShowGroupRects)
        .                   window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
    3,426 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] SCROLLING
        .           //-----------------------------------------------------------------------------
        .           
        .           // Helper to snap on edges when aiming at an item very close to the edge,
        .           // So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
-- line 11151 ----------------------------------------
-- line 11156 ----------------------------------------
        .               if (target <= snap_min + snap_threshold)
        .                   return ImLerp(snap_min, target, center_ratio);
        .               if (target >= snap_max - snap_threshold)
        .                   return ImLerp(target, snap_max, center_ratio);
        .               return target;
        .           }
        .           
        .           static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)
    2,856 ( 0.00%)  {
    2,856 ( 0.00%)      ImVec2 scroll = window->Scroll;
    8,568 ( 0.00%)      ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
        .               for (int axis = 0; axis < 2; axis++)
        .               {
   19,992 ( 0.00%)          if (window->ScrollTarget[axis] < FLT_MAX)
        .                   {
        .                       float center_ratio = window->ScrollTargetCenterRatio[axis];
        .                       float scroll_target = window->ScrollTarget[axis];
        .                       if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
        .                       {
        .                           float snap_min = 0.0f;
        .                           float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
        .                           scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
        .                       }
        .                       scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
        .                   }
   79,968 ( 0.00%)          scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0f));
   25,704 ( 0.00%)          if (!window->Collapsed && !window->SkipItems)
   37,128 ( 0.00%)              scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
        .               }
        .               return scroll;
    5,712 ( 0.00%)  }
        .           
        .           void ImGui::ScrollToItem(ImGuiScrollFlags flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               ScrollToRectEx(window, g.LastItemData.NavRect, flags);
        .           }
        .           
-- line 11194 ----------------------------------------
-- line 11480 ----------------------------------------
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] POPUPS
        .           //-----------------------------------------------------------------------------
        .           
        .           // Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
        .           bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags)
    6,852 ( 0.00%)  {
    3,426 ( 0.00%)      ImGuiContext& g = *GImGui;
    6,852 ( 0.00%)      if (popup_flags & ImGuiPopupFlags_AnyPopupId)
        .               {
        .                   // Return true if any popup is open at the current BeginPopup() level of the popup stack
        .                   // This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
        .                   IM_ASSERT(id == 0);
        .                   if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
        .                       return g.OpenPopupStack.Size > 0;
        .                   else
        .                       return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
        .               }
        .               else
        .               {
    6,852 ( 0.00%)          if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
        .                   {
        .                       // Return true if the popup is open anywhere in the popup stack
        .                       for (ImGuiPopupData& popup_data : g.OpenPopupStack)
        .                           if (popup_data.PopupId == id)
        .                               return true;
    3,426 ( 0.00%)              return false;
        .                   }
        .                   else
        .                   {
        .                       // Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
   10,278 ( 0.00%)              return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
        .                   }
        .               }
    6,852 ( 0.00%)  }
        .           
        .           bool ImGui::IsPopupOpen(const char* str_id, ImGuiPopupFlags popup_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiID id = (popup_flags & ImGuiPopupFlags_AnyPopupId) ? 0 : g.CurrentWindow->GetID(str_id);
        .               if ((popup_flags & ImGuiPopupFlags_AnyPopupLevel) && id != 0)
        .                   IM_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."); // But non-string version is legal and used internally
        .               return IsPopupOpen(id, popup_flags);
        .           }
        .           
        .           // Also see FindBlockingModal(NULL)
        .           ImGuiWindow* ImGui::GetTopMostPopupModal()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    5,139 ( 0.00%)      for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        .                   if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
        .                       if (popup->Flags & ImGuiWindowFlags_Modal)
        .                           return popup;
        .               return NULL;
        .           }
        .           
        .           // See Demo->Stacked Modal to confirm what this is for.
        .           ImGuiWindow* ImGui::GetTopMostAndVisiblePopupModal()
        .           {
        .               ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        .                   if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
        .                       if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
        .                           return popup;
        .               return NULL;
        .           }
        .           
        .           void ImGui::OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags)
        .           {
-- line 11550 ----------------------------------------
-- line 11614 ----------------------------------------
        .                   //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        .                   //    FocusWindow(parent_window);
        .               }
        .           }
        .           
        .           // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
        .           // This function closes any popups that are over 'ref_window'.
        .           void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
       30 ( 0.00%)  {
        6 ( 0.00%)      ImGuiContext& g = *GImGui;
       18 ( 0.00%)      if (g.OpenPopupStack.Size == 0)
        .                   return;
        .           
        .               // Don't close our own child popup windows.
        .               //IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
        .               int popup_count_to_keep = 0;
        .               if (ref_window)
        .               {
        .                   // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
-- line 11632 ----------------------------------------
-- line 11658 ----------------------------------------
        .                           break;
        .                   }
        .               }
        .               if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
        .               {
        .                   IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
        .                   ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
        .               }
       36 ( 0.00%)  }
        .           
        .           void ImGui::ClosePopupsExceptModals()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               int popup_count_to_keep;
        .               for (popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; popup_count_to_keep--)
        .               {
-- line 11674 ----------------------------------------
-- line 12051 ----------------------------------------
        .           //-----------------------------------------------------------------------------
        .           
        .           // FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
        .           // In our terminology those should be interchangeable, yet right now this is super confusing.
        .           // Those two functions are merely a legacy artifact, so at minimum naming should be clarified.
        .           
        .           void ImGui::SetNavWindow(ImGuiWindow* window)
        .           {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
        3 ( 0.00%)      if (g.NavWindow != window)
        .               {
       18 ( 0.00%)          IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
        6 ( 0.00%)          g.NavWindow = window;
       12 ( 0.00%)          g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        .               }
       12 ( 0.00%)      g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        .               NavUpdateAnyRequestFlag();
        .           }
        .           
        .           void ImGui::NavHighlightActivated(ImGuiID id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.NavHighlightActivatedId = id;
        .               g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER;
        .           }
        .           
        .           void ImGui::NavClearPreferredPosForAxis(ImGuiAxis axis)
        .           {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
       20 ( 0.00%)      g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;
        .           }
        .           
        .           void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel)
        .           {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.NavWindow != NULL);
        8 ( 0.00%)      IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
        4 ( 0.00%)      g.NavId = id;
        4 ( 0.00%)      g.NavLayer = nav_layer;
        4 ( 0.00%)      SetNavFocusScope(focus_scope_id);
      278 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavFocusScope(unsigned int) (4x)
       12 ( 0.00%)      g.NavWindow->NavLastIds[nav_layer] = id;
       16 ( 0.00%)      g.NavWindow->NavRectRel[nav_layer] = rect_rel;
        .           
        .               // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
        .               NavClearPreferredPosForAxis(ImGuiAxis_X);
        .               NavClearPreferredPosForAxis(ImGuiAxis_Y);
        .           }
        .           
        .           void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
        .           {
-- line 12100 ----------------------------------------
-- line 12296 ----------------------------------------
        .           }
        .           
        .           // True when current work location may be scrolled horizontally when moving left / right.
        .           // This is generally always true UNLESS within a column. We don't have a vertical equivalent.
        .           void ImGui::NavUpdateCurrentWindowIsScrollPushableX()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
   23,992 ( 0.00%)      window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
        .           }
        .           
        .           // We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
        .           // This is called after LastItemData is set, but NextItemData is also still valid.
        .           static void ImGui::NavProcessItem()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.CurrentWindow;
        .               const ImGuiID id = g.LastItemData.ID;
        .               const ImGuiItemFlags item_flags = g.LastItemData.InFlags;
        .           
        .               // When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
       18 ( 0.00%)      if (window->DC.NavIsScrollPushableX == false)
        .               {
        9 ( 0.00%)          g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
        9 ( 0.00%)          g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
        .               }
       36 ( 0.00%)      const ImRect nav_bb = g.LastItemData.NavRect;
        .           
        .               // Process Init Request
       36 ( 0.00%)      if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
        .               {
        .                   // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        .                   const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
        .                   if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0)
        .                   {
        .                       NavApplyItemToResult(&g.NavInitResult);
        .                   }
        .                   if (candidate_for_nav_default_focus)
-- line 12333 ----------------------------------------
-- line 12334 ----------------------------------------
        .                   {
        .                       g.NavInitRequest = false; // Found a match, clear request
        .                       NavUpdateAnyRequestFlag();
        .                   }
        .               }
        .           
        .               // Process Move Request (scoring for navigation)
        .               // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
       18 ( 0.00%)      if (g.NavMoveScoringItems && (item_flags & ImGuiItemFlags_Disabled) == 0)
        .               {
        .                   if ((g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi) || (window->Flags & ImGuiWindowFlags_NoNavInputs) == 0)
        .                   {
        .                       const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
        .                       if (is_tabbing)
        .                       {
        .                           NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
        .                       }
-- line 12350 ----------------------------------------
-- line 12360 ----------------------------------------
        .                               if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
        .                                   if (NavScoreItem(&g.NavMoveResultLocalVisible))
        .                                       NavApplyItemToResult(&g.NavMoveResultLocalVisible);
        .                       }
        .                   }
        .               }
        .           
        .               // Update information for currently focused/navigated item
       18 ( 0.00%)      if (g.NavId == id)
        .               {
        .                   if (g.NavWindow != window)
        .                       SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
        .                   g.NavLayer = window->DC.NavLayerCurrent;
        .                   SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
        .                   g.NavFocusScopeId = g.CurrentFocusScopeId;
        .                   g.NavIdIsAlive = true;
        .                   if (g.LastItemData.InFlags & ImGuiItemFlags_HasSelectionUserData)
-- line 12376 ----------------------------------------
-- line 12445 ----------------------------------------
        .                       NavMoveRequestResolveWithLastItem(result);
        .                   if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
        .                       NavApplyItemToResult(&g.NavTabbingResultFirst);
        .               }
        .           }
        .           
        .           bool ImGui::NavMoveRequestButNoResultYet()
        .           {
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,855 ( 0.00%)      return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
      571 ( 0.00%)  }
        .           
        .           // FIXME: ScoringRect is not set
        .           void ImGui::NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.NavWindow != NULL);
        .           
        .               if (move_flags & ImGuiNavMoveFlags_IsTabbing)
-- line 12463 ----------------------------------------
-- line 12498 ----------------------------------------
        .               NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
        .               NavClearPreferredPosForAxis(ImGuiAxis_Y);
        .               NavUpdateAnyRequestFlag();
        .           }
        .           
        .           void ImGui::NavMoveRequestCancel()
        .           {
        .               ImGuiContext& g = *GImGui;
        4 ( 0.00%)      g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        .               NavUpdateAnyRequestFlag();
        .           }
        .           
        .           // Forward will reuse the move request again on the next frame (generally with modifications done to it)
        .           void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.NavMoveForwardToNextFrame == false);
-- line 12514 ----------------------------------------
-- line 12532 ----------------------------------------
        .               if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main)
        .                   g.NavMoveFlags = (g.NavMoveFlags & ~ImGuiNavMoveFlags_WrapMask_) | wrap_flags;
        .           }
        .           
        .           // FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
        .           // This way we could find the last focused window among our children. It would be much less confusing this way?
        .           static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)
        .           {
      571 ( 0.00%)      ImGuiWindow* parent = nav_window;
    1,140 ( 0.00%)      while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        .                   parent = parent->ParentWindow;
    1,140 ( 0.00%)      if (parent && parent != nav_window)
        .                   parent->NavLastChildNavWindow = nav_window;
        .           }
        .           
        .           // Restore the last focused child.
        .           // Call when we are expected to land on the Main Layer (0) after FocusWindow()
        .           static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
        .           {
        .               if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
-- line 12551 ----------------------------------------
-- line 12584 ----------------------------------------
        .               ImGuiContext& g = *GImGui;
        .               g.NavDisableHighlight = false;
        .               g.NavDisableMouseHover = g.NavMousePosDirty = true;
        .           }
        .           
        .           static inline void ImGui::NavUpdateAnyRequestFlag()
        .           {
        .               ImGuiContext& g = *GImGui;
    2,332 ( 0.00%)      g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    1,162 ( 0.00%)      if (g.NavAnyRequest)
        .                   IM_ASSERT(g.NavWindow != NULL);
        .           }
        .           
        .           // This needs to be called before we submit any widget (aka in or before Begin)
        .           void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
       25 ( 0.00%)  {
        .               // FIXME: ChildWindow test here is wrong for docking
        5 ( 0.00%)      ImGuiContext& g = *GImGui;
       10 ( 0.00%)      IM_ASSERT(window == g.NavWindow);
        .           
       20 ( 0.00%)      if (window->Flags & ImGuiWindowFlags_NoNavInputs)
        .               {
        1 ( 0.00%)          g.NavId = 0;
        .                   SetNavFocusScope(window->NavRootFocusScopeId);
        .                   return;
        .               }
        .           
        .               bool init_for_nav = false;
        8 ( 0.00%)      if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
        .                   init_for_nav = true;
       20 ( 0.00%)      IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
        .               if (init_for_nav)
        .               {
        4 ( 0.00%)          SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
        4 ( 0.00%)          g.NavInitRequest = true;
        .                   g.NavInitRequestFromMove = false;
        4 ( 0.00%)          g.NavInitResult.ID = 0;
        .                   NavUpdateAnyRequestFlag();
        .               }
        .               else
        .               {
        .                   g.NavId = window->NavLastIds[0];
        2 ( 0.00%)          SetNavFocusScope(window->NavRootFocusScopeId);
       71 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SetNavFocusScope(unsigned int) (1x)
        .               }
       29 ( 0.00%)  }
        .           
        .           static ImVec2 ImGui::NavCalcPreferredRefPos()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.NavWindow;
        .               if (g.NavDisableHighlight || !g.NavDisableMouseHover || !window)
        .               {
        .                   // Mouse (we need a fallback in case the mouse becomes invalid after being used)
-- line 12636 ----------------------------------------
-- line 12674 ----------------------------------------
        .               }
        .               float amount = (float)GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - (float)GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
        .               if (amount != 0.0f && IsKeyDown(key_less) && IsKeyDown(key_more)) // Cancel when opposite directions are held, regardless of repeat phase
        .                   amount = 0.0f;
        .               return amount;
        .           }
        .           
        .           static void ImGui::NavUpdate()
    5,139 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
        .           
      571 ( 0.00%)      io.WantSetMousePos = false;
        .               //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
        .           
        .               // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
        .               // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
    3,426 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    1,142 ( 0.00%)      const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
    1,142 ( 0.00%)      if (nav_gamepad_active)
        .                   for (ImGuiKey key : nav_gamepad_keys_to_change_source)
        .                       if (IsKeyDown(key))
        .                           g.NavInputSource = ImGuiInputSource_Gamepad;
    2,284 ( 0.00%)      const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    2,855 ( 0.00%)      const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
      571 ( 0.00%)      if (nav_keyboard_active)
        .                   for (ImGuiKey key : nav_keyboard_keys_to_change_source)
        .                       if (IsKeyDown(key))
        .                           g.NavInputSource = ImGuiInputSource_Keyboard;
        .           
        .               // Process navigation init request (select first/default focus)
      571 ( 0.00%)      g.NavJustMovedToId = 0;
    1,713 ( 0.00%)      if (g.NavInitResult.ID != 0)
        .                   NavInitRequestApplyResult();
      571 ( 0.00%)      g.NavInitRequest = false;
        .               g.NavInitRequestFromMove = false;
      571 ( 0.00%)      g.NavInitResult.ID = 0;
        .           
        .               // Process navigation move request
    1,142 ( 0.00%)      if (g.NavMoveSubmitted)
        .                   NavMoveRequestApplyResult();
      571 ( 0.00%)      g.NavTabbingCounter = 0;
      571 ( 0.00%)      g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        .           
        .               // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
        .               bool set_mouse_pos = false;
    1,713 ( 0.00%)      if (g.NavMousePosDirty && g.NavIdIsAlive)
        .                   if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
        .                       set_mouse_pos = true;
      571 ( 0.00%)      g.NavMousePosDirty = false;
    1,713 ( 0.00%)      IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
        .           
        .               // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
    2,283 ( 0.00%)      if (g.NavWindow)
        .                   NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    1,140 ( 0.00%)      if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
        .                   g.NavWindow->NavLastChildNavWindow = NULL;
        .           
        .               // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
        .               NavUpdateWindowing();
        .           
        .               // Set output flags for user application
    2,284 ( 0.00%)      io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    1,713 ( 0.00%)      io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);
        .           
        .               // Process NavCancel input (to close a popup, get back to parent, clear focus)
        .               NavUpdateCancelRequest();
        .           
        .               // Process manual activation request
    1,142 ( 0.00%)      g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
        .               g.NavActivateFlags = ImGuiActivateFlags_None;
    2,284 ( 0.00%)      if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        .               {
        .                   const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_None)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_None));
        .                   const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, ImGuiKeyOwner_None)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_None)));
        .                   const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_None) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_None))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_None));
        .                   const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, ImGuiKeyOwner_None) || IsKeyPressed(ImGuiKey_KeypadEnter, ImGuiKeyOwner_None))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_None)));
        .                   if (g.ActiveId == 0 && activate_pressed)
        .                   {
        .                       g.NavActivateId = g.NavId;
-- line 12753 ----------------------------------------
-- line 12761 ----------------------------------------
        .                   if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down))
        .                       g.NavActivateDownId = g.NavId;
        .                   if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed))
        .                   {
        .                       g.NavActivatePressedId = g.NavId;
        .                       NavHighlightActivated(g.NavId);
        .                   }
        .               }
    3,422 ( 0.00%)      if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
       48 ( 0.00%)          g.NavDisableHighlight = true;
    1,710 ( 0.00%)      if (g.NavActivateId != 0)
        .                   IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
        .           
        .               // Highlight
    2,284 ( 0.00%)      if (g.NavHighlightActivatedTimer > 0.0f)
        .                   g.NavHighlightActivatedTimer = ImMax(0.0f, g.NavHighlightActivatedTimer - io.DeltaTime);
    2,284 ( 0.00%)      if (g.NavHighlightActivatedTimer == 0.0f)
      571 ( 0.00%)          g.NavHighlightActivatedId = 0;
        .           
        .               // Process programmatic activation request
        .               // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
    1,713 ( 0.00%)      if (g.NavNextActivateId != 0)
        .               {
        .                   g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
        .                   g.NavActivateFlags = g.NavNextActivateFlags;
        .               }
      571 ( 0.00%)      g.NavNextActivateId = 0;
        .           
        .               // Process move requests
        .               NavUpdateCreateMoveRequest();
    1,142 ( 0.00%)      if (g.NavMoveDir == ImGuiDir_None)
        .                   NavUpdateCreateTabbingRequest();
        .               NavUpdateAnyRequestFlag();
      571 ( 0.00%)      g.NavIdIsAlive = false;
        .           
        .               // Scrolling
    3,897 ( 0.00%)      if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
        .               {
        .                   // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        .                   ImGuiWindow* window = g.NavWindow;
    3,132 ( 0.00%)          const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
      522 ( 0.00%)          const ImGuiDir move_dir = g.NavMoveDir;
    2,088 ( 0.00%)          if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY && move_dir != ImGuiDir_None)
        .                   {
        .                       if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
        .                           SetScrollX(window, ImTrunc(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
        .                       if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
        .                           SetScrollY(window, ImTrunc(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        .                   }
        .           
        .                   // *Normal* Manual scroll with LStick
        .                   // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
    1,566 ( 0.00%)          if (nav_gamepad_active)
        .                   {
        .                       const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
        .                       const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
        .                       if (scroll_dir.x != 0.0f && window->ScrollbarX)
        .                           SetScrollX(window, ImTrunc(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
        .                       if (scroll_dir.y != 0.0f)
        .                           SetScrollY(window, ImTrunc(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
        .                   }
        .               }
        .           
        .               // Always prioritize mouse highlight if navigation is disabled
    3,426 ( 0.00%)      if (!nav_keyboard_active && !nav_gamepad_active)
        .               {
      571 ( 0.00%)          g.NavDisableHighlight = true;
        .                   g.NavDisableMouseHover = set_mouse_pos = false;
        .               }
        .           
        .               // Update mouse position if requested
        .               // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
        .               if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
        .                   TeleportMousePos(NavCalcPreferredRefPos());
        .           
        .               // [DEBUG]
      571 ( 0.00%)      g.NavScoringDebugCount = 0;
        .           #if IMGUI_DEBUG_NAV_RECTS
        .               if (ImGuiWindow* debug_window = g.NavWindow)
        .               {
        .                   ImDrawList* draw_list = GetForegroundDrawList(debug_window);
        .                   int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/ { ImRect r = WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255)); }
        .                   //if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
        .               }
        .           #endif
    4,568 ( 0.00%)  }
        .           
        .           void ImGui::NavInitRequestApplyResult()
        .           {
        .               // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
        .               ImGuiContext& g = *GImGui;
        .               if (!g.NavWindow)
        .                   return;
        .           
-- line 12854 ----------------------------------------
-- line 12870 ----------------------------------------
        .               if (g.NavInitRequestFromMove)
        .                   NavRestoreHighlightAfterMove();
        .           }
        .           
        .           // Bias scoring rect ahead of scoring + update preferred pos (if missing) using source position
        .           static void NavBiasScoringRect(ImRect& r, ImVec2& preferred_pos_rel, ImGuiDir move_dir, ImGuiNavMoveFlags move_flags)
        .           {
        .               // Bias initial rect
      570 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               const ImVec2 rel_to_abs_offset = g.NavWindow->DC.CursorStartPos;
        .           
        .               // Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
        .               // - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
        .               // - But each successful move sets new bias on one axis, only cleared when using mouse.
        .               if ((move_flags & ImGuiNavMoveFlags_Forwarded) == 0)
        .               {
        .                   if (preferred_pos_rel.x == FLT_MAX)
-- line 12886 ----------------------------------------
-- line 12893 ----------------------------------------
        .               if ((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX)
        .                   r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
        .               else if ((move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX)
        .                   r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
        .           }
        .           
        .           void ImGui::NavUpdateCreateMoveRequest()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
      571 ( 0.00%)      ImGuiWindow* window = g.NavWindow;
    1,615 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    2,137 ( 0.00%)      const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        .           
    1,142 ( 0.00%)      if (g.NavMoveForwardToNextFrame && window != NULL)
        .               {
        .                   // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        .                   // (preserve most state, which were already set by the NavMoveRequestForward() function)
        .                   IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        .                   IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
        .                   IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
        .               }
        .               else
        .               {
        .                   // Initiate directional inputs request
      571 ( 0.00%)          g.NavMoveDir = ImGuiDir_None;
      571 ( 0.00%)          g.NavMoveFlags = ImGuiNavMoveFlags_None;
        .                   g.NavMoveScrollFlags = ImGuiScrollFlags_None;
    3,422 ( 0.00%)          if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
        .                   {
        .                       const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateNavMove;
    3,624 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
    1,044 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
    1,044 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
    1,044 ( 0.00%)              if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
        .                   }
    1,106 ( 0.00%)          g.NavMoveClipDir = g.NavMoveDir;
    1,190 ( 0.00%)          g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
        .               }
        .           
        .               // Update PageUp/PageDown/Home/End scroll
        .               // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
        1 ( 0.00%)      float scoring_rect_offset_y = 0.0f;
    2,803 ( 0.00%)      if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
        .                   scoring_rect_offset_y = NavUpdatePageUpPageDown();
        .               if (scoring_rect_offset_y != 0.0f)
        .               {
        .                   g.NavScoringNoClipRect = window->InnerRect;
        .                   g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
        .               }
        .           
        .               // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
-- line 12944 ----------------------------------------
-- line 12950 ----------------------------------------
        .                   if (g.NavMoveDir == ImGuiDir_None)
        .                       g.NavMoveDir = g.NavMoveDirForDebug;
        .                   g.NavMoveClipDir = g.NavMoveDir;
        .                   g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
        .               }
        .           #endif
        .           
        .               // Submit
      571 ( 0.00%)      g.NavMoveForwardToNextFrame = false;
    1,142 ( 0.00%)      if (g.NavMoveDir != ImGuiDir_None)
        .                   NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
        .           
        .               // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
    2,284 ( 0.00%)      if (g.NavMoveSubmitted && g.NavId == 0)
        .               {
        .                   IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
        .                   g.NavInitRequest = g.NavInitRequestFromMove = true;
        .                   g.NavInitResult.ID = 0;
        .                   g.NavDisableHighlight = false;
        .               }
        .           
        .               // When using gamepad, we project the reference nav bounding box into window visible area.
-- line 12971 ----------------------------------------
-- line 12991 ----------------------------------------
        .                       inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
        .                       inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
        .                       window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
        .                       g.NavId = 0;
        .                   }
        .               }
        .           
        .               // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
        5 ( 0.00%)      ImRect scoring_rect;
    1,142 ( 0.00%)      if (window != NULL)
        .               {
    4,560 ( 0.00%)          ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
        .                   scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
        .                   scoring_rect.TranslateY(scoring_rect_offset_y);
    1,710 ( 0.00%)          if (g.NavMoveSubmitted)
        .                       NavBiasScoringRect(scoring_rect, window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
        .                   IM_ASSERT(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
        .                   //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
        .                   //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
        .               }
    2,284 ( 0.00%)      g.NavScoringRect = scoring_rect;
        .               g.NavScoringNoClipRect.Add(scoring_rect);
        .           }
        .           
        .           void ImGui::NavUpdateCreateTabbingRequest()
        .           {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
      571 ( 0.00%)      ImGuiWindow* window = g.NavWindow;
    1,142 ( 0.00%)      IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
    3,422 ( 0.00%)      if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
        .                   return;
        .           
    2,610 ( 0.00%)      const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
    8,874 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::IsKeyPressed(ImGuiKey, unsigned int, int) [clone .constprop.0] (522x)
        .               if (!tab_pressed)
        .                   return;
        .           
        .               // Initiate tabbing request
        .               // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
        .               // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
        .               const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        .               if (nav_keyboard_active)
-- line 13031 ----------------------------------------
-- line 13150 ----------------------------------------
        .           }
        .           
        .           // Process NavCancel input (to close a popup, get back to parent, clear focus)
        .           // FIXME: In order to support e.g. Escape to clear a selection we'll need:
        .           // - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
        .           // - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
        .           static void ImGui::NavUpdateCancelRequest()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
        .               const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    2,855 ( 0.00%)      if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
        .                   return;
        .           
        .               IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
        .               if (g.ActiveId != 0)
        .               {
        .                   ClearActiveID();
        .               }
        .               else if (g.NavLayer != ImGuiNavLayer_Main)
-- line 13169 ----------------------------------------
-- line 13200 ----------------------------------------
        .           // Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
        .           // FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
        .           // FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
        .           static float ImGui::NavUpdatePageUpPageDown()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.NavWindow;
        .               if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
      570 ( 0.00%)          return 0.0f;
        .           
        .               const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_None);
        .               const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_None);
        .               const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
        .               const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
        .               if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
        .                   return 0.0f;
        .           
-- line 13216 ----------------------------------------
-- line 13271 ----------------------------------------
        .                   }
        .                   return nav_scoring_rect_offset_y;
        .               }
        .               return 0.0f;
        .           }
        .           
        .           static void ImGui::NavEndFrame()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Show CTRL+TAB list window
    1,142 ( 0.00%)      if (g.NavWindowingTarget != NULL)
        .                   NavUpdateWindowingOverlay();
        .           
        .               // Perform wrap-around in menus
        .               // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
        .               // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
    1,142 ( 0.00%)      if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
        .                   NavUpdateCreateWrappingRequest();
        .           }
        .           
        .           static void ImGui::NavUpdateCreateWrappingRequest()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = g.NavWindow;
        .           
-- line 13296 ----------------------------------------
-- line 13386 ----------------------------------------
        .               g.NavWindowingToggleLayer = false;
        .           }
        .           
        .           // Windowing management mode
        .           // Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
        .           // Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
        .           static void ImGui::NavUpdateWindowing()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiIO& io = g.IO;
        .           
      571 ( 0.00%)      ImGuiWindow* apply_focus_window = NULL;
      571 ( 0.00%)      bool apply_toggle_layer = false;
        .           
        .               ImGuiWindow* modal_window = GetTopMostPopupModal();
        .               bool allow_windowing = (modal_window == NULL); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
        .               if (!allow_windowing)
        .                   g.NavWindowingTarget = NULL;
        .           
        .               // Fade out
    2,284 ( 0.00%)      if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
        .               {
        .                   g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
        .                   if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
        .                       g.NavWindowingTargetAnim = NULL;
        .               }
        .           
        .               // Start CTRL+Tab or Square+L/R window selection
        .               // (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
        .               const ImGuiID owner_id = ImHashStr("###NavUpdateWindowing");
    2,855 ( 0.00%)      const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    1,713 ( 0.00%)      const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    8,565 ( 0.00%)      const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, owner_id, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
   49,106 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Shortcut(int, unsigned int, int) (571x)
    8,565 ( 0.00%)      const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, owner_id, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
   49,106 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Shortcut(int, unsigned int, int) (571x)
    1,713 ( 0.00%)      const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, 0, ImGuiInputFlags_None);
    3,997 ( 0.00%)      const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
        .               if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        .                   if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        .                   {
        .                       g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
        .                       g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
        .                       g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
        .                       g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
        .                       g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
        .           
        .                       // Register ownership of our mods. Using ImGuiInputFlags_RouteGlobalHigh in the Shortcut() calls instead would probably be correct but may have more side-effects.
        .                       if (keyboard_next_window || keyboard_prev_window)
        .                           SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiMod_Mask_, owner_id);
        .                   }
        .           
        .               // Gamepad update
    1,713 ( 0.00%)      g.NavWindowingTimer += io.DeltaTime;
      571 ( 0.00%)      if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
        .               {
        .                   // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        .                   g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
        .           
        .                   // Select window to focus
        .                   const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
        .                   if (focus_change_dir != 0)
        .                   {
-- line 13446 ----------------------------------------
-- line 13471 ----------------------------------------
        .                       NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
        .                   else if ((io.KeyMods & shared_mods) != shared_mods)
        .                       apply_focus_window = g.NavWindowingTarget;
        .               }
        .           
        .               // Keyboard: Press and Release ALT to toggle menu layer
        .               const ImGuiKey windowing_toggle_keys[] = { ImGuiKey_LeftAlt, ImGuiKey_RightAlt };
        .               for (ImGuiKey windowing_toggle_key : windowing_toggle_keys)
    1,713 ( 0.00%)          if (nav_keyboard_active && IsKeyPressed(windowing_toggle_key, ImGuiKeyOwner_None))
        .                   {
        .                       g.NavWindowingToggleLayer = true;
        .                       g.NavWindowingToggleKey = windowing_toggle_key;
        .                       g.NavInputSource = ImGuiInputSource_Keyboard;
        .                       break;
        .                   }
    1,142 ( 0.00%)      if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
        .               {
        .                   // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
        .                   // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
        .                   // - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
        .                   // We cancel toggling nav layer if an owner has claimed the key.
        .                   if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper)
        .                       g.NavWindowingToggleLayer = false;
        .                   if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_None) == false || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_None) == false)
-- line 13494 ----------------------------------------
-- line 13500 ----------------------------------------
        .                       if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
        .                           if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
        .                               apply_toggle_layer = true;
        .                   if (!IsKeyDown(g.NavWindowingToggleKey))
        .                       g.NavWindowingToggleLayer = false;
        .               }
        .           
        .               // Move window
    1,713 ( 0.00%)      if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
        .               {
        .                   ImVec2 nav_move_dir;
        .                   if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
        .                       nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
        .                   if (g.NavInputSource == ImGuiInputSource_Gamepad)
        .                       nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
        .                   if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
        .                   {
-- line 13516 ----------------------------------------
-- line 13524 ----------------------------------------
        .                           ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
        .                           SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
        .                           g.NavWindowingAccumDeltaPos -= accum_floored;
        .                       }
        .                   }
        .               }
        .           
        .               // Apply final focus
    1,142 ( 0.00%)      if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
        .               {
        .                   // FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
        .                   // Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
        .                   ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
        .                   ClearActiveID();
        .                   NavRestoreHighlightAfterMove();
        .                   ClosePopupsOverWindow(apply_focus_window, false);
        .                   FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
-- line 13540 ----------------------------------------
-- line 13555 ----------------------------------------
        .                   // Request OS level focus
        .                   if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
        .                       g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
        .               }
        .               if (apply_focus_window)
        .                   g.NavWindowingTarget = NULL;
        .           
        .               // Apply menu/layer toggle
    1,142 ( 0.00%)      if (apply_toggle_layer && g.NavWindow)
        .               {
        .                   ClearActiveID();
        .           
        .                   // Move to parent menu if necessary
        .                   ImGuiWindow* new_nav_window = g.NavWindow;
        .                   while (new_nav_window->ParentWindow
        .                       && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
        .                       && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
-- line 13571 ----------------------------------------
-- line 13963 ----------------------------------------
        .                   window->DrawList->PushClipRectFullScreen();
        .               window->DrawList->AddRect(bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
        .               if (push_clip_rect)
        .                   window->DrawList->PopClipRect();
        .           }
        .           
        .           const ImGuiPayload* ImGui::GetDragDropPayload()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : NULL;
    1,142 ( 0.00%)  }
        .           
        .           void ImGui::EndDragDropTarget()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.DragDropActive);
        .               IM_ASSERT(g.DragDropWithinTarget);
        .               g.DragDropWithinTarget = false;
        .           
-- line 13981 ----------------------------------------
-- line 14163 ----------------------------------------
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.LogEnabled)
        .                   return;
        .               LogBegin(ImGuiLogType_Buffer, auto_open_depth);
        .           }
        .           
        .           void ImGui::LogFinish()
    1,714 ( 0.00%)  {
    1,714 ( 0.00%)      ImGuiContext& g = *GImGui;
    3,428 ( 0.00%)      if (!g.LogEnabled)
        .                   return;
        .           
        .               LogText(IM_NEWLINE);
        .               switch (g.LogType)
        .               {
        .               case ImGuiLogType_TTY:
        .           #ifndef IMGUI_DISABLE_TTY_FUNCTIONS
        .                   fflush(g.LogFile);
-- line 14181 ----------------------------------------
-- line 14194 ----------------------------------------
        .                   IM_ASSERT(0);
        .                   break;
        .               }
        .           
        .               g.LogEnabled = false;
        .               g.LogType = ImGuiLogType_None;
        .               g.LogFile = NULL;
        .               g.LogBuffer.clear();
    3,428 ( 0.00%)  }
        .           
        .           // Helper to display logging buttons
        .           // FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
        .           void ImGui::LogButtons()
        .           {
        .               ImGuiContext& g = *GImGui;
        .           
        .               PushID("LogButtons");
-- line 14210 ----------------------------------------
-- line 14250 ----------------------------------------
        .           // - WindowSettingsHandler_***() [Internal]
        .           //-----------------------------------------------------------------------------
        .           
        .           // Called by NewFrame()
        .           void ImGui::UpdateSettings()
        .           {
        .               // Load settings on first frame (if not explicitly loaded manually before)
        .               ImGuiContext& g = *GImGui;
    1,142 ( 0.00%)      if (!g.SettingsLoaded)
        .               {
        3 ( 0.00%)          IM_ASSERT(g.SettingsWindows.empty());
        3 ( 0.00%)          if (g.IO.IniFilename)
        1 ( 0.00%)              LoadIniSettingsFromDisk(g.IO.IniFilename);
   63,310 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LoadIniSettingsFromDisk(char const*) (1x)
        1 ( 0.00%)          g.SettingsLoaded = true;
        .               }
        .           
        .               // Save settings (with a delay after the last modification, so we don't spam disk too much)
    2,284 ( 0.00%)      if (g.SettingsDirtyTimer > 0.0f)
        .               {
       42 ( 0.00%)          g.SettingsDirtyTimer -= g.IO.DeltaTime;
       42 ( 0.00%)          if (g.SettingsDirtyTimer <= 0.0f)
        .                   {
        3 ( 0.00%)              if (g.IO.IniFilename != NULL)
        .                           SaveIniSettingsToDisk(g.IO.IniFilename);
        .                       else
        .                           g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
        1 ( 0.00%)              g.SettingsDirtyTimer = 0.0f;
        .                   }
        .               }
        .           }
        .           
        .           void ImGui::MarkIniSettingsDirty()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (g.SettingsDirtyTimer <= 0.0f)
        .                   g.SettingsDirtyTimer = g.IO.IniSavingRate;
        .           }
        .           
        .           void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
        .           {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
       16 ( 0.00%)      if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        6 ( 0.00%)          if (g.SettingsDirtyTimer <= 0.0f)
    8,571 ( 0.00%)              g.SettingsDirtyTimer = g.IO.IniSavingRate;
        .           }
        .           
        .           void ImGui::AddSettingsHandler(const ImGuiSettingsHandler* handler)
       23 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        2 ( 0.00%)      IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
        .               g.SettingsHandlers.push_back(*handler);
       12 ( 0.00%)  }
        .           
        .           void ImGui::RemoveSettingsHandler(const char* type_name)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (ImGuiSettingsHandler* handler = FindSettingsHandler(type_name))
        .                   g.SettingsHandlers.erase(handler);
        .           }
        .           
        .           ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
        .           {
        5 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               const ImGuiID type_hash = ImHashStr(type_name);
       24 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
       23 ( 0.00%)          if (handler.TypeHash == type_hash)
        .                       return &handler;
        .               return NULL;
        .           }
        .           
        .           // Clear all settings (windows, tables, docking etc.)
        .           void ImGui::ClearIniSettings()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.SettingsIniData.clear();
        .               for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        .                   if (handler.ClearAllFn != NULL)
        .                       handler.ClearAllFn(&g, &handler);
        .           }
        .           
        .           void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
        5 ( 0.00%)  {
        .               size_t file_data_size = 0;
        .               char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
        .               if (!file_data)
        .                   return;
        2 ( 0.00%)      if (file_data_size > 0)
        3 ( 0.00%)          LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
   54,065 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::LoadIniSettingsFromMemory(char const*, unsigned long) (1x)
        2 ( 0.00%)      IM_FREE(file_data);
      104 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::MemFree(void*) (1x)
        5 ( 0.00%)  }
        .           
        .           // Zero-tolerance, no error reporting, cheap .ini parsing
        .           // Set ini_size==0 to let us use strlen(ini_data). Do not call this function with a 0 if your buffer is actually empty!
        .           void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
        8 ( 0.00%)  {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
        2 ( 0.00%)      IM_ASSERT(g.Initialized);
        .               //IM_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
        .               //IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);
        .           
        .               // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
        .               // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
        3 ( 0.00%)      if (ini_size == 0)
        .                   ini_size = strlen(ini_data);
        1 ( 0.00%)      g.SettingsIniData.Buf.resize((int)ini_size + 1);
        .               char* const buf = g.SettingsIniData.Buf.Data;
        1 ( 0.00%)      char* const buf_end = buf + ini_size;
        4 ( 0.00%)      memcpy(buf, ini_data, ini_size);
       65 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        1 ( 0.00%)      buf_end[0] = 0;
        .           
        .               // Call pre-read handlers
        .               // Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
       12 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        9 ( 0.00%)          if (handler.ReadInitFn != NULL)
        3 ( 0.00%)              handler.ReadInitFn(&g, &handler);
       69 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
        .           
        1 ( 0.00%)      void* entry_data = NULL;
        1 ( 0.00%)      ImGuiSettingsHandler* entry_handler = NULL;
        .           
        .               char* line_end = NULL;
       65 ( 0.00%)      for (char* line = buf; line < buf_end; line = line_end + 1)
        .               {
        .                   // Skip new lines markers, then find end of the line
      120 ( 0.00%)          while (*line == '\n' || *line == '\r')
        5 ( 0.00%)              line++;
       22 ( 0.00%)          line_end = line;
    3,075 ( 0.00%)          while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
      384 ( 0.00%)              line_end++;
       20 ( 0.00%)          line_end[0] = 0;
       57 ( 0.00%)          if (line[0] == ';')
        .                       continue;
       58 ( 0.00%)          if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        .                   {
        .                       // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
        5 ( 0.00%)              line_end[-1] = 0;
        5 ( 0.00%)              const char* name_end = line_end - 1;
       10 ( 0.00%)              const char* type_start = line + 1;
        .                       char* type_end = (char*)(void*)ImStrchrRange(type_start, name_end, ']');
       20 ( 0.00%)              const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
       10 ( 0.00%)              if (!type_end || !name_start)
        .                           continue;
       10 ( 0.00%)              *type_end = 0; // Overwrite first ']'
        5 ( 0.00%)              name_start++;  // Skip second '['
        .                       entry_handler = FindSettingsHandler(type_start);
       25 ( 0.00%)              entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
    4,139 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, char const*) (4x)
       30 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, char const*) (1x)
        .                   }
       60 ( 0.00%)          else if (entry_handler != NULL && entry_data != NULL)
        .                   {
        .                       // Let type handler parse the line
       60 ( 0.00%)              entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
   29,468 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*, char const*) (13x)
   13,236 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*, char const*) (2x)
        .                   }
        .               }
        1 ( 0.00%)      g.SettingsLoaded = true;
        .           
        .               // [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
        5 ( 0.00%)      memcpy(buf, ini_data, ini_size);
       65 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        .           
        .               // Call post-read handlers
       11 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        9 ( 0.00%)          if (handler.ApplyAllFn != NULL)
        9 ( 0.00%)              handler.ApplyAllFn(&g, &handler);
    1,900 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
      136 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:WindowSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
        4 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_internal.h:TableSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*) (1x)
        8 ( 0.00%)  }
        .           
        .           void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
        .           {
        .               ImGuiContext& g = *GImGui;
        2 ( 0.00%)      g.SettingsDirtyTimer = 0.0f;
        .               if (!ini_filename)
        .                   return;
        .           
        1 ( 0.00%)      size_t ini_data_size = 0;
        3 ( 0.00%)      const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
   40,591 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::SaveIniSettingsToMemory(unsigned long*) (1x)
        .               ImFileHandle f = ImFileOpen(ini_filename, "wt");
        2 ( 0.00%)      if (!f)
        .                   return;
        .               ImFileWrite(ini_data, sizeof(char), ini_data_size, f);
        .               ImFileClose(f);
        .           }
        .           
        .           // Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
        .           const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
        6 ( 0.00%)  {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
        1 ( 0.00%)      g.SettingsDirtyTimer = 0.0f;
        .               g.SettingsIniData.Buf.resize(0);
        .               g.SettingsIniData.Buf.push_back(0);
       12 ( 0.00%)      for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
       12 ( 0.00%)          handler.WriteAllFn(&g, &handler, &g.SettingsIniData);
   28,831 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:WindowSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*) (1x)
   11,677 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*) (1x)
       19 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_tables.cpp:TableSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*) (1x)
        2 ( 0.00%)      if (out_size)
        6 ( 0.00%)          *out_size = (size_t)g.SettingsIniData.size();
        .               return g.SettingsIniData.c_str();
        6 ( 0.00%)  }
        .           
        .           ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
       36 ( 0.00%)  {
        4 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        8 ( 0.00%)      if (g.IO.ConfigDebugIniSettings == false)
        .               {
        .                   // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
        .                   // Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
        .                   if (const char* p = strstr(name, "###"))
        8 ( 0.00%)              name = p;
        .               }
       16 ( 0.00%)      const size_t name_len = strlen(name);
       56 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (4x)
        .           
        .               // Allocate chunk
        .               const size_t chunk_size = sizeof(ImGuiWindowSettings) + name_len + 1;
        .               ImGuiWindowSettings* settings = g.SettingsWindows.alloc_chunk(chunk_size);
        .               IM_PLACEMENT_NEW(settings) ImGuiWindowSettings();
       20 ( 0.00%)      settings->ID = ImHashStr(name, name_len);
      704 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImHashStr(char const*, unsigned long, unsigned int) (4x)
       20 ( 0.00%)      memcpy(settings->GetName(), name, name_len + 1);   // Store with zero terminator
       50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4x)
        .           
        .               return settings;
       36 ( 0.00%)  }
        .           
        .           // We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
        .           // This is called once per window .ini entry + once per newly instantiated window.
        .           ImGuiWindowSettings* ImGui::FindWindowSettingsByID(ImGuiID id)
        7 ( 0.00%)  {
        9 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
       46 ( 0.00%)          if (settings->ID == id && !settings->WantDelete)
        .                       return settings;
        .               return NULL;
       17 ( 0.00%)  }
        .           
        .           // This is faster if you are holding on a Window already as we don't need to perform a search.
        .           ImGuiWindowSettings* ImGui::FindWindowSettingsByWindow(ImGuiWindow* window)
        .           {
       10 ( 0.00%)      ImGuiContext& g = *GImGui;
       24 ( 0.00%)      if (window->SettingsOffset != -1)
        .                   return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
       16 ( 0.00%)      return FindWindowSettingsByID(window->ID);
      140 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByID(unsigned int) (4x)
        .           }
        .           
        .           // This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
        .           void ImGui::ClearWindowSettings(const char* name)
        .           {
        .               //IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
        .               ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = FindWindowByName(name);
-- line 14491 ----------------------------------------
-- line 14504 ----------------------------------------
        .           {
        .               ImGuiContext& g = *ctx;
        .               for (ImGuiWindow* window : g.Windows)
        .                   window->SettingsOffset = -1;
        .               g.SettingsWindows.clear();
        .           }
        .           
        .           static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
       75 ( 0.00%)  {
        .               ImGuiID id = ImHashStr(name);
        8 ( 0.00%)      ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByID(id);
      120 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByID(unsigned int) (4x)
        8 ( 0.00%)      if (settings)
        .                   *settings = ImGuiWindowSettings(); // Clear existing if recycling previous entry
        .               else
        8 ( 0.00%)          settings = ImGui::CreateNewWindowSettings(name);
    3,194 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::CreateNewWindowSettings(char const*) (4x)
        4 ( 0.00%)      settings->ID = id;
        4 ( 0.00%)      settings->WantApply = true;
        .               return (void*)settings;
       20 ( 0.00%)  }
        .           
        .           static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
      104 ( 0.00%)  {
        .               ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
        .               int x, y;
        .               int i;
        .               ImU32 u1;
      150 ( 0.00%)      if (sscanf(line, "Pos=%i,%i", &x, &y) == 2)             { settings->Pos = ImVec2ih((short)x, (short)y); }
    9,123 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (13x)
      101 ( 0.00%)      else if (sscanf(line, "Size=%i,%i", &x, &y) == 2)       { settings->Size = ImVec2ih((short)x, (short)y); }
    8,050 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (9x)
       45 ( 0.00%)      else if (sscanf(line, "ViewportId=0x%08X", &u1) == 1)   { settings->ViewportId = u1; }
    1,860 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (5x)
       45 ( 0.00%)      else if (sscanf(line, "ViewportPos=%i,%i", &x, &y) == 2){ settings->ViewportPos = ImVec2ih((short)x, (short)y); }
    1,860 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (5x)
       61 ( 0.00%)      else if (sscanf(line, "Collapsed=%d", &i) == 1)         { settings->Collapsed = (i != 0); }
    4,700 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (5x)
        8 ( 0.00%)      else if (sscanf(line, "IsChild=%d", &i) == 1)           { settings->IsChild = (i != 0); }
      372 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        9 ( 0.00%)      else if (sscanf(line, "DockId=0x%X,%d", &u1, &i) == 2)  { settings->DockId = u1; settings->DockOrder = (short)i; }
    1,448 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       12 ( 0.00%)      else if (sscanf(line, "DockId=0x%X", &u1) == 1)         { settings->DockId = u1; settings->DockOrder = -1; }
    1,429 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        .               else if (sscanf(line, "ClassId=0x%X", &u1) == 1)        { settings->ClassId = u1; }
       91 ( 0.00%)  }
        .           
        .           // Apply to existing windows (if any)
        .           static void WindowSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        4 ( 0.00%)  {
        .               ImGuiContext& g = *ctx;
        .               for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        8 ( 0.00%)          if (settings->WantApply)
        .                   {
        4 ( 0.00%)              if (ImGuiWindow* window = ImGui::FindWindowByID(settings->ID))
        .                           ApplyWindowSettings(window, settings);
        4 ( 0.00%)              settings->WantApply = false;
        .                   }
        4 ( 0.00%)  }
        .           
        .           static void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
       10 ( 0.00%)  {
        .               // Gather data from windows that were active during this session
        .               // (if a window wasn't opened in this session we preserve its settings)
        .               ImGuiContext& g = *ctx;
       26 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
        .               {
       12 ( 0.00%)          if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
        .                       continue;
        .           
        .                   ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByWindow(window);
        .                   if (!settings)
        .                   {
        .                       settings = ImGui::CreateNewWindowSettings(window->Name);
        .                       window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
        .                   }
        8 ( 0.00%)          IM_ASSERT(settings->ID == window->ID);
       44 ( 0.00%)          settings->Pos = ImVec2ih(window->Pos - window->ViewportPos);
        .                   settings->Size = ImVec2ih(window->SizeFull);
        8 ( 0.00%)          settings->ViewportId = window->ViewportId;
       16 ( 0.00%)          settings->ViewportPos = ImVec2ih(window->ViewportPos);
       18 ( 0.00%)          IM_ASSERT(window->DockNode == NULL || window->DockNode->ID == window->DockId);
       12 ( 0.00%)          settings->DockId = window->DockId;
        .                   settings->ClassId = window->WindowClass.ClassId;
        8 ( 0.00%)          settings->DockOrder = window->DockOrder;
        8 ( 0.00%)          settings->Collapsed = window->Collapsed;
        8 ( 0.00%)          settings->IsChild = (window->RootWindow != window); // Cannot rely on ImGuiWindowFlags_ChildWindow here as docked windows have this set.
        4 ( 0.00%)          settings->WantDelete = false;
        .               }
        .           
        .               // Write to text buffer
        3 ( 0.00%)      buf->reserve(buf->size() + g.SettingsWindows.size() * 6); // ballpark reserve
        1 ( 0.00%)      for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        .               {
        8 ( 0.00%)          if (settings->WantDelete)
        .                       continue;
        .                   const char* settings_name = settings->GetName();
       20 ( 0.00%)          buf->appendf("[%s][%s]\n", handler->TypeName, settings_name);
    5,620 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (4x)
        8 ( 0.00%)          if (settings->IsChild)
        .                   {
        .                       buf->appendf("IsChild=1\n");
        .                       buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
        .                   }
        .                   else
        .                   {
       20 ( 0.00%)              if (settings->ViewportId != 0 && settings->ViewportId != ImGui::IMGUI_VIEWPORT_DEFAULT_ID)
        .                       {
        6 ( 0.00%)                  buf->appendf("ViewportPos=%d,%d\n", settings->ViewportPos.x, settings->ViewportPos.y);
    1,890 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        5 ( 0.00%)                  buf->appendf("ViewportId=0x%08X\n", settings->ViewportId);
    1,318 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        .                       }
       16 ( 0.00%)              if (settings->Pos.x != 0 || settings->Pos.y != 0 || settings->ViewportId == ImGui::IMGUI_VIEWPORT_DEFAULT_ID)
       18 ( 0.00%)                  buf->appendf("Pos=%d,%d\n", settings->Pos.x, settings->Pos.y);
    5,316 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (3x)
       12 ( 0.00%)              if (settings->Size.x != 0 || settings->Size.y != 0)
       28 ( 0.00%)                  buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
    7,520 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (4x)
       20 ( 0.00%)              buf->appendf("Collapsed=%d\n", settings->Collapsed);
    4,448 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (4x)
       12 ( 0.00%)              if (settings->DockId != 0)
        .                       {
        .                           //buf->appendf("TabId=0x%08X\n", ImHashStr("#TAB", 4, settings->ID)); // window->TabId: this is not read back but writing it makes "debugging" the .ini data easier.
        3 ( 0.00%)                  if (settings->DockOrder == -1)
        4 ( 0.00%)                      buf->appendf("DockId=0x%08X\n", settings->DockId);
    1,318 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        .                           else
        .                               buf->appendf("DockId=0x%08X,%d\n", settings->DockId, settings->DockOrder);
        3 ( 0.00%)                  if (settings->ClassId != 0)
        .                               buf->appendf("ClassId=0x%08X\n", settings->ClassId);
        .                       }
        .                   }
       20 ( 0.00%)          buf->append("\n");
      332 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::append(char const*, char const*) (4x)
        .               }
        8 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] LOCALIZATION
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImGui::LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count)
        .           {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               for (int n = 0; n < count; n++)
        9 ( 0.00%)          g.LocalizationTable[entries[n].Key] = entries[n].Text;
        .           }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] VIEWPORTS, PLATFORM WINDOWS
        .           //-----------------------------------------------------------------------------
        .           // - GetMainViewport()
        .           // - FindViewportByID()
-- line 14641 ----------------------------------------
-- line 14659 ----------------------------------------
        .           // - FindPlatformMonitorForRect() [Internal]
        .           // - UpdateViewportPlatformMonitor() [Internal]
        .           // - DestroyPlatformWindow() [Internal]
        .           // - DestroyPlatformWindows()
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiViewport* ImGui::GetMainViewport()
        .           {
    1,144 ( 0.00%)      ImGuiContext& g = *GImGui;
    8,576 ( 0.00%)      return g.Viewports[0];
    1,144 ( 0.00%)  }
        .           
        .           // FIXME: This leaks access to viewports not listed in PlatformIO.Viewports[]. Problematic? (#4236)
        .           ImGuiViewport* ImGui::FindViewportByID(ImGuiID id)
        .           {
      236 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,147 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
    2,760 ( 0.00%)          if (viewport->ID == id)
      571 ( 0.00%)              return viewport;
        .               return NULL;
        .           }
        .           
        .           ImGuiViewport* ImGui::FindViewportByPlatformHandle(void* platform_handle)
        .           {
      229 ( 0.00%)      ImGuiContext& g = *GImGui;
      687 ( 0.00%)      for (ImGuiViewportP* viewport : g.Viewports)
      458 ( 0.00%)          if (viewport->PlatformHandle == platform_handle)
        .                       return viewport;
        .               return NULL;
      458 ( 0.00%)  }
        .           
        .           void ImGui::SetCurrentViewport(ImGuiWindow* current_window, ImGuiViewportP* viewport)
        .           {
    8,569 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               (void)current_window;
        .           
    4,570 ( 0.00%)      if (viewport)
   10,282 ( 0.00%)          viewport->LastFrameActive = g.FrameCount;
   13,709 ( 0.00%)      if (g.CurrentViewport == viewport)
        .                   return;
    1,717 ( 0.00%)      g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
    1,144 ( 0.00%)      g.CurrentViewport = viewport;
        .               //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
        .           
        .               // Notify platform layer of viewport changes
        .               // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
    1,719 ( 0.00%)      if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
        .                   g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
        .           }
        .           
        .           void ImGui::SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
        .           {
        .               // Abandon viewport
        .               if (window->ViewportOwned && window->Viewport->Window == window)
        .                   window->Viewport->Size = ImVec2(0.0f, 0.0f);
        .           
        2 ( 0.00%)      window->Viewport = viewport;
        4 ( 0.00%)      window->ViewportId = viewport->ID;
        6 ( 0.00%)      window->ViewportOwned = (viewport->Window == window);
        .           }
        .           
        .           static bool ImGui::GetWindowAlwaysWantOwnViewport(ImGuiWindow* window)
        .           {
        .               // Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
    1,143 ( 0.00%)      ImGuiContext& g = *GImGui;
    4,580 ( 0.00%)      if (g.IO.ConfigViewportsNoAutoMerge || (window->WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_NoAutoMerge))
        .                   if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
        .                       if (!window->DockIsActive)
        .                           if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip)) == 0)
        .                               if ((window->Flags & ImGuiWindowFlags_Popup) == 0 || (window->Flags & ImGuiWindowFlags_Modal) != 0)
        .                                   return true;
        .               return false;
        .           }
        .           
        .           static bool ImGui::UpdateTryMergeWindowIntoHostViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
        5 ( 0.00%)  {
        2 ( 0.00%)      ImGuiContext& g = *GImGui;
        9 ( 0.00%)      if (window->Viewport == viewport)
        3 ( 0.00%)          return false;
        9 ( 0.00%)      if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) == 0)
        .                   return false;
        6 ( 0.00%)      if ((viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0)
        .                   return false;
        .               if (!viewport->GetMainRect().Contains(window->Rect()))
        .                   return false;
        .               if (GetWindowAlwaysWantOwnViewport(window))
        .                   return false;
        .           
        .               // FIXME: Can't use g.WindowsFocusOrder[] for root windows only as we care about Z order. If we maintained a DisplayOrder along with FocusOrder we could..
       30 ( 0.00%)      for (ImGuiWindow* window_behind : g.Windows)
        .               {
       14 ( 0.00%)          if (window_behind == window)
        .                       break;
       10 ( 0.00%)          if (window_behind->WasActive && window_behind->ViewportOwned && !(window_behind->Flags & ImGuiWindowFlags_ChildWindow))
        .                       if (window_behind->Viewport->GetMainRect().Overlaps(window->Rect()))
        .                           return false;
        .               }
        .           
        .               // Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
        .               ImGuiViewportP* old_viewport = window->Viewport;
        4 ( 0.00%)      if (window->ViewportOwned)
        .                   for (int n = 0; n < g.Windows.Size; n++)
        .                       if (g.Windows[n]->Viewport == old_viewport)
        .                           SetWindowViewport(g.Windows[n], viewport);
        .               SetWindowViewport(window, viewport);
        2 ( 0.00%)      BringWindowToDisplayFront(window);
       34 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BringWindowToDisplayFront(ImGuiWindow*) (2x)
        .           
        .               return true;
        8 ( 0.00%)  }
        .           
        .           // FIXME: handle 0 to N host viewports
        .           static bool ImGui::UpdateTryMergeWindowIntoHostViewports(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports[0]);
        .           }
        .           
        .           // Translate Dear ImGui windows when a Host Viewport has been moved
        .           // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
        .           void ImGui::TranslateWindowsInViewport(ImGuiViewportP* viewport, const ImVec2& old_pos, const ImVec2& new_pos)
        3 ( 0.00%)  {
        3 ( 0.00%)      ImGuiContext& g = *GImGui;
       12 ( 0.00%)      IM_ASSERT(viewport->Window == NULL && (viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows));
        .           
        .               // 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
        .               // translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
        .               // 2) If it's not going to fit into the new size, keep it at same absolute position.
        .               // One problem with this is that most Win32 applications doesn't update their render while dragging,
        .               // and so the window will appear to teleport when releasing the mouse.
        9 ( 0.00%)      const bool translate_all_windows = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable);
        .               ImRect test_still_fit_rect(old_pos, old_pos + viewport->Size);
        .               ImVec2 delta_pos = new_pos - old_pos;
       61 ( 0.00%)      for (ImGuiWindow* window : g.Windows) // FIXME-OPT
       24 ( 0.00%)          if (translate_all_windows || (window->Viewport == viewport && test_still_fit_rect.Contains(window->Rect())))
        .                       TranslateWindow(window, delta_pos);
        .           }
        .           
        .           // Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
        .           void ImGui::ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               if (viewport->Window)
-- line 14800 ----------------------------------------
-- line 14822 ----------------------------------------
        .                           best_candidate = viewport;
        .               return best_candidate;
        .           }
        .           
        .           // Update viewports and monitor infos
        .           // Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
        .           static void ImGui::UpdateViewportsNewFrame()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
        .           
        .               // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
        .               // Update Focused status
        .               const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
    2,284 ( 0.00%)      if (viewports_enabled)
        .               {
    1,142 ( 0.00%)          ImGuiViewportP* focused_viewport = NULL;
    3,438 ( 0.00%)          for (ImGuiViewportP* viewport : g.Viewports)
        .                   {
      574 ( 0.00%)              const bool platform_funcs_available = viewport->PlatformWindowCreated;
    2,870 ( 0.00%)              if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
        .                       {
    1,713 ( 0.00%)                  bool is_minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
   14,275 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowMinimized(ImGuiViewport*) (571x)
    1,142 ( 0.00%)                  if (is_minimized)
      571 ( 0.00%)                      viewport->Flags |= ImGuiViewportFlags_IsMinimized;
        .                           else
    1,142 ( 0.00%)                      viewport->Flags &= ~ImGuiViewportFlags_IsMinimized;
        .                       }
        .           
        .                       // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
        .                       // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
    1,713 ( 0.00%)              if (g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available)
        .                       {
    1,713 ( 0.00%)                  bool is_focused = g.PlatformIO.Platform_GetWindowFocus(viewport);
   14,275 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowFocus(ImGuiViewport*) (571x)
    1,142 ( 0.00%)                  if (is_focused)
    1,177 ( 0.00%)                      viewport->Flags |= ImGuiViewportFlags_IsFocused;
        .                           else
      536 ( 0.00%)                      viewport->Flags &= ~ImGuiViewportFlags_IsFocused;
        .                           if (is_focused)
      303 ( 0.00%)                      focused_viewport = viewport;
        .                       }
        .                   }
        .           
        .                   // Focused viewport has changed?
    2,354 ( 0.00%)          if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport->ID)
        .                   {
        2 ( 0.00%)              IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport->ID);
        .                       const ImGuiViewport* prev_focused_viewport = FindViewportByID(g.PlatformLastFocusedViewportId);
        .                       const bool prev_focused_has_been_destroyed = (prev_focused_viewport == NULL) || (prev_focused_viewport->PlatformWindowCreated == false);
        .           
        .                       // Store a tag so we can infer z-order easily from all our windows
        .                       // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
        .                       // will keep the front most stamp instead of losing it back to their parent viewport.
        3 ( 0.00%)              if (focused_viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
        3 ( 0.00%)                  focused_viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
        2 ( 0.00%)              g.PlatformLastFocusedViewportId = focused_viewport->ID;
        .           
        .                       // Focus associated dear imgui window
        .                       // - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
        .                       // - if focus didn't happen because we destroyed another window (#6462)
        .                       // FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
        2 ( 0.00%)              const bool apply_imgui_focus_on_focused_viewport = !IsAnyMouseDown() && !prev_focused_has_been_destroyed;
        .                       if (apply_imgui_focus_on_focused_viewport)
        .                       {
        .                           focused_viewport->LastFocusedHadNavWindow |= (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
        .                           ImGuiFocusRequestFlags focus_request_flags = ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild;
        .                           if (focused_viewport->Window != NULL)
        .                               FocusWindow(focused_viewport->Window, focus_request_flags);
        .                           else if (focused_viewport->LastFocusedHadNavWindow)
        .                               FocusTopMostWindowUnderOne(NULL, NULL, focused_viewport, focus_request_flags); // Focus top most in viewport
        .                           else
        .                               FocusWindow(NULL, focus_request_flags); // No window had focus last time viewport was focused
        .                       }
        .                   }
        .                   if (focused_viewport)
    2,121 ( 0.00%)              focused_viewport->LastFocusedHadNavWindow = (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport);
        .               }
        .           
        .               // Create/update main viewport with current platform position.
        .               // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
    1,142 ( 0.00%)      ImGuiViewportP* main_viewport = g.Viewports[0];
    1,142 ( 0.00%)      IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
    2,284 ( 0.00%)      IM_ASSERT(main_viewport->Window == NULL);
    3,426 ( 0.00%)      ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
   31,145 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowPos(ImGuiViewport*) (571x)
    1,142 ( 0.00%)      ImVec2 main_viewport_size = g.IO.DisplaySize;
    1,142 ( 0.00%)      if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_IsMinimized))
        .               {
        .                   main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
        .                   main_viewport_size = main_viewport->Size;
        .               }
    3,426 ( 0.00%)      AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
   42,825 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::AddUpdateViewport(ImGuiWindow*, unsigned int, ImVec2 const&, ImVec2 const&, int) (571x)
        .           
      571 ( 0.00%)      g.CurrentDpiScale = 0.0f;
    1,142 ( 0.00%)      g.CurrentViewport = NULL;
        .               g.MouseViewport = NULL;
    5,150 ( 0.00%)      for (int n = 0; n < g.Viewports.Size; n++)
        .               {
    1,148 ( 0.00%)          ImGuiViewportP* viewport = g.Viewports[n];
      574 ( 0.00%)          viewport->Idx = n;
        .           
        .                   // Erase unused viewports
    1,160 ( 0.00%)          if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
        .                   {
        .                       DestroyViewport(viewport);
        .                       n--;
        1 ( 0.00%)              continue;
        .                   }
        .           
      573 ( 0.00%)          const bool platform_funcs_available = viewport->PlatformWindowCreated;
    1,719 ( 0.00%)          if (viewports_enabled)
        .                   {
        .                       // Update Position and Size (from Platform Window to ImGui) if requested.
        .                       // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
    2,294 ( 0.00%)              if (!(viewport->Flags & ImGuiViewportFlags_IsMinimized) && platform_funcs_available)
        .                       {
        .                           // Viewport->WorkPos and WorkSize will be updated below
    1,142 ( 0.00%)                  if (viewport->PlatformRequestMove)
        8 ( 0.00%)                      viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
      106 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowPos(ImGuiViewport*) (2x)
    1,142 ( 0.00%)                  if (viewport->PlatformRequestResize)
        5 ( 0.00%)                      viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
       35 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/backends/imgui_impl_sdl2.cpp:ImGui_ImplSDL2_GetWindowSize(ImGuiViewport*) (1x)
        .                       }
        .                   }
        .           
        .                   // Update/copy monitor info
    1,146 ( 0.00%)          UpdateViewportPlatformMonitor(viewport);
   24,089 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP*) (573x)
        .           
        .                   // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
    1,146 ( 0.00%)          viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
    1,146 ( 0.00%)          viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
    1,146 ( 0.00%)          viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
        .                   viewport->UpdateWorkRect();
        .           
        .                   // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
      573 ( 0.00%)          viewport->Alpha = 1.0f;
        .           
        .                   // Translate Dear ImGui windows when a Host Viewport has been moved
        .                   // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
        .                   const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
    7,988 ( 0.00%)          if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
       12 ( 0.00%)              TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);
      705 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::TranslateWindowsInViewport(ImGuiViewportP*, ImVec2 const&, ImVec2 const&) (3x)
        .           
        .                   // Update DPI scale
        .                   float new_dpi_scale;
    1,719 ( 0.00%)          if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
        .                       new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
    1,719 ( 0.00%)          else if (viewport->PlatformMonitor != -1)
    2,865 ( 0.00%)              new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
        .                   else
      573 ( 0.00%)              new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
    3,444 ( 0.00%)          if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
        .                   {
        .                       float scale_factor = new_dpi_scale / viewport->DpiScale;
        .                       if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
        .                           ScaleWindowsInViewport(viewport, scale_factor);
        .                       //if (viewport == GetMainViewport())
        .                       //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
        .           
        .                       // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
        .                       // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
        .                       // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
        .                       //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
        .                       //    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
        .                   }
      573 ( 0.00%)          viewport->DpiScale = new_dpi_scale;
        .               }
        .           
        .               // Update fallback monitor
    1,142 ( 0.00%)      g.PlatformMonitorsFullWorkRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
    1,713 ( 0.00%)      if (g.PlatformIO.Monitors.Size == 0)
        .               {
        .                   ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
        .                   monitor->MainPos = main_viewport->Pos;
        .                   monitor->MainSize = main_viewport->Size;
        .                   monitor->WorkPos = main_viewport->WorkPos;
        .                   monitor->WorkSize = main_viewport->WorkSize;
        .                   monitor->DpiScale = main_viewport->DpiScale;
        .                   g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos);
        .                   g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos + monitor->WorkSize);
        .               }
    3,997 ( 0.00%)      for (ImGuiPlatformMonitor& monitor : g.PlatformIO.Monitors)
        .               {
        .                   g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos);
        .                   g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos + monitor.WorkSize);
        .               }
        .           
    1,713 ( 0.00%)      if (!viewports_enabled)
        .               {
        .                   g.MouseViewport = main_viewport;
        .                   return;
        .               }
        .           
        .               // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
        .               // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
        .               ImGuiViewportP* viewport_hovered = NULL;
    1,142 ( 0.00%)      if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
        .               {
    1,713 ( 0.00%)          viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
      470 ( 0.00%)          if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
        .                       viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
        .               }
        .               else
        .               {
        .                   // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
        .                   // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
        .                   // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
        .                   // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
        .                   viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
        .               }
        .               if (viewport_hovered != NULL)
      235 ( 0.00%)          g.MouseLastHoveredViewport = viewport_hovered;
    1,008 ( 0.00%)      else if (g.MouseLastHoveredViewport == NULL)
        4 ( 0.00%)          g.MouseLastHoveredViewport = g.Viewports[0];
        .           
        .               // Update mouse reference viewport
        .               // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
        .               // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
    1,713 ( 0.00%)      if (g.MovingWindow && g.MovingWindow->Viewport)
        .                   g.MouseViewport = g.MovingWindow->Viewport;
        .               else
        8 ( 0.00%)          g.MouseViewport = g.MouseLastHoveredViewport;
        .           
        .               // When dragging something, always refer to the last hovered viewport.
        .               // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
        .               // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
        .               // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
        .               // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
        .               const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
    1,008 ( 0.00%)      if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
        .                   viewport_hovered = g.MouseLastHoveredViewport;
    3,325 ( 0.00%)      if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
      688 ( 0.00%)          if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
        .                       g.MouseViewport = viewport_hovered;
        .           
    1,352 ( 0.00%)      IM_ASSERT(g.MouseViewport != NULL);
        .           }
        .           
        .           // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
        .           static void ImGui::UpdateViewportsEndFrame()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               g.PlatformIO.Viewports.resize(0);
    4,577 ( 0.00%)      for (int i = 0; i < g.Viewports.Size; i++)
        .               {
    1,148 ( 0.00%)          ImGuiViewportP* viewport = g.Viewports[i];
    1,148 ( 0.00%)          viewport->LastPos = viewport->Pos;
    4,581 ( 0.00%)          if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
        4 ( 0.00%)              if (i > 0) // Always include main viewport in the list
        .                           continue;
    1,716 ( 0.00%)          if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
        .                       continue;
    1,142 ( 0.00%)          if (i > 0)
        .                       IM_ASSERT(viewport->Window != NULL);
        .                   g.PlatformIO.Viewports.push_back(viewport);
        .               }
    1,142 ( 0.00%)      g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
        .           }
        .           
        .           // FIXME: We should ideally refactor the system to call this every frame (we currently don't)
        .           ImGuiViewportP* ImGui::AddUpdateViewport(ImGuiWindow* window, ImGuiID id, const ImVec2& pos, const ImVec2& size, ImGuiViewportFlags flags)
    4,576 ( 0.00%)  {
      572 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,144 ( 0.00%)      IM_ASSERT(id != 0);
        .           
    2,860 ( 0.00%)      flags |= ImGuiViewportFlags_IsPlatformWindow;
    1,144 ( 0.00%)      if (window != NULL)
        .               {
        3 ( 0.00%)          if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
        1 ( 0.00%)              flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
        1 ( 0.00%)          if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
        6 ( 0.00%)              flags |= ImGuiViewportFlags_NoInputs;
        .                   if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
        4 ( 0.00%)              flags |= ImGuiViewportFlags_NoFocusOnAppearing;
        .               }
        .           
        .               ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
        .               if (viewport)
        .               {
        .                   // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
    1,146 ( 0.00%)          if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
    1,142 ( 0.00%)              viewport->Pos = pos;
    1,709 ( 0.00%)          if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
    1,713 ( 0.00%)              viewport->Size = size;
    2,284 ( 0.00%)          viewport->Flags = flags | (viewport->Flags & (ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_IsFocused)); // Preserve existing flags
        .               }
        .               else
        .               {
        .                   // New viewport
        .                   viewport = IM_NEW(ImGuiViewportP)();
        1 ( 0.00%)          viewport->ID = id;
        2 ( 0.00%)          viewport->Idx = g.Viewports.Size;
        3 ( 0.00%)          viewport->Pos = viewport->LastPos = pos;
        2 ( 0.00%)          viewport->Size = size;
        1 ( 0.00%)          viewport->Flags = flags;
        2 ( 0.00%)          UpdateViewportPlatformMonitor(viewport);
       42 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP*) (1x)
        .                   g.Viewports.push_back(viewport);
        1 ( 0.00%)          g.ViewportCreatedCount++;
        2 ( 0.00%)          IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
        .           
        .                   // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
        .                   // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
        3 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
        3 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
        6 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
        6 ( 0.00%)          g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
        .           
        .                   // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
        .                   // This is so we can select an appropriate font size on the first frame of our window lifetime
        3 ( 0.00%)          if (viewport->PlatformMonitor != -1)
        6 ( 0.00%)              viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
        .               }
        .           
      572 ( 0.00%)      viewport->Window = window;
    1,144 ( 0.00%)      viewport->LastFrameActive = g.FrameCount;
        .               viewport->UpdateWorkRect();
    1,147 ( 0.00%)      IM_ASSERT(window == NULL || viewport->ID == window->ID);
        .           
        .               if (window != NULL)
        1 ( 0.00%)          window->ViewportOwned = true;
        .           
        .               return viewport;
    5,148 ( 0.00%)  }
        .           
        .           static void ImGui::DestroyViewport(ImGuiViewportP* viewport)
        .           {
        .               // Clear references to this viewport in windows (window->ViewportId becomes the master data)
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
       30 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
        .               {
       12 ( 0.00%)          if (window->Viewport != viewport)
        .                       continue;
        1 ( 0.00%)          window->Viewport = NULL;
        1 ( 0.00%)          window->ViewportOwned = false;
        .               }
        2 ( 0.00%)      if (viewport == g.MouseLastHoveredViewport)
        .                   g.MouseLastHoveredViewport = NULL;
        .           
        .               // Destroy
        2 ( 0.00%)      IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Delete Viewport %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
        2 ( 0.00%)      DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
       21 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DestroyPlatformWindow(ImGuiViewportP*) (1x)
        .               IM_ASSERT(g.PlatformIO.Viewports.contains(viewport) == false);
        5 ( 0.00%)      IM_ASSERT(g.Viewports[viewport->Idx] == viewport);
        .               g.Viewports.erase(g.Viewports.Data + viewport->Idx);
        .               IM_DELETE(viewport);
        .           }
        .           
        .           // FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
        .           static void ImGui::WindowSelectViewport(ImGuiWindow* window)
        .           {
    5,712 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiWindowFlags flags = window->Flags;
    2,856 ( 0.00%)      window->ViewportAllowPlatformMonitorExtend = -1;
        .           
        .               // Restore main viewport if multi-viewport is not supported by the backend
        .               ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
    5,712 ( 0.00%)      if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
        .               {
        .                   SetWindowViewport(window, main_viewport);
        .                   return;
        .               }
    2,856 ( 0.00%)      window->ViewportOwned = false;
        .           
        .               // Appearing popups reset their viewport so they can inherit again
    8,568 ( 0.00%)      if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
        .               {
        .                   window->Viewport = NULL;
        .                   window->ViewportId = 0;
        .               }
        .           
    5,712 ( 0.00%)      if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
        .               {
        .                   // By default inherit from parent window
    4,592 ( 0.00%)          if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
        4 ( 0.00%)              window->Viewport = window->ParentWindow->Viewport;
        .           
        .                   // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
       16 ( 0.00%)          if (window->Viewport == NULL && window->ViewportId != 0)
        .                   {
        .                       window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
        .                       if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
        .                           window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
        .                   }
        .               }
        .           
        .               bool lock_viewport = false;
        .               if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
        .               {
        .                   // Code explicitly request a viewport
    1,142 ( 0.00%)          window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
      571 ( 0.00%)          window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
    1,713 ( 0.00%)          if (window->Viewport && (window->Flags & ImGuiWindowFlags_DockNodeHost) != 0 && window->Viewport->Window != NULL)
        .                   {
        .                       window->Viewport->Window = window;
        .                       window->Viewport->ID = window->ViewportId = window->ID; // Overwrite ID (always owned by node)
        .                   }
        .                   lock_viewport = true;
        .               }
    4,570 ( 0.00%)      else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
        .               {
        .                   // Always inherit viewport from parent window
    6,282 ( 0.00%)          if (window->DockNode && window->DockNode->HostWindow)
    3,426 ( 0.00%)              IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
        .                   window->Viewport = window->ParentWindow->Viewport;
        .               }
    2,286 ( 0.00%)      else if (window->DockNode && window->DockNode->HostWindow)
        .               {
        .                   // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
    1,142 ( 0.00%)          window->Viewport = window->DockNode->HostWindow->Viewport;
        .               }
    2,286 ( 0.00%)      else if (flags & ImGuiWindowFlags_Tooltip)
        .               {
        .                   window->Viewport = g.MouseViewport;
        .               }
        .               else if (GetWindowAlwaysWantOwnViewport(window))
        .               {
        .                   window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
        .               }
    3,429 ( 0.00%)      else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
        .               {
    1,143 ( 0.00%)          if (window->Viewport != NULL && window->Viewport->Window == window)
        .                       window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
        .               }
        .               else
        .               {
        .                   // Merge into host viewport?
        .                   // We cannot test window->ViewportOwned as it set lower in the function.
        .                   // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
    4,566 ( 0.00%)          bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
        .                   if (try_to_merge_into_host_viewport)
        .                       UpdateTryMergeWindowIntoHostViewports(window);
        .               }
        .           
        .               // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
    2,284 ( 0.00%)      if (window->Viewport == NULL)
       27 ( 0.00%)          if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
      208 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateTryMergeWindowIntoHostViewport(ImGuiWindow*, ImGuiViewportP*) (3x)
       11 ( 0.00%)              window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
      300 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::AddUpdateViewport(ImGuiWindow*, unsigned int, ImVec2 const&, ImVec2 const&, int) (1x)
        .           
        .               // Mark window as allowed to protrude outside of its viewport and into the current monitor
        .               if (!lock_viewport)
        .               {
    4,573 ( 0.00%)          if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        .                   {
        .                       // We need to take account of the possibility that mouse may become invalid.
        .                       // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
        .                       ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
        .                       bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
        .                       bool mouse_valid = IsMousePosValid(&mouse_ref);
        .                       if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
        .                           window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
        .                       else
        .                           window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
        .                   }
   14,856 ( 0.00%)          else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
        .                   {
        .                       // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
        .                       const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
        .                       if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
        .                       {
        .                           // Steal/transfer ownership
        .                           IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
        .                           window->Viewport->Window = window;
-- line 15281 ----------------------------------------
-- line 15283 ----------------------------------------
        .                           window->Viewport->LastNameHash = 0;
        .                       }
        .                       else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
        .                       {
        .                           // New viewport
        .                           window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
        .                       }
        .                   }
   11,425 ( 0.00%)          else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
        .                   {
        .                       // Regular (non-child, non-popup) windows by default are also allowed to protrude
        .                       // Child windows are kept contained within their parent.
    3,429 ( 0.00%)              window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
        .                   }
        .               }
        .           
        .               // Update flags
   11,425 ( 0.00%)      window->ViewportOwned = (window == window->Viewport->Window);
    6,855 ( 0.00%)      window->ViewportId = window->Viewport->ID;
        .           
        .               // If the OS window has a title bar, hide our imgui title bar
        .               //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
        .               //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
        .           }
        .           
        .           void ImGui::WindowSyncOwnedViewport(ImGuiWindow* window, ImGuiWindow* parent_window_in_stack)
        .           {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        1 ( 0.00%)      bool viewport_rect_changed = false;
        .           
        .               // Synchronize window --> viewport in most situations
        .               // Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
    3,429 ( 0.00%)      if (window->Viewport->PlatformRequestMove)
        .               {
        .                   window->Pos = window->Viewport->Pos;
        .                   MarkIniSettingsDirty(window);
        .               }
        3 ( 0.00%)      else if (memcmp(&window->Viewport->Pos, &window->Pos, sizeof(window->Pos)) != 0)
        .               {
        .                   viewport_rect_changed = true;
        .                   window->Viewport->Pos = window->Pos;
        .               }
        .           
        2 ( 0.00%)      if (window->Viewport->PlatformRequestResize)
        .               {
        .                   window->Size = window->SizeFull = window->Viewport->Size;
        .                   MarkIniSettingsDirty(window);
        .               }
        3 ( 0.00%)      else if (memcmp(&window->Viewport->Size, &window->Size, sizeof(window->Size)) != 0)
        .               {
        .                   viewport_rect_changed = true;
        .                   window->Viewport->Size = window->Size;
        .               }
        .               window->Viewport->UpdateWorkRect();
        .           
        .               // The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
        .               // Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
        2 ( 0.00%)      if (viewport_rect_changed)
        .                   UpdateViewportPlatformMonitor(window->Viewport);
        .           
        .               // Update common viewport flags
        .               const ImGuiViewportFlags viewport_flags_to_clear = ImGuiViewportFlags_TopMost | ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_NoRendererClear;
        2 ( 0.00%)      ImGuiViewportFlags viewport_flags = window->Viewport->Flags & ~viewport_flags_to_clear;
        1 ( 0.00%)      ImGuiWindowFlags window_flags = window->Flags;
        2 ( 0.00%)      const bool is_modal = (window_flags & ImGuiWindowFlags_Modal) != 0;
        3 ( 0.00%)      const bool is_short_lived_floating_window = (window_flags & (ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup)) != 0;
        2 ( 0.00%)      if (window_flags & ImGuiWindowFlags_Tooltip)
        .                   viewport_flags |= ImGuiViewportFlags_TopMost;
        5 ( 0.00%)      if ((g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal)
        .                   viewport_flags |= ImGuiViewportFlags_NoTaskBarIcon;
        2 ( 0.00%)      if (g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window)
        1 ( 0.00%)          viewport_flags |= ImGuiViewportFlags_NoDecoration;
        .           
        .               // Not correct to set modal as topmost because:
        .               // - Because other popups can be stacked above a modal (e.g. combo box in a modal)
        .               // - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
        .               //if (flags & ImGuiWindowFlags_Modal)
        .               //    viewport_flags |= ImGuiViewportFlags_TopMost;
        .           
        .               // For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
        .               // won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
        .               // Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
        .               // but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
        7 ( 0.00%)      if (is_short_lived_floating_window && !is_modal)
        .                   viewport_flags |= ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_NoFocusOnClick;
        .           
        .               // We can overwrite viewport flags using ImGuiWindowClass (advanced users)
        .               if (window->WindowClass.ViewportFlagsOverrideSet)
        1 ( 0.00%)          viewport_flags |= window->WindowClass.ViewportFlagsOverrideSet;
        1 ( 0.00%)      if (window->WindowClass.ViewportFlagsOverrideClear)
        3 ( 0.00%)          viewport_flags &= ~window->WindowClass.ViewportFlagsOverrideClear;
        .           
        .               // We can also tell the backend that clearing the platform window won't be necessary,
        .               // as our window background is filling the viewport and we have disabled BgAlpha.
        .               // FIXME: Work on support for per-viewport transparency (#2766)
        .               if (!(window_flags & ImGuiWindowFlags_NoBackground))
        4 ( 0.00%)          viewport_flags |= ImGuiViewportFlags_NoRendererClear;
        .           
        1 ( 0.00%)      window->Viewport->Flags = viewport_flags;
        .           
        .               // Update parent viewport ID
        .               // (the !IsFallbackWindow test mimic the one done in WindowSelectViewport())
        3 ( 0.00%)      if (window->WindowClass.ParentViewportId != (ImGuiID)-1)
        .                   window->Viewport->ParentViewportId = window->WindowClass.ParentViewportId;
        2 ( 0.00%)      else if ((window_flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && parent_window_in_stack && (!parent_window_in_stack->IsFallbackWindow || parent_window_in_stack->WasActive))
        2 ( 0.00%)          window->Viewport->ParentViewportId = parent_window_in_stack->Viewport->ID;
        .               else
    9,143 ( 0.00%)          window->Viewport->ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID;
        .           }
        .           
        .           // Called by user at the end of the main loop, after EndFrame()
        .           // This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
        .           void ImGui::UpdatePlatformWindows()
    3,997 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      IM_ASSERT(g.FrameCountEnded == g.FrameCount && "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?");
    1,142 ( 0.00%)      IM_ASSERT(g.FrameCountPlatformEnded < g.FrameCount);
      571 ( 0.00%)      g.FrameCountPlatformEnded = g.FrameCount;
    1,142 ( 0.00%)      if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
        .                   return;
        .           
        .               // Create/resize/destroy platform windows to match each active viewport.
        .               // Skip the main viewport (index 0), which is always fully handled by the application!
    1,734 ( 0.00%)      for (int i = 1; i < g.Viewports.Size; i++)
        .               {
        6 ( 0.00%)          ImGuiViewportP* viewport = g.Viewports[i];
        .           
        .                   // Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
        .                   // (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
        .                   bool destroy_platform_window = false;
        .                   destroy_platform_window |= (viewport->LastFrameActive < g.FrameCount - 1);
        9 ( 0.00%)          destroy_platform_window |= (viewport->Window && !IsWindowActiveAndVisible(viewport->Window));
        .                   if (destroy_platform_window)
        .                   {
        6 ( 0.00%)              DestroyPlatformWindow(viewport);
       63 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DestroyPlatformWindow(ImGuiViewportP*) (3x)
        .                       continue;
        .                   }
        .           
        .                   // New windows that appears directly in a new viewport won't always have a size on their first frame
        .                   if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0 || viewport->Size.y <= 0)
        .                       continue;
        .           
        .                   // Create window
-- line 15426 ----------------------------------------
-- line 15486 ----------------------------------------
        .                       // This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
        .                       if (viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
        .                           viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
        .                   }
        .           
        .                   // Clear request flags
        .                   viewport->ClearRequestFlags();
        .               }
    4,568 ( 0.00%)  }
        .           
        .           // This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
        .           // Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
        .           // The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
        .           //
        .           //    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
        .           //    for (int i = 1; i < platform_io.Viewports.Size; i++)
        .           //        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
        .           //            MyRenderFunction(platform_io.Viewports[i], my_args);
        .           //    for (int i = 1; i < platform_io.Viewports.Size; i++)
        .           //        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
        .           //            MySwapBufferFunction(platform_io.Viewports[i], my_args);
        .           //
        .           void ImGui::RenderPlatformWindowsDefault(void* platform_render_arg, void* renderer_render_arg)
    2,855 ( 0.00%)  {
        .               // Skip the main viewport (index 0), which is always fully handled by the application!
        .               ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
    3,426 ( 0.00%)      for (int i = 1; i < platform_io.Viewports.Size; i++)
        .               {
        .                   ImGuiViewport* viewport = platform_io.Viewports[i];
        .                   if (viewport->Flags & ImGuiViewportFlags_IsMinimized)
        .                       continue;
        .                   if (platform_io.Platform_RenderWindow) platform_io.Platform_RenderWindow(viewport, platform_render_arg);
        .                   if (platform_io.Renderer_RenderWindow) platform_io.Renderer_RenderWindow(viewport, renderer_render_arg);
        .               }
        .               for (int i = 1; i < platform_io.Viewports.Size; i++)
        .               {
        .                   ImGuiViewport* viewport = platform_io.Viewports[i];
        .                   if (viewport->Flags & ImGuiViewportFlags_IsMinimized)
        .                       continue;
        .                   if (platform_io.Platform_SwapBuffers) platform_io.Platform_SwapBuffers(viewport, platform_render_arg);
        .                   if (platform_io.Renderer_SwapBuffers) platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg);
        .               }
    3,426 ( 0.00%)  }
        .           
        .           static int ImGui::FindPlatformMonitorForPos(const ImVec2& pos)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
        .               {
        .                   const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
        .                   if (ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize).Contains(pos))
-- line 15536 ----------------------------------------
-- line 15539 ----------------------------------------
        .               return -1;
        .           }
        .           
        .           // Search for the monitor with the largest intersection area with the given rectangle
        .           // We generally try to avoid searching loops but the monitor count should be very small here
        .           // FIXME-OPT: We could test the last monitor used for that viewport first, and early
        .           static int ImGui::FindPlatformMonitorForRect(const ImRect& rect)
        .           {
      574 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
      574 ( 0.00%)      const int monitor_count = g.PlatformIO.Monitors.Size;
    1,148 ( 0.00%)      if (monitor_count <= 1)
      574 ( 0.00%)          return monitor_count - 1;
        .           
        .               // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
        .               // This is necessary for tooltips which always resize down to zero at first.
    2,870 ( 0.00%)      const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
    1,148 ( 0.00%)      int best_monitor_n = -1;
      574 ( 0.00%)      float best_monitor_surface = 0.001f;
        .           
    2,302 ( 0.00%)      for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
        .               {
        .                   const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
        .                   const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
        .                   if (monitor_rect.Contains(rect))
      573 ( 0.00%)              return monitor_n;
        .                   ImRect overlapping_rect = rect;
        .                   overlapping_rect.ClipWithFull(monitor_rect);
        1 ( 0.00%)          float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
        1 ( 0.00%)          if (overlapping_surface < best_monitor_surface)
        .                       continue;
        .                   best_monitor_surface = overlapping_surface;
        2 ( 0.00%)          best_monitor_n = monitor_n;
        .               }
        .               return best_monitor_n;
        .           }
        .           
        .           // Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
        .           static void ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP* viewport)
      574 ( 0.00%)  {
      574 ( 0.00%)      viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
      574 ( 0.00%)  }
        .           
        .           // Return value is always != NULL, but don't hold on it across frames.
        .           const ImGuiPlatformMonitor* ImGui::GetViewportPlatformMonitor(ImGuiViewport* viewport_p)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)viewport_p;
        1 ( 0.00%)      int monitor_idx = viewport->PlatformMonitor;
        4 ( 0.00%)      if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
        1 ( 0.00%)          return &g.PlatformIO.Monitors[monitor_idx];
        .               return &g.FallbackMonitor;
        .           }
        .           
        .           void ImGui::DestroyPlatformWindow(ImGuiViewportP* viewport)
       16 ( 0.00%)  {
        .               ImGuiContext& g = *GImGui;
        8 ( 0.00%)      if (viewport->PlatformWindowCreated)
        .               {
        .                   IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Destroy Platform Window %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
        .                   if (g.PlatformIO.Renderer_DestroyWindow)
        .                       g.PlatformIO.Renderer_DestroyWindow(viewport);
        .                   if (g.PlatformIO.Platform_DestroyWindow)
        .                       g.PlatformIO.Platform_DestroyWindow(viewport);
        .                   IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL);
        .           
        .                   // Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
        .                   // The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
        .                   if (viewport->ID != IMGUI_VIEWPORT_DEFAULT_ID)
        .                       viewport->PlatformWindowCreated = false;
        .               }
        .               else
        .               {
       24 ( 0.00%)          IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL && viewport->PlatformHandle == NULL);
        .               }
       12 ( 0.00%)      viewport->RendererUserData = viewport->PlatformUserData = viewport->PlatformHandle = NULL;
        .               viewport->ClearRequestFlags();
       16 ( 0.00%)  }
        .           
        .           void ImGui::DestroyPlatformWindows()
        .           {
        .               // We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
        .               // to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
        .               // It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
        .               // code to operator a consistent manner.
        .               // It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
-- line 15624 ----------------------------------------
-- line 15755 ----------------------------------------
        .               ImGuiID             ParentWindowId;
        .               ImGuiID             SelectedTabId;
        .               signed char         SplitAxis;
        .               char                Depth;
        .               ImGuiDockNodeFlags  Flags;                  // NB: We save individual flags one by one in ascii format (ImGuiDockNodeFlags_SavedFlagsMask_)
        .               ImVec2ih            Pos;
        .               ImVec2ih            Size;
        .               ImVec2ih            SizeRef;
       11 ( 0.00%)      ImGuiDockNodeSettings() { memset(this, 0, sizeof(*this)); SplitAxis = ImGuiAxis_None; }
        .           };
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: Forward Declarations
        .           //-----------------------------------------------------------------------------
        .           
        .           namespace ImGui
        .           {
-- line 15771 ----------------------------------------
-- line 15798 ----------------------------------------
        .               static void             DockNodeUpdateVisibleFlag(ImGuiDockNode* node);
        .               static void             DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window);
        .               static bool             DockNodeIsDropAllowed(ImGuiWindow* host_window, ImGuiWindow* payload_window);
        .               static void             DockNodePreviewDockSetup(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, ImGuiDockNode* payload_node, ImGuiDockPreviewData* preview_data, bool is_explicit_target, bool is_outer_docking);
        .               static void             DockNodePreviewDockRender(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, const ImGuiDockPreviewData* preview_data);
        .               static void             DockNodeCalcTabBarLayout(const ImGuiDockNode* node, ImRect* out_title_rect, ImRect* out_tab_bar_rect, ImVec2* out_window_menu_button_pos, ImVec2* out_close_button_pos);
        .               static void             DockNodeCalcSplitRects(ImVec2& pos_old, ImVec2& size_old, ImVec2& pos_new, ImVec2& size_new, ImGuiDir dir, ImVec2 size_new_desired);
        .               static bool             DockNodeCalcDropRectsAndTestMousePos(const ImRect& parent, ImGuiDir dir, ImRect& out_draw, bool outer_docking, ImVec2* test_mouse_pos);
        8 ( 0.00%)      static const char*      DockNodeGetHostWindowTitle(ImGuiDockNode* node, char* buf, int buf_size) { ImFormatString(buf, buf_size, "##DockNode_%02X", node->ID); return buf; }
      591 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFormatString(char*, unsigned long, char const*, ...) (1x)
        .               static int              DockNodeGetTabOrder(ImGuiWindow* window);
        .           
        .               // ImGuiDockNode tree manipulations
        .               static void             DockNodeTreeSplit(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiAxis split_axis, int split_first_child, float split_ratio, ImGuiDockNode* new_node);
        .               static void             DockNodeTreeMerge(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiDockNode* merge_lead_child);
        .               static void             DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, ImGuiDockNode* only_write_to_single_node = NULL);
        .               static void             DockNodeTreeUpdateSplitter(ImGuiDockNode* node);
        .               static ImGuiDockNode*   DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos);
-- line 15814 ----------------------------------------
-- line 15849 ----------------------------------------
        .           // - DockContextRemoveNode()
        .           // - ImGuiDockContextPruneNodeData
        .           // - DockContextPruneUnusedSettingsNodes()
        .           // - DockContextBuildNodesFromSettings()
        .           // - DockContextBuildAddWindowsToNodes()
        .           //-----------------------------------------------------------------------------
        .           
        .           void ImGui::DockContextInitialize(ImGuiContext* ctx)
       10 ( 0.00%)  {
        .               ImGuiContext& g = *ctx;
        .           
        .               // Add .ini handle for persistent docking data
        .               ImGuiSettingsHandler ini_handler;
        2 ( 0.00%)      ini_handler.TypeName = "Docking";
        .               ini_handler.TypeHash = ImHashStr("Docking");
        1 ( 0.00%)      ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
        .               ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
        .               ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
        .               ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
        4 ( 0.00%)      ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
        .               ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
        .               g.SettingsHandlers.push_back(ini_handler);
        .           
        2 ( 0.00%)      g.DockNodeWindowMenuHandler = &DockNodeWindowMenuHandler_Default;
        6 ( 0.00%)  }
        .           
        .           void ImGui::DockContextShutdown(ImGuiContext* ctx)
        .           {
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .               for (int n = 0; n < dc->Nodes.Data.Size; n++)
        .                   if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                       IM_DELETE(node);
        .           }
        .           
        5 ( 0.00%)  void ImGui::DockContextClearNodes(ImGuiContext* ctx, ImGuiID root_id, bool clear_settings_refs)
        .           {
        .               IM_UNUSED(ctx);
        3 ( 0.00%)      IM_ASSERT(ctx == GImGui);
        .               DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs);
        2 ( 0.00%)      DockBuilderRemoveNodeChildNodes(root_id);
       33 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockBuilderRemoveNodeChildNodes(unsigned int) (1x)
        5 ( 0.00%)  }
        .           
        .           // [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
        .           // (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
        .           void ImGui::DockContextRebuildNodes(ImGuiContext* ctx)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .               IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRebuildNodes\n");
-- line 15897 ----------------------------------------
-- line 15899 ----------------------------------------
        .               ImGuiID root_id = 0; // Rebuild all
        .               DockContextClearNodes(ctx, root_id, false);
        .               DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
        .               DockContextBuildAddWindowsToNodes(ctx, root_id);
        .           }
        .           
        .           // Docking context update function, called by NewFrame()
        .           void ImGui::DockContextNewFrameUpdateUndocking(ImGuiContext* ctx)
    2,284 ( 0.00%)  {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
    1,142 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .               {
        .                   if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
        .                       DockContextClearNodes(ctx, 0, true);
        .                   return;
        .               }
        .           
        .               // Setting NoSplit at runtime merges all nodes
    1,142 ( 0.00%)      if (g.IO.ConfigDockingNoSplit)
        .                   for (int n = 0; n < dc->Nodes.Data.Size; n++)
        .                       if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                           if (node->IsRootNode() && node->IsSplitNode())
        .                           {
        .                               DockBuilderRemoveNodeChildNodes(node->ID);
        .                               //dc->WantFullRebuild = true;
        .                           }
        .           
        .               // Process full rebuild
        .           #if 0
        .               if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
        .                   dc->WantFullRebuild = true;
        .           #endif
    1,142 ( 0.00%)      if (dc->WantFullRebuild)
        .               {
        .                   DockContextRebuildNodes(ctx);
        .                   dc->WantFullRebuild = false;
        .               }
        .           
        .               // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
    1,713 ( 0.00%)      for (ImGuiDockRequest& req : dc->Requests)
        .               {
        .                   if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetWindow)
        .                       DockContextProcessUndockWindow(ctx, req.UndockTargetWindow);
        .                   else if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetNode)
        .                       DockContextProcessUndockNode(ctx, req.UndockTargetNode);
        .               }
    2,284 ( 0.00%)  }
        .           
        .           // Docking context update function, called by NewFrame()
    2,284 ( 0.00%)  void ImGui::DockContextNewFrameUpdateDocking(ImGuiContext* ctx)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
    2,284 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
   24,909 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextNewFrameUpdateDocking(ImGuiContext*) [clone .part.0] (571x)
        .                   return;
        .           
        .               // [DEBUG] Store hovered dock node.
        .               // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
        .               // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
      571 ( 0.00%)      g.DebugHoveredDockNode = NULL;
    1,713 ( 0.00%)      if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
        .               {
      777 ( 0.00%)          if (hovered_window->DockNodeAsHost)
        .                       g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
    1,036 ( 0.00%)          else if (hovered_window->RootWindow->DockNode)
      256 ( 0.00%)              g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
        .               }
        .           
        .               // Process Docking requests
    1,713 ( 0.00%)      for (ImGuiDockRequest& req : dc->Requests)
        .                   if (req.Type == ImGuiDockRequestType_Dock)
        .                       DockContextProcessDock(ctx, &req);
        .               dc->Requests.resize(0);
        .           
        .               // Create windows for each automatic docking nodes
        .               // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
    3,997 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
    3,426 ( 0.00%)          if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                       if (node->IsFloatingNode())
        .                           DockNodeUpdate(node);
    2,284 ( 0.00%)  }
        .           
        .           void ImGui::DockContextEndFrame(ImGuiContext* ctx)
    5,139 ( 0.00%)  {
        .               // Draw backgrounds of node missing their window
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &g.DockContext;
    3,426 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
    3,426 ( 0.00%)          if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
    7,423 ( 0.00%)              if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
        .                       {
        .                           ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
        .                           ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), g.Style.DockingSeparatorSize);
        .                           node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        .                           node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
        .                       }
    3,997 ( 0.00%)  }
        .           
        .           ImGuiDockNode* ImGui::DockContextFindNodeByID(ImGuiContext* ctx, ImGuiID id)
        .           {
        3 ( 0.00%)      return (ImGuiDockNode*)ctx->DockContext.Nodes.GetVoidPtr(id);
       26 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::GetVoidPtr(unsigned int) const (1x)
        .           }
        .           
        .           ImGuiID ImGui::DockContextGenNodeID(ImGuiContext* ctx)
        .           {
        .               // Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
        .               // FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry.0
        .               // We should poke in ctx->Nodes to find a suitable ID faster. Even more so trivial that ctx->Nodes lookup is already sorted.
        .               ImGuiID id = 0x0001;
        .               while (DockContextFindNodeByID(ctx, id) != NULL)
        .                   id++;
        .               return id;
        .           }
        .           
        .           static ImGuiDockNode* ImGui::DockContextAddNode(ImGuiContext* ctx, ImGuiID id)
        7 ( 0.00%)  {
        .               // Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
        .               ImGuiContext& g = *ctx;
        5 ( 0.00%)      if (id == 0)
        .                   id = DockContextGenNodeID(ctx);
        .               else
        .                   IM_ASSERT(DockContextFindNodeByID(ctx, id) == NULL);
        .           
        .               // We don't set node->LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
        2 ( 0.00%)      IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextAddNode 0x%08X\n", id);
        .               ImGuiDockNode* node = IM_NEW(ImGuiDockNode)(id);
        5 ( 0.00%)      ctx->DockContext.Nodes.SetVoidPtr(node->ID, node);
      126 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiStorage::SetVoidPtr(unsigned int, void*) (1x)
        .               return node;
        7 ( 0.00%)  }
        .           
        .           static void ImGui::DockContextRemoveNode(ImGuiContext* ctx, ImGuiDockNode* node, bool merge_sibling_into_parent_node)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .           
        .               IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRemoveNode 0x%08X\n", node->ID);
        .               IM_ASSERT(DockContextFindNodeByID(ctx, node->ID) == node);
-- line 16036 ----------------------------------------
-- line 16065 ----------------------------------------
        .               return ImGui::DockNodeGetDepth(b) - ImGui::DockNodeGetDepth(a);
        .           }
        .           
        .           // Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
        .           struct ImGuiDockContextPruneNodeData
        .           {
        .               int         CountWindows, CountChildWindows, CountChildNodes;
        .               ImGuiID     RootId;
        2 ( 0.00%)      ImGuiDockContextPruneNodeData() { CountWindows = CountChildWindows = CountChildNodes = 0; RootId = 0; }
        .           };
        .           
        .           // Garbage collect unused nodes (run once at init time)
        .           static void ImGui::DockContextPruneUnusedSettingsNodes(ImGuiContext* ctx)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .               IM_ASSERT(g.Windows.Size == 0);
        .           
        .               ImPool<ImGuiDockContextPruneNodeData> pool;
        3 ( 0.00%)      pool.Reserve(dc->NodesSettings.Size);
        .           
        .               // Count child nodes and compute RootID
        9 ( 0.00%)      for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        .               {
        .                   ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        4 ( 0.00%)          ImGuiDockContextPruneNodeData* parent_data = settings->ParentNodeId ? pool.GetByKey(settings->ParentNodeId) : 0;
        2 ( 0.00%)          pool.GetOrAddByKey(settings->ID)->RootId = parent_data ? parent_data->RootId : settings->ID;
        3 ( 0.00%)          if (settings->ParentNodeId)
        .                       pool.GetOrAddByKey(settings->ParentNodeId)->CountChildNodes++;
        .               }
        .           
        .               // Count reference to dock ids from dockspaces
        .               // We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
        9 ( 0.00%)      for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        .               {
        .                   ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        3 ( 0.00%)          if (settings->ParentWindowId != 0)
        3 ( 0.00%)              if (ImGuiWindowSettings* window_settings = FindWindowSettingsByID(settings->ParentWindowId))
       28 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::FindWindowSettingsByID(unsigned int) (1x)
        3 ( 0.00%)                  if (window_settings->DockId)
        .                               if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(window_settings->DockId))
        .                                   data->CountChildNodes++;
        .               }
        .           
        .               // Count reference to dock ids from window settings
        .               // We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
        .               for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
       12 ( 0.00%)          if (ImGuiID dock_id = settings->DockId)
        2 ( 0.00%)              if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(dock_id))
        .                       {
        1 ( 0.00%)                  data->CountWindows++;
        3 ( 0.00%)                  if (ImGuiDockContextPruneNodeData* data_root = (data->RootId == dock_id) ? data : pool.GetByKey(data->RootId))
        2 ( 0.00%)                      data_root->CountChildWindows++;
        .                       }
        .           
        .               // Prune
        6 ( 0.00%)      for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        .               {
        .                   ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        1 ( 0.00%)          ImGuiDockContextPruneNodeData* data = pool.GetByKey(settings->ID);
        3 ( 0.00%)          if (data->CountWindows > 1)
        .                       continue;
        4 ( 0.00%)          ImGuiDockContextPruneNodeData* data_root = (data->RootId == settings->ID) ? data : pool.GetByKey(data->RootId);
        .           
        .                   bool remove = false;
       11 ( 0.00%)          remove |= (data->CountWindows == 1 && settings->ParentNodeId == 0 && data->CountChildNodes == 0 && !(settings->Flags & ImGuiDockNodeFlags_CentralNode));  // Floating root node with only 1 window
        .                   remove |= (data->CountWindows == 0 && settings->ParentNodeId == 0 && data->CountChildNodes == 0); // Leaf nodes with 0 window
        .                   remove |= (data_root->CountChildWindows == 0);
        3 ( 0.00%)          if (remove)
        .                   {
        .                       IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings->ID);
        .                       DockSettingsRemoveNodeReferences(&settings->ID, 1);
        .                       settings->ID = 0;
        .                   }
        .               }
        .           }
        .           
        .           static void ImGui::DockContextBuildNodesFromSettings(ImGuiContext* ctx, ImGuiDockNodeSettings* node_settings_array, int node_settings_count)
       11 ( 0.00%)  {
        .               // Build nodes
        5 ( 0.00%)      for (int node_n = 0; node_n < node_settings_count; node_n++)
        .               {
        .                   ImGuiDockNodeSettings* settings = &node_settings_array[node_n];
        3 ( 0.00%)          if (settings->ID == 0)
        .                       continue;
        3 ( 0.00%)          ImGuiDockNode* node = DockContextAddNode(ctx, settings->ID);
      251 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextAddNode(ImGuiContext*, unsigned int) (1x)
        5 ( 0.00%)          node->ParentNode = settings->ParentNodeId ? DockContextFindNodeByID(ctx, settings->ParentNodeId) : NULL;
        3 ( 0.00%)          node->Pos = ImVec2(settings->Pos.x, settings->Pos.y);
        .                   node->Size = ImVec2(settings->Size.x, settings->Size.y);
        5 ( 0.00%)          node->SizeRef = ImVec2(settings->SizeRef.x, settings->SizeRef.y);
        4 ( 0.00%)          node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_DockNode;
        2 ( 0.00%)          if (node->ParentNode && node->ParentNode->ChildNodes[0] == NULL)
        .                       node->ParentNode->ChildNodes[0] = node;
        .                   else if (node->ParentNode && node->ParentNode->ChildNodes[1] == NULL)
        .                       node->ParentNode->ChildNodes[1] = node;
        2 ( 0.00%)          node->SelectedTabId = settings->SelectedTabId;
        2 ( 0.00%)          node->SplitAxis = (ImGuiAxis)settings->SplitAxis;
        2 ( 0.00%)          node->SetLocalFlags(settings->Flags & ImGuiDockNodeFlags_SavedFlagsMask_);
        .           
        .                   // Bind host window immediately if it already exist (in case of a rebuild)
        .                   // This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node->HostWindow to be set.
        .                   char host_window_title[20];
        .                   ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        1 ( 0.00%)          node->HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title, IM_ARRAYSIZE(host_window_title)));
        .               }
        7 ( 0.00%)  }
        .           
        .           void ImGui::DockContextBuildAddWindowsToNodes(ImGuiContext* ctx, ImGuiID root_id)
        5 ( 0.00%)  {
        .               // Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
        .               ImGuiContext& g = *ctx;
        2 ( 0.00%)      for (ImGuiWindow* window : g.Windows)
        .               {
        .                   if (window->DockId == 0 || window->LastFrameActive < g.FrameCount - 1)
        .                       continue;
        .                   if (window->DockNode != NULL)
        .                       continue;
        .           
        .                   ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
        .                   IM_ASSERT(node != NULL);   // This should have been called after DockContextBuildNodesFromSettings()
        .                   if (root_id == 0 || DockNodeGetRootNode(node)->ID == root_id)
        .                       DockNodeAddWindow(node, window, true);
        .               }
        6 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: ImGuiDockContext Docking/Undocking functions
        .           //-----------------------------------------------------------------------------
        .           // - DockContextQueueDock()
        .           // - DockContextQueueUndockWindow()
        .           // - DockContextQueueUndockNode()
        .           // - DockContextQueueNotifyRemovedNode()
-- line 16195 ----------------------------------------
-- line 16503 ----------------------------------------
        .           // - DockNodeCalcSplitRects()
        .           // - DockNodeCalcDropRectsAndTestMousePos()
        .           // - DockNodePreviewDockSetup()
        .           // - DockNodePreviewDockRender()
        .           //-----------------------------------------------------------------------------
        .           
        .           ImGuiDockNode::ImGuiDockNode(ImGuiID id)
        .           {
        1 ( 0.00%)      ID = id;
        2 ( 0.00%)      SharedFlags = LocalFlags = LocalFlagsInWindows = MergedFlags = ImGuiDockNodeFlags_None;
        3 ( 0.00%)      ParentNode = ChildNodes[0] = ChildNodes[1] = NULL;
        1 ( 0.00%)      TabBar = NULL;
        1 ( 0.00%)      SplitAxis = ImGuiAxis_None;
        .           
        1 ( 0.00%)      State = ImGuiDockNodeState_Unknown;
        1 ( 0.00%)      LastBgColor = IM_COL32_WHITE;
        2 ( 0.00%)      HostWindow = VisibleWindow = NULL;
        .               CentralNode = OnlyNodeWithWindows = NULL;
        2 ( 0.00%)      CountNodeWithWindows = 0;
        .               LastFrameAlive = LastFrameActive = LastFrameFocused = -1;
        1 ( 0.00%)      LastFocusedNodeId = 0;
        .               SelectedTabId = 0;
        .               WantCloseTabId = 0;
        .               RefViewportId = 0;
        1 ( 0.00%)      AuthorityForPos = AuthorityForSize = ImGuiDataAuthority_DockNode;
        .               AuthorityForViewport = ImGuiDataAuthority_Auto;
        .               IsVisible = true;
        .               IsFocused = HasCloseButton = HasWindowMenuButton = HasCentralNodeChild = false;
        .               IsBgDrawnThisFrame = false;
        1 ( 0.00%)      WantCloseAll = WantLockSizeOnce = WantMouseMove = WantHiddenTabBarUpdate = WantHiddenTabBarToggle = false;
        .           }
        .           
        .           ImGuiDockNode::~ImGuiDockNode()
        .           {
        .               IM_DELETE(TabBar);
        .               TabBar = NULL;
        .               ChildNodes[0] = ChildNodes[1] = NULL;
        .           }
-- line 16540 ----------------------------------------
-- line 16550 ----------------------------------------
        .           
        .           static void DockNodeHideWindowDuringHostWindowCreation(ImGuiWindow* window)
        .           {
        .               window->Hidden = true;
        .               window->HiddenFramesCanSkipItems = window->Active ? 1 : 2;
        .           }
        .           
        .           static void ImGui::DockNodeAddWindow(ImGuiDockNode* node, ImGuiWindow* window, bool add_to_tab_bar)
        9 ( 0.00%)  {
        1 ( 0.00%)      ImGuiContext& g = *GImGui; (void)g;
        3 ( 0.00%)      if (window->DockNode)
        .               {
        .                   // Can overwrite an existing window->DockNode (e.g. pointing to a disabled DockSpace node)
        .                   IM_ASSERT(window->DockNode->ID != node->ID);
        .                   DockNodeRemoveWindow(window->DockNode, window, 0);
        .               }
        .               IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL);
        2 ( 0.00%)      IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeAddWindow node 0x%08X window '%s'\n", node->ID, window->Name);
        .           
        .               // If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
        .               // we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
        .               // We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
        2 ( 0.00%)      if (node->HostWindow == NULL && node->Windows.Size == 1 && node->Windows[0]->WasActive == false)
        .                   DockNodeHideWindowDuringHostWindowCreation(node->Windows[0]);
        .           
        .               node->Windows.push_back(window);
        1 ( 0.00%)      node->WantHiddenTabBarUpdate = true;
        1 ( 0.00%)      window->DockNode = node;
        2 ( 0.00%)      window->DockId = node->ID;
        6 ( 0.00%)      window->DockIsActive = (node->Windows.Size > 1);
        .               window->DockTabWantClose = false;
        .           
        .               // When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
        .               // In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
        3 ( 0.00%)      if (node->HostWindow == NULL && node->IsFloatingNode())
        .               {
        .                   if (node->AuthorityForPos == ImGuiDataAuthority_Auto)
        .                       node->AuthorityForPos = ImGuiDataAuthority_Window;
        .                   if (node->AuthorityForSize == ImGuiDataAuthority_Auto)
        .                       node->AuthorityForSize = ImGuiDataAuthority_Window;
        .                   if (node->AuthorityForViewport == ImGuiDataAuthority_Auto)
        .                       node->AuthorityForViewport = ImGuiDataAuthority_Window;
        .               }
        .           
        .               // Add to tab bar if requested
        2 ( 0.00%)      if (add_to_tab_bar)
        .               {
        3 ( 0.00%)          if (node->TabBar == NULL)
        .                   {
        .                       DockNodeAddTabBar(node);
        3 ( 0.00%)              node->TabBar->SelectedTabId = node->TabBar->NextSelectedTabId = node->SelectedTabId;
        .           
        .                       // Add existing windows
        2 ( 0.00%)              for (int n = 0; n < node->Windows.Size - 1; n++)
        .                           TabBarAddTab(node->TabBar, ImGuiTabItemFlags_None, node->Windows[n]);
        .                   }
        3 ( 0.00%)          TabBarAddTab(node->TabBar, ImGuiTabItemFlags_Unsorted, window);
      395 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGui::TabBarAddTab(ImGuiTabBar*, int, ImGuiWindow*) (1x)
        .               }
        .           
        .               DockNodeUpdateVisibleFlag(node);
        .           
        .               // Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
        3 ( 0.00%)      if (node->HostWindow)
        5 ( 0.00%)          UpdateWindowParentAndRootLinks(window, window->Flags | ImGuiWindowFlags_ChildWindow, node->HostWindow);
       33 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow*, int, ImGuiWindow*) (1x)
        6 ( 0.00%)  }
        .           
        .           static void ImGui::DockNodeRemoveWindow(ImGuiDockNode* node, ImGuiWindow* window, ImGuiID save_dock_id)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(window->DockNode == node);
        .               //IM_ASSERT(window->RootWindowDockTree == node->HostWindow);
        .               //IM_ASSERT(window->LastFrameActive < g.FrameCount);    // We may call this from Begin()
        .               IM_ASSERT(save_dock_id == 0 || save_dock_id == node->ID);
-- line 16622 ----------------------------------------
-- line 16760 ----------------------------------------
        .           // Search function called once by root node in DockNodeUpdate()
        .           struct ImGuiDockNodeTreeInfo
        .           {
        .               ImGuiDockNode*      CentralNode;
        .               ImGuiDockNode*      FirstNodeWithWindows;
        .               int                 CountNodesWithWindows;
        .               //ImGuiWindowClass  WindowClassForMerges;
        .           
    2,284 ( 0.00%)      ImGuiDockNodeTreeInfo() { memset(this, 0, sizeof(*this)); }
        .           };
        .           
        .           static void DockNodeFindInfo(ImGuiDockNode* node, ImGuiDockNodeTreeInfo* info)
    3,426 ( 0.00%)  {
    1,713 ( 0.00%)      if (node->Windows.Size > 0)
        .               {
    1,140 ( 0.00%)          if (info->FirstNodeWithWindows == NULL)
    1,140 ( 0.00%)              info->FirstNodeWithWindows = node;
      570 ( 0.00%)          info->CountNodesWithWindows++;
        .               }
    1,142 ( 0.00%)      if (node->IsCentralNode())
        .               {
    1,142 ( 0.00%)          IM_ASSERT(info->CentralNode == NULL); // Should be only one
    1,142 ( 0.00%)          IM_ASSERT(node->IsLeafNode() && "If you get this assert: please submit .ini file + repro of actions leading to this.");
      571 ( 0.00%)          info->CentralNode = node;
        .               }
    1,142 ( 0.00%)      if (info->CountNodesWithWindows > 1 && info->CentralNode != NULL)
        .                   return;
        .               if (node->ChildNodes[0])
        .                   DockNodeFindInfo(node->ChildNodes[0], info);
    1,713 ( 0.00%)      if (node->ChildNodes[1])
        .                   DockNodeFindInfo(node->ChildNodes[1], info);
    2,284 ( 0.00%)  }
        .           
        .           static ImGuiWindow* ImGui::DockNodeFindWindowByID(ImGuiDockNode* node, ImGuiID id)
        .           {
        .               IM_ASSERT(id != 0);
        .               for (ImGuiWindow* window : node->Windows)
        .                   if (window->ID == id)
        .                       return window;
        .               return NULL;
        .           }
        .           
        .           // - Remove inactive windows/nodes.
        .           // - Update visibility flag.
        .           static void ImGui::DockNodeUpdateFlagsAndCollapse(ImGuiDockNode* node)
    2,855 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      IM_ASSERT(node->ParentNode == NULL || node->ParentNode->ChildNodes[0] == node || node->ParentNode->ChildNodes[1] == node);
        .           
        .               // Inherit most flags
        .               if (node->ParentNode)
        .                   node->SharedFlags = node->ParentNode->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
        .           
        .               // Recurse into children
        .               // There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
        .               // If 'node->ChildNode[0]' delete itself, then 'node->ChildNode[1]->Windows' will be moved into 'node'
        .               // If 'node->ChildNode[1]' delete itself, then 'node->ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
      571 ( 0.00%)      node->HasCentralNodeChild = false;
    1,713 ( 0.00%)      if (node->ChildNodes[0])
        .                   DockNodeUpdateFlagsAndCollapse(node->ChildNodes[0]);
    1,713 ( 0.00%)      if (node->ChildNodes[1])
        .                   DockNodeUpdateFlagsAndCollapse(node->ChildNodes[1]);
        .           
        .               // Remove inactive windows, collapse nodes
        .               // Merge node flags overrides stored in windows
      571 ( 0.00%)      node->LocalFlagsInWindows = ImGuiDockNodeFlags_None;
    5,704 ( 0.00%)      for (int window_n = 0; window_n < node->Windows.Size; window_n++)
        .               {
    1,140 ( 0.00%)          ImGuiWindow* window = node->Windows[window_n];
    1,140 ( 0.00%)          IM_ASSERT(window->DockNode == node);
        .           
    1,140 ( 0.00%)          bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
        .                   bool remove = false;
    3,990 ( 0.00%)          remove |= node_was_active && (window->LastFrameActive + 1 < g.FrameCount);
    2,850 ( 0.00%)          remove |= node_was_active && (node->WantCloseAll || node->WantCloseTabId == window->TabId) && window->HasCloseButton && !(window->Flags & ImGuiWindowFlags_UnsavedDocument);  // Submit all _expected_ closure from last frame
        .                   remove |= (window->DockTabWantClose);
    2,280 ( 0.00%)          if (remove)
        .                   {
        .                       window->DockTabWantClose = false;
        .                       if (node->Windows.Size == 1 && !node->IsCentralNode())
        .                       {
        .                           DockNodeHideHostWindow(node);
        .                           node->State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
        .                           DockNodeRemoveWindow(node, window, node->ID); // Will delete the node so it'll be invalid on return
        .                           return;
-- line 16844 ----------------------------------------
-- line 16845 ----------------------------------------
        .                       }
        .                       DockNodeRemoveWindow(node, window, node->ID);
        .                       window_n--;
        .                       continue;
        .                   }
        .           
        .                   // FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
        .                   //node->LocalFlagsInWindow &= ~window->WindowClass.DockNodeFlagsOverrideClear;
    1,140 ( 0.00%)          node->LocalFlagsInWindows |= window->WindowClass.DockNodeFlagsOverrideSet;
        .               }
        .               node->UpdateMergedFlags();
        .           
        .               // Auto-hide tab bar option
        .               ImGuiDockNodeFlags node_flags = node->MergedFlags;
    1,714 ( 0.00%)      if (node->WantHiddenTabBarUpdate && node->Windows.Size == 1 && (node_flags & ImGuiDockNodeFlags_AutoHideTabBar) && !node->IsHiddenTabBar())
        .                   node->WantHiddenTabBarToggle = true;
    1,712 ( 0.00%)      node->WantHiddenTabBarUpdate = false;
        .           
        .               // Cancel toggling if we know our tab bar is enforced to be hidden at all times
    1,142 ( 0.00%)      if (node->WantHiddenTabBarToggle && node->VisibleWindow && (node->VisibleWindow->WindowClass.DockNodeFlagsOverrideSet & ImGuiDockNodeFlags_HiddenTabBar))
        .                   node->WantHiddenTabBarToggle = false;
        .           
        .               // Apply toggles at a single point of the frame (here!)
    1,138 ( 0.00%)      if (node->Windows.Size > 1)
        .                   node->SetLocalFlags(node->LocalFlags & ~ImGuiDockNodeFlags_HiddenTabBar);
        1 ( 0.00%)      else if (node->WantHiddenTabBarToggle)
        .                   node->SetLocalFlags(node->LocalFlags ^ ImGuiDockNodeFlags_HiddenTabBar);
    1,142 ( 0.00%)      node->WantHiddenTabBarToggle = false;
        .           
        .               DockNodeUpdateVisibleFlag(node);
    2,855 ( 0.00%)  }
        .           
        .           // This is rarely called as DockNodeUpdateForRootNode() generally does it most frames.
        .           static void ImGui::DockNodeUpdateHasCentralNodeChild(ImGuiDockNode* node)
        .           {
        .               node->HasCentralNodeChild = false;
        .               if (node->ChildNodes[0])
        .                   DockNodeUpdateHasCentralNodeChild(node->ChildNodes[0]);
        .               if (node->ChildNodes[1])
-- line 16883 ----------------------------------------
-- line 16891 ----------------------------------------
        .                       mark_node = mark_node->ParentNode;
        .                   }
        .               }
        .           }
        .           
        .           static void ImGui::DockNodeUpdateVisibleFlag(ImGuiDockNode* node)
        .           {
        .               // Update visibility flag
    5,144 ( 0.00%)      bool is_visible = (node->ParentNode == NULL) ? node->IsDockSpace() : node->IsCentralNode();
    1,717 ( 0.00%)      is_visible |= (node->Windows.Size > 0);
    1,716 ( 0.00%)      is_visible |= (node->ChildNodes[0] && node->ChildNodes[0]->IsVisible);
    1,716 ( 0.00%)      is_visible |= (node->ChildNodes[1] && node->ChildNodes[1]->IsVisible);
    3,432 ( 0.00%)      node->IsVisible = is_visible;
        .           }
        .           
        .           static void ImGui::DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(node->WantMouseMove == true);
        .               StartMouseMovingWindow(window);
        .               g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node->Pos;
        .               g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
        .               node->WantMouseMove = false;
        .           }
        .           
        .           // Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
        .           static void ImGui::DockNodeUpdateForRootNode(ImGuiDockNode* node)
        .           {
      571 ( 0.00%)      DockNodeUpdateFlagsAndCollapse(node);
   58,206 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdateFlagsAndCollapse(ImGuiDockNode*) (571x)
        .           
        .               // - Setup central node pointers
        .               // - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
        .               // Cannot merge this with DockNodeUpdateFlagsAndCollapse() because FirstNodeWithWindows is found after window removal and child collapsing
        .               ImGuiDockNodeTreeInfo info;
    1,142 ( 0.00%)      DockNodeFindInfo(node, &info);
   17,125 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:DockNodeFindInfo(ImGuiDockNode*, ImGuiDockNodeTreeInfo*) (571x)
    1,142 ( 0.00%)      node->CentralNode = info.CentralNode;
    2,855 ( 0.00%)      node->OnlyNodeWithWindows = (info.CountNodesWithWindows == 1) ? info.FirstNodeWithWindows : NULL;
      571 ( 0.00%)      node->CountNodeWithWindows = info.CountNodesWithWindows;
    1,717 ( 0.00%)      if (node->LastFocusedNodeId == 0 && info.FirstNodeWithWindows != NULL)
        2 ( 0.00%)          node->LastFocusedNodeId = info.FirstNodeWithWindows->ID;
        .           
        .               // Copy the window class from of our first window so it can be used for proper dock filtering.
        .               // When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
        .               // FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
    1,138 ( 0.00%)      if (ImGuiDockNode* first_node_with_windows = info.FirstNodeWithWindows)
        .               {
    2,850 ( 0.00%)          node->WindowClass = first_node_with_windows->Windows[0]->WindowClass;
    1,710 ( 0.00%)          for (int n = 1; n < first_node_with_windows->Windows.Size; n++)
        .                       if (first_node_with_windows->Windows[n]->WindowClass.DockingAllowUnclassed == false)
        .                       {
        .                           node->WindowClass = first_node_with_windows->Windows[n]->WindowClass;
        .                           break;
        .                       }
        .               }
        .           
        .               ImGuiDockNode* mark_node = node->CentralNode;
    2,284 ( 0.00%)      while (mark_node)
        .               {
      571 ( 0.00%)          mark_node->HasCentralNodeChild = true;
      571 ( 0.00%)          mark_node = mark_node->ParentNode;
        .               }
        .           }
        .           
        .           static void DockNodeSetupHostWindow(ImGuiDockNode* node, ImGuiWindow* host_window)
        .           {
        .               // Remove ourselves from any previous different host window
        .               // This can happen if a user mistakenly does (see #4295 for details):
        .               //  - N+0: DockBuilderAddNode(id, 0)    // missing ImGuiDockNodeFlags_DockSpace
        .               //  - N+1: NewFrame()                   // will create floating host window for that node
        .               //  - N+1: DockSpace(id)                // requalify node as dockspace, moving host window
    3,995 ( 0.00%)      if (node->HostWindow && node->HostWindow != host_window && node->HostWindow->DockNodeAsHost == node)
        .                   node->HostWindow->DockNodeAsHost = NULL;
        .           
    1,142 ( 0.00%)      host_window->DockNodeAsHost = node;
    1,142 ( 0.00%)      node->HostWindow = host_window;
        .           }
        .           
        .           static void ImGui::DockNodeUpdate(ImGuiDockNode* node)
    3,997 ( 0.00%)  {
    1,142 ( 0.00%)      ImGuiContext& g = *GImGui;
    1,713 ( 0.00%)      IM_ASSERT(node->LastFrameActive != g.FrameCount);
      571 ( 0.00%)      node->LastFrameAlive = g.FrameCount;
      571 ( 0.00%)      node->IsBgDrawnThisFrame = false;
        .           
    1,713 ( 0.00%)      node->CentralNode = node->OnlyNodeWithWindows = NULL;
    1,142 ( 0.00%)      if (node->IsRootNode())
        .                   DockNodeUpdateForRootNode(node);
        .           
        .               // Remove tab bar if not needed
    1,716 ( 0.00%)      if (node->TabBar && node->IsNoTabBar())
        .                   DockNodeRemoveTabBar(node);
        .           
        .               // Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
        .               bool want_to_hide_host_window = false;
        .               if (node->IsFloatingNode())
        .               {
      571 ( 0.00%)          if (node->Windows.Size <= 1 && node->IsLeafNode())
        .                       if (!g.IO.ConfigDockingAlwaysTabBar && (node->Windows.Size == 0 || !node->Windows[0]->WindowClass.DockingAlwaysTabBar))
        .                           want_to_hide_host_window = true;
        .                   if (node->CountNodeWithWindows == 0)
        .                       want_to_hide_host_window = true;
        .               }
        .               if (want_to_hide_host_window)
        .               {
        .                   if (node->Windows.Size == 1)
-- line 16995 ----------------------------------------
-- line 17035 ----------------------------------------
        .               // This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
        .               // otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
        .               //   N+0: Begin(): window created (with no known size), node is created
        .               //   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
        .               //   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
        .               // We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
        .               // It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
        .               // In reality it isn't very important as user quickly ends up with size data in .ini file.
    2,855 ( 0.00%)      if (node->IsVisible && node->HostWindow == NULL && node->IsFloatingNode() && node->IsLeafNode())
        .               {
        .                   IM_ASSERT(node->Windows.Size > 0);
        .                   ImGuiWindow* ref_window = NULL;
        .                   if (node->SelectedTabId != 0) // Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!
        .                       ref_window = DockNodeFindWindowByID(node, node->SelectedTabId);
        .                   if (ref_window == NULL)
        .                       ref_window = node->Windows[0];
        .                   if (ref_window->AutoFitFramesX > 0 || ref_window->AutoFitFramesY > 0)
-- line 17051 ----------------------------------------
-- line 17053 ----------------------------------------
        .                       node->State = ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing;
        .                       return;
        .                   }
        .               }
        .           
        .               const ImGuiDockNodeFlags node_flags = node->MergedFlags;
        .           
        .               // Decide if the node will have a close button and a window menu button
    3,993 ( 0.00%)      node->HasWindowMenuButton = (node->Windows.Size > 0) && (node_flags & ImGuiDockNodeFlags_NoWindowMenuButton) == 0;
    2,855 ( 0.00%)      node->HasCloseButton = false;
    3,992 ( 0.00%)      for (ImGuiWindow* window : node->Windows)
        .               {
        .                   // FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
    4,560 ( 0.00%)          node->HasCloseButton |= window->HasCloseButton;
    3,993 ( 0.00%)          window->DockIsActive = (node->Windows.Size > 1);
        .               }
    1,142 ( 0.00%)      if (node_flags & ImGuiDockNodeFlags_NoCloseButton)
        .                   node->HasCloseButton = false;
        .           
        .               // Bind or create host window
        .               ImGuiWindow* host_window = NULL;
      571 ( 0.00%)      bool beginned_into_host_window = false;
    1,142 ( 0.00%)      if (node->IsDockSpace())
        .               {
        .                   // [Explicit root dockspace node]
    1,713 ( 0.00%)          IM_ASSERT(node->HostWindow);
        .                   host_window = node->HostWindow;
        .               }
        .               else
        .               {
        .                   // [Automatic root or child nodes]
        .                   if (node->IsRootNode() && node->IsVisible)
        .                   {
        .                       ImGuiWindow* ref_window = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
-- line 17086 ----------------------------------------
-- line 17143 ----------------------------------------
        .                   else if (node->ParentNode)
        .                   {
        .                       node->HostWindow = host_window = node->ParentNode->HostWindow;
        .                       node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Auto;
        .                   }
        .                   if (node->WantMouseMove && node->HostWindow)
        .                       DockNodeStartMouseMovingWindow(node, node->HostWindow);
        .               }
      571 ( 0.00%)      node->RefViewportId = 0; // Clear when we have a host window
        .           
        .               // Update focused node (the one whose title bar is highlight) within a node tree
    1,142 ( 0.00%)      if (node->IsSplitNode())
        .                   IM_ASSERT(node->TabBar == NULL);
    1,142 ( 0.00%)      if (node->IsRootNode())
    2,855 ( 0.00%)          if (ImGuiWindow* p_window = g.NavWindow ? g.NavWindow->RootWindow : NULL)
    3,899 ( 0.00%)              while (p_window != NULL && p_window->DockNode != NULL)
        .                       {
        .                           ImGuiDockNode* p_node = DockNodeGetRootNode(p_window->DockNode);
    1,044 ( 0.00%)                  if (p_node == node)
        .                           {
    1,044 ( 0.00%)                      node->LastFocusedNodeId = p_window->DockNode->ID; // Note: not using root node ID!
        .                               break;
        .                           }
      571 ( 0.00%)                  p_window = p_node->HostWindow ? p_node->HostWindow->RootWindow : NULL;
        .                       }
        .           
        .               // Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
      571 ( 0.00%)      ImGuiDockNode* central_node = node->CentralNode;
    7,942 ( 0.00%)      const bool central_node_hole = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0 && central_node != NULL && central_node->IsEmpty();
        .               bool central_node_hole_register_hit_test_hole = central_node_hole;
        .               if (central_node_hole)
        .                   if (const ImGuiPayload* payload = ImGui::GetDragDropPayload())
        .                       if (payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, *(ImGuiWindow**)payload->Data))
        .                           central_node_hole_register_hit_test_hole = false;
        .               if (central_node_hole_register_hit_test_hole)
        .               {
        .                   // We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
-- line 17179 ----------------------------------------
-- line 17194 ----------------------------------------
        .                       if (host_window->ParentWindow)
        .                           SetWindowHitTestHole(host_window->ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min);
        .                   }
        .               }
        .           
        .               // Update position/size, process and draw resizing splitters
        .               if (node->IsRootNode() && host_window)
        .               {
    3,426 ( 0.00%)          DockNodeTreeUpdatePosSize(node, host_window->Pos, host_window->Size);
   11,420 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeTreeUpdatePosSize(ImGuiDockNode*, ImVec2, ImVec2, ImGuiDockNode*) (571x)
    2,284 ( 0.00%)          PushStyleColor(ImGuiCol_Separator, g.Style.Colors[ImGuiCol_Border]);
   22,919 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleColor(int, ImVec4 const&) (571x)
    2,284 ( 0.00%)          PushStyleColor(ImGuiCol_SeparatorActive, g.Style.Colors[ImGuiCol_ResizeGripActive]);
   22,840 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleColor(int, ImVec4 const&) (571x)
    2,284 ( 0.00%)          PushStyleColor(ImGuiCol_SeparatorHovered, g.Style.Colors[ImGuiCol_ResizeGripHovered]);
   22,840 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleColor(int, ImVec4 const&) (571x)
    1,142 ( 0.00%)          DockNodeTreeUpdateSplitter(node);
   11,420 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeTreeUpdateSplitter(ImGuiDockNode*) (571x)
        .                   PopStyleColor(3);
        .               }
        .           
        .               // Draw empty node background (currently can only be the Central Node)
        2 ( 0.00%)      if (host_window && node->IsEmpty() && node->IsVisible)
        .               {
        1 ( 0.00%)          host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        3 ( 0.00%)          node->LastBgColor = (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) ? 0 : GetColorU32(ImGuiCol_DockingEmptyBg);
        2 ( 0.00%)          if (node->LastBgColor != 0)
        9 ( 0.00%)              host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, node->LastBgColor);
      284 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_draw.cpp:ImDrawList::AddRectFilled(ImVec2 const&, ImVec2 const&, unsigned int, float, int) (1x)
        1 ( 0.00%)          node->IsBgDrawnThisFrame = true;
        .               }
        .           
        .               // Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
        .               // We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
        .               // _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
    2,280 ( 0.00%)      const bool render_dockspace_bg = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0;
        .               if (render_dockspace_bg && node->IsVisible)
        .               {
        .                   host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        .                   if (central_node_hole)
        .                       RenderRectFilledWithHole(host_window->DrawList, node->Rect(), central_node->Rect(), GetColorU32(ImGuiCol_WindowBg), 0.0f);
        .                   else
        .                       host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, GetColorU32(ImGuiCol_WindowBg), 0.0f);
        .               }
        .           
        .               // Draw and populate Tab Bar
        .               if (host_window)
      571 ( 0.00%)          host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
    1,713 ( 0.00%)      if (host_window && node->Windows.Size > 0)
        .               {
        .                   DockNodeUpdateTabBar(node, host_window);
        .               }
        .               else
        .               {
        .                   node->WantCloseAll = false;
        1 ( 0.00%)          node->WantCloseTabId = 0;
        1 ( 0.00%)          node->IsFocused = false;
        .               }
        3 ( 0.00%)      if (node->TabBar && node->TabBar->SelectedTabId)
        .                   node->SelectedTabId = node->TabBar->SelectedTabId;
        3 ( 0.00%)      else if (node->Windows.Size > 0)
    1,710 ( 0.00%)          node->SelectedTabId = node->Windows[0]->TabId;
        .           
        .               // Draw payload drop target
    1,714 ( 0.00%)      if (host_window && node->IsVisible)
    3,426 ( 0.00%)          if (node->IsRootNode() && (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != host_window))
    1,142 ( 0.00%)              BeginDockableDragDropTarget(host_window);
   15,417 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::BeginDockableDragDropTarget(ImGuiWindow*) (571x)
        .           
        .               // We update this after DockNodeUpdateTabBar()
    1,713 ( 0.00%)      node->LastFrameActive = g.FrameCount;
        .           
        .               // Recurse into children
        .               // FIXME-DOCK FIXME-OPT: Should not need to recurse into children
      571 ( 0.00%)      if (host_window)
        .               {
    1,713 ( 0.00%)          if (node->ChildNodes[0])
        .                       DockNodeUpdate(node->ChildNodes[0]);
    1,713 ( 0.00%)          if (node->ChildNodes[1])
        .                       DockNodeUpdate(node->ChildNodes[1]);
        .           
        .                   // Render outer borders last (after the tab bar)
    1,142 ( 0.00%)          if (node->IsRootNode())
    1,713 ( 0.00%)              RenderWindowOuterBorders(host_window);
   41,112 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::RenderWindowOuterBorders(ImGuiWindow*) (571x)
        .               }
        .           
        .               // End host window
    1,142 ( 0.00%)      if (beginned_into_host_window) //-V1020
        .                   End();
    4,568 ( 0.00%)  }
        .           
        .           // Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
        .           static int IMGUI_CDECL TabItemComparerByDockOrder(const void* lhs, const void* rhs)
        .           {
        .               ImGuiWindow* a = ((const ImGuiTabItem*)lhs)->Window;
        .               ImGuiWindow* b = ((const ImGuiTabItem*)rhs)->Window;
        .               if (int d = ((a->DockOrder == -1) ? INT_MAX : a->DockOrder) - ((b->DockOrder == -1) ? INT_MAX : b->DockOrder))
        .                   return d;
-- line 17284 ----------------------------------------
-- line 17354 ----------------------------------------
        .               PopID();
        .               End();
        .           }
        .           
        .           static bool IsDockNodeTitleBarHighlighted(ImGuiDockNode* node, ImGuiDockNode* root_node)
        .           {
        .               // CTRL+Tab highlight (only highlighting leaf node, not whole hierarchy)
        .               ImGuiContext& g = *GImGui;
    1,710 ( 0.00%)      if (g.NavWindowingTarget)
        .                   return (g.NavWindowingTarget->DockNode == node);
        .           
        .               // FIXME-DOCKING: May want alternative to treat central node void differently? e.g. if (g.NavWindow == host_window)
    3,420 ( 0.00%)      if (g.NavWindow && root_node->LastFocusedNodeId == node->ID)
        .               {
        .                   // FIXME: This could all be backed in RootWindowForTitleBarHighlight? Probably need to reorganize for both dock nodes + other RootWindowForTitleBarHighlight users (not-node)
        .                   ImGuiWindow* parent_window = g.NavWindow->RootWindow;
    1,140 ( 0.00%)          while (parent_window->Flags & ImGuiWindowFlags_ChildMenu)
      570 ( 0.00%)              parent_window = parent_window->ParentWindow->RootWindow;
    2,850 ( 0.00%)          ImGuiDockNode* start_parent_node = parent_window->DockNodeAsHost ? parent_window->DockNodeAsHost : parent_window->DockNode;
    1,188 ( 0.00%)          for (ImGuiDockNode* parent_node = start_parent_node; parent_node != NULL; parent_node = parent_node->HostWindow ? parent_node->HostWindow->RootWindow->DockNode : NULL)
    1,044 ( 0.00%)              if ((parent_node = ImGui::DockNodeGetRootNode(parent_node)) == root_node)
        .                           return true;
        .               }
        .               return false;
        .           }
        .           
        .           // Submit the tab bar corresponding to a dock node and various housekeeping details.
        .           static void ImGui::DockNodeUpdateTabBar(ImGuiDockNode* node, ImGuiWindow* host_window)
        .           {
      570 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiStyle& style = g.Style;
        .           
    2,850 ( 0.00%)      const bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
    2,280 ( 0.00%)      const bool closed_all = node->WantCloseAll && node_was_active;
    4,560 ( 0.00%)      const ImGuiID closed_one = node->WantCloseTabId && node_was_active;
    1,710 ( 0.00%)      node->WantCloseAll = false;
      570 ( 0.00%)      node->WantCloseTabId = 0;
        .           
        .               // Decide if we should use a focused title bar color
        .               bool is_focused = false;
        .               ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        .               if (IsDockNodeTitleBarHighlighted(node, root_node))
        .                   is_focused = true;
        .           
        .               // Hidden tab bar will show a triangle on the upper-left (in Begin)
    1,140 ( 0.00%)      if (node->IsHiddenTabBar() || node->IsNoTabBar())
        .               {
    1,710 ( 0.00%)          node->VisibleWindow = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
    1,140 ( 0.00%)          node->IsFocused = is_focused;
      522 ( 0.00%)          if (is_focused)
    1,044 ( 0.00%)              node->LastFrameFocused = g.FrameCount;
    1,140 ( 0.00%)          if (node->VisibleWindow)
        .                   {
        .                       // Notify root of visible window (used to display title in OS task bar)
       96 ( 0.00%)              if (is_focused || root_node->VisibleWindow == NULL)
      522 ( 0.00%)                  root_node->VisibleWindow = node->VisibleWindow;
    1,710 ( 0.00%)              if (node->TabBar)
        .                           node->TabBar->VisibleTabId = node->VisibleWindow->TabId;
        .                   }
        .                   return;
        .               }
        .           
        .               // Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
        .               bool backup_skip_item = host_window->SkipItems;
        .               if (!node->IsDockSpace())
-- line 17418 ----------------------------------------
-- line 17656 ----------------------------------------
        .                   host_window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
        .                   host_window->SkipItems = backup_skip_item;
        .               }
        .           }
        .           
        .           static void ImGui::DockNodeAddTabBar(ImGuiDockNode* node)
        .           {
        .               IM_ASSERT(node->TabBar == NULL);
        4 ( 0.00%)      node->TabBar = IM_NEW(ImGuiTabBar);
       10 ( 0.00%)  => /home/coco/Documents/GitHub/SpaghettiKart/build/_deps/imgui-src/imgui_widgets.cpp:ImGuiTabBar::ImGuiTabBar() (1x)
        .           }
        .           
        .           static void ImGui::DockNodeRemoveTabBar(ImGuiDockNode* node)
        .           {
        .               if (node->TabBar == NULL)
        .                   return;
        .               IM_DELETE(node->TabBar);
        1 ( 0.00%)      node->TabBar = NULL;
        .           }
        .           
        .           static bool DockNodeIsDropAllowedOne(ImGuiWindow* payload, ImGuiWindow* host_window)
        .           {
        .               if (host_window->DockNodeAsHost && host_window->DockNodeAsHost->IsDockSpace() && payload->BeginOrderWithinContext < host_window->BeginOrderWithinContext)
        .                   return false;
        .           
        .               ImGuiWindowClass* host_class = host_window->DockNodeAsHost ? &host_window->DockNodeAsHost->WindowClass : &host_window->WindowClass;
-- line 17680 ----------------------------------------
-- line 18149 ----------------------------------------
        .                   ctx->DockContext.Nodes.SetVoidPtr(child_1->ID, NULL);
        .                   IM_DELETE(child_1);
        .               }
        .           }
        .           
        .           // Update Pos/Size for a node hierarchy (don't affect child Windows yet)
        .           // (Depth-first, Pre-Order)
        .           void ImGui::DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, ImGuiDockNode* only_write_to_single_node)
    3,997 ( 0.00%)  {
        .               // During the regular dock node update we write to all nodes.
        .               // 'only_write_to_single_node' is only set when turning a node visible mid-frame and we need its size right-away.
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               const bool write_to_node = only_write_to_single_node == NULL || only_write_to_single_node == node;
    1,142 ( 0.00%)      if (write_to_node)
        .               {
      571 ( 0.00%)          node->Pos = pos;
    1,142 ( 0.00%)          node->Size = size;
        .               }
        .           
    1,142 ( 0.00%)      if (node->IsLeafNode())
        .                   return;
        .           
        .               ImGuiDockNode* child_0 = node->ChildNodes[0];
        .               ImGuiDockNode* child_1 = node->ChildNodes[1];
        .               ImVec2 child_0_pos = pos, child_1_pos = pos;
        .               ImVec2 child_0_size = size, child_1_size = size;
        .           
        .               const bool child_0_is_toward_single_node = (only_write_to_single_node != NULL && DockNodeIsInHierarchyOf(only_write_to_single_node, child_0));
-- line 18176 ----------------------------------------
-- line 18241 ----------------------------------------
        .                   child_0->WantLockSizeOnce = child_1->WantLockSizeOnce = false;
        .           
        .               const bool child_0_recurse = only_write_to_single_node ? child_0_is_toward_single_node : child_0->IsVisible;
        .               const bool child_1_recurse = only_write_to_single_node ? child_1_is_toward_single_node : child_1->IsVisible;
        .               if (child_0_recurse)
        .                   DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size);
        .               if (child_1_recurse)
        .                   DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size);
    2,284 ( 0.00%)  }
        .           
        .           static void DockNodeTreeUpdateSplitterFindTouchingNode(ImGuiDockNode* node, ImGuiAxis axis, int side, ImVector<ImGuiDockNode*>* touching_nodes)
        .           {
        .               if (node->IsLeafNode())
        .               {
        .                   touching_nodes->push_back(node);
        .                   return;
        .               }
-- line 18257 ----------------------------------------
-- line 18260 ----------------------------------------
        .                       DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[0], axis, side, touching_nodes);
        .               if (node->ChildNodes[1]->IsVisible)
        .                   if (node->SplitAxis != axis || side == 1 || !node->ChildNodes[0]->IsVisible)
        .                       DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[1], axis, side, touching_nodes);
        .           }
        .           
        .           // (Depth-First, Pre-Order)
        .           void ImGui::DockNodeTreeUpdateSplitter(ImGuiDockNode* node)
    5,139 ( 0.00%)  {
    1,142 ( 0.00%)      if (node->IsLeafNode())
        .                   return;
        .           
        .               ImGuiContext& g = *GImGui;
        .           
        .               ImGuiDockNode* child_0 = node->ChildNodes[0];
        .               ImGuiDockNode* child_1 = node->ChildNodes[1];
        .               if (child_0->IsVisible && child_1->IsVisible)
        .               {
-- line 18277 ----------------------------------------
-- line 18374 ----------------------------------------
        .                       PopID();
        .                   }
        .               }
        .           
        .               if (child_0->IsVisible)
        .                   DockNodeTreeUpdateSplitter(child_0);
        .               if (child_1->IsVisible)
        .                   DockNodeTreeUpdateSplitter(child_1);
    4,568 ( 0.00%)  }
        .           
        .           ImGuiDockNode* ImGui::DockNodeTreeFindFallbackLeafNode(ImGuiDockNode* node)
        .           {
        .               if (node->IsLeafNode())
        .                   return node;
        .               if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[0]))
        .                   return leaf_node;
        .               if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[1]))
-- line 18390 ----------------------------------------
-- line 18460 ----------------------------------------
        .               window->DockId = dock_id;
        .           }
        .           
        .           // Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
        .           // The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
        .           // DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
        .           // When ImGuiDockNodeFlags_KeepAliveOnly is set, nothing is submitted in the current window (function may be called from any location).
        .           ImGuiID ImGui::DockSpace(ImGuiID id, const ImVec2& size_arg, ImGuiDockNodeFlags flags, const ImGuiWindowClass* window_class)
    5,139 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiWindow* window = GetCurrentWindowRead();
    1,142 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .                   return 0;
        .           
        .               // Early out if parent window is hidden/collapsed
        .               // This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
        .               // If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
    3,426 ( 0.00%)      if (window->SkipItems)
        .                   flags |= ImGuiDockNodeFlags_KeepAliveOnly;
    1,713 ( 0.00%)      if ((flags & ImGuiDockNodeFlags_KeepAliveOnly) == 0)
        .                   window = GetCurrentWindow(); // call to set window->WriteAccessed = true;
        .           
    1,142 ( 0.00%)      IM_ASSERT((flags & ImGuiDockNodeFlags_DockSpace) == 0);
    1,142 ( 0.00%)      IM_ASSERT(id != 0);
        .               ImGuiDockNode* node = DockContextFindNodeByID(&g, id);
    1,142 ( 0.00%)      if (!node)
        .               {
        .                   IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X created\n", id);
        .                   node = DockContextAddNode(&g, id);
        .                   node->SetLocalFlags(ImGuiDockNodeFlags_CentralNode);
        .               }
    1,142 ( 0.00%)      if (window_class && window_class->ClassId != node->WindowClass.ClassId)
        .                   IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", id, node->WindowClass.ClassId, window_class->ClassId);
      571 ( 0.00%)      node->SharedFlags = flags;
    2,284 ( 0.00%)      node->WindowClass = window_class ? *window_class : ImGuiWindowClass();
        .           
        .               // When a DockSpace transitioned form implicit to explicit this may be called a second time
        .               // It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
    1,713 ( 0.00%)      if (node->LastFrameActive == g.FrameCount && !(flags & ImGuiDockNodeFlags_KeepAliveOnly))
        .               {
        .                   IM_ASSERT(node->IsDockSpace() == false && "Cannot call DockSpace() twice a frame with the same ID");
        .                   node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_DockSpace);
      571 ( 0.00%)          return id;
        .               }
    1,142 ( 0.00%)      node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_DockSpace);
        .           
        .               // Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
    1,142 ( 0.00%)      if (flags & ImGuiDockNodeFlags_KeepAliveOnly)
        .               {
        .                   node->LastFrameAlive = g.FrameCount;
        .                   return id;
        .               }
        .           
        .               const ImVec2 content_avail = GetContentRegionAvail();
        .               ImVec2 size = ImTrunc(size_arg);
    1,713 ( 0.00%)      if (size.x <= 0.0f)
    2,284 ( 0.00%)          size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    1,713 ( 0.00%)      if (size.y <= 0.0f)
    2,284 ( 0.00%)          size.y = ImMax(content_avail.y + size.y, 4.0f);
    3,997 ( 0.00%)      IM_ASSERT(size.x > 0.0f && size.y > 0.0f);
        .           
    1,142 ( 0.00%)      node->Pos = window->DC.CursorPos;
    1,713 ( 0.00%)      node->Size = node->SizeRef = size;
        .               SetNextWindowPos(node->Pos);
        .               SetNextWindowSize(node->Size);
      571 ( 0.00%)      g.NextWindowData.PosUndock = false;
        .           
        .               // FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
        .               // FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
        .               ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_DockNodeHost;
        .               window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
        .               window_flags |= ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;
        .               window_flags |= ImGuiWindowFlags_NoBackground;
        .           
        .               char title[256];
    5,710 ( 0.00%)      ImFormatString(title, IM_ARRAYSIZE(title), "%s/DockSpace_%08X", window->Name, id);
  443,096 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImFormatString(char*, unsigned long, char const*, ...) (571x)
        .           
    1,713 ( 0.00%)      PushStyleVar(ImGuiStyleVar_ChildBorderSize, 0.0f);
   21,698 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PushStyleVar(int, float) (571x)
    2,284 ( 0.00%)      Begin(title, NULL, window_flags);
1,503,900 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::Begin(char const*, bool*, int) (571x)
      571 ( 0.00%)      PopStyleVar();
   15,417 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::PopStyleVar(int) [clone .constprop.0] (571x)
        .           
      571 ( 0.00%)      ImGuiWindow* host_window = g.CurrentWindow;
        .               DockNodeSetupHostWindow(node, host_window);
      571 ( 0.00%)      host_window->ChildId = window->GetID(title);
      571 ( 0.00%)      node->OnlyNodeWithWindows = NULL;
        .           
    1,142 ( 0.00%)      IM_ASSERT(node->IsRootNode());
        .           
        .               // We need to handle the rare case were a central node is missing.
        .               // This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
        .               // Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
        .               // It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
        .               // The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
        .               // as it doesn't make sense for an empty dockspace to not have this property.
    2,284 ( 0.00%)      if (node->IsLeafNode() && !node->IsCentralNode())
        .                   node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
        .           
        .               // Update the node
    1,713 ( 0.00%)      DockNodeUpdate(node);
  417,139 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeUpdate(ImGuiDockNode*) (571x)
        .           
      571 ( 0.00%)      End();
   86,792 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::End() (571x)
        .           
        .               ImRect bb(node->Pos, node->Pos + size);
    2,284 ( 0.00%)      ItemSize(size);
   32,547 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ItemSize(ImVec2 const&, float) (571x)
    3,426 ( 0.00%)      ItemAdd(bb, id, NULL, ImGuiItemFlags_NoNav); // Not a nav point (could be, would need to draw the nav rect and replicate/refactor activation from BeginChild(), but seems like CTRL+Tab works better here?)
   50,816 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::ItemAdd(ImRect const&, unsigned int, ImRect const*, int) (571x)
    1,969 ( 0.00%)      if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && IsWindowChildOf(g.HoveredWindow, host_window, false, true)) // To fullfill IsItemHovered(), similar to EndChild()
      768 ( 0.00%)          g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
        .           
        .               return id;
    5,139 ( 0.00%)  }
        .           
        .           // Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
        .           // The limitation with this call is that your window won't have a menu bar.
        .           // Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
        .           // But you can also use BeginMainMenuBar(). If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
        .           ImGuiID ImGui::DockSpaceOverViewport(const ImGuiViewport* viewport, ImGuiDockNodeFlags dockspace_flags, const ImGuiWindowClass* window_class)
        .           {
        .               if (viewport == NULL)
-- line 18577 ----------------------------------------
-- line 18649 ----------------------------------------
        .                   if (settings->DockId != node_id)
        .                       settings->DockOrder = -1;
        .                   settings->DockId = node_id;
        .               }
        .           }
        .           
        .           ImGuiDockNode* ImGui::DockBuilderGetNode(ImGuiID node_id)
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               return DockContextFindNodeByID(&g, node_id);
        .           }
        .           
        .           void ImGui::DockBuilderSetNodePos(ImGuiID node_id, ImVec2 pos)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiDockNode* node = DockContextFindNodeByID(&g, node_id);
        .               if (node == NULL)
-- line 18665 ----------------------------------------
-- line 18725 ----------------------------------------
        .                   return;
        .               if (node->IsCentralNode() && node->ParentNode)
        .                   node->ParentNode->SetLocalFlags(node->ParentNode->LocalFlags | ImGuiDockNodeFlags_CentralNode);
        .               DockContextRemoveNode(&g, node, true);
        .           }
        .           
        .           // root_id = 0 to remove all, root_id != 0 to remove child of given node.
        .           void ImGui::DockBuilderRemoveNodeChildNodes(ImGuiID root_id)
        8 ( 0.00%)  {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               ImGuiDockContext* dc = &g.DockContext;
        .           
        2 ( 0.00%)      ImGuiDockNode* root_node = root_id ? DockContextFindNodeByID(&g, root_id) : NULL;
        .               if (root_id && root_node == NULL)
        .                   return;
        .               bool has_central_node = false;
        .           
        .               ImGuiDataAuthority backup_root_node_authority_for_pos = root_node ? root_node->AuthorityForPos : ImGuiDataAuthority_Auto;
        .               ImGuiDataAuthority backup_root_node_authority_for_size = root_node ? root_node->AuthorityForSize : ImGuiDataAuthority_Auto;
        .           
        .               // Process active windows
        .               ImVector<ImGuiDockNode*> nodes_to_remove;
        3 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
        .                   if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        .                   {
        .                       bool want_removal = (root_id == 0) || (node->ID != root_id && DockNodeGetRootNode(node)->ID == root_id);
        .                       if (want_removal)
        .                       {
        .                           if (node->IsCentralNode())
        .                               has_central_node = true;
        .                           if (root_id != 0)
-- line 18755 ----------------------------------------
-- line 18792 ----------------------------------------
        .                   dc->Nodes.Clear();
        .                   dc->Requests.clear();
        .               }
        .               else if (has_central_node)
        .               {
        .                   root_node->CentralNode = root_node;
        .                   root_node->SetLocalFlags(root_node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
        .               }
        8 ( 0.00%)  }
        .           
        .           void ImGui::DockBuilderRemoveNodeDockedWindows(ImGuiID root_id, bool clear_settings_refs)
        .           {
        .               // Clear references in settings
        .               ImGuiContext& g = *GImGui;
        2 ( 0.00%)      if (clear_settings_refs)
        .               {
        .                   for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        .                   {
        .                       bool want_removal = (root_id == 0) || (settings->DockId == root_id);
        .                       if (!want_removal && settings->DockId != 0)
        .                           if (ImGuiDockNode* node = DockContextFindNodeByID(&g, settings->DockId))
        .                               if (DockNodeGetRootNode(node)->ID == root_id)
        .                                   want_removal = true;
        .                       if (want_removal)
        .                           settings->DockId = 0;
        .                   }
        .               }
        .           
        .               // Clear references in windows
        4 ( 0.00%)      for (int n = 0; n < g.Windows.Size; n++)
        .               {
        .                   ImGuiWindow* window = g.Windows[n];
        .                   bool want_removal = (root_id == 0) || (window->DockNode && DockNodeGetRootNode(window->DockNode)->ID == root_id) || (window->DockNodeAsHost && window->DockNodeAsHost->ID == root_id);
        .                   if (want_removal)
        .                   {
        .                       const ImGuiID backup_dock_id = window->DockId;
        .                       IM_UNUSED(backup_dock_id);
        .                       DockContextProcessUndockWindow(&g, window, clear_settings_refs);
-- line 18829 ----------------------------------------
-- line 19044 ----------------------------------------
        .           // - BeginDocked()
        .           // - BeginDockableDragDropSource()
        .           // - BeginDockableDragDropTarget()
        .           //-----------------------------------------------------------------------------
        .           
        .           bool ImGui::GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
   13,709 ( 0.00%)      if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
      571 ( 0.00%)          if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
        .                       if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
        .                           return true;
        .               return false;
        .           }
        .           
        .           static ImGuiDockNode* ImGui::DockContextBindNodeToWindow(ImGuiContext* ctx, ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *ctx;
        .               ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
        .               IM_ASSERT(window->DockNode == NULL);
        .           
        .               // We should not be docking into a split node (SetWindowDock should avoid this)
        4 ( 0.00%)      if (node && node->IsSplitNode())
        .               {
        .                   DockContextProcessUndockWindow(ctx, window);
        .                   return NULL;
        .               }
        .           
        .               // Create node
        .               if (node == NULL)
        .               {
-- line 19074 ----------------------------------------
-- line 19076 ----------------------------------------
        .                   node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;
        .                   node->LastFrameAlive = g.FrameCount;
        .               }
        .           
        .               // If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
        .               // so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
        .               // If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
        .               // This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
        4 ( 0.00%)      if (!node->IsVisible)
        .               {
        .                   ImGuiDockNode* ancestor_node = node;
        .                   while (!ancestor_node->IsVisible && ancestor_node->ParentNode)
        .                       ancestor_node = ancestor_node->ParentNode;
        .                   IM_ASSERT(ancestor_node->Size.x > 0.0f && ancestor_node->Size.y > 0.0f);
        .                   DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(ancestor_node));
        .                   DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node->Pos, ancestor_node->Size, node);
        .               }
        .           
        .               // Add window to node
        .               bool node_was_visible = node->IsVisible;
        4 ( 0.00%)      DockNodeAddWindow(node, window, true);
      672 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockNodeAddWindow(ImGuiDockNode*, ImGuiWindow*, bool) (1x)
        6 ( 0.00%)      node->IsVisible = node_was_visible; // Don't mark visible right away (so DockContextEndFrame() doesn't render it, maybe other side effects? will see)
        4 ( 0.00%)      IM_ASSERT(node == window->DockNode);
        .               return node;
        .           }
        .           
        .           static void StoreDockStyleForWindow(ImGuiWindow* window)
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .               for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
    3,426 ( 0.00%)          window->DockStyle.Colors[color_n] = ImGui::ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
        .           }
        .           
        .           void ImGui::BeginDocked(ImGuiWindow* window, bool* p_open)
    3,997 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               // Clear fields ahead so most early-out paths don't have to do it
      571 ( 0.00%)      window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
        .           
        .               const bool auto_dock_node = GetWindowAlwaysWantOwnTabBar(window);
        .               if (auto_dock_node)
        .               {
      571 ( 0.00%)          if (window->DockId == 0)
        .                   {
        .                       IM_ASSERT(window->DockNode == NULL);
        .                       window->DockId = DockContextGenNodeID(&g);
        .                   }
        .               }
        .               else
        .               {
        .                   // Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
        .                   bool want_undock = false;
    1,142 ( 0.00%)          want_undock |= (window->Flags & ImGuiWindowFlags_NoDocking) != 0;
    1,142 ( 0.00%)          want_undock |= (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) && (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) && g.NextWindowData.PosUndock;
    1,142 ( 0.00%)          if (want_undock)
        .                   {
        .                       DockContextProcessUndockWindow(&g, window);
        .                       return;
        .                   }
        .               }
        .           
        .               // Bind to our dock node
    1,142 ( 0.00%)      ImGuiDockNode* node = window->DockNode;
    1,142 ( 0.00%)      if (node != NULL)
    1,140 ( 0.00%)          IM_ASSERT(window->DockId == node->ID);
        2 ( 0.00%)      if (window->DockId != 0 && node == NULL)
        .               {
        .                   node = DockContextBindNodeToWindow(&g, window);
        .                   if (node == NULL)
        .                       return;
        .               }
        .           
        .           #if 0
        .               // Undock if the ImGuiDockNodeFlags_NoDockingInCentralNode got set
-- line 19150 ----------------------------------------
-- line 19152 ----------------------------------------
        .               {
        .                   DockContextProcessUndockWindow(ctx, window);
        .                   return;
        .               }
        .           #endif
        .           
        .               // Undock if our dockspace node disappeared
        .               // Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
    1,713 ( 0.00%)      if (node->LastFrameAlive < g.FrameCount)
        .               {
        .                   // If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
        .                   ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        .                   if (root_node->LastFrameAlive < g.FrameCount)
        .                       DockContextProcessUndockWindow(&g, window);
        .                   else
        .                       window->DockIsActive = true;
        .                   return;
-- line 19168 ----------------------------------------
-- line 19169 ----------------------------------------
        .               }
        .           
        .               // Store style overrides
        .               StoreDockStyleForWindow(window);
        .           
        .               // Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
        .               // and never create neither a host window neither a tab bar.
        .               // FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
    1,713 ( 0.00%)      if (node->HostWindow == NULL)
        .               {
        .                   if (node->State == ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing)
        .                       window->DockIsActive = true;
        .                   if (node->Windows.Size > 1 && window->Appearing) // Only hide appearing window
        .                       DockNodeHideWindowDuringHostWindowCreation(window);
        .                   return;
        .               }
        .           
        .               // We can have zero-sized nodes (e.g. children of a small-size dockspace)
        .               IM_ASSERT(node->HostWindow);
    1,142 ( 0.00%)      IM_ASSERT(node->IsLeafNode());
    3,997 ( 0.00%)      IM_ASSERT(node->Size.x >= 0.0f && node->Size.y >= 0.0f);
      571 ( 0.00%)      node->State = ImGuiDockNodeState_HostWindowVisible;
        .           
        .               // Undock if we are submitted earlier than the host window
    2,855 ( 0.00%)      if (!(node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly) && window->BeginOrderWithinContext < node->HostWindow->BeginOrderWithinContext)
        .               {
        .                   DockContextProcessUndockWindow(&g, window);
        .                   return;
        .               }
        .           
        .               // Position/Size window
        .               SetNextWindowPos(node->Pos);
        .               SetNextWindowSize(node->Size);
      571 ( 0.00%)      g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
    2,284 ( 0.00%)      window->DockIsActive = true;
        .               window->DockNodeIsVisible = true;
        .               window->DockTabIsVisible = false;
    1,713 ( 0.00%)      if (node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly)
        .                   return;
        .           
        .               // When the window is selected we mark it as visible.
    2,855 ( 0.00%)      if (node->VisibleWindow == window)
        .                   window->DockTabIsVisible = true;
        .           
        .               // Update window flag
    1,713 ( 0.00%)      IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) == 0);
        .               window->Flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize;
      571 ( 0.00%)      window->ChildFlags |= ImGuiChildFlags_AlwaysUseWindowPadding;
        .               if (node->IsHiddenTabBar() || node->IsNoTabBar())
        .                   window->Flags |= ImGuiWindowFlags_NoTitleBar;
        .               else
    3,426 ( 0.00%)          window->Flags &= ~ImGuiWindowFlags_NoTitleBar;      // Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!
        .           
        .               // Save new dock order only if the window has been visible once already
        .               // This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
    1,715 ( 0.00%)      if (node->TabBar && window->WasActive)
        .                   window->DockOrder = (short)DockNodeGetTabOrder(window);
        .           
    2,855 ( 0.00%)      if ((node->WantCloseAll || node->WantCloseTabId == window->TabId) && p_open != NULL)
        .                   *p_open = false;
        .           
        .               // Update ChildId to allow returning from Child to Parent with Escape
      571 ( 0.00%)      ImGuiWindow* parent_window = window->DockNode->HostWindow;
    1,142 ( 0.00%)      window->ChildId = parent_window->GetID(window->Name);
    3,426 ( 0.00%)  }
        .           
        .           void ImGui::BeginDockableDragDropSource(ImGuiWindow* window)
        .           {
        .               ImGuiContext& g = *GImGui;
        .               IM_ASSERT(g.ActiveId == window->MoveId);
        .               IM_ASSERT(g.MovingWindow == window);
        .               IM_ASSERT(g.CurrentWindow == window);
        .           
-- line 19241 ----------------------------------------
-- line 19259 ----------------------------------------
        .               {
        .                   SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
        .                   EndDragDropSource();
        .                   StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
        .               }
        .           }
        .           
        .           void ImGui::BeginDockableDragDropTarget(ImGuiWindow* window)
    6,852 ( 0.00%)  {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
        .           
        .               //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
    1,142 ( 0.00%)      IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
    1,142 ( 0.00%)      if (!g.DragDropActive)
        .                   return;
        .               //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
        .               if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
        .                   return;
        .           
        .               // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
        .               // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
        .               const ImGuiPayload* payload = &g.DragDropPayload;
-- line 19280 ----------------------------------------
-- line 19339 ----------------------------------------
        .                       DockNodePreviewDockRender(window, node, payload_window, &split_outer);
        .           
        .                       // Queue docking request
        .                       if (split_data->IsDropAllowed && payload->IsDelivery())
        .                           DockContextQueueDock(&g, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
        .                   }
        .               }
        .               EndDragDropTarget();
    5,710 ( 0.00%)  }
        .           
        .           //-----------------------------------------------------------------------------
        .           // Docking: Settings
        .           //-----------------------------------------------------------------------------
        .           // - DockSettingsRenameNodeReferences()
        .           // - DockSettingsRemoveNodeReferences()
        .           // - DockSettingsFindNodeSettings()
        .           // - DockSettingsHandler_ApplyAll()
-- line 19355 ----------------------------------------
-- line 19392 ----------------------------------------
        .                           return;
        .                       }
        .           }
        .           
        .           static ImGuiDockNodeSettings* ImGui::DockSettingsFindNodeSettings(ImGuiContext* ctx, ImGuiID id)
        .           {
        .               // FIXME-OPT
        .               ImGuiDockContext* dc = &ctx->DockContext;
        1 ( 0.00%)      for (int n = 0; n < dc->NodesSettings.Size; n++)
        .                   if (dc->NodesSettings[n].ID == id)
        .                       return &dc->NodesSettings[n];
        .               return NULL;
        .           }
        .           
        .           // Clear settings data
        .           static void ImGui::DockSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        2 ( 0.00%)  {
        .               ImGuiDockContext* dc = &ctx->DockContext;
        .               dc->NodesSettings.clear();
        3 ( 0.00%)      DockContextClearNodes(ctx, 0, true);
       60 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextClearNodes(ImGuiContext*, unsigned int, bool) [clone .constprop.0] (1x)
        1 ( 0.00%)  }
        .           
        .           // Recreate nodes based on settings data
        .           static void ImGui::DockSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        8 ( 0.00%)  {
        .               // Prune settings at boot time only
        .               ImGuiDockContext* dc = &ctx->DockContext;
        3 ( 0.00%)      if (ctx->Windows.Size == 0)
        .                   DockContextPruneUnusedSettingsNodes(ctx);
        4 ( 0.00%)      DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
    1,183 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextBuildNodesFromSettings(ImGuiContext*, ImGuiDockNodeSettings*, int) (1x)
        3 ( 0.00%)      DockContextBuildAddWindowsToNodes(ctx, 0);
       16 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGui::DockContextBuildAddWindowsToNodes(ImGuiContext*, unsigned int) (1x)
        7 ( 0.00%)  }
        .           
        .           static void* ImGui::DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
        2 ( 0.00%)  {
        6 ( 0.00%)      if (strcmp(name, "Data") != 0)
       20 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 (1x)
        .                   return NULL;
        .               return (void*)1;
        2 ( 0.00%)  }
        .           
        .           static void ImGui::DockSettingsHandler_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void*, const char* line)
       20 ( 0.00%)  {
        2 ( 0.00%)      char c = 0;
        4 ( 0.00%)      int x = 0, y = 0;
        2 ( 0.00%)      int r = 0;
        .           
        .               // Parsing, e.g.
        .               // " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
        .               // "   DockNode ID=0x00000002 Parent=0x00000001 "
        .               // Important: this code expect currently fields in a fixed order.
        .               ImGuiDockNodeSettings node;
        .               line = ImStrSkipBlank(line);
       16 ( 0.00%)      if      (strncmp(line, "DockNode", 8) == 0)  { line = ImStrSkipBlank(line + strlen("DockNode")); }
       50 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (2x)
       17 ( 0.00%)      else if (strncmp(line, "DockSpace", 9) == 0) { line = ImStrSkipBlank(line + strlen("DockSpace")); node.Flags |= ImGuiDockNodeFlags_DockSpace; }
       47 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (2x)
        .               else return;
       12 ( 0.00%)      if (sscanf(line, "ID=0x%08X%n",      &node.ID, &r) == 1)            { line += r; } else return;
    1,381 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        9 ( 0.00%)      if (sscanf(line, " Parent=0x%08X%n", &node.ParentNodeId, &r) == 1)  { line += r; if (node.ParentNodeId == 0) return; }
      427 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       15 ( 0.00%)      if (sscanf(line, " Window=0x%08X%n", &node.ParentWindowId, &r) ==1) { line += r; if (node.ParentWindowId == 0) return; }
    1,517 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        3 ( 0.00%)      if (node.ParentNodeId == 0)
        .               {
       19 ( 0.00%)          if (sscanf(line, " Pos=%i,%i%n",  &x, &y, &r) == 2)         { line += r; node.Pos = ImVec2ih((short)x, (short)y); } else return;
    1,690 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       18 ( 0.00%)          if (sscanf(line, " Size=%i,%i%n", &x, &y, &r) == 2)         { line += r; node.Size = ImVec2ih((short)x, (short)y); } else return;
    1,672 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        .               }
        .               else
        .               {
        .                   if (sscanf(line, " SizeRef=%i,%i%n", &x, &y, &r) == 2)      { line += r; node.SizeRef = ImVec2ih((short)x, (short)y); }
        .               }
        9 ( 0.00%)      if (sscanf(line, " Split=%c%n", &c, &r) == 1)                   { line += r; if (c == 'X') node.SplitAxis = ImGuiAxis_X; else if (c == 'Y') node.SplitAxis = ImGuiAxis_Y; }
      419 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        9 ( 0.00%)      if (sscanf(line, " NoResize=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoResize; }
      419 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       16 ( 0.00%)      if (sscanf(line, " CentralNode=%d%n", &x, &r) == 1)             { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_CentralNode; }
    1,251 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
       16 ( 0.00%)      if (sscanf(line, " NoTabBar=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoTabBar; }
    1,150 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        9 ( 0.00%)      if (sscanf(line, " HiddenTabBar=%d%n", &x, &r) == 1)            { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_HiddenTabBar; }
      411 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        9 ( 0.00%)      if (sscanf(line, " NoWindowMenuButton=%d%n", &x, &r) == 1)      { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoWindowMenuButton; }
      411 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        9 ( 0.00%)      if (sscanf(line, " NoCloseButton=%d%n", &x, &r) == 1)           { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoCloseButton; }
      411 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        7 ( 0.00%)      if (sscanf(line, " Selected=0x%08X%n", &node.SelectedTabId,&r) == 1) { line += r; }
    1,611 ( 0.00%)  => /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdio-common/isoc23_sscanf.c:__isoc23_sscanf (1x)
        3 ( 0.00%)      if (node.ParentNodeId != 0)
        .                   if (ImGuiDockNodeSettings* parent_settings = DockSettingsFindNodeSettings(ctx, node.ParentNodeId))
        .                       node.Depth = parent_settings->Depth + 1;
        .               ctx->DockContext.NodesSettings.push_back(node);
       16 ( 0.00%)  }
        .           
        .           static void DockSettingsHandler_DockNodeToSettings(ImGuiDockContext* dc, ImGuiDockNode* node, int depth)
        .           {
        .               ImGuiDockNodeSettings node_settings;
        .               IM_ASSERT(depth < (1 << (sizeof(node_settings.Depth) << 3)));
        2 ( 0.00%)      node_settings.ID = node->ID;
        .               node_settings.ParentNodeId = node->ParentNode ? node->ParentNode->ID : 0;
       12 ( 0.00%)      node_settings.ParentWindowId = (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow) ? node->HostWindow->ParentWindow->ID : 0;
        .               node_settings.SelectedTabId = node->SelectedTabId;
        4 ( 0.00%)      node_settings.SplitAxis = (signed char)(node->IsSplitNode() ? node->SplitAxis : ImGuiAxis_None);
        .               node_settings.Depth = (char)depth;
        3 ( 0.00%)      node_settings.Flags = (node->LocalFlags & ImGuiDockNodeFlags_SavedFlagsMask_);
       11 ( 0.00%)      node_settings.Pos = ImVec2ih(node->Pos);
        .               node_settings.Size = ImVec2ih(node->Size);
        4 ( 0.00%)      node_settings.SizeRef = ImVec2ih(node->SizeRef);
        .               dc->NodesSettings.push_back(node_settings);
        3 ( 0.00%)      if (node->ChildNodes[0])
        .                   DockSettingsHandler_DockNodeToSettings(dc, node->ChildNodes[0], depth + 1);
        3 ( 0.00%)      if (node->ChildNodes[1])
        .                   DockSettingsHandler_DockNodeToSettings(dc, node->ChildNodes[1], depth + 1);
        .           }
        .           
        .           static void ImGui::DockSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
       15 ( 0.00%)  {
        .               ImGuiContext& g = *ctx;
        4 ( 0.00%)      ImGuiDockContext* dc = &ctx->DockContext;
        2 ( 0.00%)      if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        .                   return;
        .           
        .               // Gather settings data
        .               // (unlike our windows settings, because nodes are always built we can do a full rewrite of the SettingsNode buffer)
        .               dc->NodesSettings.resize(0);
        1 ( 0.00%)      dc->NodesSettings.reserve(dc->Nodes.Data.Size);
        7 ( 0.00%)      for (int n = 0; n < dc->Nodes.Data.Size; n++)
        6 ( 0.00%)          if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        2 ( 0.00%)              if (node->IsRootNode())
        .                           DockSettingsHandler_DockNodeToSettings(dc, node, 0);
        .           
        3 ( 0.00%)      int max_depth = 0;
       17 ( 0.00%)      for (int node_n = 0; node_n < dc->NodesSettings.Size; node_n++)
        1 ( 0.00%)          max_depth = ImMax((int)dc->NodesSettings[node_n].Depth, max_depth);
        .           
        .               // Write to text buffer
        6 ( 0.00%)      buf->appendf("[%s][Data]\n", handler->TypeName);
      948 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
       11 ( 0.00%)      for (int node_n = 0; node_n < dc->NodesSettings.Size; node_n++)
        .               {
        .                   const int line_start_pos = buf->size(); (void)line_start_pos;
        .                   const ImGuiDockNodeSettings* node_settings = &dc->NodesSettings[node_n];
       16 ( 0.00%)          buf->appendf("%*s%s%*s", node_settings->Depth * 2, "", (node_settings->Flags & ImGuiDockNodeFlags_DockSpace) ? "DockSpace" : "DockNode ", (max_depth - node_settings->Depth) * 2, "");  // Text align nodes to facilitate looking at .ini file
    1,562 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        7 ( 0.00%)          buf->appendf(" ID=0x%08X", node_settings->ID);
    1,248 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        3 ( 0.00%)          if (node_settings->ParentNodeId)
        .                   {
        .                       buf->appendf(" Parent=0x%08X SizeRef=%d,%d", node_settings->ParentNodeId, node_settings->SizeRef.x, node_settings->SizeRef.y);
        .                   }
        .                   else
        .                   {
        3 ( 0.00%)              if (node_settings->ParentWindowId)
        5 ( 0.00%)                  buf->appendf(" Window=0x%08X", node_settings->ParentWindowId);
    1,352 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        8 ( 0.00%)              buf->appendf(" Pos=%d,%d Size=%d,%d", node_settings->Pos.x, node_settings->Pos.y, node_settings->Size.x, node_settings->Size.y);
    3,136 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        .                   }
        3 ( 0.00%)          if (node_settings->SplitAxis != ImGuiAxis_None)
        .                       buf->appendf(" Split=%c", (node_settings->SplitAxis == ImGuiAxis_X) ? 'X' : 'Y');
        3 ( 0.00%)          if (node_settings->Flags & ImGuiDockNodeFlags_NoResize)
        .                       buf->appendf(" NoResize=1");
        2 ( 0.00%)          if (node_settings->Flags & ImGuiDockNodeFlags_CentralNode)
        4 ( 0.00%)              buf->appendf(" CentralNode=1");
      482 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        4 ( 0.00%)          if (node_settings->Flags & ImGuiDockNodeFlags_NoTabBar)
        4 ( 0.00%)              buf->appendf(" NoTabBar=1");
      482 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        4 ( 0.00%)          if (node_settings->Flags & ImGuiDockNodeFlags_HiddenTabBar)
        .                       buf->appendf(" HiddenTabBar=1");
        2 ( 0.00%)          if (node_settings->Flags & ImGuiDockNodeFlags_NoWindowMenuButton)
        .                       buf->appendf(" NoWindowMenuButton=1");
        2 ( 0.00%)          if (node_settings->Flags & ImGuiDockNodeFlags_NoCloseButton)
        .                       buf->appendf(" NoCloseButton=1");
        3 ( 0.00%)          if (node_settings->SelectedTabId)
        5 ( 0.00%)              buf->appendf(" Selected=0x%08X", node_settings->SelectedTabId);
    1,244 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        .           
        .                   // [DEBUG] Include comments in the .ini file to ease debugging (this makes saving slower!)
        2 ( 0.00%)          if (g.IO.ConfigDebugIniSettings)
        .                       if (ImGuiDockNode* node = DockContextFindNodeByID(ctx, node_settings->ID))
        .                       {
        .                           buf->appendf("%*s", ImMax(2, (line_start_pos + 92) - buf->size()), "");     // Align everything
        .                           if (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow)
        .                               buf->appendf(" ; in '%s'", node->HostWindow->ParentWindow->Name);
        .                           // Iterate settings so we can give info about windows that didn't exist during the session.
        .                           int contains_window = 0;
        .                           for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
-- line 19558 ----------------------------------------
-- line 19559 ----------------------------------------
        .                               if (settings->DockId == node_settings->ID)
        .                               {
        .                                   if (contains_window++ == 0)
        .                                       buf->appendf(" ; contains ");
        .                                   buf->appendf("'%s' ", settings->GetName());
        .                               }
        .                       }
        .           
        4 ( 0.00%)          buf->appendf("\n");
      488 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        .               }
        4 ( 0.00%)      buf->appendf("\n");
      488 ( 0.00%)  => build/_deps/imgui-src/imgui.cpp:ImGuiTextBuffer::appendf(char const*, ...) (1x)
        9 ( 0.00%)  }
        .           
        .           
        .           //-----------------------------------------------------------------------------
        .           // [SECTION] PLATFORM DEPENDENT HELPERS
        .           //-----------------------------------------------------------------------------
        .           
        .           #if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)
        .           
-- line 19578 ----------------------------------------
-- line 19933 ----------------------------------------
        .               DebugFlashStyleColorStop();
        .               g.DebugFlashStyleColorTime = 0.5f;
        .               g.DebugFlashStyleColorIdx = idx;
        .               g.DebugFlashStyleColorBackup = g.Style.Colors[idx];
        .           }
        .           
        .           void ImGui::UpdateDebugToolFlashStyleColor()
        .           {
        1 ( 0.00%)      ImGuiContext& g = *GImGui;
    2,284 ( 0.00%)      if (g.DebugFlashStyleColorTime <= 0.0f)
        .                   return;
        .               ColorConvertHSVtoRGB(cosf(g.DebugFlashStyleColorTime * 6.0f) * 0.5f + 0.5f, 0.5f, 0.5f, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z);
        .               g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0f;
        .               if ((g.DebugFlashStyleColorTime -= g.IO.DeltaTime) <= 0.0f)
        .                   DebugFlashStyleColorStop();
        .           }
        .           
        .           // Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
-- line 19950 ----------------------------------------
-- line 21447 ----------------------------------------
        .           {
        .               ImGuiContext& g = *GImGui;
        .               g.DebugItemPickerActive = true;
        .           }
        .           
        .           // [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
        .           void ImGui::UpdateDebugToolItemPicker()
        .           {
      571 ( 0.00%)      ImGuiContext& g = *GImGui;
      571 ( 0.00%)      g.DebugItemPickerBreakId = 0;
    1,142 ( 0.00%)      if (!g.DebugItemPickerActive)
        .                   return;
        .           
        .               const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
        .               SetMouseCursor(ImGuiMouseCursor_Hand);
        .               if (IsKeyPressed(ImGuiKey_Escape))
        .                   g.DebugItemPickerActive = false;
        .               const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
        .               if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
-- line 21465 ----------------------------------------
-- line 21485 ----------------------------------------
        .           
        .           // [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
        .           void ImGui::UpdateDebugToolStackQueries()
        .           {
        .               ImGuiContext& g = *GImGui;
        .               ImGuiIDStackTool* tool = &g.DebugIDStackTool;
        .           
        .               // Clear hook when id stack tool is not visible
      571 ( 0.00%)      g.DebugHookIdInfo = 0;
    2,284 ( 0.00%)      if (g.FrameCount != tool->LastActiveFrame + 1)
        .                   return;
        .           
        .               // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
        .               // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
        4 ( 0.00%)      const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
        3 ( 0.00%)      if (tool->QueryId != query_id)
        .               {
        .                   tool->QueryId = query_id;
        .                   tool->StackLevel = -1;
        .                   tool->Results.resize(0);
        .               }
        2 ( 0.00%)      if (query_id == 0)
        .                   return;
        .           
        .               // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
        .               int stack_level = tool->StackLevel;
        .               if (stack_level >= 0 && stack_level < tool->Results.Size)
        .                   if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
        .                       tool->StackLevel++;
        .           
-- line 21514 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/fmt/format.h
--------------------------------------------------------------------------------
Ir               

-- line 828 ----------------------------------------
      .           using is_double_double = bool_constant<std::numeric_limits<T>::digits == 106>;
      .           
      .           #ifndef FMT_USE_FULL_CACHE_DRAGONBOX
      .           #  define FMT_USE_FULL_CACHE_DRAGONBOX 0
      .           #endif
      .           
      .           template <typename T>
      .           template <typename U>
806,208 ( 0.00%)  void buffer<T>::append(const U* begin, const U* end) {
268,736 ( 0.00%)    while (begin != end) {
134,368 ( 0.00%)      auto count = to_unsigned(end - begin);
201,552 ( 0.00%)      try_reserve(size_ + count);
 67,184 ( 0.00%)      auto free_cap = capacity_ - size_;
134,368 ( 0.00%)      if (free_cap < count) count = free_cap;
 67,184 ( 0.00%)      std::uninitialized_copy_n(begin, count, ptr_ + size_);
201,552 ( 0.00%)      size_ += count;
      .               begin += count;
      .             }
537,472 ( 0.00%)  }
      .           
      .           template <typename T, typename Enable = void>
      .           struct is_locale : std::false_type {};
      .           template <typename T>
      .           struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
      .           }  // namespace detail
      .           
      .           FMT_BEGIN_EXPORT
-- line 854 ----------------------------------------
-- line 885 ----------------------------------------
      .             T store_[SIZE];
      .           
      .             // Don't inherit from Allocator to avoid generating type_info for it.
      .             FMT_NO_UNIQUE_ADDRESS Allocator alloc_;
      .           
      .             // Deallocate memory allocated by the buffer.
      .             FMT_CONSTEXPR20 void deallocate() {
      .               T* data = this->data();
 62,801 ( 0.00%)      if (data != store_) alloc_.deallocate(data, this->capacity());
      .             }
      .           
      .            protected:
      .             FMT_CONSTEXPR20 void grow(size_t size) override {
      .               detail::abort_fuzzing_if(size > 5000);
      .               const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
      .               size_t old_capacity = this->capacity();
  5,232 ( 0.00%)      size_t new_capacity = old_capacity + old_capacity / 2;
  2,616 ( 0.00%)      if (size > new_capacity)
      .                 new_capacity = size;
  2,616 ( 0.00%)      else if (new_capacity > max_size)
      .                 new_capacity = size > max_size ? size : max_size;
      .               T* old_data = this->data();
      .               T* new_data =
      .                   std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
      .               // Suppress a bogus -Wstringop-overflow in gcc 13.1 (#3481).
      .               detail::assume(this->size() <= new_capacity);
      .               // The following code doesn't throw, so the raw pointer above doesn't leak.
      .               std::uninitialized_copy_n(old_data, this->size(), new_data);
      .               this->set(new_data, new_capacity);
      .               // deallocate must not throw according to the standard, but even if it does,
      .               // the buffer already uses the new storage and will deallocate it in
      .               // destructor.
  5,232 ( 0.00%)      if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
      .             }
      .           
      .            public:
      .             using value_type = T;
      .             using const_reference = const T&;
      .           
      .             FMT_CONSTEXPR20 explicit basic_memory_buffer(
      .                 const Allocator& alloc = Allocator())
 53,630 ( 0.00%)        : alloc_(alloc) {
 20,346 ( 0.00%)      this->set(store_, SIZE);
      .               if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
      .             }
 20,056 ( 0.00%)    FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
      .           
      .            private:
      .             // Move data from other to this buffer.
      .             FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
      .               alloc_ = std::move(other.alloc_);
      .               T* data = other.data();
      .               size_t size = other.size(), capacity = other.capacity();
 11,862 ( 0.00%)      if (data == other.store_) {
      .                 this->set(store_, capacity);
      .                 detail::copy_str<T>(other.store_, other.store_ + size, store_);
      .               } else {
      .                 this->set(data, capacity);
      .                 // Set pointer to the inline array so that delete is not called
      .                 // when deallocating.
      .                 other.set(other.store_, 0);
      .                 other.clear();
-- line 946 ----------------------------------------
-- line 1300 ----------------------------------------
      .             Iterator begin;
      .             Iterator end;
      .           };
      .           
      .           // Formats a decimal unsigned integer value writing into out pointing to a
      .           // buffer of specified size. The caller must ensure that the buffer is large
      .           // enough.
      .           template <typename Char, typename UInt>
  7,904 ( 0.00%)  FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
      .               -> format_decimal_result<Char*> {
      .             FMT_ASSERT(size >= count_digits(value), "invalid digit count");
 15,808 ( 0.00%)    out += size;
      .             Char* end = out;
 36,896 ( 0.00%)    while (value >= 100) {
      .               // Integer division is slow so do it for a group of two digits instead
      .               // of for every digit. The idea comes from the talk by Alexandrescu
      .               // "Three Optimization Tips for C++". See speed-test for a comparison.
  5,272 ( 0.00%)      out -= 2;
 31,632 ( 0.00%)      copy2(out, digits2(static_cast<size_t>(value % 100)));
  5,272 ( 0.00%)      value /= 100;
      .             }
 15,808 ( 0.00%)    if (value < 10) {
  3,960 ( 0.00%)      *--out = static_cast<Char>('0' + value);
  7,904 ( 0.00%)      return {out, end};
      .             }
  6,584 ( 0.00%)    out -= 2;
  6,584 ( 0.00%)    copy2(out, digits2(static_cast<size_t>(value)));
      .             return {out, end};
  7,904 ( 0.00%)  }
      .           
      .           template <typename Char, typename UInt, typename Iterator,
      .                     FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
      .           FMT_CONSTEXPR inline auto format_decimal(Iterator out, UInt value, int size)
      .               -> format_decimal_result<Iterator> {
      .             // Buffer is large enough to hold all digits (digits10 + 1).
      .             Char buffer[digits10<UInt>() + 1] = {};
      .             auto end = format_decimal(buffer, value, size).end;
-- line 1336 ----------------------------------------
-- line 3972 ----------------------------------------
      .             // Buffer should be large enough to hold all digits (digits10 + 1),
      .             // a sign and a null character.
      .             enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
      .             mutable char buffer_[buffer_size];
      .             char* str_;
      .           
      .             template <typename UInt> auto format_unsigned(UInt value) -> char* {
      .               auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
 31,616 ( 0.00%)      return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
 72,488 ( 0.00%)  => /usr/include/fmt/format.h:fmt::v10::detail::format_decimal_result<char*> fmt::v10::detail::format_decimal<char, unsigned int>(char*, unsigned int, int) [clone .constprop.0] (3,952x)
      .             }
      .           
      .             template <typename Int> auto format_signed(Int value) -> char* {
      .               auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
      .               bool negative = value < 0;
 23,712 ( 0.00%)      if (negative) abs_value = 0 - abs_value;
      .               auto begin = format_unsigned(abs_value);
 15,808 ( 0.00%)      if (negative) *--begin = '-';
      .               return begin;
      .             }
      .           
      .            public:
  7,904 ( 0.00%)    explicit format_int(int value) : str_(format_signed(value)) {}
      .             explicit format_int(long value) : str_(format_signed(value)) {}
      .             explicit format_int(long long value) : str_(format_signed(value)) {}
      .             explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
      .             explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
      .             explicit format_int(unsigned long long value)
      .                 : str_(format_unsigned(value)) {}
      .           
      .             /** Returns the number of characters written to the output buffer. */
-- line 4001 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/hash_bytes.cc
  /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/new_op.cc
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/elf/dl-lookup.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/getc.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/libio/libioP.h
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/arena.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/malloc/malloc.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_lock.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_mutex_unlock.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_once.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/nptl/pthread_self.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/../stdlib/strtol_l.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/stdlib/getenv.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strcspn-sse4.c
  /usr/src/debug/glibc-2.39-22.fc40.x86_64/string/../sysdeps/x86_64/multiarch/strlen-avx2.S
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/../modules/im/ximcp/imLcPrs.c
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/StrKeysym.c
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/VisUtil.c
  /usr/src/debug/libX11-1.8.10-2.fc40.x86_64/src/xlibi18n/lcFile.c
  /usr/src/debug/libXi-1.8.2-1.fc40.x86_64/src/XExtInt.c
  /usr/src/debug/libxcb-1.17.0-2.fc40.x86_64/src/xcb_in.c
  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/hashmap.c
  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/path-util.c
  /usr/src/debug/systemd-255.13-1.fc40.x86_64/redhat-linux-build/../src/basic/siphash24.c
  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inffast_tpl.h
  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inflate.c
  /usr/src/debug/zlib-ng-2.1.7-1.fc40.x86_64/inftrees.c

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
57,286,903,511 (97.19%)  events annotated

